(window["webpackJsonp"] = window["webpackJsonp"] || []).push([
  ["chunk-vendors"], {
   "00ee": function(t, e, n) {
    var r = n("b622"),
     i = r("toStringTag"),
     o = {};
    o[i] = "z", t.exports = "[object z]" === String(o)
   },
   "0366": function(t, e, n) {
    var r = n("1c0b");
    t.exports = function(t, e, n) {
     if (r(t), void 0 === e) return t;
     switch (n) {
      case 0:
       return function() {
        return t.call(e)
       };
      case 1:
       return function(n) {
        return t.call(e, n)
       };
      case 2:
       return function(n, r) {
        return t.call(e, n, r)
       };
      case 3:
       return function(n, r, i) {
        return t.call(e, n, r, i)
       }
     }
     return function() {
      return t.apply(e, arguments)
     }
    }
   },
   "0481": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("a2bf"),
     o = n("7b0b"),
     a = n("50c4"),
     s = n("a691"),
     u = n("65f0");
    r({
     target: "Array",
     proto: !0
    }, {
     flat: function() {
      var t = arguments.length ? arguments[0] : void 0,
       e = o(this),
       n = a(e.length),
       r = u(e, 0);
      return r.length = i(r, e, e, n, 0, void 0 === t ? 1 : s(t)), r
     }
    })
   },
   "057f": function(t, e, n) {
    var r = n("fc6a"),
     i = n("241c").f,
     o = {}.toString,
     a = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
     s = function(t) {
      try {
       return i(t)
      } catch (e) {
       return a.slice()
      }
     };
    t.exports.f = function(t) {
     return a && "[object Window]" == o.call(t) ? s(t) : i(r(t))
    }
   },
   "06cf": function(t, e, n) {
    var r = n("83ab"),
     i = n("d1e7"),
     o = n("5c6c"),
     a = n("fc6a"),
     s = n("c04e"),
     u = n("5135"),
     c = n("0cfb"),
     l = Object.getOwnPropertyDescriptor;
    e.f = r ? l : function(t, e) {
     if (t = a(t), e = s(e, !0), c) try {
      return l(t, e)
     } catch (n) {}
     if (u(t, e)) return o(!i.f.call(t, e), t[e])
    }
   },
   "0789": function(t, e, n) {
    "use strict";
    n("99af");
    var r = n("d9f7");
 
    function i() {
     for (var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
     return (t = Array()).concat.apply(t, [e].concat(r))
    }
 
    function o(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "top center 0",
      n = arguments.length > 2 ? arguments[2] : void 0;
     return {
      name: t,
      functional: !0,
      props: {
       group: {
        type: Boolean,
        default: !1
       },
       hideOnLeave: {
        type: Boolean,
        default: !1
       },
       leaveAbsolute: {
        type: Boolean,
        default: !1
       },
       mode: {
        type: String,
        default: n
       },
       origin: {
        type: String,
        default: e
       }
      },
      render: function(e, n) {
       var o = "transition".concat(n.props.group ? "-group" : ""),
        a = {
         props: {
          name: t,
          mode: n.props.mode
         },
         on: {
          beforeEnter: function(t) {
           t.style.transformOrigin = n.props.origin, t.style.webkitTransformOrigin = n.props.origin
          }
         }
        };
       return n.props.leaveAbsolute && (a.on.leave = i(a.on.leave, (function(t) {
        return t.style.position = "absolute"
       }))), n.props.hideOnLeave && (a.on.leave = i(a.on.leave, (function(t) {
        return t.style.display = "none"
       }))), e(o, Object(r["a"])(n.data, a), n.children)
      }
     }
    }
 
    function a(t, e) {
     var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "in-out";
     return {
      name: t,
      functional: !0,
      props: {
       mode: {
        type: String,
        default: n
       }
      },
      render: function(n, i) {
       return n("transition", Object(r["a"])(i.data, {
        props: {
         name: t
        },
        on: e
       }), i.children)
      }
     }
    }
    var s = n("ade3"),
     u = n("80d2"),
     c = function() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
       e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
       n = e ? "width" : "height",
       r = "offset".concat(Object(u["v"])(n));
      return {
       beforeEnter: function(t) {
        t._parent = t.parentNode, t._initialStyle = Object(s["a"])({
         transition: t.style.transition,
         visibility: t.style.visibility,
         overflow: t.style.overflow
        }, n, t.style[n])
       },
       enter: function(e) {
        var i = e._initialStyle,
         o = "".concat(e[r], "px");
        e.style.setProperty("transition", "none", "important"), e.style.visibility = "hidden", e.style.visibility = i.visibility, e.style.overflow = "hidden", e.style[n] = "0", e.offsetHeight, e.style.transition = i.transition, t && e._parent && e._parent.classList.add(t), requestAnimationFrame((function() {
         e.style[n] = o
        }))
       },
       afterEnter: o,
       enterCancelled: o,
       leave: function(t) {
        t._initialStyle = Object(s["a"])({
         transition: "",
         visibility: "",
         overflow: t.style.overflow
        }, n, t.style[n]), t.style.overflow = "hidden", t.style[n] = "".concat(t[r], "px"), t.offsetHeight, requestAnimationFrame((function() {
         return t.style[n] = "0"
        }))
       },
       afterLeave: i,
       leaveCancelled: i
      };
 
      function i(e) {
       t && e._parent && e._parent.classList.remove(t), o(e)
      }
 
      function o(t) {
       var e = t._initialStyle[n];
       t.style.overflow = t._initialStyle.overflow, null != e && (t.style[n] = e), delete t._initialStyle
      }
     };
    n.d(e, "c", (function() {
     return l
    })), n.d(e, "d", (function() {
     return h
    })), n.d(e, "a", (function() {
     return p
    })), n.d(e, "b", (function() {
     return f
    }));
    o("carousel-transition"), o("carousel-reverse-transition"), o("tab-transition"), o("tab-reverse-transition"), o("menu-transition"), o("fab-transition", "center center", "out-in"), o("dialog-transition"), o("dialog-bottom-transition");
    var l = o("fade-transition"),
     h = (o("scale-transition"), o("scroll-x-transition"), o("scroll-x-reverse-transition"), o("scroll-y-transition"), o("scroll-y-reverse-transition"), o("slide-x-transition")),
     p = (o("slide-x-reverse-transition"), o("slide-y-transition"), o("slide-y-reverse-transition"), a("expand-transition", c())),
     f = a("expand-x-transition", c("", !0))
   },
   "07ac": function(t, e, n) {
    var r = n("23e7"),
     i = n("6f53").values;
    r({
     target: "Object",
     stat: !0
    }, {
     values: function(t) {
      return i(t)
     }
    })
   },
   "0a06": function(t, e, n) {
    "use strict";
    var r = n("c532"),
     i = n("30b5"),
     o = n("f6b4"),
     a = n("5270"),
     s = n("4a7b");
 
    function u(t) {
     this.defaults = t, this.interceptors = {
      request: new o,
      response: new o
     }
    }
    u.prototype.request = function(t) {
     "string" === typeof t ? (t = arguments[1] || {}, t.url = arguments[0]) : t = t || {}, t = s(this.defaults, t), t.method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = "get";
     var e = [a, void 0],
      n = Promise.resolve(t);
     this.interceptors.request.forEach((function(t) {
      e.unshift(t.fulfilled, t.rejected)
     })), this.interceptors.response.forEach((function(t) {
      e.push(t.fulfilled, t.rejected)
     }));
     while (e.length) n = n.then(e.shift(), e.shift());
     return n
    }, u.prototype.getUri = function(t) {
     return t = s(this.defaults, t), i(t.url, t.params, t.paramsSerializer).replace(/^\?/, "")
    }, r.forEach(["delete", "get", "head", "options"], (function(t) {
     u.prototype[t] = function(e, n) {
      return this.request(r.merge(n || {}, {
       method: t,
       url: e
      }))
     }
    })), r.forEach(["post", "put", "patch"], (function(t) {
     u.prototype[t] = function(e, n, i) {
      return this.request(r.merge(i || {}, {
       method: t,
       url: e,
       data: n
      }))
     }
    })), t.exports = u
   },
   "0b53": function(t, e, n) {
    "use strict";
    var r = n("7c3e"),
     i = n("45ef"),
     o = function(t, e) {
      return (o = Object.setPrototypeOf || {
        __proto__: []
       }
       instanceof Array && function(t, e) {
        t.__proto__ = e
       } || function(t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
       })(t, e)
     };
 
    function a(t, e) {
     function n() {
      this.constructor = t
     }
     o(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
    }
    var s, u = function() {
     return (u = Object.assign || function(t) {
      for (var e, n = 1, r = arguments.length; n < r; n++)
       for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
      return t
     }).apply(this, arguments)
    };
 
    function c(t, e, n, r) {
     return new(n || (n = Promise))((function(i, o) {
      function a(t) {
       try {
        u(r.next(t))
       } catch (t) {
        o(t)
       }
      }
 
      function s(t) {
       try {
        u(r.throw(t))
       } catch (t) {
        o(t)
       }
      }
 
      function u(t) {
       t.done ? i(t.value) : new n((function(e) {
        e(t.value)
       })).then(a, s)
      }
      u((r = r.apply(t, e || [])).next())
     }))
    }
 
    function l(t, e) {
     var n, r, i, o, a = {
      label: 0,
      sent: function() {
       if (1 & i[0]) throw i[1];
       return i[1]
      },
      trys: [],
      ops: []
     };
     return o = {
      next: s(0),
      throw: s(1),
      return: s(2)
     }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
      return this
     }), o;
 
     function s(o) {
      return function(s) {
       return function(o) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; a;) try {
         if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
         switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
          case 0:
          case 1:
           i = o;
           break;
          case 4:
           return a.label++, {
            value: o[1],
            done: !1
           };
          case 5:
           a.label++, r = o[1], o = [0];
           continue;
          case 7:
           o = a.ops.pop(), a.trys.pop();
           continue;
          default:
           if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
            a = 0;
            continue
           }
           if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
            a.label = o[1];
            break
           }
           if (6 === o[0] && a.label < i[1]) {
            a.label = i[1], i = o;
            break
           }
           if (i && a.label < i[2]) {
            a.label = i[2], a.ops.push(o);
            break
           }
           i[2] && a.ops.pop(), a.trys.pop();
           continue
         }
         o = e.call(t, a)
        } catch (t) {
         o = [6, t], r = 0
        } finally {
         n = i = 0
        }
        if (5 & o[0]) throw o[1];
        return {
         value: o[0] ? o[1] : void 0,
         done: !0
        }
       }([o, s])
      }
     }
    }
 
    function h() {
     return null == s && (s = Object(i["backend"])().epsilon()), s
    }
 
    function p() {
     return "channelsLast"
    }
    var f = function(t) {
      function e(n) {
       var r = t.call(this, n) || this;
       return Object.setPrototypeOf(r, e.prototype), r
      }
      return a(e, t), e
     }(Error),
     d = function(t) {
      function e(n) {
       var r = t.call(this, n) || this;
       return Object.setPrototypeOf(r, e.prototype), r
      }
      return a(e, t), e
     }(Error),
     v = function(t) {
      function e(n) {
       var r = t.call(this, n) || this;
       return Object.setPrototypeOf(r, e.prototype), r
      }
      return a(e, t), e
     }(Error),
     m = function(t) {
      function e(n) {
       var r = t.call(this, n) || this;
       return Object.setPrototypeOf(r, e.prototype), r
      }
      return a(e, t), e
     }(Error),
     g = function(t) {
      function e(n) {
       var r = t.call(this, n) || this;
       return Object.setPrototypeOf(r, e.prototype), r
      }
      return a(e, t), e
     }(Error);
    (function(t) {
     function e(n) {
      var r = t.call(this, n) || this;
      return Object.setPrototypeOf(r, e.prototype), r
     }
     a(e, t)
    })(Error);
 
    function y(t, e) {
     if (Array.isArray(t)) {
      for (var n = [], r = 0; r < e; r++) n = n.concat(t);
      return n
     }
     return (n = new Array(e)).fill(t), n
    }
 
    function b(t, e) {
     if (!t) throw new g(e)
    }
 
    function x(t, e) {
     for (var n = 0, r = 0, i = t; r < i.length; r++) i[r] === e && n++;
     return n
    }
 
    function w(t) {
     return 1 === t.length ? t[0] : t
    }
 
    function C(t) {
     return Array.isArray(t) ? t : [t]
    }
 
    function S(t) {
     var e = t.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
     return "_" !== e[0] ? e : "private" + e
    }
 
    function E(t) {
     return t.length <= 1 ? t : -1 === t.indexOf("_") ? t : t.replace(/[_]+(\w|$)/g, (function(t, e) {
      return e.toUpperCase()
     }))
    }
    var k = {};
 
    function I(t) {
     if (null === t || void 0 === t) return null;
     var e = {};
     return e.className = t.getClassName(), e.config = t.getConfig(), e
    }
 
    function O(t) {
     if (null != t && "object" == typeof t)
      if (Array.isArray(t)) t.forEach((function(t) {
       return O(t)
      }));
      else
       for (var e = 0, n = Object.keys(t); e < n.length; e++) {
        var r = n[e],
         i = t[r];
        null != i && "object" == typeof i && (Array.isArray(i) || "ndarray" !== i.type || "number" != typeof i.value ? O(i) : t[r] = i.value)
       }
    }
 
    function A(t, e, n, r, i) {
     var o, a, s;
     if (void 0 === e && (e = {}), void 0 === n && (n = {}), void 0 === r && (r = "object"), void 0 === i && (i = !1), "string" == typeof t) {
      var c = t,
       l = void 0;
      if (c in n) l = n[c];
      else if (c in k) l = k[c];
      else if (null == (l = e[c])) throw new v("Unknown " + r + ": " + t + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
      return l
     }
     var h = t;
     if (null == h.className || null == h.config) throw new v(r + ": Improper config format: " + JSON.stringify(h) + ".\n'className' and 'config' must set.");
     var p = h.className,
      f = void 0,
      d = void 0;
     if (p in n ? (f = (o = n[p])[0], d = o[1]) : p in k ? (f = (a = k.className)[0], d = a[1]) : p in e && (f = (s = e[p])[0], d = s[1]), null == f) throw new v("Unknown " + r + ": " + p + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
     if (null != d) {
      for (var m = {}, g = 0, y = Object.keys(k); g < y.length; g++) m[E = y[g]] = k[E];
      for (var b = 0, x = Object.keys(n); b < x.length; b++) m[E = x[b]] = n[E];
      h.config.customObjects = m;
      for (var w = u({}, k), C = 0, S = Object.keys(n); C < S.length; C++) {
       var E = S[C];
       k[E] = n[E]
      }
      O(h.config);
      var I = d(f, h.config, n, i);
      return k = u({}, w), I
     }
     w = u({}, k);
     for (var A = 0, N = Object.keys(n); A < N.length; A++) E = N[A], k[E] = n[E];
     return I = new f(h.config), k = u({}, w), I
    }
 
    function N(t, e) {
     return t < e ? -1 : t > e ? 1 : 0
    }
 
    function R(t, e) {
     return -1 * N(t, e)
    }
 
    function T(t) {
     if (null == t) return t;
     for (var e = [], n = 0, r = t; n < r.length; n++) {
      var i = r[n]; - 1 === e.indexOf(i) && e.push(i)
     }
     return e
    }
 
    function _(t) {
     if (null == t) throw new v("Invalid value in obj: " + JSON.stringify(t));
     for (var e in t)
      if (t.hasOwnProperty(e)) return !1;
     return !0
    }
 
    function D(t, e, n) {
     if (null != n && t.indexOf(n) < 0) throw new v(n + " is not a valid " + e + ".  Valid values are " + t + " or null/undefined.")
    }
 
    function F(t, e, n, r) {
     return void 0 === n && (n = 0), void 0 === r && (r = 1 / 0), b(n >= 0), b(r >= n), Array.isArray(t) && t.length >= n && t.length <= r && t.every((function(t) {
      return typeof t === e
     }))
    }
 
    function M(t, e) {
     Array.isArray(t) ? (i["util"].assert(t.length > 0, (function() {
      return e + " is unexpectedly an empty array."
     })), t.forEach((function(t, n) {
      return M(t, "element " + (n + 1) + " of " + e)
     }))) : i["util"].assert(Number.isInteger(t) && t > 0, (function() {
      return "Expected " + e + " to be a positive integer, but got " + L(t) + "."
     }))
    }
 
    function L(t) {
     return null === t ? "null" : Array.isArray(t) ? "[" + t.map((function(t) {
      return L(t)
     })).join(",") + "]" : "string" == typeof t ? '"' + t + '"' : "" + t
    }
 
    function B(t, e) {
     var n, r = i["util"].now();
     return function() {
      for (var o = [], a = 0; a < arguments.length; a++) o[a] = arguments[a];
      var s = i["util"].now();
      return s - r < e ? n : (r = s, n = t.apply(void 0, o))
     }
    }
 
    function P(t) {
     return "relu" === t ? "relu" : "linear" === t ? "linear" : "elu" === t ? "elu" : null
    }
 
    function z(t, e) {
     return Object(i["tidy"])((function() {
      return Object(i["sqrt"])(Object(i["sum"])(Object(i["mulStrict"])(t, t), e, !0))
     }))
    }
    var j = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.getConfig = function() {
       return {}
      }, e
     }(i["serialization"].Serializable),
     W = function(t) {
      function e(e) {
       var n = t.call(this) || this;
       return n.defaultMaxValue = 2, n.defaultAxis = 0, n.maxValue = null != e.maxValue ? e.maxValue : n.defaultMaxValue, n.axis = null != e.axis ? e.axis : n.defaultAxis, n
      }
      return a(e, t), e.prototype.apply = function(t) {
       var e = this;
       return Object(i["tidy"])((function() {
        var n = z(t, e.axis),
         r = Object(i["clipByValue"])(n, 0, e.maxValue);
        return Object(i["mul"])(t, Object(i["div"])(r, Object(i["add"])(h(), n)))
       }))
      }, e.prototype.getConfig = function() {
       return {
        maxValue: this.maxValue,
        axis: this.axis
       }
      }, e.className = "MaxNorm", e
     }(j);
    i["serialization"].registerClass(W);
    var V = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      return n.defaultAxis = 0, n.axis = null != e.axis ? e.axis : n.defaultAxis, n
     }
     return a(e, t), e.prototype.apply = function(t) {
      var e = this;
      return Object(i["tidy"])((function() {
       return Object(i["div"])(t, Object(i["add"])(h(), z(t, e.axis)))
      }))
     }, e.prototype.getConfig = function() {
      return {
       axis: this.axis
      }
     }, e.className = "UnitNorm", e
    }(j);
    i["serialization"].registerClass(V);
    var U = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["relu"])(t)
     }, e.className = "NonNeg", e
    }(j);
    i["serialization"].registerClass(U);
    var H = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      return n.defaultMinValue = 0, n.defaultMaxValue = 1, n.defaultRate = 1, n.defaultAxis = 0, n.minValue = null != e.minValue ? e.minValue : n.defaultMinValue, n.maxValue = null != e.maxValue ? e.maxValue : n.defaultMaxValue, n.rate = null != e.rate ? e.rate : n.defaultRate, n.axis = null != e.axis ? e.axis : n.defaultAxis, n
     }
     return a(e, t), e.prototype.apply = function(t) {
      var e = this;
      return Object(i["tidy"])((function() {
       var n = z(t, e.axis),
        r = Object(i["add"])(Object(i["mul"])(e.rate, Object(i["clipByValue"])(n, e.minValue, e.maxValue)), Object(i["mul"])(1 - e.rate, n));
       return Object(i["mul"])(t, Object(i["div"])(r, Object(i["add"])(h(), n)))
      }))
     }, e.prototype.getConfig = function() {
      return {
       minValue: this.minValue,
       maxValue: this.maxValue,
       rate: this.rate,
       axis: this.axis
      }
     }, e.className = "MinMaxNorm", e
    }(j);
    i["serialization"].registerClass(H);
    var $ = {
     maxNorm: "MaxNorm",
     minMaxNorm: "MinMaxNorm",
     nonNeg: "NonNeg",
     unitNorm: "UnitNorm"
    };
 
    function G(t) {
     return I(t)
    }
 
    function q(t, e) {
     return void 0 === e && (e = {}), A(t, i["serialization"].SerializationMap.getMap().classNameMap, e, "constraint")
    }
 
    function K(t) {
     return null == t ? null : "string" == typeof t ? q({
      className: t in $ ? $[t] : t,
      config: {}
     }) : t instanceof j ? t : q(t)
    }
 
    function X(t) {
     return new W(t)
    }
 
    function Y(t) {
     return new V(t)
    }
 
    function Z() {
     return new U
    }
 
    function J(t) {
     return new H(t)
    }
    Object.freeze({
     maxNorm: X,
     unitNorm: Y,
     nonNeg: Z,
     minMaxNorm: J
    });
    var Q = ["channelsFirst", "channelsLast"],
     tt = ["valid", "same", "causal"],
     et = ["max", "avg"],
     nt = ["sum", "mul", "concat", "ave"],
     rt = new Map;
 
    function it(t) {
     D(Q, "DataFormat", t)
    }
 
    function ot(t) {
     D(tt, "PaddingMode", t)
    }
 
    function at(t) {
     D(et, "PoolMode", t)
    }
    var st = [],
     ut = "/";
 
    function ct(t, e) {
     st.push(t);
     try {
      var n = e();
      return st.pop(), n
     } catch (t) {
      throw st.pop(), t
     }
    }
 
    function lt() {
     return 0 === st.length ? "" : st.join(ut) + ut
    }
 
    function ht(t) {
     if (!dt(t)) throw new Error("Not a valid tensor name: '" + t + "'");
     return lt() + t
    }
 
    function pt(t) {
     if (!dt(t)) throw new Error("Not a valid tensor name: '" + t + "'");
     rt.has(t) || rt.set(t, 0);
     var e = rt.get(t);
     if (rt.set(t, rt.get(t) + 1), e > 0) {
      var n = t + "_" + e;
      return rt.set(n, 1), n
     }
     return t
    }
    var ft = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
 
    function dt(t) {
     return !!t.match(ft)
    }
 
    function vt(t) {
     return t === parseInt(t.toString(), 10)
    }
 
    function mt(t, e, n) {
     null == e && (e = 0), null == n && (n = t.length);
     for (var r = 1, i = e; i < n; ++i) r *= t[i];
     return r
    }
 
    function gt(t) {
     return t = Array.isArray(t) ? new Float32Array(t) : t, Object(i["tensor1d"])(t)
    }
 
    function yt(t) {
     return Object(i["min"])(gt(t)).dataSync()[0]
    }
 
    function bt(t) {
     return Object(i["max"])(gt(t)).dataSync()[0]
    }
 
    function xt(t, e) {
     if (e < t) throw new v("end (" + e + ") < begin (" + t + ") is forbidden.");
     for (var n = [], r = t; r < e; ++r) n.push(r);
     return n
    }
 
    function wt(t, e) {
     return t.asType(e)
    }
 
    function Ct(t, e) {
     void 0 === e && (e = -1);
     var n = t.shape.slice();
     return e < 0 && (e = n.length + e + 1), n.splice(e, 0, 1), t.reshape(n)
    }
 
    function St(t, e) {
     return Object(i["tidy"])((function() {
      if (2 !== t.shape.length) throw new v("repeat() expects a rank-2 tensor, but received a rank-" + t.shape.length + " tensor.");
      return Tt(Ct(t, 1), [1, e, 1])
     }))
    }
 
    function Et(t) {
     var e = [mt(t.shape)];
     return t.reshape(e)
    }
 
    function kt(t) {
     if (t.rank <= 1) throw new v("batchFlatten requires a minimum rank of 2. Got rank: " + t.rank + ".");
     var e = [t.shape[0], mt(t.shape, 1)];
     return t.reshape(e)
    }
 
    function It(t, e, n) {
     return Object(i["tidy"])((function() {
      switch (t.rank) {
       case 1:
        return Object(i["slice1d"])(t, e, n);
       case 2:
        return Object(i["slice2d"])(t, [e, 0], [n, t.shape[1]]);
       case 3:
        return Object(i["slice3d"])(t, [e, 0, 0], [n, t.shape[1], t.shape[2]]);
       case 4:
        return Object(i["slice4d"])(t, [e, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3]]);
       case 5:
        return Object(i["slice"])(t, [e, 0, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3], t.shape[4]]);
       case 6:
        return Object(i["slice"])(t, [e, 0, 0, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3], t.shape[4], t.shape[5]]);
       default:
        throw new v("sliceAlongFirstAxis() received an unsupported tensor rank: " + t.rank)
      }
     }))
    }
 
    function Ot(t, e, n) {
     return Object(i["tidy"])((function() {
      switch (t.rank) {
       case 1:
        return Object(i["slice1d"])(t, e, n);
       case 2:
        return Object(i["slice2d"])(t, [0, e], [t.shape[0], n]);
       case 3:
        return Object(i["slice3d"])(t, [0, 0, e], [t.shape[0], t.shape[1], n]);
       case 4:
        return Object(i["slice4d"])(t, [0, 0, 0, e], [t.shape[0], t.shape[1], t.shape[2], n]);
       default:
        throw new v("sliceAlongLastAxis() received an unsupported tensor rank: " + t.rank)
      }
     }))
    }
 
    function At(t, e, n, r) {
     return Object(i["tidy"])((function() {
      switch (t.rank) {
       case 1:
        return Object(i["slice1d"])(t, e, n);
       case 2:
        switch (r) {
         case 1:
          return It(t, e, n);
         case 2:
          return Ot(t, e, n);
         default:
          throw new v("The axis is not within the rank of the tensor " + r)
        }
       case 3:
        switch (r) {
         case 1:
          return It(t, e, n);
         case 2:
          return Object(i["slice3d"])(t, [0, e, 0], [t.shape[0], n, t.shape[2]]);
         case 3:
          return Ot(t, e, n);
         default:
          throw new v("The axis is not within the rank of the tensor " + r)
        }
       case 4:
        switch (r) {
         case 1:
          return It(t, e, n);
         case 2:
          return Object(i["slice4d"])(t, [0, e, 0, 0], [t.shape[0], n, t.shape[2], t.shape[3]]);
         case 3:
          return Object(i["slice4d"])(t, [0, 0, e, 0], [t.shape[0], t.shape[1], n, t.shape[3]]);
         case 4:
          return Ot(t, e, n);
         default:
          throw new v("The axis is not within the rank of the tensor " + r)
        }
       default:
        throw new v("sliceAlongLastAxis() received an unsupported tensor rank: " + t.rank)
      }
     }))
    }
 
    function Nt(t, e) {
     var n;
     return void 0 === e && (e = -1), e < 0 && (e = 0 !== (n = t[0].rank) ? n : 0), e === t[0].rank && (e = -1), Object(i["concat"])(t, e)
    }
 
    function Rt(t, e) {
     switch (t.rank) {
      case 1:
       return Object(i["concat1d"])([t, e]);
      case 2:
       return Object(i["concat2d"])([t, e], 0);
      case 3:
       return Object(i["concat3d"])([t, e], 0);
      case 4:
       return Object(i["concat4d"])([t, e], 0);
      default:
       throw new v("concatAlongFirstAxis() received an unsupported tensor rank: " + t.rank)
     }
    }
 
    function Tt(t, e) {
     if (Array.isArray(e) || (e = [e]), t.rank !== e.length) throw new v("The length of input n (" + e.length + ") does not match the number of dimensions in input x (" + t.rank + ")");
     return Object(i["tile"])(t, e)
    }
 
    function _t(t, e, n, r, o) {
     return void 0 === e && (e = 0), void 0 === n && (n = 1), Object(i["randomNormal"])(t, e, n, r, o)
    }
 
    function Dt(t, e, n, r) {
     if (t.rank < 2 || e.rank < 2) throw new m("dot requires both inputs to be rank >= 2 but got x shape = " + t.shape + " and y shape = " + e.shape);
     if (e.rank >= 3 && t.shape.slice(-1)[0] !== (h = e.shape.slice(-2)[0])) throw new m("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + t.shape + " and  y shape = " + e.shape);
     if (2 === t.rank && 2 === e.rank) {
      var o = !1,
       a = !1;
      return i["fused"].matMul({
       a: t,
       b: e,
       transposeA: o,
       transposeB: a,
       bias: r ? Lt(t.rank, r, p()) : null,
       activation: n
      })
     }
     var s = t.shape.slice(),
      u = s.pop();
     t = t.reshape([-1, u]);
     var c = e.shape.slice(),
      l = c.pop(),
      h = c.pop(),
      f = c.concat([l]),
      d = Array.from({
       length: e.rank
      }, (function(t, n) {
       return 0 === n ? e.rank - 2 : n <= e.rank - 2 ? n - 1 : n
      }));
     e = e.transpose(d).reshape([h, -1]);
     var v = s.concat(f);
     return o = !1, a = !1, i["fused"].matMul({
      a: t,
      b: e,
      transposeA: o,
      transposeB: a,
      bias: r ? Lt(t.rank, r, p()) : null,
      activation: n
     }).reshape(v)
    }
 
    function Ft(t, e, n) {
     return Object(i["tidy"])((function() {
      return e = Array.isArray(e) ? Object(i["tensor1d"])(e, "int32") : e.toInt(), Object(i["gather"])(t, e, n)
     }))
    }
 
    function Mt(t) {
     return Object(i["mulStrict"])(t, t)
    }
 
    function Lt(t, e, n) {
     var r = e.shape;
     if (1 !== e.rank && e.rank !== t) throw new v("Unexpected bias dimensions: " + e.rank + "; expected it to be 1 or " + t);
     if (5 === t) {
      if ("channelsFirst" === n) return 1 === r.length ? e.reshape([1, r[0], 1, 1, 1]) : e.reshape([1, r[3], r[0], r[1], r[2]]);
      if ("channelsLast" === n) return 1 === r.length ? e.reshape([1, 1, 1, 1, r[0]]) : e.reshape([1].concat(r))
     } else if (4 === t) {
      if ("channelsFirst" === n) return 1 === r.length ? e.reshape([1, r[0], 1, 1]) : e.reshape([1, r[2], r[0], r[1]]);
      if ("channelsLast" === n) return 1 === r.length ? e.reshape([1, 1, 1, r[0]]) : e.reshape([1].concat(r))
     } else if (3 === t) {
      if ("channelsFirst" === n) return 1 === r.length ? e.reshape([1, r[0], 1]) : e.reshape([1, r[1], r[0]]);
      if ("channelsLast" === n) return 1 === r.length ? e.reshape([1, 1, r[0]]) : e.reshape([1].concat(r))
     } else if (t < 3) return e;
     throw new v("Unsupported input rank by biasAdd: " + e.rank)
    }
 
    function Bt(t, e, n) {
     return Object(i["tidy"])((function() {
      return null == n && (n = p()), it(n), t.add(Lt(t.rank, e, n))
     }))
    }
 
    function Pt(t, e) {
     if (void 0 === e && (e = 1), 1 !== e) throw new m("Support for alpha values other than 1 (" + e + ") is not implemented yet.");
     return Object(i["elu"])(t)
    }
 
    function zt(t) {
     return Object(i["tidy"])((function() {
      return Object(i["div"])(t, Object(i["abs"])(t).add(1))
     }))
    }
 
    function jt(t, e, n, r) {
     return Object(i["tidy"])((function() {
      return Object(i["dropout"])(t, e, n, r)
     }))
    }
 
    function Wt(t) {
     return Object(i["tidy"])((function() {
      var e = Object(i["add"])(.5, Object(i["mul"])(.2, t));
      return Object(i["clipByValue"])(e, 0, 1)
     }))
    }
 
    function Vt(t, e, n) {
     return void 0 === n && (n = !1), n ? t() : e()
    }
    var Ut = ["fanIn", "fanOut", "fanAvg"],
     Ht = ["normal", "uniform", "truncatedNormal"];
 
    function $t(t) {
     D(Ut, "FanMode", t)
    }
 
    function Gt(t) {
     D(Ht, "Distribution", t)
    }
    var qt = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.fromConfigUsesCustomObjects = function() {
       return !1
      }, e.prototype.getConfig = function() {
       return {}
      }, e
     }(i["serialization"].Serializable),
     Kt = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.apply = function(t, e) {
       return Object(i["zeros"])(t, e)
      }, e.className = "Zeros", e
     }(qt);
    i["serialization"].registerClass(Kt);
    var Xt = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      return Object(i["ones"])(t, e)
     }, e.className = "Ones", e
    }(qt);
    i["serialization"].registerClass(Xt);
    var Yt = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      if ("object" != typeof e) throw new v("Expected argument of type ConstantConfig but got " + e);
      if (void 0 === e.value) throw new v("config must have value set but got " + e);
      return n.value = e.value, n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       return Object(i["mul"])(Object(i["scalar"])(n.value), Object(i["ones"])(t, e))
      }))
     }, e.prototype.getConfig = function() {
      return {
       value: this.value
      }
     }, e.className = "Constant", e
    }(qt);
    i["serialization"].registerClass(Yt);
    var Zt = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      return n.DEFAULT_MINVAL = -.05, n.DEFAULT_MAXVAL = .05, n.minval = e.minval || n.DEFAULT_MINVAL, n.maxval = e.maxval || n.DEFAULT_MAXVAL, n.seed = e.seed, n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      return Object(i["randomUniform"])(t, this.minval, this.maxval, e)
     }, e.prototype.getConfig = function() {
      return {
       minval: this.minval,
       maxval: this.maxval,
       seed: this.seed
      }
     }, e.className = "RandomUniform", e
    }(qt);
    i["serialization"].registerClass(Zt);
    var Jt = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = e.mean || n.DEFAULT_MEAN, n.stddev = e.stddev || n.DEFAULT_STDDEV, n.seed = e.seed, n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      if ("float32" !== (e = e || "float32") && "int32" !== e) throw new m("randomNormal does not support dType " + e + ".");
      return _t(t, this.mean, this.stddev, e, this.seed)
     }, e.prototype.getConfig = function() {
      return {
       mean: this.mean,
       stddev: this.stddev,
       seed: this.seed
      }
     }, e.className = "RandomNormal", e
    }(qt);
    i["serialization"].registerClass(Jt);
    var Qt = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = e.mean || n.DEFAULT_MEAN, n.stddev = e.stddev || n.DEFAULT_STDDEV, n.seed = e.seed, n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      if ("float32" !== (e = e || "float32") && "int32" !== e) throw new m("truncatedNormal does not support dType " + e + ".");
      return Object(i["truncatedNormal"])(t, this.mean, this.stddev, e, this.seed)
     }, e.prototype.getConfig = function() {
      return {
       mean: this.mean,
       stddev: this.stddev,
       seed: this.seed
      }
     }, e.className = "TruncatedNormal", e
    }(qt);
    i["serialization"].registerClass(Qt);
    var te = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      return n.gain = null != e.gain ? e.gain : 1, n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       if (2 !== t.length || t[0] !== t[1]) throw new v("Identity matrix initializer can only be used for 2D square matrices.");
       return Object(i["mul"])(n.gain, Object(i["eye"])(t[0]))
      }))
     }, e.prototype.getConfig = function() {
      return {
       gain: this.gain
      }
     }, e.className = "Identity", e
    }(qt);
 
    function ee(t, e) {
     var n, r;
     if (void 0 === e && (e = "channelsLast"), it(e), 2 === t.length) n = t[0], r = t[1];
     else if (-1 !== [3, 4, 5].indexOf(t.length))
      if ("channelsFirst" === e) {
       var i = mt(t, 2);
       n = t[1] * i, r = t[0] * i
      } else "channelsLast" === e && (i = mt(t, 0, t.length - 2), n = t[t.length - 2] * i, r = t[t.length - 1] * i);
     else {
      var o = mt(t);
      n = Math.sqrt(o), r = Math.sqrt(o)
     }
     return [n, r]
    }
    i["serialization"].registerClass(te);
    var ne = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      if (e.scale < 0) throw new v("scale must be a positive float. Got: " + e.scale);
      return n.scale = null == e.scale ? 1 : e.scale, n.mode = null == e.mode ? "fanIn" : e.mode, $t(n.mode), n.distribution = null == e.distribution ? "normal" : e.distribution, Gt(n.distribution), n.seed = e.seed, n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      var n = ee(t),
       r = n[0],
       o = n[1],
       a = this.scale;
      if ("fanIn" === this.mode ? a /= Math.max(1, r) : "fanOut" === this.mode ? a /= Math.max(1, o) : a /= Math.max(1, (r + o) / 2), "normal" === this.distribution) {
       var s = Math.sqrt(a);
       if ("float32" !== (e = e || "float32") && "int32" !== e) throw new m(this.getClassName() + " does not support dType " + e + ".");
       return Object(i["truncatedNormal"])(t, 0, s, e, this.seed)
      }
      var u = Math.sqrt(3 * a);
      return Object(i["randomUniform"])(t, -u, u, e)
     }, e.prototype.getConfig = function() {
      return {
       scale: this.scale,
       mode: this.mode,
       distribution: this.distribution,
       seed: this.seed
      }
     }, e.className = "VarianceScaling", e
    }(qt);
    i["serialization"].registerClass(ne);
    var re = function(t) {
     function e(e) {
      return t.call(this, {
       scale: 1,
       mode: "fanAvg",
       distribution: "uniform",
       seed: null == e ? null : e.seed
      }) || this
     }
     return a(e, t), e.prototype.getClassName = function() {
      return ne.className
     }, e.className = "GlorotUniform", e
    }(ne);
    i["serialization"].registerClass(re);
    var ie = function(t) {
     function e(e) {
      return t.call(this, {
       scale: 1,
       mode: "fanAvg",
       distribution: "normal",
       seed: null == e ? null : e.seed
      }) || this
     }
     return a(e, t), e.prototype.getClassName = function() {
      return ne.className
     }, e.className = "GlorotNormal", e
    }(ne);
    i["serialization"].registerClass(ie);
    var oe = function(t) {
     function e(e) {
      return t.call(this, {
       scale: 2,
       mode: "fanIn",
       distribution: "normal",
       seed: null == e ? null : e.seed
      }) || this
     }
     return a(e, t), e.prototype.getClassName = function() {
      return ne.className
     }, e.className = "HeNormal", e
    }(ne);
    i["serialization"].registerClass(oe);
    var ae = function(t) {
     function e(e) {
      return t.call(this, {
       scale: 2,
       mode: "fanIn",
       distribution: "uniform",
       seed: null == e ? null : e.seed
      }) || this
     }
     return a(e, t), e.prototype.getClassName = function() {
      return ne.className
     }, e.className = "HeUniform", e
    }(ne);
    i["serialization"].registerClass(ae);
    var se = function(t) {
     function e(e) {
      return t.call(this, {
       scale: 1,
       mode: "fanIn",
       distribution: "normal",
       seed: null == e ? null : e.seed
      }) || this
     }
     return a(e, t), e.prototype.getClassName = function() {
      return ne.className
     }, e.className = "LeCunNormal", e
    }(ne);
    i["serialization"].registerClass(se);
    var ue = function(t) {
     function e(e) {
      return t.call(this, {
       scale: 1,
       mode: "fanIn",
       distribution: "uniform",
       seed: null == e ? null : e.seed
      }) || this
     }
     return a(e, t), e.prototype.getClassName = function() {
      return ne.className
     }, e.className = "LeCunNormal", e
    }(ne);
    i["serialization"].registerClass(ue);
    var ce = function(t) {
     function e(e) {
      var n = t.call(this) || this;
      if (n.DEFAULT_GAIN = 1, n.gain = null == e.gain ? n.DEFAULT_GAIN : e.gain, n.seed = e.seed, null != n.seed) throw new m("Random seed is not implemented for Orthogonal Initializer yet.");
      return n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       if (2 !== t.length) throw new m("The Orthogonal Initializer does not support non-2D shapes yet.");
       t[0] * t[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + t[0] * t[1] + ") elements: Slowness may result.");
       var e = _t(t[0] > t[1] ? [t[1], t[0]] : t, 0, 1, "float32"),
        r = i["linalg"].gramSchmidt(e);
       return t[0] > t[1] && (r = r.transpose()), Object(i["mul"])(n.gain, r)
      }))
     }, e.prototype.getConfig = function() {
      return {
       gain: this.gain,
       seed: this.seed
      }
     }, e.className = "Orthogonal", e
    }(qt);
    i["serialization"].registerClass(ce);
    var le = {
     constant: "Constant",
     glorotNormal: "GlorotNormal",
     glorotUniform: "GlorotUniform",
     heNormal: "HeNormal",
     heUniform: "HeUniform",
     identity: "Identity",
     leCunNormal: "LeCunNormal",
     leCunUniform: "LeCunUniform",
     ones: "Ones",
     orthogonal: "Orthogonal",
     randomNormal: "RandomNormal",
     randomUniform: "RandomUniform",
     truncatedNormal: "TruncatedNormal",
     varianceScaling: "VarianceScaling",
     zeros: "Zeros"
    };
 
    function he(t, e) {
     return void 0 === e && (e = {}), A(t, i["serialization"].SerializationMap.getMap().classNameMap, e, "initializer")
    }
 
    function pe(t) {
     return I(t)
    }
 
    function fe(t) {
     if ("string" == typeof t) {
      var e = t in le ? le[t] : t;
      if ("GlorotNormal" === e) return new ie;
      if ("GlorotUniform" === e) return new re;
      if ("HeNormal" === e) return new oe;
      if ("HeUniform" === e) return new ae;
      if ("LeCunNormal" === e) return new se;
      if ("LeCunUniform" === e) return new ue;
      var n = {};
      return n.className = e, n.config = {}, he(n)
     }
     return t instanceof qt ? t : he(t)
    }
 
    function de() {
     return new Kt
    }
 
    function ve() {
     return new Xt
    }
 
    function me(t) {
     return new Yt(t)
    }
 
    function ge(t) {
     return new Zt(t)
    }
 
    function ye(t) {
     return new Jt(t)
    }
 
    function be(t) {
     return new Qt(t)
    }
 
    function xe(t) {
     return new te(t)
    }
 
    function we(t) {
     return new ne(t)
    }
 
    function Ce(t) {
     return new re(t)
    }
 
    function Se(t) {
     return new ie(t)
    }
 
    function Ee(t) {
     return new oe(t)
    }
 
    function ke(t) {
     return new ae(t)
    }
 
    function Ie(t) {
     return new se(t)
    }
 
    function Oe(t) {
     return new ue(t)
    }
 
    function Ae(t) {
     return new ce(t)
    }
    Object.freeze({
     zeros: de,
     ones: ve,
     constant: me,
     randomUniform: ge,
     randomNormal: ye,
     truncatedNormal: be,
     identity: xe,
     varianceScaling: we,
     glorotUniform: Ce,
     glorotNormal: Se,
     heNormal: Ee,
     heUniform: ke,
     leCunNormal: Ie,
     leCunUniform: Oe,
     orthogonal: Ae
    });
    var Ne = 0;
 
    function Re() {
     return Ne++
    }
    var Te = {};
 
    function _e(t) {
     return void 0 === t && (t = ""), t in Te || (Te[t] = 0), Te[t] += 1, t + Te[t].toString()
    }
 
    function De(t) {
     return Array.isArray(t) && Array.isArray(t[0])
    }
 
    function Fe(t) {
     return 0 === t.length ? [] : Array.isArray(t[0]) ? t : [t]
    }
 
    function Me(t) {
     var e;
     if (Array.isArray(t)) {
      if (1 !== t.length) throw new v("Expected Tensor length to be 1; got " + t.length);
      e = t[0]
     } else e = t;
     return e
    }
 
    function Le(t) {
     if (Array.isArray(t) && Array.isArray(t[0])) {
      if (1 === t.length) return (t = t)[0];
      throw new v("Expected exactly 1 Shape; got " + t.length)
     }
     return t
    }
 
    function Be(t) {
     for (var e = 0, n = 0, r = t; n < r.length; n++) {
      var i = r[n];
      0 === i.shape.length ? e += 1 : e += i.shape.reduce((function(t, e) {
       return t * e
      }))
     }
     return e
    }
    var Pe = "Variable",
     ze = function() {
      function t(t, e, n, r, o) {
       void 0 === e && (e = "float32"), void 0 === n && (n = Pe), void 0 === r && (r = !0), void 0 === o && (o = null), this.dtype = null == e ? "float32" : e, this.shape = t.shape, this.id = Re(), n = null == n ? Pe : n, this.originalName = ht(n), this.name = pt(this.originalName), this.trainable_ = r, this.constraint = o, this.val = Object(i["variable"])(t, this.trainable_, this.name, this.dtype)
      }
      return t.prototype.read = function() {
       return this.assertNotDisposed(), this.val
      }, t.prototype.write = function(t) {
       return this.assertNotDisposed(), je(this.val, t), this.val.id !== t.id && (this.val.assign(t), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this
      }, t.prototype.dispose = function() {
       this.assertNotDisposed(), this.val.dispose()
      }, t.prototype.assertNotDisposed = function() {
       if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.")
      }, Object.defineProperty(t.prototype, "trainable", {
       get: function() {
        return this.trainable_
       },
       set: function(t) {
        this.trainable_ = t, this.val.trainable = t
       },
       enumerable: !0,
       configurable: !0
      }), t
     }();
 
    function je(t, e) {
     if (t.shape.toString() !== e.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(t.shape) + " vs. " + JSON.stringify(e.shape))
    }
 
    function We(t) {
     return t.map((function(t) {
      return t.read()
     }))
    }
 
    function Ve(t) {
     t.forEach((function(t) {
      t[0].write(t[1])
     }))
    }
    var Ue = function() {
      return function(t) {
       this.dtype = t.dtype, this.shape = t.shape, null != t.shape ? this.ndim = t.shape.length : this.ndim = t.ndim, this.maxNDim = t.maxNDim, this.minNDim = t.minNDim, this.axes = t.axes || {}
      }
     }(),
     He = function() {
      return function(t, e, n, r, i, o, a) {
       this.dtype = t, this.shape = e, this.sourceLayer = n, this.inputs = r, this.callArgs = i, this.outputTensorIndex = a, this.id = Re(), null != o && (this.originalName = ht(o), this.name = pt(this.originalName)), this.rank = e.length
      }
     }(),
     $e = 0,
     Ge = function() {
      function t(t, e) {
       this.callArgs = e, this.id = $e++, this.outboundLayer = t.outboundLayer, this.inboundLayers = t.inboundLayers, this.nodeIndices = t.nodeIndices, this.tensorIndices = t.tensorIndices, this.inputTensors = t.inputTensors, this.outputTensors = t.outputTensors, this.inputMasks = t.inputMasks, this.outputMasks = t.outputMasks, this.inputShapes = t.inputShapes, this.outputShapes = t.outputShapes;
       for (var n = 0, r = t.inboundLayers; n < r.length; n++) {
        var i = r[n];
        null != i && i.outboundNodes.push(this)
       }
       t.outboundLayer.inboundNodes.push(this)
      }
      return t.prototype.getConfig = function() {
       for (var t = [], e = 0, n = this.inboundLayers; e < n.length; e++) {
        var r = n[e];
        null != r ? t.push(r.name) : t.push(null)
       }
       return {
        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
        inboundLayers: t,
        nodeIndices: this.nodeIndices,
        tensorIndices: this.tensorIndices
       }
      }, t
     }(),
     qe = 0,
     Ke = function(t) {
      function e(e) {
       var n = t.call(this) || this;
       n._callHook = null, n._addedWeightNames = [], n._stateful = !1, n.id = qe++, n.activityRegularizer = null, n.inputSpec = null, n.supportsMasking = !1, n._trainableWeights = [], n._nonTrainableWeights = [], n._losses = [], n._updates = [], n._built = !1, n.inboundNodes = [], n.outboundNodes = [];
       var r = e.name;
       if (!r) {
        var i = n.getClassName();
        r = S(i) + "_" + _e(i)
       }
       if (n.name = r, n.trainable_ = null == e.trainable || e.trainable, null != e.inputShape || null != e.batchInputShape) {
        var o = void 0;
        if (null != e.batchInputShape) o = e.batchInputShape;
        else if (null != e.inputShape) {
         var a = null;
         null != e.batchSize && (a = e.batchSize), o = [a].concat(e.inputShape)
        }
        n.batchInputShape = o;
        var s = e.dtype;
        null == s && (s = e.inputDType), null == s && (s = "float32"), n.dtype = s
       }
       return null != e.weights ? n.initialWeights = e.weights : n.initialWeights = null, n._refCount = null, n.fastWeightInitDuringBuild = !1, n
      }
      return a(e, t), e.nodeKey = function(t, e) {
       return t.name + "_ib-" + e.toString()
      }, e.prototype.getNodeAtIndex = function(t, e) {
       if (0 === this.inboundNodes.length) throw new d("The layer has never been called and thus has no defined " + e + ".");
       if (this.inboundNodes.length <= t) throw new v("Asked to get " + e + " at node " + t + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
       return this.inboundNodes[t]
      }, e.prototype.getInputAt = function(t) {
       return w(this.getNodeAtIndex(t, "input").inputTensors)
      }, e.prototype.getOutputAt = function(t) {
       return w(this.getNodeAtIndex(t, "output").outputTensors)
      }, Object.defineProperty(e.prototype, "input", {
       get: function() {
        if (this.inboundNodes.length > 1) throw new f("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
        if (0 === this.inboundNodes.length) throw new f("Layer " + this.name + " is not connected, no input to return.");
        return w(this.getNodeAtIndex(0, "input").inputTensors)
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "output", {
       get: function() {
        if (0 === this.inboundNodes.length) throw new f("Layer " + this.name + " has no inbound nodes.");
        if (this.inboundNodes.length > 1) throw new f("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
        return w(this.getNodeAtIndex(0, "output").outputTensors)
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "losses", {
       get: function() {
        return this._losses
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.calculateLosses = function() {
       return this.losses.map((function(t) {
        return t()
       }))
      }, Object.defineProperty(e.prototype, "updates", {
       get: function() {
        return this._updates
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "built", {
       get: function() {
        return this._built
       },
       set: function(t) {
        this._built = t
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "trainable", {
       get: function() {
        return this.trainable_
       },
       set: function(t) {
        this._trainableWeights.forEach((function(e) {
         return e.trainable = t
        })), this.trainable_ = t
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "trainableWeights", {
       get: function() {
        return this.trainable_ ? this._trainableWeights.filter((function(t) {
         return t.trainable
        })) : []
       },
       set: function(t) {
        this._trainableWeights = t
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
       get: function() {
        return this.trainable ? this._trainableWeights.filter((function(t) {
         return !t.trainable
        })).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights)
       },
       set: function(t) {
        this._nonTrainableWeights = t
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "weights", {
       get: function() {
        return this.trainableWeights.concat(this.nonTrainableWeights)
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "stateful", {
       get: function() {
        return this._stateful
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.resetStates = function() {
       if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")
      }, e.prototype.assertInputCompatibility = function(t) {
       if (t = C(t), null != this.inputSpec && 0 !== this.inputSpec.length) {
        var e = C(this.inputSpec);
        if (t.length !== e.length) throw new v("Layer " + this.name + " expects " + e.length + " inputs, but it received " + t.length + " input tensors. Input received: " + t);
        for (var n = 0; n < t.length; n++) {
         var r = t[n],
          i = e[n];
         if (null != i) {
          var o = r.rank;
          if (null != i.ndim && o !== i.ndim) throw new v("Input " + n + " is incompatible with layer " + this.name + ": expected ndim=" + i.ndim + ", found ndim=" + o);
          if (null != i.maxNDim && o > i.maxNDim) throw new v("Input " + n + " is incompatible with layer " + this.name + ": expected max_ndim=" + i.maxNDim + ", found ndim=" + o);
          if (null != i.minNDim && o < i.minNDim) throw new v("Input " + n + " is incompatible with layer " + this.name + ": expected min_ndim=" + i.minNDim + ", found ndim=" + o + ".");
          if (null != i.dtype && r.dtype !== i.dtype) throw new v("Input " + n + " is incompatible with layer " + this.name + " : expected dtype=" + i.dtype + ", found dtype=" + r.dtype + ".");
          if (i.axes) {
           var a = r.shape;
           for (var s in i.axes) {
            var u = Number(s),
             c = i.axes[s],
             l = u >= 0 ? a[u] : a[a.length + u];
            if (null != c && -1 === [c, null].indexOf(l)) throw new v("Input " + n + " is incompatible with layer " + this.name + ": expected axis " + u + " of input shape to have value " + c + " but got shape " + a + ".")
           }
          }
          if (null != i.shape)
           for (var h = 0; h < i.shape.length; ++h) {
            var p = i.shape[h],
             f = r.shape[h];
            if (null != p && null != f && p !== f) throw new v("Input " + n + " is incompatible with layer " + this.name + ": expected shape=" + i.shape + ", found shape=" + r.shape + ".")
           }
         }
        }
       }
      }, e.prototype.call = function(t, e) {
       return t
      }, e.prototype.invokeCallHook = function(t, e) {
       null != this._callHook && this._callHook(t, e)
      }, e.prototype.setCallHook = function(t) {
       this._callHook = t
      }, e.prototype.clearCallHook = function() {
       this._callHook = null
      }, e.prototype.apply = function(t, e) {
       var n = this;
       e = e || {}, this.assertNotDisposed();
       for (var r = C(t), i = !0, o = 0, a = r; o < a.length; o++)
        if (!(a[o] instanceof He)) {
         i = !1;
         break
        } for (var s = !0, u = 0, c = r; u < c.length; u++)
        if (c[u] instanceof He) {
         s = !1;
         break
        } if (i === s) throw new v("Arguments to apply() must be all SymbolicTensors or all Tensors");
       return ct(this.name, (function() {
        if (!n.built) {
         n.assertInputCompatibility(t);
         for (var i = [], o = 0, a = C(t); o < a.length; o++) {
          var u = a[o];
          i.push(u.shape)
         }
         n.build(w(i)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && s && (n._refCount = 1)
        }
        if (n.assertInputCompatibility(t), s) {
         for (var c = [], l = 0, h = C(v = n.call(t, e)); l < h.length; l++) {
          var p = h[l]; - 1 !== r.indexOf(p) && (p = p.clone()), c.push(p)
         }
         if (v = w(c), null != n.activityRegularizer) throw new m("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
         return v
        }
        var f = Xe(t),
         d = n.computeOutputShape(f),
         v = void 0,
         g = Ye(t);
        if (n.warnOnIncompatibleInputShape(Array.isArray(t) ? f[0] : f), v = null != d && d.length > 0 && Array.isArray(d[0]) ? d.map((function(r, i) {
          return new He(g, r, n, C(t), e, n.name, i)
         })) : new He(g, d, n, C(t), e, n.name), n.addInboundNode(t, v, null, null, f, d, e), n._refCount++, null != n.activityRegularizer) throw new m("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
        return v
       }))
      }, e.prototype.warnOnIncompatibleInputShape = function(t) {
       if (null != this.batchInputShape)
        if (t.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(t) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);
        else {
         var e = !1;
         this.batchInputShape.forEach((function(n, r) {
          null != n && null != t[r] && t[r] !== n && (e = !0)
         })), e && console.warn("The shape of the input tensor (" + JSON.stringify(t) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape))
        }
      }, Object.defineProperty(e.prototype, "outputShape", {
       get: function() {
        if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new f("The layer " + this.name + " has never been called and thus has no defined output shape.");
        for (var t = [], e = 0, n = this.inboundNodes; e < n.length; e++) {
         var r = n[e],
          i = JSON.stringify(r.outputShapes); - 1 === t.indexOf(i) && t.push(i)
        }
        if (1 === t.length) {
         var o = this.inboundNodes[0].outputShapes;
         return Array.isArray(o) && Array.isArray(o[0]) && 1 === o.length ? o[0] : o
        }
        throw new f("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.')
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.countParams = function() {
       if (!this.built) throw new d("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
       return Be(this.weights)
      }, e.prototype.build = function(t) {
       this.built = !0
      }, e.prototype.getWeights = function(t) {
       return void 0 === t && (t = !1), We(t ? this.trainableWeights : this.weights)
      }, e.prototype.setWeights = function(t) {
       var e = this;
       Object(i["tidy"])((function() {
        var n = e.weights;
        if (n.length !== t.length) throw new v('You called setWeights(weights) on layer "' + e.name + '" with a weight list of length ' + t.length + ", but the layer was expecting " + n.length + " weights. Provided weights: " + t + "...");
        if (0 !== n.length) {
         for (var r = [], o = We(n), a = 0; a < o.length; ++a) {
          var s = o[a],
           u = n[a],
           c = t[a];
          if (!i["util"].arraysEqual(s.shape, c.shape)) throw new v("Layer weight shape " + s.shape + " not compatible with provided weight shape " + c.shape);
          r.push([u, c])
         }
         Ve(r)
        }
       }))
      }, e.prototype.addWeight = function(t, e, n, r, i, o, a) {
       if (-1 !== this._addedWeightNames.indexOf(t)) throw new v("Duplicate weight name " + t + " for layer " + this.name);
       this._addedWeightNames.push(t), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = fe("zeros"));
       var s = r.apply(e, n),
        u = new ze(s, n, t, o, a);
       return s.dispose(), null != i && this.addLoss((function() {
        return i.apply(u.read())
       })), null == o && (o = !0), o ? this._trainableWeights.push(u) : this._nonTrainableWeights.push(u), u
      }, e.prototype.setFastWeightInitDuringBuild = function(t) {
       this.fastWeightInitDuringBuild = t
      }, e.prototype.addLoss = function(t) {
       var e;
       null == t || Array.isArray(t) && 0 === t.length || (t = C(t), void 0 !== this._losses && null !== this._losses && (e = this.losses).push.apply(e, t))
      }, e.prototype.computeOutputShape = function(t) {
       return t
      }, e.prototype.computeMask = function(t, e) {
       var n = this;
       if (!this.supportsMasking) {
        if (null != e) {
         if (!Array.isArray(e)) throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
         e.forEach((function(t) {
          if (null != t) throw new TypeError("Layer " + n.name + " does not support masking, but was passed an inputMask.")
         }))
        }
        return null
       }
       return e
      }, e.prototype.addInboundNode = function(t, e, n, r, i, o, a) {
       void 0 === a && (a = null);
       var s = C(t);
       e = C(e), n = C(n), r = C(r), i = Fe(i), o = Fe(o);
       for (var u = [], c = [], l = [], h = 0, p = s; h < p.length; h++) {
        var f = p[h];
        u.push(f.sourceLayer), c.push(f.nodeIndex), l.push(f.tensorIndex)
       }
       new Ge({
        outboundLayer: this,
        inboundLayers: u,
        nodeIndices: c,
        tensorIndices: l,
        inputTensors: s,
        outputTensors: e,
        inputMasks: n,
        outputMasks: r,
        inputShapes: i,
        outputShapes: o
       }, a);
       for (var d = 0; d < e.length; d++) e[d].sourceLayer = this, e[d].nodeIndex = this.inboundNodes.length - 1, e[d].tensorIndex = d
      }, e.prototype.getConfig = function() {
       var t = {
        name: this.name,
        trainable: this.trainable
       };
       return null != this.batchInputShape && (t.batchInputShape = this.batchInputShape), null != this.dtype && (t.dtype = this.dtype), t
      }, e.prototype.disposeWeights = function() {
       return this.weights.forEach((function(t) {
        return t.dispose()
       })), this.weights.length
      }, e.prototype.assertNotDisposed = function() {
       if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.")
      }, e.prototype.dispose = function() {
       if (!this.built) throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
       if (null === this._refCount) throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
       this.assertNotDisposed();
       var t = 0;
       return 0 == --this._refCount && (t = this.disposeWeights()), {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: t
       }
      }, e
     }(i["serialization"].Serializable);
 
    function Xe(t) {
     for (var e = [], n = 0, r = t = C(t); n < r.length; n++) {
      var i = r[n];
      e.push(i.shape)
     }
     return w(e)
    }
 
    function Ye(t) {
     return "float32"
    }
 
    function Ze(t, e, n) {
     if ((null == e || null != n && n > 0) && (e = t.sourceLayer, n = t.nodeIndex), 0 === e.inboundNodes.length) return [t];
     var r = e.inboundNodes[n];
     if (0 === r.inboundLayers.length) return r.inputTensors;
     for (var i = [], o = 0; o < r.inboundLayers.length; o++)
      for (var a = 0, s = Ze(r.inputTensors[o], r.inboundLayers[o], r.nodeIndices[o]); a < s.length; a++) {
       var u = s[a]; - 1 === i.indexOf(u) && i.push(u)
      }
     return i
    }
    var Je, Qe = function(t) {
     function e(e) {
      var n = t.call(this, {
       dtype: e.dtype,
       name: null != e.name ? e.name : _e("input").toString()
      }) || this;
      if (null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), n.trainable = !1, n.built = !0, n.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new v("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      var r = e.batchInputShape;
      if (null == r) {
       if (null == e.inputShape) throw new v("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
       r = [e.batchSize].concat(e.inputShape)
      } else if (null != e.batchSize) throw new v("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      var i = e.dtype || "float32";
      n.batchInputShape = r, n.dtype = i, n.inputSpec = [{
       shape: r
      }];
      var o = new He(n.dtype, n.batchInputShape, n, [], {}, n.name);
      return o.nodeIndex = 0, o.tensorIndex = 0, new Ge({
       outboundLayer: n,
       inboundLayers: [],
       nodeIndices: [],
       tensorIndices: [],
       inputTensors: [o],
       outputTensors: [o],
       inputMasks: [null],
       outputMasks: [null],
       inputShapes: [r],
       outputShapes: [r]
      }), n
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      throw new v("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name)
     }, e.prototype.dispose = function() {
      return {
       refCountAfterDispose: this._refCount,
       numDisposedVariables: 0
      }
     }, e.prototype.getConfig = function() {
      return {
       batchInputShape: this.batchInputShape,
       dtype: this.dtype,
       sparse: this.sparse,
       name: this.name
      }
     }, e.className = "InputLayer", e
    }(Ke);
 
    function tn(t) {
     if (null == t.batchShape && null == t.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
     if (null != t.batchShape && null != t.shape) throw new v("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
     var e = t.batchShape;
     null != t.shape && null == e && (e = [null].concat(t.shape));
     var n = t.dtype;
     return null == n && (n = "float32"), new Qe({
      batchInputShape: e,
      name: t.name,
      dtype: n,
      sparse: t.sparse
     }).inboundNodes[0].outputTensors[0]
    }
 
    function en(t) {
     return c(this, void 0, void 0, (function() {
      var e, n, r, o, a, s, u, c;
      return l(this, (function(l) {
       switch (l.label) {
        case 0:
         if (null == t) return [2];
         for (o in e = [], n = [], r = [], t) "number" != typeof(a = t[o]) && (s = a, e.push(s.data()), n.push(o), r.push(s));
         return e.length > 0 ? [4, Promise.all(e)] : [3, 2];
        case 1:
         for (u = l.sent(), c = 0; c < u.length; ++c) t[n[c]] = u[c][0];
         Object(i["dispose"])(r), l.label = 2;
        case 2:
         return [2]
       }
      }))
     }))
    }
 
    function nn(t) {
     if (null != t)
      for (var e in t) {
       var n = t[e];
       "number" != typeof n && n.dispose()
      }
    }
    i["serialization"].registerClass(Qe),
     function(t) {
      t[t.SILENT = 0] = "SILENT", t[t.VERBOSE = 1] = "VERBOSE"
     }(Je || (Je = {}));
    var rn = 125,
     on = function() {
      function t() {
       this.validationData = null
      }
      return t.prototype.setParams = function(t) {
       this.params = t
      }, t.prototype.onEpochBegin = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return [2]
        }))
       }))
      }, t.prototype.onEpochEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return [2]
        }))
       }))
      }, t.prototype.onBatchBegin = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return [2]
        }))
       }))
      }, t.prototype.onBatchEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return [2]
        }))
       }))
      }, t.prototype.onTrainBegin = function(t) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return [2]
        }))
       }))
      }, t.prototype.onTrainEnd = function(t) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return [2]
        }))
       }))
      }, t.prototype.setModel = function(t) {}, t
     }(),
     an = function() {
      function t(t, e) {
       void 0 === e && (e = 10), null == t && (t = []), this.callbacks = t, this.queueLength = e
      }
      return t.prototype.append = function(t) {
       this.callbacks.push(t)
      }, t.prototype.setParams = function(t) {
       for (var e = 0, n = this.callbacks; e < n.length; e++) n[e].setParams(t)
      }, t.prototype.setModel = function(t) {
       for (var e = 0, n = this.callbacks; e < n.length; e++) n[e].setModel(t)
      }, t.prototype.onEpochBegin = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n, r;
        return l(this, (function(i) {
         switch (i.label) {
          case 0:
           null == e && (e = {}), n = 0, r = this.callbacks, i.label = 1;
          case 1:
           return n < r.length ? [4, r[n].onEpochBegin(t, e)] : [3, 4];
          case 2:
           i.sent(), i.label = 3;
          case 3:
           return n++, [3, 1];
          case 4:
           return [2]
         }
        }))
       }))
      }, t.prototype.onEpochEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n, r;
        return l(this, (function(i) {
         switch (i.label) {
          case 0:
           null == e && (e = {}), n = 0, r = this.callbacks, i.label = 1;
          case 1:
           return n < r.length ? [4, r[n].onEpochEnd(t, e)] : [3, 4];
          case 2:
           i.sent(), i.label = 3;
          case 3:
           return n++, [3, 1];
          case 4:
           return [2]
         }
        }))
       }))
      }, t.prototype.onBatchBegin = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n, r;
        return l(this, (function(i) {
         switch (i.label) {
          case 0:
           null == e && (e = {}), n = 0, r = this.callbacks, i.label = 1;
          case 1:
           return n < r.length ? [4, r[n].onBatchBegin(t, e)] : [3, 4];
          case 2:
           i.sent(), i.label = 3;
          case 3:
           return n++, [3, 1];
          case 4:
           return [2]
         }
        }))
       }))
      }, t.prototype.onBatchEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n, r;
        return l(this, (function(i) {
         switch (i.label) {
          case 0:
           null == e && (e = {}), n = 0, r = this.callbacks, i.label = 1;
          case 1:
           return n < r.length ? [4, r[n].onBatchEnd(t, e)] : [3, 4];
          case 2:
           i.sent(), i.label = 3;
          case 3:
           return n++, [3, 1];
          case 4:
           return [2]
         }
        }))
       }))
      }, t.prototype.onTrainBegin = function(t) {
       return c(this, void 0, void 0, (function() {
        var e, n;
        return l(this, (function(r) {
         switch (r.label) {
          case 0:
           null == t && (t = {}), e = 0, n = this.callbacks, r.label = 1;
          case 1:
           return e < n.length ? [4, n[e].onTrainBegin(t)] : [3, 4];
          case 2:
           r.sent(), r.label = 3;
          case 3:
           return e++, [3, 1];
          case 4:
           return [2]
         }
        }))
       }))
      }, t.prototype.onTrainEnd = function(t) {
       return c(this, void 0, void 0, (function() {
        var e, n;
        return l(this, (function(r) {
         switch (r.label) {
          case 0:
           null == t && (t = {}), e = 0, n = this.callbacks, r.label = 1;
          case 1:
           return e < n.length ? [4, n[e].onTrainEnd(t)] : [3, 4];
          case 2:
           r.sent(), r.label = 3;
          case 3:
           return e++, [3, 1];
          case 4:
           return [2]
         }
        }))
       }))
      }, t
     }(),
     sn = function(t) {
      function e() {
       return t.call(this) || this
      }
      return a(e, t), e.prototype.onEpochBegin = function(t) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return this.seen = 0, this.totals = {}, [2]
        }))
       }))
      }, e.prototype.onBatchEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var t, n, r, o, a = this;
        return l(this, (function(s) {
         for (o in null == e && (e = {}), t = null == e.size ? 0 : e.size, this.seen += t, n = function(n) {
           var o = e[n];
           if ("number" == typeof o) r.totals.hasOwnProperty(n) || (r.totals[n] = 0), r.totals[n] = r.totals[n] + o * t;
           else {
            var s = void 0;
            n in r.totals ? s = r.totals[n] : r.totals[n] = 0;
            var u = Object(i["tidy"])((function() {
             return Object(i["add"])(a.totals[n], Object(i["mul"])(o, t))
            }));
            r.totals[n] = u, null != s && s.dispose()
           }
          }, r = this, e) n(o);
         return [2]
        }))
       }))
      }, e.prototype.onEpochEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var t, n, r, o, a, s = this;
        return l(this, (function(u) {
         if (null != e)
          for (t = function(t) {
            if (null == n.totals[t]) return "continue";
            "number" == typeof n.totals[t] ? e[t] = n.totals[t] / n.seen : Object(i["tidy"])((function() {
             var n = Object(i["mul"])(Object(i["div"])(1, s.seen), s.totals[t]);
             e[t] = n, s.totals[t].dispose(), Object(i["keep"])(e[t])
            }))
           }, n = this, r = 0, o = this.params.metrics; r < o.length; r++) a = o[r], t(a);
         return [2]
        }))
       }))
      }, e
     }(on),
     un = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.onTrainBegin = function(t) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(t) {
         return this.epoch = [], this.history = {}, [2]
        }))
       }))
      }, e.prototype.onEpochEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n;
        return l(this, (function(r) {
         for (n in null == e && (e = {}), this.epoch.push(t), e) null == this.history[n] && (this.history[n] = []), this.history[n].push(e[n]);
         return [2]
        }))
       }))
      }, e.prototype.syncData = function() {
       return c(this, void 0, void 0, (function() {
        var t, e, n, r, i, o, a, s, u;
        return l(this, (function(c) {
         switch (c.label) {
          case 0:
           for (r in t = [], e = [], n = [], this.history)
            for (i = this.history[r], o = 0; o < i.length; ++o) "number" != typeof i[o] && (a = i[o], t.push(a.data()), e.push(r), n.push(o));
           return [4, Promise.all(t)];
          case 1:
           for (s = c.sent(), u = 0; u < s.length; ++u) this.history[e[u]][n[u]].dispose(), this.history[e[u]][n[u]] = s[u][0];
           return [2]
         }
        }))
       }))
      }, e
     }(on),
     cn = function(t) {
      function e(e, n) {
       var r = t.call(this) || this;
       if (r.currentEpoch = 0, r.yieldEvery = n || "auto", "auto" === r.yieldEvery && (r.yieldEvery = rn), "never" === r.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
       return i["util"].isNumber(r.yieldEvery) && (r.maybeWait = B(r.maybeWait.bind(r), r.yieldEvery)), r.trainBegin = e.onTrainBegin, r.trainEnd = e.onTrainEnd, r.epochBegin = e.onEpochBegin, r.epochEnd = e.onEpochEnd, r.batchBegin = e.onBatchBegin, r.batchEnd = e.onBatchEnd, r.yield = e.onYield, r
      }
      return a(e, t), e.prototype.maybeWait = function(t, e, n) {
       return c(this, void 0, void 0, (function() {
        var r;
        return l(this, (function(o) {
         switch (o.label) {
          case 0:
           return r = [], null == this.yield ? [3, 2] : [4, en(n)];
          case 1:
           o.sent(), r.push(this.yield(t, e, n)), o.label = 2;
          case 2:
           return r.push(Object(i["nextFrame"])()), [4, Promise.all(r)];
          case 3:
           return o.sent(), [2]
         }
        }))
       }))
      }, e.prototype.onEpochBegin = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(n) {
         switch (n.label) {
          case 0:
           return this.currentEpoch = t, null == this.epochBegin ? [3, 3] : [4, en(e)];
          case 1:
           return n.sent(), [4, this.epochBegin(t, e)];
          case 2:
           n.sent(), n.label = 3;
          case 3:
           return [2]
         }
        }))
       }))
      }, e.prototype.onEpochEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n;
        return l(this, (function(r) {
         switch (r.label) {
          case 0:
           return n = [], null == this.epochEnd ? [3, 2] : [4, en(e)];
          case 1:
           r.sent(), n.push(this.epochEnd(t, e)), r.label = 2;
          case 2:
           return "epoch" === this.yieldEvery && n.push(Object(i["nextFrame"])()), [4, Promise.all(n)];
          case 3:
           return r.sent(), [2]
         }
        }))
       }))
      }, e.prototype.onBatchBegin = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(n) {
         switch (n.label) {
          case 0:
           return null == this.batchBegin ? [3, 3] : [4, en(e)];
          case 1:
           return n.sent(), [4, this.batchBegin(t, e)];
          case 2:
           n.sent(), n.label = 3;
          case 3:
           return [2]
         }
        }))
       }))
      }, e.prototype.onBatchEnd = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n;
        return l(this, (function(r) {
         switch (r.label) {
          case 0:
           return n = [], null == this.batchEnd ? [3, 2] : [4, en(e)];
          case 1:
           r.sent(), n.push(this.batchEnd(t, e)), r.label = 2;
          case 2:
           return "batch" === this.yieldEvery ? n.push(Object(i["nextFrame"])()) : i["util"].isNumber(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, t, e)), [4, Promise.all(n)];
          case 3:
           return r.sent(), [2]
         }
        }))
       }))
      }, e.prototype.onTrainBegin = function(t) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(e) {
         switch (e.label) {
          case 0:
           return null == this.trainBegin ? [3, 3] : [4, en(t)];
          case 1:
           return e.sent(), [4, this.trainBegin(t)];
          case 2:
           e.sent(), e.label = 3;
          case 3:
           return [2]
         }
        }))
       }))
      }, e.prototype.onTrainEnd = function(t) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(e) {
         switch (e.label) {
          case 0:
           return null == this.trainEnd ? [3, 3] : [4, en(t)];
          case 1:
           return e.sent(), [4, this.trainEnd(t)];
          case 2:
           e.sent(), e.label = 3;
          case 3:
           return [2]
         }
        }))
       }))
      }, e
     }(on);
 
    function ln(t, e) {
     return null == t && (t = {}), t instanceof on ? [t] : Array.isArray(t) && t[0] instanceof on ? t : C(t).map((function(t) {
      return new cn(t, e)
     }))
    }
    var hn = function() {
     function t() {}
     return t.registerCallbackConstructor = function(e, n) {
      i["util"].assert(e >= 0 && Number.isInteger(e), (function() {
       return "Verbosity level is expected to be an integer >= 0, but got " + e
      })), t.checkForDuplicate(n), null == t.constructors[e] && (t.constructors[e] = []), t.constructors[e].push(n)
     }, t.checkForDuplicate = function(e) {
      for (var n in t.constructors) t.constructors[+n].forEach((function(t) {
       if (t === e) throw new v("Duplicate callback constructor.")
      }))
     }, t.clear = function() {
      t.constructors = {}
     }, t.createCallbacks = function(e) {
      var n = [];
      for (var r in t.constructors) {
       var i = +r;
       e >= i && n.push.apply(n, t.constructors[i])
      }
      return n.map((function(t) {
       return new t
      }))
     }, t.constructors = {}, t
    }();
 
    function pn(t, e, n, r, i, o, a, s, u) {
     var c = new un,
      l = [new sn].concat(hn.createCallbacks(e));
     null != t && l.push.apply(l, t), l.push(c);
     var h = new an(l);
     return h.setParams({
      epochs: n,
      initialEpoch: r,
      samples: i,
      steps: o,
      batchSize: a,
      verbose: e,
      doValidation: s,
      metrics: u
     }), {
      callbackList: h,
      history: c
     }
    }
 
    function fn(t, e, n) {
     return void 0 === e && (e = {}), void 0 === n && (n = !1), A(t, i["serialization"].SerializationMap.getMap().classNameMap, e, "layer", n)
    }
 
    function dn(t, e) {
     return Object(i["tidy"])((function() {
      "float32" !== t.dtype && (t = t.asType("float32"));
      var n = Object(i["sum"])(Mt(t), e, !0),
       r = Object(i["fill"])(n.shape, h()),
       o = Object(i["sqrt"])(Object(i["maximum"])(n, r));
      return Object(i["div"])(t, o)
     }))
    }
 
    function vn(t, e) {
     return Object(i["tidy"])((function() {
      return Object(i["mean"])(Mt(Object(i["sub"])(e, t)), -1)
     }))
    }
 
    function mn(t, e) {
     return Object(i["tidy"])((function() {
      return Object(i["mean"])(Object(i["abs"])(Object(i["sub"])(e, t)), -1)
     }))
    }
 
    function gn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["sub"])(t, e),
       r = Object(i["clipByValue"])(Object(i["abs"])(t), h(), Number.MAX_VALUE),
       o = Object(i["abs"])(Object(i["div"])(n, r));
      return Object(i["mul"])(100, Object(i["mean"])(o, -1))
     }))
    }
 
    function yn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["clipByValue"])(e, h(), Number.MAX_VALUE),
       r = Object(i["log"])(Object(i["add"])(1, n)),
       o = Object(i["clipByValue"])(t, h(), Number.MAX_VALUE),
       a = Object(i["log"])(Object(i["add"])(1, o));
      return Object(i["mean"])(Mt(Object(i["sub"])(r, a)), -1)
     }))
    }
 
    function bn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["maximum"])(0, Object(i["sub"])(1, Object(i["mul"])(t, e)));
      return Object(i["mean"])(Mt(n), -1)
     }))
    }
 
    function xn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["maximum"])(0, Object(i["sub"])(1, Object(i["mul"])(t, e)));
      return Object(i["mean"])(n, -1)
     }))
    }
 
    function wn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["sum"])(Object(i["mul"])(t, e), -1),
       r = Object(i["max"])(Object(i["mul"])(Object(i["sub"])(1, t), e), -1);
      return Object(i["maximum"])(0, Object(i["add"])(1, Object(i["sub"])(r, n)))
     }))
    }
 
    function Cn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Math.log(2),
       r = Object(i["sub"])(e, t),
       o = Object(i["sub"])(Object(i["add"])(r, Object(i["softplus"])(Object(i["mul"])(-2, r))), n);
      return Object(i["mean"])(o, -1)
     }))
    }
 
    function Sn(t, e, n) {
     return void 0 === n && (n = !1), Object(i["tidy"])((function() {
      if (n) e = Object(i["softmax"])(e);
      else {
       var r = Object(i["sum"])(e, e.shape.length - 1, !0);
       e = Object(i["div"])(e, r)
      }
      return e = Object(i["clipByValue"])(e, h(), 1 - h()), Object(i["neg"])(Object(i["sum"])(Object(i["mul"])(t.toFloat(), Object(i["log"])(e)), e.shape.length - 1))
     }))
    }
 
    function En(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["floor"])(Et(t)).toInt(),
       r = (e = Object(i["clipByValue"])(e, h(), 1 - h())).shape;
      return Sn(Object(i["oneHot"])(n, r[r.length - 1]).reshape(r), e, !1)
     }))
    }
 
    function kn(t, e) {
     if (!i["util"].arraysEqual(t.shape, e.shape)) throw new v("logits and labels must have the same shape, but got shapes " + JSON.stringify(t.shape) + " and " + JSON.stringify(e.shape));
     return Object(i["tidy"])((function() {
      var n = e.relu(),
       r = e.abs().neg();
      return n.sub(e.mul(t)).add(r.exp().log1p())
     }))
    }
 
    function In(t, e) {
     return Object(i["tidy"])((function() {
      var n;
      return n = Object(i["clipByValue"])(e, h(), 1 - h()), n = Object(i["log"])(Object(i["div"])(n, Object(i["sub"])(1, n))), Object(i["mean"])(kn(t, n), -1)
     }))
    }
 
    function On(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["clipByValue"])(t, h(), 1),
       r = Object(i["clipByValue"])(e, h(), 1);
      return Object(i["sum"])(Object(i["mul"])(t, Object(i["log"])(Object(i["div"])(n, r))), -1)
     }))
    }
 
    function An(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["log"])(Object(i["add"])(h(), e));
      return Object(i["mean"])(Object(i["sub"])(e, Object(i["mul"])(t, n)), -1)
     }))
    }
 
    function Nn(t, e) {
     return Object(i["tidy"])((function() {
      var n = dn(t, -1),
       r = dn(e, -1),
       o = Object(i["mul"])(n, r);
      return Object(i["neg"])(Object(i["sum"])(o, -1))
     }))
    }
    var Rn = {
     meanSquaredError: vn,
     meanAbsoluteError: mn,
     meanAbsolutePercentageError: gn,
     meanSquaredLogarithmicError: yn,
     squaredHinge: bn,
     hinge: xn,
     categoricalHinge: wn,
     logcosh: Cn,
     categoricalCrossentropy: Sn,
     sparseCategoricalCrossentropy: En,
     binaryCrossentropy: In,
     kullbackLeiblerDivergence: On,
     poisson: An,
     cosineProximity: Nn
    };
 
    function Tn(t) {
     if ("string" == typeof t) {
      if (t in Rn) return Rn[t];
      var e = "Unknown loss " + t;
      throw t.toLowerCase().includes("softmaxcrossentropy") && (e = "Unknown loss " + t + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new v(e)
     }
     return t
    }
 
    function _n(t, e) {
     return Object(i["tidy"])((function() {
      var n = Object(i["mul"])(.5, Object(i["onesLike"])(e)),
       r = wt(Object(i["greater"])(e, n), t.dtype);
      return Object(i["mean"])(Object(i["equal"])(t, r), -1)
     }))
    }
 
    function Dn(t, e) {
     return Object(i["tidy"])((function() {
      return wt(Object(i["equal"])(Object(i["argMax"])(t, -1), Object(i["argMax"])(e, -1)), "float32")
     }))
    }
 
    function Fn(t, e) {
     return Object(i["tidy"])((function() {
      return Object(i["logicalAnd"])(t.equal(1), e.equal(1)).sum().cast("float32")
     }))
    }
 
    function Mn(t, e) {
     return Object(i["tidy"])((function() {
      return Object(i["logicalAnd"])(t.equal(1), e.equal(0)).sum().cast("float32")
     }))
    }
 
    function Ln(t, e) {
     return Object(i["tidy"])((function() {
      return Object(i["logicalAnd"])(t.equal(0), e.equal(1)).sum().cast("float32")
     }))
    }
 
    function Bn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Fn(t, e),
       r = Ln(t, e),
       o = n.add(r);
      return Object(i["where"])(Object(i["greater"])(o, 0), n.div(o), 0).cast("float32")
     }))
    }
 
    function Pn(t, e) {
     return Object(i["tidy"])((function() {
      var n = Fn(t, e),
       r = Mn(t, e),
       o = n.add(r);
      return Object(i["where"])(Object(i["greater"])(o, 0), n.div(o), 0).cast("float32")
     }))
    }
 
    function zn(t, e) {
     return In(t, e)
    }
 
    function jn(t, e) {
     return t.rank === e.rank && (t = t.squeeze([t.rank - 1])), (e = e.argMax(-1)).dtype !== t.dtype && (e = e.asType(t.dtype)), Object(i["equal"])(t, e).asType("float32")
    }
    var Wn = vn,
     Vn = vn,
     Un = mn,
     Hn = mn,
     $n = gn,
     Gn = gn,
     qn = Sn,
     Kn = Nn,
     Xn = En,
     Yn = {
      binaryAccuracy: _n,
      categoricalAccuracy: Dn,
      precision: Bn,
      categoricalCrossentropy: qn,
      sparseCategoricalCrossentropy: Xn,
      mse: Wn,
      MSE: Vn,
      mae: Un,
      MAE: Hn,
      mape: $n,
      MAPE: Gn,
      cosine: Kn
     };
 
    function Zn(t) {
     if ("string" == typeof t && t in Yn) return Yn[t];
     if ("string" != typeof t && null != t) return t;
     throw new v("Unknown metric " + t)
    }
 
    function Jn(t) {
     if (b(null !== t, "Unknown LossOrMetricFn " + t), "string" == typeof t) return t;
     for (var e = void 0, n = 0, r = Object.keys(Rn); n < r.length; n++) {
      var i = r[n];
      if (Rn[i] === t) {
       e = i;
       break
      }
     }
     if (void 0 !== e) return e;
     for (var o = 0, a = Object.keys(Yn); o < a.length; o++)
      if (i = a[o], Yn[i] === t) {
       e = i;
       break
      } return void 0 !== e ? e : t.name
    }
 
    function Qn(t) {
     var e = {
      Adagrad: function() {
       return i["train"].adagrad(.01)
      },
      Adadelta: function() {
       return i["train"].adadelta(1, .95, h())
      },
      Adam: function() {
       return i["train"].adam(.001, .9, .999, h())
      },
      Adamax: function() {
       return i["train"].adamax(.002, .9, .999, h(), 0)
      },
      RMSProp: function() {
       return i["train"].rmsprop(.001, .9, 0, h())
      },
      SGD: function() {
       return i["train"].sgd(.01)
      }
     };
     if (e.adagrad = e.Adagrad, e.adadelta = e.Adadelta, e.adam = e.Adam, e.adamax = e.Adamax, e.rmsprop = e.RMSProp, e.sgd = e.SGD, t in e) return e[t]();
     throw new v("Unknown Optimizer " + t)
    }
    var tr = 1048576;
 
    function er(t, e, n) {
     if (void 0 === n && (n = !1), null == t || "object" != typeof t || Object.getPrototypeOf(t) !== Object.prototype || !nr(t)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
     if (n) {
      var r = JSON.stringify(t);
      r.length > tr && console.warn('User-defined metadata of model "' + e + '" is too large in size (length=' + r.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + tr + ".")
     }
    }
 
    function nr(t) {
     if (null === t) return !0;
     if ("object" == typeof t) {
      if (Object.getPrototypeOf(t) === Object.prototype) {
       for (var e = 0, n = Object.keys(t); e < n.length; e++) {
        var r = n[e];
        if ("string" != typeof r) return !1;
        if (!nr(t[r])) return !1
       }
       return !0
      }
      if (Array.isArray(t)) {
       for (var i = 0, o = t; i < o.length; i++)
        if (!nr(o[i])) return !1;
       return !0
      }
      return !1
     }
     var a = typeof t;
     return "string" === a || "number" === a || "boolean" === a
    }
 
    function rr(t, e, n, r) {
     void 0 === r && (r = console.log);
     var i, o = or(t),
      a = ["Layer (type)", "Output shape", "Param #"];
     if (o ? (e = e || 65, n = n || [.45, .85, 1]) : (e = e || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map((function(t) {
       return Math.floor(e * t)
      }))), !o)
      for (var s in a.push("Receives inputs"), i = [], t.nodesByDepth) i.push.apply(i, t.nodesByDepth[s]);
     r("_".repeat(e)), ar(a, n, r), r("=".repeat(e));
     for (var u = t.layers, c = 0; c < u.length; ++c) o ? sr(u[c], n, r) : ur(u[c], n, i, r), r((c === u.length - 1 ? "=" : "_").repeat(e));
     t.checkTrainableWeightsConsistency();
     var l = ir(t),
      h = Be(t.nonTrainableWeights);
     r("Total params: " + (l + h)), r("Trainable params: " + l), r("Non-trainable params: " + h), r("_".repeat(e))
    }
 
    function ir(t) {
     return null != t.collectedTrainableWeights ? Be(t.collectedTrainableWeights) : Be(t.trainableWeights)
    }
 
    function or(t) {
     var e = !0,
      n = [],
      r = [];
     for (var i in t.nodesByDepth) n.push(t.nodesByDepth[i]);
     for (var o = 0, a = n; o < a.length; o++) {
      var s = a[o];
      if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
       e = !1;
       break
      }
      r.push.apply(r, s)
     }
     if (e)
      for (var u = 0, c = t.layers; u < c.length; u++) {
       for (var l = !1, h = 0, p = c[u].inboundNodes; h < p.length; h++) {
        var f = p[h];
        if (-1 !== r.indexOf(f)) {
         if (l) {
          e = !1;
          break
         }
         l = !0
        }
       }
       if (!e) break
      }
     return e
    }
 
    function ar(t, e, n) {
     void 0 === n && (n = console.log);
     for (var r = "", i = 0; i < t.length; ++i) i > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += t[i]).slice(0, e[i]), r += " ".repeat(e[i] - r.length);
     n(r)
    }
 
    function sr(t, e, n) {
     var r;
     try {
      r = JSON.stringify(t.outputShape)
     } catch (t) {
      r = "multiple"
     }
     ar([t.name + " (" + t.getClassName() + ")", r, t.countParams().toString()], e, n)
    }
 
    function ur(t, e, n, r) {
     var i;
     try {
      i = JSON.stringify(t.outputShape)
     } catch (t) {
      i = "multiple"
     }
     for (var o = [], a = 0, s = t.inboundNodes; a < s.length; a++) {
      var u = s[a];
      if (!(null != n && n.length > 0 && -1 === n.indexOf(u)))
       for (var c = 0; c < u.inboundLayers.length; ++c) {
        var l = u.inboundLayers[c].name,
         h = u.nodeIndices[c],
         p = u.tensorIndices[c];
        o.push(l + "[" + h + "][" + p + "]")
       }
     }
     var f = t.name,
      d = t.getClassName(),
      v = 0 === o.length ? "" : o[0];
     for (ar([f + " (" + d + ")", i, t.countParams().toString(), v], e, r), c = 1; c < o.length; ++c) ar(["", "", "", o[c]], e, r)
    }
 
    function cr(t, e, n) {
     return ("inboundNodes" === t || "outputLayers" === t || "inputLayers" === t) && 0 === e && "string" == typeof n
    }
 
    function lr(t, e) {
     if (null === t) return null;
     if ("string" == typeof t) return E(t);
     if ("number" == typeof t || "boolean" == typeof t) return t;
     if (t instanceof Array) {
      for (var n = [], r = t.length, i = 0; i < r; ++i) {
       var o = t[i];
       cr(e, i, o) ? n.push(o) : n.push(lr(o, e))
      }
      return n
     }
     for (var a = {}, s = 0, u = Object.keys(t); s < u.length; s++) {
      var c = u[s],
       l = t[c];
      if ("name" === c && "string" == typeof l) a[c] = l;
      else {
       var h = E(c);
       a[h] = lr(l, h)
      }
     }
     return a
    }
 
    function hr(t, e) {
     if (null === t || void 0 === t) return null;
     if ("string" == typeof t) return S(t);
     if ("number" == typeof t || "boolean" == typeof t) return t;
     if (t instanceof Array) {
      for (var n = [], r = t.length, i = 0; i < r; ++i) {
       var o = t[i];
       cr(e, i, o) ? n.push(o) : n.push(hr(o, e))
      }
      return n
     }
     for (var a = {}, s = 0, u = Object.keys(t); s < u.length; s++) {
      var c = u[s],
       l = t[c],
       h = S(c);
      a[h] = "name" !== c && "className" !== c || "string" != typeof l ? hr(l, c) : l
     }
     return a
    }
    var pr = "1.5.2";
 
    function fr(t, e) {
     if (null == t.dtype || t.dtype === e.dtype) return e;
     try {
      return Object(i["cast"])(e, t.dtype)
     } catch (n) {
      throw new v("The dtype of the feed (" + e.dtype + ") can not be cast to the dtype of the key '" + t.name + "' (" + t.dtype + ").")
     }
    }
    var dr = function() {
      function t(e) {
       if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof t)
        for (var n in e.id2Value) this.id2Value[n] = e.id2Value[n], n in e.id2Mask && (this.id2Mask[n] = e.id2Mask[n]);
       else {
        if (null == e) return;
        for (var r = 0, i = e; r < i.length; r++) {
         var o = i[r];
         this.add(o.key, o.value)
        }
       }
      }
      return t.prototype.add = function(t, e, n) {
       if (null != this.id2Value[t.id]) throw new v("Duplicate key: name=" + t.name + ", id=" + t.id);
       return this.id2Value[t.id] = fr(t, e), this.name2Id[t.name] = t.id, null != n && (this.id2Mask[t.id] = n), this
      }, t.prototype.addFeed = function(t) {
       this.add(t.key, t.value)
      }, t.prototype.hasKey = function(t) {
       return null != this.id2Value[t.id]
      }, t.prototype.names = function() {
       return Object.keys(this.name2Id)
      }, t.prototype.getValue = function(t) {
       if (t instanceof He) {
        if (null == this.id2Value[t.id]) throw new v("Nonexistent key: " + t.name);
        return this.id2Value[t.id]
       }
       var e = this.name2Id[t];
       if (null == e) throw new v("Feed dict has no SymbolicTensor name: " + t);
       return this.id2Value[e]
      }, t.prototype.getMask = function(t) {
       if (t instanceof He) {
        if (null == this.id2Value[t.id]) throw new v("Nonexistent key: " + t.name);
        return this.id2Mask[t.id]
       }
       var e = this.name2Id[t];
       if (null == e) throw new v("Feed dict has no SymbolicTensor name: " + t);
       return this.id2Mask[e]
      }, t.prototype.disposeMasks = function() {
       null != this.id2Mask && Object(i["dispose"])(this.id2Mask)
      }, t
     }(),
     vr = {},
     mr = {};
 
    function gr(t, e, n, r) {
     for (var o = null != n && n.training, a = Array.isArray(t), s = a ? t : [t], u = s.map((function(t) {
       return t.name
      })), c = [], l = e.names(), h = 0, p = u; h < p.length; h++) {
      var f = p[h]; - 1 !== l.indexOf(f) ? c.push(e.getValue(f)) : c.push(null)
     }
     null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
     var d, v, m = u.join(",") + "|" + e.names().join(",");
     if (null == vr[m]) {
      var g = yr(s, e);
      d = g.sorted, v = g.recipientCounts, vr[m] = d, mr[m] = v
     }
     d = vr[m], v = {}, o || Object.assign(v, mr[m]);
     for (var y = new dr(e), b = 0; b < d.length; ++b) {
      if (null != r) {
       var x = Object(i["memory"])().numTensors;
       x > r.maxNumTensors && (r.maxNumTensors = x), x < r.minNumTensors && (r.minNumTensors = x)
      }
      var w = d[b],
       S = w.sourceLayer;
      if (!(S instanceof Qe)) {
       for (var E = [], k = [], I = [], O = !1, A = 0, N = w.inputs; A < N.length; A++) {
        var R = N[A],
         T = y.getValue(R),
         _ = y.getMask(R);
        E.push(T), k.push(_), null != _ && (O = !0), o || (v[R.name]--, 0 !== v[R.name] || e.hasKey(R) || -1 !== u.indexOf(R.name) || T.isDisposed || !0 === R.sourceLayer.stateful || I.push(T))
       }
       O && ((n = n || {}).mask = k[0]);
       var D = C(S.apply(E, n)),
        F = null;
       S.supportsMasking && (F = S.computeMask(E, k));
       for (var M = wr(w), L = Array.isArray(M) ? M : [M], B = 0; B < L.length; ++B) {
        y.hasKey(L[B]) || y.add(L[B], D[B], Array.isArray(F) ? F[0] : F);
        var P = u.indexOf(L[B].name); - 1 !== P && (c[P] = D[B])
       }
       o || Object(i["dispose"])(I)
      }
     }
     return y.disposeMasks(), a ? c : c[0]
    }
 
    function yr(t, e) {
     i["util"].assert(null != t && t.length > 0, (function() {
      return "Expected at least one fetch, got none"
     }));
     var n = [],
      r = {};
     if (1 === t.length) {
      var o = xr(t[0], e);
      n = o.sorted, r = o.recipientMap
     } else
      for (var a = new Set, s = 0, u = t; s < u.length; s++) {
       for (var c = xr(u[s], e), l = c.sorted, h = c.recipientMap, p = 0, f = l; p < f.length; p++) {
        var d = f[p];
        a.has(d.name) || (n.push(d), a.add(d.name))
       }
       var v = function(t) {
        null == r[t] && (r[t] = new Set), h[t].forEach((function(e) {
         return r[t].add(e)
        }))
       };
       for (var m in h) v(m)
      }
     return {
      sorted: n,
      recipientCounts: br(r)
     }
    }
 
    function br(t) {
     var e = {};
     for (var n in t) e[n] = t[n].size;
     return e
    }
 
    function xr(t, e) {
     for (var n = new Set, r = [], i = {}, o = 0, a = e.names(); o < a.length; o++) {
      var s = a[o];
      n.add(s)
     }
     var u = [],
      c = [];
     for (u.push(t); u.length > 0;) {
      var l = u[u.length - 1];
      if (n.has(l.name)) u.pop();
      else {
       var h = c[c.length - 1] === u.length - 1;
       if (0 === l.inputs.length || h) u.pop(), r.push(l), n.add(l.name), h && c.pop();
       else {
        c.push(u.length - 1);
        for (var p = 0, f = l.inputs; p < f.length; p++) {
         var d = f[p];
         null == i[d.name] && (i[d.name] = new Set), i[d.name].add(l.name), n.has(d.name) || u.push(d)
        }
       }
      }
     }
     return {
      sorted: r,
      recipientMap: i
     }
    }
 
    function wr(t) {
     var e;
     if (1 === t.sourceLayer.inboundNodes.length) e = t.sourceLayer.output;
     else {
      for (var n = null, r = 0; r < t.sourceLayer.inboundNodes.length; ++r)
       for (var i = 0, o = t.sourceLayer.inboundNodes[r].outputTensors; i < o.length; i++)
        if (o[i].id === t.id) {
         n = r;
         break
        } e = t.sourceLayer.getOutputAt(n)
     }
     return e
    }
    var Cr = function(t) {
     function e(n) {
      var r = t.call(this, {}) || this;
      if (r.containerNodes = new Set, r.name = n.name, null == r.name) {
       var i = r.getClassName().toLowerCase();
       r.name = _e(i)
      }
      if (r.supportsMasking = !1, r.trainable_ = !0, Array.isArray(n.inputs) ? r.inputs = n.inputs.slice() : r.inputs = [n.inputs], Array.isArray(n.outputs) ? r.outputs = n.outputs.slice() : r.outputs = [n.outputs], T(r.inputs).length !== r.inputs.length) throw new v("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r.inputs.map((function(t) {
       return t.name
      })));
      T(r.outputs).length !== r.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r.outputs.map((function(t) {
       return t.name
      }))), r.inputLayers = [], r.inputLayersNodeIndices = [], r.inputLayersTensorIndices = [], r.outputLayers = [], r.outputLayersNodeIndices = [], r.outputLayersTensorIndices = [], r.layers = [], r.internalContainerRefs = [];
      for (var o = 0, a = r.outputs; o < a.length; o++) {
       var s = (N = a[o]).sourceLayer,
        u = N.nodeIndex,
        c = N.tensorIndex;
       r.outputLayers.push(s), r.outputLayersNodeIndices.push(u), r.outputLayersTensorIndices.push(c)
      }
      for (var l = 0, h = r.inputs; l < h.length; l++) s = (N = h[l]).sourceLayer, u = N.nodeIndex, c = N.tensorIndex, b(0 === u, "input layer has >1 nodes"), b(0 === c, "input layer has >1 tensors"), r.inputLayers.push(s), r.inputLayersNodeIndices.push(u), r.inputLayersTensorIndices.push(c);
      r.inputNames = [], r.outputNames = [], r.feedInputShapes = [], r.feedInputNames = [], r.feedOutputNames = [];
      for (var p = 0; p < r.inputLayers.length; p++) {
       if (!((s = r.inputLayers[p]) instanceof Qe)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n.inputs + ". Input " + p + " (0-based) originates from layer type " + s.getClassName() + ".");
       r.inputNames.push(s.name), r.feedInputShapes.push(s.batchInputShape), r.feedInputNames.push(s.name)
      }
      for (var f = 0, m = r.outputLayers; f < m.length; f++) s = m[f], r.outputNames.push(s.name);
      r.internalInputShapes = r.inputs.map((function(t) {
       return t.shape
      })), r.internalOutputShapes = r.outputs.map((function(t) {
       return t.shape
      }));
      for (var g = {}, y = {}, x = {}, w = {}, C = {}, S = [], E = function(t, n, i, o, a, s) {
        null != o && null != a && null != s || (o = t.sourceLayer, a = t.nodeIndex, s = t.tensorIndex);
        var u = o.inboundNodes[a];
        if (-1 !== i.indexOf(u)) throw new d("The tensor " + t.name + ' at layer "' + o.name + '" is part of a cycle.');
        if (-1 === n.indexOf(u)) {
         r.containerNodes.add(e.nodeKey(o, a)), o.id in C || (C[o.id] = Object.keys(C).length), -1 === i.indexOf(u) && i.push(u);
         for (var c = u.inboundLayers.length, l = 0; l < c; l++) {
          var h = u.inputTensors[l],
           p = u.inboundLayers[l],
           f = u.nodeIndices[l],
           v = u.tensorIndices[l];
          E(h, n, i, p, f, v)
         }
         for (n.push(u); i.indexOf(u) >= 0;) i.splice(i.indexOf(u), 1);
         S.push(u)
        }
       }, k = [], I = [], O = 0, A = r.outputs; O < A.length; O++) {
       var N = A[O];
       E(N, k, I)
      }
      for (var _ = 0, D = S.slice().reverse(); _ < D.length; _++) {
       y[(et = D[_]).id] = et, et.id in g || (g[et.id] = 0);
       var F = g[et.id],
        M = null == x[et.outboundLayer.id] ? 0 : x[et.outboundLayer.id];
       for (F = Math.max(F, M), x[et.outboundLayer.id] = F, w[et.outboundLayer.id] = et.outboundLayer, g[et.id] = F, p = 0; p < et.inboundLayers.length; p++) {
        var L = et.inboundLayers[p],
         B = (u = et.nodeIndices[p], L.inboundNodes[u]),
         P = null == g[B.id] ? 0 : g[B.id];
        g[B.id] = Math.max(F + 1, P), y[B.id] = B
       }
      }
      var z = {};
      for (var j in g)(F = g[j]) in z || (z[F] = []), z[F].push(y[j]);
      var W = {};
      for (var V in x)(F = x[V]) in W || (W[F] = []), W[F].push(w[V]);
      var U = Object.keys(W).map((function(t) {
       return parseInt(t, 10)
      })).sort(R);
      r.layers = [];
      for (var H = 0, $ = U; H < $.length; H++) {
       var G = W[F = $[H]];
       G.sort((function(t, e) {
        var n = C[t.id],
         r = C[e.id];
        return n < r ? -1 : n > r ? 1 : 0
       }));
       for (var q = 0, K = G; q < K.length; q++)(s = K[q]) instanceof e && r.internalContainerRefs.push(s), r.layers.push(s)
      }
      r.layersByDepth = W, U = Object.keys(z).map((function(t) {
       return parseInt(t, 10)
      })).sort(R);
      for (var X = r.inputs.slice(), Y = [], Z = 0, J = U; Z < J.length; Z++)
       for (var Q = 0, tt = z[F = J[Z]]; Q < tt.length; Q++) {
        var et;
        if (null != (s = (et = tt[Q]).outboundLayer)) {
         for (var nt = 0, rt = et.inputTensors; nt < rt.length; nt++)
          if (N = rt[nt], -1 === X.indexOf(N)) throw new d("Graph disconnected: cannot obtain value for tensor " + N + ' at layer "' + s.name + '". The following previous layers were accessed without issue: ' + Y);
         for (var it = 0, ot = et.outputTensors; it < ot.length; it++) N = ot[it], X.push(N);
         Y.push(s.name)
        }
       }
      r.nodesByDepth = z;
      for (var at = r.layers.map((function(t) {
        return t.name
       })), st = function(t) {
        var e = at.filter((function(e) {
         return e === t
        })).length;
        if (1 !== e) throw new d('The name "' + t + '" is used ' + e + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(at))
       }, ut = 0, ct = at; ut < ct.length; ut++) st(ct[ut]);
      return r.outboundNodes = [], r.inboundNodes = [], new Ge({
       outboundLayer: r,
       inboundLayers: [],
       nodeIndices: [],
       tensorIndices: [],
       inputTensors: r.inputs,
       outputTensors: r.outputs,
       inputMasks: r.inputs.map((function(t) {
        return null
       })),
       outputMasks: r.outputs.map((function(t) {
        return null
       })),
       inputShapes: r.inputs.map((function(t) {
        return t.shape
       })),
       outputShapes: r.outputs.map((function(t) {
        return t.shape
       }))
      }), r.built = !0, r._refCount = 1, r
     }
     return a(e, t), e.prototype.assertNotDisposed = function() {
      if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.")
     }, e.prototype.dispose = function() {
      this.assertNotDisposed();
      var t = {
       refCountAfterDispose: null,
       numDisposedVariables: 0
      };
      if (0 == --this._refCount) {
       for (var e = 0, n = this.layers; e < n.length; e++) {
        var r = n[e];
        t.numDisposedVariables += r.dispose().numDisposedVariables
       }
       for (var i = 0, o = this.internalContainerRefs; i < o.length; i++) {
        var a = o[i];
        t.numDisposedVariables += a.dispose().numDisposedVariables
       }
      }
      return t.refCountAfterDispose = this._refCount, t
     }, Object.defineProperty(e.prototype, "trainable", {
      get: function() {
       return this.trainable_
      },
      set: function(t) {
       this.layers.forEach((function(e) {
        e._trainableWeights.forEach((function(e) {
         return e.trainable = t
        }))
       })), this.trainable_ = t
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "trainableWeights", {
      get: function() {
       if (this._trainableWeights.length > 0) throw new v("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
       if (!this.trainable) return [];
       for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
        var r = n[e];
        t = t.concat(r.trainableWeights)
       }
       return t
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
      get: function() {
       for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
        var r = n[e];
        t.push.apply(t, r.nonTrainableWeights)
       }
       if (!this.trainable) {
        for (var i = [], o = 0, a = this.layers; o < a.length; o++) r = a[o], i.push.apply(i, r.trainableWeights);
        return i.concat(t)
       }
       return t
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "weights", {
      get: function() {
       return this.trainableWeights.concat(this.nonTrainableWeights)
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.loadWeights = function(t, e) {
      void 0 === e && (e = !0);
      for (var n = {}, r = 0, i = 0, o = this.layers; i < o.length; i++)
       for (var a = 0, s = o[i].weights; a < s.length; a++) {
        var u = s[a];
        if (null != n[u.originalName]) throw new v("Duplicate weight name: " + u.originalName);
        n[u.originalName] = u, r++
       }
      var c = [];
      for (var l in t) {
       if (null != n[l]) c.push([n[l], t[l]]);
       else if (e) throw new v("Provided weight data has no target variable: " + l);
       delete n[l]
      }
      if (e) {
       var h = [];
       for (var p in n) h.push(p);
       if (h.length > 0) throw new v(h.length + " of " + r + " weights are not set: " + h)
      }
      Ve(c)
     }, e.prototype.updatedConfig = function() {
      var t = this.getConfig(),
       e = {};
      return e.className = this.getClassName(), e.config = t, e.kerasVersion = "tfjs-layers " + pr, e.backend = "TensorFlow.js", e
     }, e.prototype.toJSON = function(t, e) {
      void 0 === e && (e = !0);
      var n = hr(this.updatedConfig());
      return e ? JSON.stringify(n) : n
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       t = C(t);
       for (var r = new dr, i = 0; i < n.inputs.length; ++i) r.add(n.inputs[i], t[i]);
       return gr(n.outputs, r, e)
      }))
     }, e.prototype.computeMask = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var r;
       return t = C(t), r = null == e ? y(null, t.length) : C(e), n.runInternalGraph(t, r)[1]
      }))
     }, e.prototype.computeOutputShape = function(t) {
      var e = Fe(t);
      if (e.length !== this.inputLayers.length) throw new v("Invalid inputShape argument " + t + ": model has " + this.inputLayers.length + " tensor inputs.");
      for (var n = {}, r = 0; r < e.length; r++) {
       var i = this.inputLayers[r],
        o = e[r];
       n[I = i.name + "_0_0"] = o
      }
      var a = Object.keys(this.nodesByDepth).map((function(t) {
       return parseInt(t, 10)
      })).sort(R);
      if (a.length > 1)
       for (var s = 0, u = a; s < u.length; s++)
        for (var c = u[s], l = 0, h = this.nodesByDepth[c]; l < h.length; l++) {
         var p = h[l];
         if (i = p.outboundLayer, -1 === this.inputLayers.map((function(t) {
           return t.id
          })).indexOf(i.id)) {
          for (var f = [], d = 0; d < p.inboundLayers.length; d++) {
           var m = p.inboundLayers[d],
            g = p.nodeIndices[d],
            y = p.tensorIndices[d],
            x = n[I = m.name + "_" + g + "_" + y];
           f.push(x)
          }
          var C = Fe(i.computeOutputShape(w(f))),
           S = i.inboundNodes.indexOf(p);
          for (d = 0; d < C.length; d++) n[I = i.name + "_" + S + "_" + d] = C[d]
         }
        }
      var E = [],
       k = [];
      for (r = 0; r < this.outputLayers.length; r++) {
       i = this.outputLayers[r], S = this.outputLayersNodeIndices[r], y = this.outputLayersTensorIndices[r];
       var I = i.name + "_" + S + "_" + y;
       k.push(I)
      }
      for (r = 0; r < k.length; r++) {
       var O = k[r];
       b(O in n), E.push(n[O])
      }
      return w(E)
     }, e.prototype.runInternalGraph = function(t, e) {
      null == e && (e = y(null, t.length));
      for (var n = {}, r = 0; r < this.inputs.length; ++r) {
       var i = this.inputs[r],
        o = t[r],
        a = e[r];
       n[i.id] = [o, a]
      }
      for (var s = 0, u = Object.keys(this.nodesByDepth).map((function(t) {
        return parseInt(t, 10)
       })).sort(R); s < u.length; s++)
       for (var c = u[s], l = 0, h = this.nodesByDepth[c]; l < h.length; l++) {
        for (var p = h[l], f = p.outboundLayer, d = p.inputTensors, v = p.outputTensors, g = new Array, x = 0, w = d; x < w.length; x++)(i = w[x]).id in n && g.push(n[i.id]);
        if (g.length === d.length) {
         var S = {},
          E = void 0,
          k = void 0,
          I = void 0,
          O = void 0;
         if (null != p.callArgs && (S = p.callArgs), 1 === g.length) {
          var A = g[0],
           N = A[0],
           T = A[1];
          null == S.mask && (S.mask = T), I = C(f.call(N, S)), O = C(f.computeMask(N, T)), E = [N], k = [T]
         } else E = g.map((function(t) {
          return t[0]
         })), k = g.map((function(t) {
          return t[1]
         })), null == S.mask && (S.mask = k), I = C(f.call(E, S)), O = C(f.computeMask(E, k));
         if (f.activityRegularizer) throw new m("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
         for (r = 0; r < v.length; ++r) i = v[r], o = I[r], a = O[r], n[i.id] = [o, a]
        }
       }
      for (var _ = [], D = [], F = [], M = 0, L = this.outputs; M < L.length; M++) {
       b((i = L[M]).id in n, "Could not compute output " + i.name + " : " + i.id);
       var B = n[i.id],
        P = B[0];
       a = B[1], F.push(P.shape), _.push(P), D.push(a)
      }
      return [_, D, F]
     }, e.prototype.buildNodeConversionMap = function(t) {
      for (var n, r = {}, i = 0, o = this.layers; i < o.length; i++) {
       var a = o[i];
       n = a instanceof e ? 1 : 0;
       for (var s = 0; s < a.inboundNodes.length; s++) {
        var u = e.nodeKey(a, s);
        this.containerNodes.has(u) && (r[u] = n, n += 1)
       }
      }
      return r
     }, e.prototype.getLayer = function(t, e) {
      if (null != e) {
       if (this.layers.length <= e) throw new v("Was asked to retrieve layer at index " + e + ", but model only has " + this.layers.length + " layer(s).");
       return this.layers[e]
      }
      if (null == t) throw new v("Provide either a layer name or layer index");
      for (var n = 0, r = this.layers; n < r.length; n++) {
       var i = r[n];
       if (i.name === t) return i
      }
      throw new v("No such layer: " + t)
     }, e.prototype.calculateLosses = function() {
      var t = this;
      return Object(i["tidy"])((function() {
       for (var n = [], r = 0, i = t.layers; r < i.length; r++)
        for (var o = i[r], a = 0; a < o.inboundNodes.length; ++a) {
         var s = e.nodeKey(o, a);
         t.containerNodes.has(s) && n.push.apply(n, o.calculateLosses())
        }
       return n
      }))
     }, e.prototype.getConfig = function() {
      for (var t = {
        name: this.name
       }, n = this.buildNodeConversionMap(this.layers), r = [], i = 0, o = this.layers; i < o.length; i++) {
       for (var a = (x = o[i]).getClassName(), s = x.getConfig(), u = [], c = 0; c < x.inboundNodes.length; c++) {
        var l = x.inboundNodes[c],
         h = e.nodeKey(x, c),
         p = {};
        if (this.containerNodes.has(h)) {
         if (l.callArgs) try {
          JSON.stringify(l.callArgs), p = l.callArgs
         } catch (t) {
          console.warn("Layer " + x.name + " was passed non-serializable keyword arguments: " + l.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), p = {}
         }
         if (l.inboundLayers.length > 0) {
          for (var f = [], d = 0; d < l.inboundLayers.length; d++) {
           var v = l.inboundLayers[d],
            m = l.nodeIndices[d],
            g = l.tensorIndices[d];
           null == (C = n[e.nodeKey(v, m)]) && (C = 0), f.push([v.name, C, g, p])
          }
          u.push(f)
         }
        }
       }
       var y = {};
       y.name = x.name, y.className = a, y.config = s, y.inboundNodes = u, r.push(y)
      }
      t.layers = r;
      var b = [];
      for (d = 0; d < this.inputLayers.length; d++) {
       var x = this.inputLayers[d];
       m = this.inputLayersNodeIndices[d], h = e.nodeKey(x, m), this.containerNodes.has(h) && (null !== (C = n[h]) && void 0 !== C || (C = 0), g = this.inputLayersTensorIndices[d], b.push([x.name, C, g]))
      }
      t.inputLayers = b;
      var w = [];
      for (d = 0; d < this.outputLayers.length; d++) {
       var C;
       if (x = this.outputLayers[d], m = this.outputLayersNodeIndices[d], h = e.nodeKey(x, m), this.containerNodes.has(h)) null !== (C = n[h]) && void 0 !== C || (C = 0), g = this.outputLayersTensorIndices[d], w.push([x.name, C, g])
      }
      return t.outputLayers = w, t
     }, e.fromConfig = function(t, e, n, r) {
      void 0 === n && (n = {}), void 0 === r && (r = !1);
      var i = {},
       o = {};
 
      function a(t, e) {
       t.name in o ? o[t.name].push(e) : o[t.name] = [e]
      }
 
      function s(t, e) {
       for (var n, r = [], o = 0, s = e; o < s.length; o++) {
        var u = s[o],
         c = u[0],
         l = u[1],
         h = u[2];
        if (n = null == u[3] ? {} : u[3], !(c in i)) return void a(t, e);
        var p = i[c];
        if (p.inboundNodes.length <= l) return void a(t, e);
        var f = p.inboundNodes[l];
        r.push(f.outputTensors[h])
       }
       r.length > 0 && t.apply(w(r), n)
      }
 
      function u(t) {
       var n = t.name,
        o = fn(t, null != e.customObjects ? e.customObjects : {});
       o.setFastWeightInitDuringBuild(r), i[n] = o, t.inboundNodes.forEach((function(t) {
        if (!(t instanceof Array)) throw new v("Corrupted configuration, expected array for nodeData: " + t);
        a(o, t)
       }))
      }
      for (var c = e.name, l = e.layers, h = 0, p = l; h < p.length; h++) u(m = p[h]);
      for (; !_(o);)
       for (var f = 0, d = l; f < d.length; f++) {
        var m = d[f];
        if ((D = i[m.name]).name in o) {
         var g = o[D.name];
         delete o[D.name];
         for (var y = 0, x = g; y < x.length; y++) s(D, x[y])
        }
       }
      for (var C = [], S = [], E = 0, k = e.inputLayers; E < k.length; E++) {
       var I = (m = k[E])[0],
        O = m[1],
        A = m[2];
       b(I in i);
       var N = (D = i[I]).inboundNodes[O].outputTensors;
       C.push(N[A])
      }
      for (var R = 0, T = e.outputLayers; R < T.length; R++) {
       var D;
       I = (m = T[R])[0], O = m[1], A = m[2], b(I in i), N = (D = i[I]).inboundNodes[O].outputTensors, S.push(N[A])
      }
      return new t({
       inputs: C,
       outputs: S,
       name: c
      })
     }, Object.defineProperty(e.prototype, "stateful", {
      get: function() {
       if (this._stateful) throw new v("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
       for (var t = 0, e = this.layers; t < e.length; t++)
        if (e[t].stateful) return !0;
       return !1
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.resetStates = function() {
      var t = this;
      Object(i["tidy"])((function() {
       t.layers.forEach((function(t) {
        t.stateful && t.resetStates()
       }))
      }))
     }, e
    }(Ke);
 
    function Sr(t, e, n) {
     var r = e.length;
     if (null == t || Array.isArray(t) && 0 === t.length) return e.map((function(t) {
      return null
     }));
     if (1 === r) return Array.isArray(t) && 1 === t.length ? t : "object" == typeof t && e[0] in t ? [t[e[0]]] : [t];
     if (Array.isArray(t)) {
      if (t.length !== r) throw new Error("Provided " + n + " is an array of " + t.length + " element(s), but the model has " + r + " outputs. Make sure a set of weights is provided for each model output.");
      return t
     }
     if ("object" == typeof t && Object.keys(t).length > 0 && "object" == typeof t[Object.keys(t)[0]]) {
      var i = [];
      return e.forEach((function(e) {
       e in t ? i.push(t[e]) : i.push(null)
      })), i
     }
     throw new Error("The model has multiple (" + r + ") outputs, so " + n + " must be either an array with " + r + " elements or an object with " + e + " keys. Provided " + n + " not understood: " + JSON.stringify(t))
    }
 
    function Er(t, e) {
     return Sr(t, e, "classWeight")
    }
 
    function kr(t, e, n, r) {
     return c(this, void 0, void 0, (function() {
      var o, a, s, u, c;
      return l(this, (function(l) {
       switch (l.label) {
        case 0:
         if (null != e || null != r) throw new Error("Support sampleWeight is not implemented yet");
         return null == n ? [3, 2] : (o = Object(i["tidy"])((function() {
          if (1 === t.shape.length) return t.clone();
          if (2 === t.shape.length) {
           if (t.shape[1] > 1) return t.argMax(1);
           if (1 === t.shape[1]) return t.reshape([t.shape[0]]);
           throw new Error("Encountered unexpected last-dimension size (" + t.shape[1] + ") during handling of class weights. The size is expected to be >= 1.")
          }
          throw new Error("Unexpected rank of target (y) tensor (" + t.rank + ") during handling of class weights. The rank is expected to be 1 or 2.")
         })), u = (s = Array).from, [4, o.data()]);
        case 1:
         return a = u.apply(s, [l.sent()]), Object(i["dispose"])(o), c = [], a.forEach((function(t) {
          if (null == n[t]) throw new Error("classWeight must contain all classes in the training data. The class " + t + " exists in the data but not in classWeight");
          c.push(n[t])
         })), [2, Object(i["tensor1d"])(c, "float32")];
        case 2:
         return [2, null]
       }
      }))
     }))
    }
 
    function Ir(t, e) {
     return Object(i["mul"])(t, e)
    }
    var Or = 32;
 
    function Ar(t, e) {
     var n, r, o = e;
     n = o.xs, r = o.ys, i["util"].assert(null != n && null != r, (function() {
      return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + e
     }));
     var a = Nr("input", t.inputNames, n),
      s = Nr("output", t.outputNames, r),
      u = a[0].shape[0];
     i["util"].assert(a.length === t.inputs.length, (function() {
      return "LayersModel has " + t.inputs.length + " inputs, but the dataset provides " + a.length + " inputs.  (Expected input keys: " + JSON.stringify(t.inputNames) + ")"
     })), i["util"].assert(s.length === t.outputs.length, (function() {
      return "LayersModel has " + t.outputs.length + " outputs, but the dataset provides " + s.length + " outputs.  (Expected output keys: " + JSON.stringify(t.outputNames) + ")"
     }));
     for (var c = function(e) {
       i["util"].assert(a[e].shape[0] === u, (function() {
        return "Batch size mismatch: input " + t.inputNames[e] + " has " + a[e].shape[0] + "; expected  " + u + " based on input " + t.inputNames[0] + "."
       }))
      }, l = 0; l < a.length; l++) c(l);
     for (var h = function(e) {
       i["util"].assert(s[e].shape[0] === u, (function() {
        return "Batch size mismatch: output " + t.outputNames[e] + " has " + s[e].shape[0] + "; expected  " + u + " based on input " + t.inputNames[0] + "."
       }))
      }, p = 0; p < s.length; p++) h(p);
     return {
      xs: a,
      ys: s
     }
    }
 
    function Nr(t, e, n) {
     if (n instanceof i["Tensor"]) return [n];
     if (Array.isArray(n)) return i["util"].assert(n.length === e.length, (function() {
      return "Received an array of " + n.length + " Tensors, but expected " + e.length + " to match the " + t + " keys " + e + "."
     })), n;
     for (var r = [], o = 0, a = e; o < a.length; o++) {
      var s = a[o];
      if (null == n[s]) throw new v("The feature data generated by the dataset lacks the required " + t + " key '" + s + "'.");
      r.push(n[s])
     }
     return r
    }
 
    function Rr(t) {
     if (3 === t.length) throw new m("Validation with sample weights is not implemented yet.");
     return {
      xs: t[0],
      ys: t[1]
     }
    }
 
    function Tr(t, e, n) {
     return c(this, void 0, void 0, (function() {
      var r, o, a, s, u, c, h, p, f, d, v, m, g, y, b, x, w, S, E, k, I, O, A, N, R, T, _, D, F, M, L, B, P, z;
      return l(this, (function(l) {
       switch (l.label) {
        case 0:
         if (r = null != n.batchesPerEpoch, i["util"].assert(null != t.optimizer, (function() {
           return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."
          })), i["util"].assert(null != n, (function() {
           return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."
          })), i["util"].assert(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), (function() {
           return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + n.epochs
          })), i["util"].assert(!r || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), (function() {
           return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + n.batchesPerEpoch
          })), i["util"].assert(null == n.validationSplit, (function() {
           return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."
          })), t.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
         t.isTraining = !0, l.label = 1;
        case 1:
         return l.trys.push([1, , 26, 27]), o = null != n.validationData, a = void 0, s = void 0, o && (Dr(n.validationData) ? i["util"].assert(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), (function() {
          return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + n.validationBatches
         })) : (u = Rr(n.validationData), a = u.xs, s = u.ys)), c = t.makeTrainFunction(), h = t.getDedupedMetricsNames(), p = void 0, p = o ? h.slice().concat(h.map((function(t) {
          return "val_" + t
         }))) : h.slice(), f = ln(n.callbacks, n.yieldEvery), d = null == n.verbose ? 1 : n.verbose, v = pn(f, d, n.epochs, null, null, _r(e, n), null, o, p), m = v.callbackList, g = v.history, m.setModel(t), t.history = g, [4, m.onTrainBegin()];
        case 2:
         return l.sent(), t.stopTraining_ = !1, y = null == n.initialEpoch ? 0 : n.initialEpoch, [4, e.iterator()];
        case 3:
         b = l.sent(), l.label = 4;
        case 4:
         return y < n.epochs ? (x = {}, [4, m.onEpochBegin(y)]) : [3, 23];
        case 5:
         return l.sent(), w = 0, S = 0, r ? [3, 7] : [4, e.iterator()];
        case 6:
         b = l.sent(), l.label = 7;
        case 7:
         return !r || w < n.batchesPerEpoch ? [4, b.next()] : [3, 21];
        case 8:
         return E = l.sent(), r && E.done ? (console.warn("You provided `batchesPerEpoch` as " + n.batchesPerEpoch + ", but your dataset iterator ran out of data after " + w + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset."), [3, 21]) : null == E.value ? [3, 15] : (k = Ar(t, E.value), I = k.xs, O = k.ys, (A = {}).batch = S, A.size = I[0].shape[0], [4, m.onBatchBegin(S, A)]);
        case 9:
         if (l.sent(), N = [], null == n.classWeight) return [3, 13];
         R = Er(n.classWeight, t.outputNames), z = 0, l.label = 10;
        case 10:
         return z < R.length ? (_ = (T = N).push, [4, kr(O[z], null, R[z])]) : [3, 13];
        case 11:
         _.apply(T, [l.sent()]), l.label = 12;
        case 12:
         return ++z, [3, 10];
        case 13:
         for (D = I.concat(O).concat(N), F = c(D), Object(i["dispose"])(D), z = 0; z < h.length; ++z) M = h[z], L = F[z], A[M] = L, Object(i["keep"])(L);
         return [4, m.onBatchEnd(S, A)];
        case 14:
         l.sent(), nn(A), S++, w++, l.label = 15;
        case 15:
         return (r ? w >= n.batchesPerEpoch : E.done) ? o ? (B = void 0, Dr(n.validationData) ? (P = C, [4, t.evaluateDataset(n.validationData, {
          batches: n.validationBatches
         })]) : [3, 17]) : [3, 19] : [3, 20];
        case 16:
         return B = P.apply(void 0, [l.sent()]), [3, 18];
        case 17:
         B = C(t.evaluate(a, s, {
          batchSize: null == n.validationBatchSize ? Or : n.validationBatchSize,
          verbose: 0
         })), l.label = 18;
        case 18:
         for (z = 0; z < t.metricsNames.length; ++z) x["val_" + t.metricsNames[z]] = B[z];
         l.label = 19;
        case 19:
         return [3, 21];
        case 20:
         return t.stopTraining_ ? [3, 21] : [3, 7];
        case 21:
         return [4, m.onEpochEnd(y, x)];
        case 22:
         return l.sent(), y++, t.stopTraining_ ? [3, 23] : [3, 4];
        case 23:
         return [4, m.onTrainEnd()];
        case 24:
         return l.sent(), [4, t.history.syncData()];
        case 25:
         return l.sent(), [2, t.history];
        case 26:
         return t.isTraining = !1, [7];
        case 27:
         return [2]
       }
      }))
     }))
    }
 
    function _r(t, e) {
     var n = null;
     return null != e.batchesPerEpoch ? n = e.batchesPerEpoch : Number.isFinite(t.size) && (n = t.size), n
    }
 
    function Dr(t) {
     return "function" == typeof t.iterator
    }
 
    function Fr(t) {
     return "function" == typeof t.next
    }
 
    function Mr(t, e, n) {
     return c(this, void 0, void 0, (function() {
      var r, o, a, s, u, c, h, p, f, d;
      return l(this, (function(v) {
       switch (v.label) {
        case 0:
         if (r = null != (n = n || {}).batches, o = t.testFunction, a = [], n.verbose > 0) throw new m("Verbose mode is not implemented yet.");
         return i["util"].assert(!r || n.batches > 0 && Number.isInteger(n.batches), (function() {
          return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(n.batches)
         })), Fr(e) ? (u = e, [3, 3]) : [3, 1];
        case 1:
         return [4, e.iterator()];
        case 2:
         u = v.sent(), v.label = 3;
        case 3:
         s = u, c = 0, h = 0, p = function() {
          var e;
          return l(this, (function(u) {
           switch (u.label) {
            case 0:
             return [4, s.next()];
            case 1:
             return e = u.sent(), a = Object(i["tidy"])((function() {
              if (e.value) {
               var n = Ar(t, e.value),
                r = n.xs,
                s = n.ys,
                u = r.concat(s),
                l = Object(i["tidy"])((function() {
                 return o(u)
                }));
               if (Object(i["dispose"])(u), 0 === h)
                for (var p = 0; p < l.length; ++p) a.push(Object(i["scalar"])(0));
               var f = u[0].shape[0],
                d = function(t) {
                 var e = l[t],
                  n = a[t];
                 a[t] = Object(i["tidy"])((function() {
                  return Object(i["add"])(a[t], Object(i["mul"])(f, e))
                 })), h > 0 && Object(i["dispose"])(n)
                };
               for (p = 0; p < l.length; ++p) d(p);
               Object(i["dispose"])(l), c += f, ++h
              }
              return a
             })), e.done ? (r && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + n.batches + " batches). You may need to use the repeat() function when building your dataset."), [2, "break"]) : [2]
           }
          }))
         }, v.label = 4;
        case 4:
         return !r || h < n.batches ? [5, p()] : [3, 6];
        case 5:
         return "break" === v.sent() ? [3, 6] : [3, 4];
        case 6:
         for (f = 0; f < a.length; ++f) d = a[f], a[f] = Object(i["div"])(a[f], c), Object(i["dispose"])(d);
         return [2, w(a)]
       }
      }))
     }))
    }
 
    function Lr(t) {
     i["util"].assert(t > 0 && Number.isInteger(t), (function() {
      return "batchSize is required to be a positive integer, but got " + t
     }))
    }
 
    function Br(t, e, n) {
     return null == t ? [null] : Array.isArray(t) ? t.map((function(t) {
      return It(t, e, n - e)
     })) : It(t, e, n - e)
    }
 
    function Pr(t, e) {
     return Object(i["tidy"])((function() {
      return null == t ? null : Array.isArray(t) ? t.map((function(t) {
       return Pr(t, e)
      })) : Ft(t, "int32" === e.dtype ? e : e.toInt())
     }))
    }
 
    function zr(t, e) {
     for (var n = [], r = 0, i = null; r < t;)(i = r + e) >= t && (i = t), n.push([r, i]), r = i;
     return n
    }
 
    function jr(t, e, n, r, o, a, s, u, h, p, f, d, g, y, b) {
     return c(this, void 0, void 0, (function() {
      var c, x, w, C, S, E, k, I;
      return l(this, (function(O) {
       switch (O.label) {
        case 0:
         if (null == o && (o = 32), null == a && (a = 1), null == f && (f = !0), null == g && (g = 0), c = !1, null != h && null != p && (c = !0), null != b && (c = !0, null == y)) throw new v("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
         return null != (x = t.checkNumSamples(n, o, y, "steps_per_epoch")) && (w = xt(0, x)), null == s && (s = 1), C = pn(u, s, a, g, x, y, o, c, d), S = C.callbackList, E = C.history, S.setModel(t), t.history = E, [4, S.onTrainBegin()];
        case 1:
         O.sent(), t.stopTraining_ = !1, k = function(a) {
          var s, u, d, v, g;
          return l(this, (function(b) {
           switch (b.label) {
            case 0:
             return [4, S.onEpochBegin(a)];
            case 1:
             if (b.sent(), s = {}, null == y) return [3, 2];
             throw new m("stepsPerEpoch mode is not implemented yet.");
            case 2:
             if ("batch" === f) throw new m("batch shuffling is not implemneted yet");
             f && i["util"].shuffle(w), u = Object(i["tensor1d"])(w), d = zr(x, o), v = function(a) {
              var f;
              return l(this, (function(l) {
               switch (l.label) {
                case 0:
                 return f = {}, [4, S.onBatchBegin(a, f)];
                case 1:
                 return l.sent(), Object(i["tidy"])((function() {
                  var l = d[a][0],
                   v = d[a][1],
                   m = It(u, l, v - l);
                  f.batch = a, f.size = v - l;
                  for (var g = Pr(n, m), y = e(g), b = 0; b < r.length; ++b) {
                   var x = r[b],
                    w = y[b];
                   f[x] = w, Object(i["keep"])(w)
                  }
                  if (a === d.length - 1 && c) {
                   var C = t.testLoop(h, p, o);
                   for (b = 0; b < r.length; ++b) x = r[b], w = C[b], Object(i["keep"])(w), s["val_" + x] = w
                  }
                 })), [4, S.onBatchEnd(a, f)];
                case 2:
                 return l.sent(), nn(f), t.stopTraining_ ? [2, "break"] : [2]
               }
              }))
             }, g = 0, b.label = 3;
            case 3:
             return g < d.length ? [5, v(g)] : [3, 6];
            case 4:
             if ("break" === b.sent()) return [3, 6];
             b.label = 5;
            case 5:
             return ++g, [3, 3];
            case 6:
             u.dispose(), b.label = 7;
            case 7:
             return [4, S.onEpochEnd(a, s)];
            case 8:
             return b.sent(), t.stopTraining_ ? [2, "break"] : [2]
           }
          }))
         }, I = g, O.label = 2;
        case 2:
         return I < a ? [5, k(I)] : [3, 5];
        case 3:
         if ("break" === O.sent()) return [3, 5];
         O.label = 4;
        case 4:
         return ++I, [3, 2];
        case 5:
         return [4, S.onTrainEnd()];
        case 6:
         return O.sent(), [4, t.history.syncData()];
        case 7:
         return O.sent(), [2, t.history]
       }
      }))
     }))
    }
 
    function Wr(t, e, n, r) {
     return void 0 === r && (r = {}), c(this, void 0, void 0, (function() {
      var o, a, s, u, c, h, p, f, d, g, y, b, x, w, C, S, E, k, I, O, A, N;
      return l(this, (function(l) {
       switch (l.label) {
        case 0:
         if (t.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
         t.isTraining = !0, l.label = 1;
        case 1:
         return l.trys.push([1, , 7, 8]), Lr(f = null == r.batchSize ? 32 : r.batchSize), d = !1, [4, t.standardizeUserData(e, n, r.sampleWeight, r.classWeight, d, f)];
        case 2:
         if (g = l.sent(), o = g[0], a = g[1], p = g[2], y = !1, b = void 0, !(null != r.validationData && r.validationData.length > 0)) return [3, 4];
         if (y = !0, 2 !== r.validationData.length) throw 3 === r.validationData.length ? new m("validationData including sample weights is not supported yet.") : new v("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + r.validationData + " is invalid.");
         return s = r.validationData[0], u = r.validationData[1], x = !0, [4, t.standardizeUserData(s, u, null, null, x, f)];
        case 3:
         return w = l.sent(), c = w[0], h = w[1], b = c.concat(h), [3, 5];
        case 4:
         null != r.validationSplit && r.validationSplit > 0 && r.validationSplit < 1 ? (y = !0, C = Math.floor(o[0].shape[0] * (1 - r.validationSplit)), S = o[0].shape[0], c = Br(o, C, S), o = Br(o, 0, C), h = Br(a, C, S), a = Br(a, 0, C), b = c.concat(h)) : null != r.validationSteps && (y = !0), l.label = 5;
        case 5:
         return E = o.concat(a).concat(p), t.checkTrainableWeightsConsistency(), k = t.makeTrainFunction(), I = t.getDedupedMetricsNames(), O = void 0, A = void 0, y ? (t.makeTestFunction(), O = t.testFunction, A = I.slice().concat(I.map((function(t) {
          return "val_" + t
         })))) : (O = null, b = [], A = I.slice()), N = ln(r.callbacks, r.yieldEvery), [4, jr(t, k, E, I, f, r.epochs, r.verbose, N, O, b, r.shuffle, A, r.initialEpoch, null, null)];
        case 6:
         return [2, l.sent()];
        case 7:
         return t.isTraining = !1, Ur(o, e), Ur(a, n), Ur(c, s), Ur(h, u), null != p && Object(i["dispose"])(p), [7];
        case 8:
         return [2]
       }
      }))
     }))
    }
 
    function Vr(t) {
     var e = [];
     t instanceof i["Tensor"] && (t = [t]);
     for (var n = 0; n < t.length; ++n) {
      var r = t[n];
      if (1 === r.rank) e.push(Ct(r, 1));
      else {
       if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
       e.push(r)
      }
     }
     return e
    }
 
    function Ur(t, e) {
     if (null != t) {
      var n = [];
      if (e instanceof i["Tensor"]) n.push(e.id);
      else if (Array.isArray(e)) e.forEach((function(t) {
       return n.push(t.id)
      }));
      else if (null != e)
       for (var r in e) {
        var o = e[r];
        n.push(o.id)
       }
      var a = [];
      if (t instanceof i["Tensor"]) - 1 === n.indexOf(t.id) && a.push(t);
      else if (Array.isArray(t)) t.forEach((function(t) {
       -1 === n.indexOf(t.id) && a.push(t)
      }));
      else if (null != t)
       for (var s in t) {
        var u = t[s]; - 1 === n.indexOf(u.id) && a.push(u)
       }
      a.forEach((function(t) {
       t.isDisposed || t.dispose()
      }))
     }
    }
 
    function Hr(t) {
     return t instanceof i["Tensor"]
    }
 
    function $r(t) {
     return Array.isArray(t)
    }
 
    function Gr(t) {
     return !Hr(t) && !$r(t)
    }
 
    function qr(t, e, n, r, i) {
     if (void 0 === r && (r = !0), void 0 === i && (i = ""), null == e || 0 === e.length) {
      if (null != t) {
       var o = !1;
       if ($r(t) && t.length > 0) o = !0;
       else if (Gr(t)) {
        for (var a in t)
         if (t.hasOwnProperty(a)) {
          o = !0;
          break
         }
       } else o = !0;
       if (o) throw new v("Error when checking model " + i + " expected no data, but got " + t)
      }
      return []
     }
     if (null == t) return e.map((function(t) {
      return null
     }));
     var s;
     if (Gr(t)) {
      t = t, s = [];
      for (var u = 0, c = e; u < c.length; u++) {
       var l = c[u];
       if (null == t[l]) throw new v('No data provided for "' + l + '". Need data for each key in: ' + e);
       s.push(t[l])
      }
     } else if ($r(t)) {
      if ((t = t).length !== e.length) throw new v("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + e.length + " Tensor(s), but instead got the following list of Tensor(s): " + t);
      s = t
     } else {
      if (t = t, e.length > 1) throw new v("The model " + i + " expects " + e.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + t.shape);
      s = [t]
     }
     if (s = Vr(s), null != n)
      for (var h = 0; h < e.length; ++h)
       if (null != n[h]) {
        var p = s[h];
        if (p.shape.length !== n[h].length) throw new v("Error when checking " + i + ": expected " + e[h] + " to have " + n[h].length + " dimension(s). but got array with shape " + p.shape);
        for (var f = 0; f < n[h].length; ++f)
         if (0 !== f || r) {
          var d = p.shape[f],
           m = n[h][f];
          if (null != m && m >= 0 && d !== m) throw new v("Error when checking " + i + ": expected " + e[h] + " to have shape [" + n[h] + "], but got array with shape [" + p.shape + "].")
         }
       } return s
    }
 
    function Kr(t, e, n) {
     var r = T(t.map((function(t) {
      return t.shape[0]
     })));
     r.sort();
     var o = T(e.map((function(t) {
      return t.shape[0]
     })));
     if (o.sort(), r.length > 1) throw new v("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(t.map((function(t) {
      return t.shape
     }))));
     if (o.length > 1) throw new v("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(e.map((function(t) {
      return t.shape
     }))));
     if (r.length > 0 && o.length > 0 && !i["util"].arraysEqual(r, o)) throw new v("Input Tensors should have the same number of samples as target Tensors. Found " + r[0] + " input sample(s) and " + o[0] + " target sample(s).")
    }
 
    function Xr(t, e, n) {
     for (var r = [vn, In, Sn], i = 0; i < t.length; ++i) {
      var o = t[i],
       a = e[i],
       s = n[i];
      if (null != a) {
       if (a === Sn && 1 === o.shape[o.shape.length - 1]) throw new v("You are passing a target array of shape " + o.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
       if (-1 !== r.indexOf(a))
        for (var u = o.shape.slice(1), c = s.slice(1), l = 0; l < u.length; ++l) {
         var h = u[l],
          p = c[l];
         if (null != p && h !== p) throw new v("A target Tensor with shape " + o.shape + " was passed for an output of shape " + s + ", while using a loss function that expects targets to have the same shape as the output.")
        }
      }
     }
    }
 
    function Yr(t, e, n, r, i) {
     var o;
     if (void 0 === r && (r = !0), void 0 === i && (i = ""), Array.isArray(t)) {
      if (t.length !== e.length) throw new v("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + e.length + " Tensor(s), but instead got " + t.length + " Tensors(s).");
      o = t
     } else {
      if (e.length > 1) throw new v("The model expects " + e.length + " " + i + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(t.shape) + ".");
      o = [t]
     }
     if (null != n)
      for (var a = 0; a < e.length; ++a)
       if (null != n[a]) {
        var s = o[a];
        if (s.shape.length !== n[a].length) throw new v("Error when checking " + i + ": expected " + e[a] + " to have " + n[a].length + " dimension(s), but got array with shape " + JSON.stringify(s.shape));
        for (var u = 0; u < n[a].length; ++u)
         if (0 !== u || r) {
          var c = s.shape[u],
           l = n[a][u];
          if (null != l && l !== c) throw new v("Error when checking " + i + ": expected " + e[a] + " to have shape " + JSON.stringify(n[a]) + " but got array with shape " + JSON.stringify(s.shape) + ".")
         }
       }
    }
 
    function Zr(t, e) {
     if (null == t || Array.isArray(t) && 0 === t.length) return e.map((function(t) {
      return []
     }));
     var n;
     if ("string" == typeof t || "function" == typeof t) n = [t];
     else {
      if (!Array.isArray(t) && "object" != typeof t) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + t);
      n = t
     }
     if (Array.isArray(n)) return e.map((function(t) {
      return n
     }));
     for (var r = [], i = 0, o = e; i < o.length; i++) {
      var a = o[i],
       s = n.hasOwnProperty(a) ? n[a] : [];
      Array.isArray(s) || (s = [s]), r.push(s)
     }
     return r
    }
    var Jr = "layers-model",
     Qr = function(t) {
      function e(e) {
       var n = t.call(this, e) || this;
       return n.isTraining = !1, n
      }
      return a(e, t), e.prototype.summary = function(t, e, n) {
       if (void 0 === n && (n = console.log), !this.built) throw new v("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
       rr(this, t, e, n)
      }, e.prototype.compile = function(t) {
       var e = this;
       if (null == t.loss && (t.loss = []), this.loss = t.loss, "string" == typeof t.optimizer) this.optimizer_ = Qn(t.optimizer), this.isOptimizerOwned = !0;
       else {
        if (!(t.optimizer instanceof i["Optimizer"])) throw new v("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = t.optimizer, this.isOptimizerOwned = !1
       }
       var n = [];
       if (Array.isArray(t.loss) || "string" == typeof t.loss || "function" == typeof t.loss)
        if (Array.isArray(t.loss)) {
         if (t.loss.length !== this.outputs.length) throw new v("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + t.loss + ".");
         var r = t.loss;
         n = r.map((function(t) {
          return Tn(t)
         }))
        } else {
         var o = Tn(t.loss);
         this.outputs.forEach((function(t) {
          n.push(o)
         }))
        }
       else {
        for (var a in t.loss = t.loss, t.loss)
         if (-1 === this.outputNames.indexOf(a)) throw new v('Unknown entry in loss dictionary: "' + a + '". Only expected the following keys: ' + this.outputNames);
        for (var s = 0, u = this.outputNames; s < u.length; s++) {
         var c = u[s];
         null == t.loss[c] && console.warn('Output "' + c + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + c + " during training"), n.push(Tn(t.loss[c]))
        }
       }
       this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
       for (var l = 0; l < this.outputs.length; ++l) {
        var h = this.internalOutputShapes[l],
         p = this.outputNames[l];
        this.feedOutputNames.push(p), this.feedOutputShapes.push(h), this.feedLossFns.push(this.lossFunctions[l])
       }
       var f = [];
       this.metrics = t.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], ct("loss", (function() {
        for (var t = 0; t < e.outputs.length; ++t)
         if (-1 === f.indexOf(t)) {
          var n = e.lossFunctions[t];
          e.outputs.length > 1 && (e.metricsTensors.push([n, t]), e.metricsNames.push(e.outputNames[t] + "_loss"))
         }
       }));
       var d = Zr(t.metrics, this.outputNames);
       ct("metric", (function() {
        for (var t = function(t) {
          if (-1 !== f.indexOf(t)) return "continue";
          ! function(n) {
           for (var r, i, o, a = function(n) {
             if ("string" == typeof n && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(n)) {
              var a = e.internalOutputShapes[t];
              1 === a[a.length - 1] || e.lossFunctions[t] === In ? -1 !== ["accuracy", "acc"].indexOf(n) ? i = _n : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = zn) : e.lossFunctions[t] === En ? -1 !== ["accuracy", "acc"].indexOf(n) ? i = jn : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = Xn) : -1 !== ["accuracy", "acc"].indexOf(n) ? i = Dn : -1 !== ["crossentropy", "ce"].indexOf(n) && (i = qn);
              var s = void 0; - 1 !== ["accuracy", "acc"].indexOf(n) ? s = "acc" : -1 !== ["crossentropy", "ce"].indexOf(n) && (s = "ce"), o = i, r = "" + s
             } else {
              var u = Zn(n);
              o = u, r = "" + Jn(n)
             }
             var c;
             ct(r, (function() {
               c = o
              })),
              function(t, n, r) {
               e.outputNames.length > 1 && (n = e.outputNames[t] + "_" + n), e.metricsNames.push(n), e.metricsTensors.push([r, t])
              }(t, r, c)
            }, s = 0, u = n; s < u.length; s++) a(u[s])
          }(d[t])
         }, n = 0; n < e.outputs.length; ++n) t(n)
       })), this.collectedTrainableWeights = this.trainableWeights
      }, e.prototype.checkTrainableWeightsConsistency = function() {
       null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")
      }, e.prototype.evaluate = function(t, e, n) {
       void 0 === n && (n = {});
       var r = null == n.batchSize ? 32 : n.batchSize;
       Lr(r);
       var i = this.standardizeUserDataXY(t, e, !0, r);
       try {
        var o = i[0].concat(i[1]);
        this.makeTestFunction();
        var a = this.testFunction;
        return w(this.testLoop(a, o, r, n.verbose, n.steps))
       } finally {
        Ur(i[0], t), Ur(i[1], e)
       }
      }, e.prototype.evaluateDataset = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(n) {
         return this.makeTestFunction(), [2, Mr(this, t, e)]
        }))
       }))
      }, e.prototype.checkNumSamples = function(t, e, n, r) {
       var i;
       if (void 0 === r && (r = "steps"), null != n) {
        if (i = null, null != e) throw new v("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + e)
       } else {
        if (null == t) throw new v("Either the input data should have a defined shape, or " + r + " shoud be specified.");
        i = Array.isArray(t) ? t[0].shape[0] : t.shape[0]
       }
       return i
      }, e.prototype.execute = function(t, e) {
       if (Array.isArray(e) && 0 === e.length) throw new v("`outputs` is an empty Array, which is not allowed.");
       var n = Array.isArray(e),
        r = n ? e : [e],
        o = this.retrieveSymbolicTensors(r),
        a = new dr;
       if (t instanceof i["Tensor"] && (t = [t]), Array.isArray(t)) {
        if (t.length !== this.inputs.length) throw new v("The number of inputs provided (" + t.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");
        for (var s = 0; s < this.inputs.length; ++s) a.add(this.inputs[s], t[s])
       } else
        for (var u = 0, c = this.inputs; u < c.length; u++) {
         var l = c[u],
          h = t[l.name];
         if (null == h) throw new v("No value is provided for the model's input " + l.name);
         a.add(l, h)
        }
       var p = gr(o, a);
       return n ? p : p[0]
      }, e.prototype.retrieveSymbolicTensors = function(t) {
       for (var e = y(null, t.length), n = t.length, r = 0, i = this.layers; r < i.length; r++) {
        for (var o = i[r], a = Array.isArray(o.output) ? o.output : [o.output], s = a.map((function(t) {
          return t.name
         })), u = 0; u < t.length; ++u) {
         var c = s.indexOf(t[u]);
         if (-1 !== c && (e[u] = a[c], n--), 0 === n) break
        }
        if (0 === n) break
       }
       if (n > 0) {
        var l = [];
        throw e.forEach((function(e, n) {
         null == e && l.push(t[n])
        })), new v("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(l))
       }
       return e
      }, e.prototype.predictLoop = function(t, e, n) {
       var r = this;
       return void 0 === e && (e = 32), void 0 === n && (n = !1), Object(i["tidy"])((function() {
        var o = r.checkNumSamples(t);
        if (n) throw new m("Verbose predictLoop() is not implemented yet.");
        for (var a = zr(o, e), s = r.outputs.map((function(t) {
          return []
         })), u = function(e) {
          Object(i["tidy"])((function() {
           var n = a[e][0],
            i = a[e][1],
            o = Br(t, n, i),
            s = [];
           if (Array.isArray(o))
            for (var u = 0; u < o.length; ++u) s.push({
             key: r.inputs[u],
             value: o[u]
            });
           else s.push({
            key: r.inputs[0],
            value: o
           });
           var c = new dr(s);
           return gr(r.outputs, c)
          })).forEach((function(t, e) {
           return s[e].push(t)
          }))
         }, c = 0; c < a.length; ++c) u(c);
        return w(s.map((function(t) {
         return Object(i["concat"])(t, 0)
        })))
       }))
      }, e.prototype.predict = function(t, e) {
       void 0 === e && (e = {});
       var n = Vr(t);
       Yr(n, this.inputNames, this.feedInputShapes, !1);
       try {
        var r = null == e.batchSize ? 32 : e.batchSize;
        return Lr(r), this.predictLoop(n, r)
       } finally {
        Ur(n, t)
       }
      }, e.prototype.predictOnBatch = function(t) {
       Yr(t, this.inputNames, this.feedInputShapes, !0);
       var e = (Array.isArray(t) ? t[0] : t).shape[0];
       return this.predictLoop(t, e)
      }, e.prototype.standardizeUserDataXY = function(t, e, n, r) {
       if (void 0 === n && (n = !0), null == this.optimizer_) throw new d("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
       for (var i = [], o = 0; o < this.feedOutputShapes.length; ++o) {
        var a = this.feedOutputShapes[o];
        this.feedLossFns[o] === En ? i.push(a.slice(0, a.length - 1).concat([1])) : i.push(a)
       }
       if (Kr(t = qr(t, this.feedInputNames, this.feedInputShapes, !1, "input"), e = qr(e, this.feedOutputNames, i, !1, "target"), null), Xr(e, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r && r > 0 && t[0].shape[0] % r != 0) throw new v("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r + ". Found: " + t[0].shape[0] + " sample(s).");
       return [t, e]
      }, e.prototype.standardizeUserData = function(t, e, n, r, i, o) {
       return void 0 === i && (i = !0), c(this, void 0, void 0, (function() {
        var a, s, u, c, h, p, f, d;
        return l(this, (function(l) {
         switch (l.label) {
          case 0:
           if (a = this.standardizeUserDataXY(t, e, i, o), s = a[0], u = a[1], null != n) throw new Error("sample weight is not supported yet.");
           if (c = null, null == r) return [3, 4];
           h = Er(r, this.outputNames), c = [], p = 0, l.label = 1;
          case 1:
           return p < h.length ? (d = (f = c).push, [4, kr(u[p], null, h[p])]) : [3, 4];
          case 2:
           d.apply(f, [l.sent()]), l.label = 3;
          case 3:
           return ++p, [3, 1];
          case 4:
           return [2, [s, u, c]]
         }
        }))
       }))
      }, e.prototype.testLoop = function(t, e, n, r, o) {
       var a = this;
       return void 0 === r && (r = 0), Object(i["tidy"])((function() {
        var s = a.checkNumSamples(e, n, o, "steps"),
         u = [];
        if (r > 0) throw new m("Verbose mode is not implemented yet.");
        if (null != o) throw new m("steps mode in testLoop() is not implemented yet");
        for (var c = zr(s, n), l = Object(i["tensor1d"])(xt(0, s)), h = 0; h < c.length; ++h) {
         var p = c[h][0],
          f = c[h][1],
          d = It(l, p, f - p),
          v = Pr(e, d),
          g = t(v);
         if (0 === h)
          for (var y = 0; y < g.length; ++y) u.push(Object(i["scalar"])(0));
         for (y = 0; y < g.length; ++y) {
          var b = g[y];
          u[y] = Object(i["add"])(u[y], Object(i["mul"])(f - p, b))
         }
        }
        for (y = 0; y < u.length; ++y) u[y] = Object(i["div"])(u[y], s);
        return u
       }))
      }, e.prototype.getDedupedMetricsNames = function() {
       for (var t = this.metricsNames, e = [], n = 0; n < t.length; ++n) {
        var r = t[n],
         i = r;
        x(t, r) > 1 && (i += "_" + x(t.slice(0, n), r)), e.push(i)
       }
       return e
      }, e.prototype.makeTrainFunction = function() {
       var t = this;
       return function(e) {
        var n = [],
         r = e.slice(0, t.inputs.length),
         o = e.slice(t.inputs.length, t.inputs.length + t.outputs.length),
         a = e.slice(t.inputs.length + t.outputs.length, t.inputs.length + 2 * t.outputs.length),
         s = [],
         u = t.collectedTrainableWeights.map((function(t) {
          return t.read()
         }));
        return [t.optimizer_.minimize((function() {
         for (var e = [], u = 0; u < t.inputs.length; ++u) e.push({
          key: t.inputs[u],
          value: r[u]
         });
         var c, l = new dr(e),
          h = gr(t.outputs, l, {
           training: !0
          });
         for (u = 0; u < t.lossFunctions.length; ++u) {
          var p = (0, t.lossFunctions[u])(o[u], h[u]);
          null != a[u] && (p = Ir(p, a[u]));
          var f = Object(i["mean"])(p);
          n.push(f), c = 0 === u ? p : Object(i["add"])(c, p)
         }
         for (u = 0; u < t.metricsTensors.length; ++u) {
          var d = void 0;
          if (t.outputs.length > 1 && u < t.outputs.length) d = n[u];
          else {
           var v = t.metricsTensors[u][0],
            m = t.metricsTensors[u][1];
           d = Object(i["mean"])(v(o[m], h[m]))
          }
          Object(i["keep"])(d), s.push(d)
         }
         return c = Object(i["mean"])(c), t.calculateLosses().forEach((function(t) {
          c = Object(i["add"])(c, t)
         })), c
        }), !0, u)].concat(s)
       }
      }, e.prototype.makeTestFunction = function() {
       var t = this;
       this.testFunction = function(e) {
        return Object(i["tidy"])((function() {
         for (var n, r = [], o = e.slice(0, t.inputs.length), a = e.slice(t.inputs.length, t.inputs.length + t.outputs.length), s = [], u = 0; u < t.inputs.length; ++u) s.push({
          key: t.inputs[u],
          value: o[u]
         });
         var c = new dr(s),
          l = gr(t.outputs, c);
         for (u = 0; u < t.lossFunctions.length; ++u) {
          var h = t.lossFunctions[u],
           p = Object(i["mean"])(h(a[u], l[u]));
          n = 0 === u ? p : Object(i["add"])(n, p), r.push(n)
         }
         for (u = 0; u < t.metricsTensors.length; ++u) {
          var f = t.metricsTensors[u][0],
           d = t.metricsTensors[u][1],
           v = Object(i["mean"])(f(a[d], l[d]));
          r.push(v)
         }
         return r
        }))
       }
      }, e.prototype.fit = function(t, e, n) {
       return void 0 === n && (n = {}), c(this, void 0, void 0, (function() {
        return l(this, (function(r) {
         return [2, Wr(this, t, e, n)]
        }))
       }))
      }, e.prototype.fitDataset = function(t, e) {
       return c(this, void 0, void 0, (function() {
        return l(this, (function(n) {
         return [2, Tr(this, t, e)]
        }))
       }))
      }, e.prototype.trainOnBatch = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n, r, o, a, s, u, c, h, p;
        return l(this, (function(l) {
         switch (l.label) {
          case 0:
           return [4, this.standardizeUserData(t, e)];
          case 1:
           n = l.sent(), r = n[0], o = n[1], a = this.makeTrainFunction(), s = a(r.concat(o)), u = [], c = 0, h = s, l.label = 2;
          case 2:
           return c < h.length ? [4, h[c].data()] : [3, 5];
          case 3:
           p = l.sent(), u.push(p[0]), l.label = 4;
          case 4:
           return c++, [3, 2];
          case 5:
           return Object(i["dispose"])(s), [2, w(u)]
         }
        }))
       }))
      }, e.prototype.getNamedWeights = function(t) {
       for (var e = [], n = null != t && t.trainableOnly, r = n ? this.trainableWeights : this.weights, i = this.getWeights(n), o = 0; o < r.length; ++o) n && !r[o].trainable || e.push({
        name: r[o].originalName,
        tensor: i[o]
       });
       return e
      }, Object.defineProperty(e.prototype, "stopTraining", {
       get: function() {
        return this.stopTraining_
       },
       set: function(t) {
        this.stopTraining_ = t
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "optimizer", {
       get: function() {
        return this.optimizer_
       },
       set: function(t) {
        this.optimizer_ !== t && (this.optimizer_ = t, this.isOptimizerOwned = !1)
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.dispose = function() {
       var e = t.prototype.dispose.call(this);
       if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
        var n = Object(i["memory"])().numTensors;
        this.optimizer_.dispose(), e.numDisposedVariables += n - Object(i["memory"])().numTensors
       }
       return e
      }, e.prototype.getLossIdentifiers = function() {
       var t;
       if ("string" == typeof this.loss) t = S(this.loss);
       else if (Array.isArray(this.loss)) {
        for (var e = 0, n = this.loss; e < n.length; e++)
         if ("string" != typeof n[e]) throw new Error("Serialization of non-string loss is not supported.");
        t = this.loss.map((function(t) {
         return S(t)
        }))
       } else {
        var r = Object.keys(this.loss);
        t = {};
        for (var i = this.loss, o = 0, a = r; o < a.length; o++) {
         var s = a[o];
         if ("string" != typeof i[s]) throw new Error("Serialization of non-string loss is not supported.");
         t[s] = S(i[s])
        }
       }
       return t
      }, e.prototype.getMetricIdentifiers = function() {
       if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [S(Jn(this.metrics))];
       if (Array.isArray(this.metrics)) return this.metrics.map((function(t) {
        return S(Jn(t))
       }));
       var t = {};
       for (var e in this.metrics) t[e] = S(Jn(this.metrics[e]));
       return t
      }, e.prototype.getTrainingConfig = function() {
       return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
         class_name: this.optimizer.getClassName(),
         config: this.optimizer.getConfig()
        }
       }
      }, e.prototype.loadTrainingConfig = function(t) {
       if (null != t.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
       if (null != t.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
       if (null != t.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
       var e, n, r = fn(lr(t.optimizer_config));
       if ("string" == typeof t.loss) e = E(t.loss);
       else if (Array.isArray(t.loss)) e = t.loss.map((function(t) {
        return E(t)
       }));
       else if (null != t.loss)
        for (var i in e = {}, t.loss) e[i] = E(t.loss[i]);
       if (Array.isArray(t.metrics)) n = t.metrics.map((function(t) {
        return E(t)
       }));
       else if (null != t.metrics)
        for (var i in n = {}, t.metrics) n[i] = E(t.metrics[i]);
       this.compile({
        loss: e,
        metrics: n,
        optimizer: r
       })
      }, e.prototype.save = function(t, e) {
       return c(this, void 0, void 0, (function() {
        var n, r, o, a, s, u, c, h, p, f, d, m, g, y;
        return l(this, (function(l) {
         switch (l.label) {
          case 0:
           if ("string" == typeof t) {
            if (0 === (n = i["io"].getSaveHandlers(t)).length) throw new v("Cannot find any save handlers for URL '" + t + "'");
            if (n.length > 1) throw new v("Found more than one (" + n.length + ") save handlers for URL '" + t + "'");
            t = n[0]
           }
           if (null == t.save) throw new v("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
           return [4, i["io"].encodeWeights(this.getNamedWeights(e))];
          case 1:
           return r = l.sent(), o = !1, a = null, s = this.toJSON(a, o), u = {
            modelTopology: s,
            format: Jr,
            generatedBy: "TensorFlow.js tfjs-layers v" + pr,
            convertedBy: null
           }, null != e && e.includeOptimizer && null != this.optimizer ? (u.trainingConfig = this.getTrainingConfig(), c = "optimizer", m = (d = i["io"]).encodeWeights, [4, this.optimizer.getWeights()]) : [3, 4];
          case 2:
           return [4, m.apply(d, [l.sent(), c])];
          case 3:
           h = l.sent(), p = h.data, f = h.specs, (y = r.specs).push.apply(y, f), r.data = i["io"].concatenateArrayBuffers([r.data, p]), l.label = 4;
          case 4:
           return null != this.userDefinedMetadata && (g = !0, er(this.userDefinedMetadata, this.name, g), u.userDefinedMetadata = this.userDefinedMetadata), u.weightData = r.data, u.weightSpecs = r.specs, [2, t.save(u)]
         }
        }))
       }))
      }, e.prototype.setUserDefinedMetadata = function(t) {
       er(t, this.name), this.userDefinedMetadata = t
      }, e.prototype.getUserDefinedMetadata = function() {
       return this.userDefinedMetadata
      }, e.className = "Model", e
     }(Cr);
 
    function ti(t, e) {
     return c(this, void 0, void 0, (function() {
      var n, r, o, a, s, u, c, h;
      return l(this, (function(l) {
       switch (l.label) {
        case 0:
         return "modelTopology" in t || (t = {
          modelTopology: t
         }), null != (n = (t = t).modelTopology).model_config && (n = n.model_config), r = lr(n), o = fn(r, e), null == t.weightsManifest ? [3, 2] : [4, i["io"].loadWeights(t.weightsManifest, t.pathPrefix, o.weights.map((function(t) {
          return t.originalName
         })))];
        case 1:
         for (a = l.sent(), s = {}, u = 0, c = o.weights; u < c.length; u++) h = c[u], s[h.originalName] = a[h.originalName];
         o.loadWeights(s), Object(i["dispose"])(a), l.label = 2;
        case 2:
         return [2, o]
       }
      }))
     }))
    }
    i["serialization"].registerClass(Qr);
    var ei = function(t) {
     function e(e) {
      var n = t.call(this, {
       inputs: [],
       outputs: []
      }) || this;
      if (e = e || {}, n.trainable = !0, n.built = !1, n.name = null != e.name ? e.name : _e("sequential_"), null != e.layers)
       for (var r = 0, i = e.layers; r < i.length; r++) {
        var o = i[r];
        n.add(o)
       }
      return n
     }
     return a(e, t), e.prototype.checkShape = function(t) {
      if (t.inboundNodes[0].outputTensors[0].shape.some((function(t) {
        return t < 0
       }))) throw new v("Negative dimension size caused by adding layer " + t.name + " with input shape [" + t.inboundNodes[0].inputTensors[0].shape + "]")
     }, e.prototype.add = function(t) {
      var n, r = t instanceof e || t instanceof Qr;
      if (r) {
       if (1 !== (n = t).outputs.length) throw new v("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
       if (1 !== n.inputs.length) throw new v("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")
      }
      if (0 === this.outputs.length) {
       if (0 === t.inboundNodes.length) {
        if (null == t.batchInputShape) throw new v("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
        var i = tn({
         batchShape: t.batchInputShape,
         dtype: t.dtype,
         name: t.name + "_input"
        });
        t.apply(i)
       }
       if (r) this.outputs = n.outputs, this.inputs = n.inputs;
       else {
        if (1 !== t.inboundNodes.length) throw new v("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + t.name + " which has " + t.inboundNodes.length + " pre-existing inbound connections.");
        if (1 !== t.inboundNodes[0].outputTensors.length) throw new v("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(t), this.outputs = [t.inboundNodes[0].outputTensors[0]], this.inputs = Ze(this.outputs[0])
       }
       this.inboundNodes = [], new Ge({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: y(null, this.inputs.length),
        outputMasks: [null],
        inputShapes: this.inputs.map((function(t) {
         return t.shape
        })),
        outputShapes: this.outputs[0].shape
       })
      } else {
       var o = t.apply(this.outputs[0]);
       if (Array.isArray(o)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
       this.checkShape(t), this.outputs = [o], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
      }
      this.layers.push(t), this.built = !1
     }, e.prototype.pop = function() {
      if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
      else {
       var t = this.layers.length - 1;
       this.layers[t].outboundNodes = [], this.outputs = [this.layers[t].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
      }
     }, e.prototype.call = function(t, e) {
      return null == this.model && this.build(), this.model.call(t, e)
     }, e.prototype.build = function(t) {
      if (Le(t), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new Qr({
       inputs: this.inputs,
       outputs: this.outputs[0],
       name: this.name + "_model"
      }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0
     }, e.prototype.countParams = function() {
      return this.built || this.build(), t.prototype.countParams.call(this)
     }, e.prototype.summary = function(e, n, r) {
      void 0 === r && (r = console.log), this.built || this.build(), t.prototype.summary.call(this, e, n, r)
     }, e.prototype.setWeights = function(t) {
      null == this.model && this.build(), this.model.setWeights(t)
     }, e.prototype.evaluate = function(t, e, n) {
      if (void 0 === n && (n = {}), !this.built) throw new d("The model needs to be compiled before being used.");
      return this.model.evaluate(t, e, n)
     }, e.prototype.evaluateDataset = function(t, e) {
      return c(this, void 0, void 0, (function() {
       return l(this, (function(n) {
        if (!this.built) throw new d("The model needs to be compiled before being used.");
        return [2, this.model.evaluateDataset(t, e)]
       }))
      }))
     }, e.prototype.predict = function(t, e) {
      return void 0 === e && (e = {}), null == this.model && this.build(), this.model.predict(t, e)
     }, e.prototype.predictOnBatch = function(t) {
      return null == this.model && this.build(), this.model.predictOnBatch(t)
     }, e.prototype.compile = function(t) {
      this.build(), this.model.compile(t), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames
     }, Object.defineProperty(e.prototype, "optimizer", {
      get: function() {
       return null == this.model ? void 0 : this.model.optimizer
      },
      set: function(t) {
       this.model.optimizer = t
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.fit = function(t, e, n) {
      return void 0 === n && (n = {}), c(this, void 0, void 0, (function() {
       return l(this, (function(r) {
        if (!this.built) throw new d("The model needs to be compiled before being used.");
        return [2, this.model.fit(t, e, n)]
       }))
      }))
     }, e.prototype.fitDataset = function(t, e) {
      return c(this, void 0, void 0, (function() {
       return l(this, (function(n) {
        if (!this.built) throw new d("The model needs to be compiled before being used.");
        return [2, this.model.fitDataset(t, e)]
       }))
      }))
     }, e.prototype.trainOnBatch = function(t, e) {
      return c(this, void 0, void 0, (function() {
       return l(this, (function(n) {
        return [2, this.model.trainOnBatch(t, e)]
       }))
      }))
     }, e.fromConfig = function(t, n, r, o) {
      var a;
      void 0 === r && (r = {}), void 0 === o && (o = !1);
      var s = {};
      if (n instanceof Array) {
       if (null == n[0].className || "Merge" === n[0].className) throw new v("Legacy serialization format not supported yet.");
       a = n
      } else i["util"].assert(null != n.layers, (function() {
       return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."
      })), a = n.layers, delete n.layers, s = n;
      var u = new t(s);
      if (!(u instanceof e)) throw new m("Sequential.fromConfig called on non-Sequential input: " + u);
      for (var c = 0, l = a; c < l.length; c++) {
       var h = fn(l[c], void 0, o);
       o && h.setFastWeightInitDuringBuild(!0), u.add(h)
      }
      return u
     }, Object.defineProperty(e.prototype, "stopTraining", {
      get: function() {
       if (null == this.model) throw new v("Cannot get the stopTraining property of a sequential model before it is compiled.");
       return this.model.stopTraining
      },
      set: function(t) {
       if (null == this.model) throw new v("Cannot set the stopTraining property of a sequential model before it is compiled.");
       this.model.stopTraining = t
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.getConfig = function() {
      for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
       var r = n[e],
        i = {};
       i.className = r.getClassName(), i.config = r.getConfig(), t.push(i)
      }
      return {
       name: this.name,
       layers: t
      }
     }, e.className = "Sequential", e
    }(Qr);
 
    function ni(t) {
     return tn(t)
    }
    i["serialization"].registerClass(ei);
    var ri = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.getConfig = function() {
       return {}
      }, e
     }(i["serialization"].Serializable),
     ii = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.apply = function(t, e) {
       return void 0 === e && (e = 1), Pt(t, e)
      }, e.className = "elu", e
     }(ri);
    i["serialization"].registerClass(ii);
    var oi = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["selu"])(t)
     }, e.className = "selu", e
    }(ri);
    i["serialization"].registerClass(oi);
    var ai = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["relu"])(t)
     }, e.className = "relu", e
    }(ri);
    i["serialization"].registerClass(ai);
    var si = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["tidy"])((function() {
       return Object(i["minimum"])(6, Object(i["relu"])(t))
      }))
     }, e.className = "relu6", e
    }(ri);
    i["serialization"].registerClass(si);
    var ui = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return t
     }, e.className = "linear", e
    }(ri);
    i["serialization"].registerClass(ui);
    var ci = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["sigmoid"])(t)
     }, e.className = "sigmoid", e
    }(ri);
    i["serialization"].registerClass(ci);
    var li = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Wt(t)
     }, e.className = "hardSigmoid", e
    }(ri);
    i["serialization"].registerClass(li);
    var hi = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["softplus"])(t)
     }, e.className = "softplus", e
    }(ri);
    i["serialization"].registerClass(hi);
    var pi = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return zt(t)
     }, e.className = "softsign", e
    }(ri);
    i["serialization"].registerClass(pi);
    var fi = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t) {
      return Object(i["tanh"])(t)
     }, e.className = "tanh", e
    }(ri);
    i["serialization"].registerClass(fi);
    var di = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      return void 0 === e && (e = -1), Object(i["softmax"])(t, e)
     }, e.className = "softmax", e
    }(ri);
    i["serialization"].registerClass(di);
    var vi = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.apply = function(t, e) {
      return void 0 === e && (e = -1), Object(i["logSoftmax"])(t, e)
     }, e.className = "logSoftmax", e
    }(ri);
 
    function mi(t) {
     return t.getClassName()
    }
 
    function gi(t, e) {
     return void 0 === e && (e = {}), A(t, i["serialization"].SerializationMap.getMap().classNameMap, e, "activation")
    }
 
    function yi(t) {
     var e;
     return null == t ? gi(e = {
      className: "linear",
      config: {}
     }) : "string" == typeof t ? ((e = {}).className = t, e.config = {}, gi(e)) : t instanceof ri ? t : gi(t)
    }
 
    function bi(t) {
     if (null != t && "object" != typeof t) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + t)
    }
    i["serialization"].registerClass(vi);
    var xi = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e
     }(i["serialization"].Serializable),
     wi = function(t) {
      function e(e) {
       var n = t.call(this) || this;
       return bi(e), n.l1 = null == e || null == e.l1 ? .01 : e.l1, n.l2 = null == e || null == e.l2 ? .01 : e.l2, n.hasL1 = 0 !== n.l1, n.hasL2 = 0 !== n.l2, n
      }
      return a(e, t), e.prototype.apply = function(t) {
       var e = this;
       return Object(i["tidy"])((function() {
        var n = Object(i["zeros"])([1]);
        return e.hasL1 && (n = Object(i["add"])(n, Object(i["sum"])(Object(i["mul"])(e.l1, Object(i["abs"])(t))))), e.hasL2 && (n = Object(i["add"])(n, Object(i["sum"])(Object(i["mul"])(e.l2, Mt(t))))), n.asScalar()
       }))
      }, e.prototype.getConfig = function() {
       return {
        l1: this.l1,
        l2: this.l2
       }
      }, e.fromConfig = function(t, e) {
       return new t({
        l1: e.l1,
        l2: e.l2
       })
      }, e.className = "L1L2", e
     }(xi);
 
    function Ci(t) {
     return bi(t), new wi({
      l1: null != t ? t.l1 : null,
      l2: 0
     })
    }
 
    function Si(t) {
     return bi(t), new wi({
      l2: null != t ? t.l2 : null,
      l1: 0
     })
    }
    i["serialization"].registerClass(wi);
    var Ei = {
     l1l2: "L1L2"
    };
 
    function ki(t) {
     return I(t)
    }
 
    function Ii(t, e) {
     return void 0 === e && (e = {}), A(t, i["serialization"].SerializationMap.getMap().classNameMap, e, "regularizer")
    }
 
    function Oi(t) {
     return null == t ? null : "string" == typeof t ? Ii({
      className: t in Ei ? Ei[t] : t,
      config: {}
     }) : t instanceof xi ? t : Ii(t)
    }
    var Ai = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.supportsMasking = !0, null != e && (n.maxValue = e.maxValue), n
     }
     return a(e, t), e.prototype.call = function(t, e) {
      t = Me(t);
      var n = Object(i["relu"])(t);
      return null != this.maxValue && (n = Object(i["clipByValue"])(n, 0, this.maxValue)), n
     }, e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = {
        maxValue: this.maxValue
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "ReLU", e
    }(Ke);
    i["serialization"].registerClass(Ai);
    var Ni = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.DEFAULT_ALPHA = .3, null == e && (e = {}), n.alpha = null == e.alpha ? n.DEFAULT_ALPHA : e.alpha, n
     }
     return a(e, t), e.prototype.call = function(t, e) {
      var n = Me(t);
      return Object(i["leakyRelu"])(n, this.alpha)
     }, e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = {
        alpha: this.alpha
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "LeakyReLU", e
    }(Ke);
    i["serialization"].registerClass(Ni);
    var Ri = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      if (n.DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), n.supportsMasking = !0, n.alphaInitializer = fe(e.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER), n.alphaRegularizer = Oi(e.alphaRegularizer), n.alphaConstraint = K(e.alphaConstraint), null == e.sharedAxes) n.sharedAxes = null;
      else if (Array.isArray(e.sharedAxes)) n.sharedAxes = e.sharedAxes;
      else {
       if ("number" != typeof e.sharedAxes) throw new v("Expected sharedAxes to be a number or an array of numbers, but got " + e.sharedAxes);
       n.sharedAxes = [e.sharedAxes]
      }
      return n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e = (t = Le(t)).slice(1);
      if (null != this.sharedAxes)
       for (var n = 0, r = this.sharedAxes; n < r.length; n++) e[(o = r[n]) - 1] = 1;
      this.alpha = this.addWeight("alpha", e, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
      var i = {};
      if (null != this.sharedAxes)
       for (var o = 1; o < t.length; ++o) i[o] = t[o];
      this.inputSpec = [new Ue({
       ndim: t.length,
       axes: i
      })], this.built = !0
     }, e.prototype.call = function(t, e) {
      return t = Me(t), Object(i["prelu"])(t, this.alpha.read())
     }, e.prototype.getConfig = function() {
      var e = {
        alphaInitializer: pe(this.alphaInitializer),
        alphaRegularizer: ki(this.alphaRegularizer),
        alphaConstraint: G(this.alphaConstraint),
        sharedAxes: this.sharedAxes
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "PReLU", e
    }(Ke);
    i["serialization"].registerClass(Ri);
    var Ti = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      if (n.DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== n.DEFAULT_ALPHA) throw new m("Non-default alpha value (" + e.alpha + ") is not supported by the ELU layer yet.");
      return n.alpha = null == e.alpha ? n.DEFAULT_ALPHA : e.alpha, n
     }
     return a(e, t), e.prototype.call = function(t, e) {
      var n = Me(t);
      return Object(i["elu"])(n)
     }, e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = {
        alpha: this.alpha
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "ELU", e
    }(Ke);
    i["serialization"].registerClass(Ti);
    var _i = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.DEFAULT_THETA = 1, null == e && (e = {}), n.theta = null == e.theta ? n.DEFAULT_THETA : e.theta, n
     }
     return a(e, t), e.prototype.call = function(t, e) {
      var n = Me(t);
      return n.mul(wt(n.greater(this.theta), "float32"))
     }, e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = {
        theta: this.theta
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "ThresholdedReLU", e
    }(Ke);
    i["serialization"].registerClass(_i);
    var Di = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.DEFAULT_AXIS = 1, null == e && (e = {}), n.softmax = (new di).apply, n.axis = null == e.axis ? n.DEFAULT_AXIS : e.axis, n
     }
     return a(e, t), e.prototype.call = function(t, e) {
      var n = Me(t);
      return this.softmax(n, this.axis)
     }, e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = {
        axis: this.axis
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Softmax", e
    }(Ke);
 
    function Fi(t, e, n) {
     if ("number" == typeof t) return y(t, e);
     if (t.length !== e) throw new v("The " + n + " argument must be an integer or tuple of " + e + " integers. Received: " + t.length + " elements.");
     for (var r = 0; r < e; ++r) {
      var i = t[r];
      if (!vt(i)) throw new v("The " + n + " argument must be an integer or tuple of " + e + " integers. Received: " + JSON.stringify(t) + " including a non-integer number " + i)
     }
     return t
    }
 
    function Mi(t, e, n, r, i) {
     return void 0 === i && (i = 1), null == t ? t : (o = "same" === n ? t : t - (e + (e - 1) * (i - 1)) + 1, Math.floor((o + r - 1) / r));
     var o
    }
 
    function Li(t, e, n, r) {
     if (null == t) return null;
     if ("valid" === r) t = t * e + bt([n - e, 0]);
     else {
      if ("same" !== r) throw new v("Unsupport padding mode: " + r + ".");
      t *= e
     }
     return t
    }
 
    function Bi(t, e) {
     return Object(i["tidy"])((function() {
      return it(e), "channelsFirst" === e ? Object(i["transpose"])(t, [0, 2, 3, 1]) : t
     }))
    }
 
    function Pi(t, e) {
     return Object(i["tidy"])((function() {
      return it(e), "channelsFirst" === e ? Object(i["transpose"])(t, [0, 2, 3, 4, 1]) : t
     }))
    }
 
    function zi(t, e, n, r, o, a, s) {
     return void 0 === r && (r = 1), void 0 === o && (o = "valid"), void 0 === s && (s = 1), Object(i["tidy"])((function() {
      if (null == a && (a = p()), it(a), 3 !== t.shape.length) throw new v("The input of a conv1dWithBias operation should be 3, but is " + t.shape.length + " instead.");
      if (3 !== e.shape.length) throw new v("The kernel for a conv1dWithBias operation should be 3, but is " + e.shape.length + " instead");
      if (null != n && 1 !== n.shape.length) throw new v("The bias for a conv1dWithBias operation should be 1, but is " + e.shape.length + " instead");
      if ("channelsFirst" === a && (t = Object(i["transpose"])(t, [0, 2, 1])), "causal" === o) throw new m("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      var u = Object(i["conv1d"])(t, e, r, "same" === o ? "same" : "valid", "NWC", s);
      return null != n && (u = Bt(u, n)), u
     }))
    }
 
    function ji(t, e, n, r, o, a, s, u) {
     return void 0 === r && (r = [1, 1]), void 0 === o && (o = "valid"), void 0 === u && (u = null), Object(i["tidy"])((function() {
      if (null == a && (a = p()), it(a), 3 !== t.rank && 4 !== t.rank) throw new v("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + t.rank + ".");
      if (3 !== e.rank && 4 !== e.rank) throw new v("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + t.rank + ".");
      var c = Bi(t, a);
      if ("causal" === o) throw new m("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      return c = i["fused"].conv2d({
       x: c,
       filter: e,
       strides: r,
       pad: "same" === o ? "same" : "valid",
       dilations: s,
       dataFormat: "NHWC",
       bias: n,
       activation: u
      }), "channelsFirst" === a && (c = Object(i["transpose"])(c, [0, 3, 1, 2])), c
     }))
    }
 
    function Wi(t, e, n, r, o, a, s) {
     return void 0 === r && (r = [1, 1, 1]), void 0 === o && (o = "valid"), Object(i["tidy"])((function() {
      if (null == a && (a = p()), it(a), 4 !== t.rank && 5 !== t.rank) throw new v("conv3dWithBias expects input to be of rank 4 or 5, but received " + t.rank + ".");
      if (4 !== e.rank && 5 !== e.rank) throw new v("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + t.rank + ".");
      var u = Pi(t, a);
      if ("causal" === o) throw new m("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      return u = Object(i["conv3d"])(u, e, r, "same" === o ? "same" : "valid", "NDHWC", s), null != n && (u = Bt(u, n)), "channelsFirst" === a && (u = Object(i["transpose"])(u, [0, 4, 1, 2, 3])), u
     }))
    }
    i["serialization"].registerClass(Di);
    var Vi = function(t) {
      function e(n, r) {
       var i = t.call(this, r) || this;
       if (i.bias = null, i.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", i.DEFAULT_BIAS_INITIALIZER = "zeros", e.verifyArgs(r), i.rank = n, M(i.rank, "rank"), 1 !== i.rank && 2 !== i.rank && 3 !== i.rank) throw new m("Convolution layer for rank other than 1, 2, or 3 (" + i.rank + ") is not implemented yet.");
       if (i.kernelSize = Fi(r.kernelSize, n, "kernelSize"), i.strides = Fi(null == r.strides ? 1 : r.strides, n, "strides"), i.padding = null == r.padding ? "valid" : r.padding, ot(i.padding), i.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, it(i.dataFormat), i.activation = yi(r.activation), i.useBias = null == r.useBias || r.useBias, i.biasInitializer = fe(r.biasInitializer || i.DEFAULT_BIAS_INITIALIZER), i.biasConstraint = K(r.biasConstraint), i.biasRegularizer = Oi(r.biasRegularizer), i.activityRegularizer = Oi(r.activityRegularizer), i.dilationRate = Fi(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate"), 1 === i.rank && Array.isArray(i.dilationRate) && 1 !== i.dilationRate.length) throw new v("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(i.dilationRate));
       if (2 === i.rank) {
        if ("number" == typeof i.dilationRate) i.dilationRate = [i.dilationRate, i.dilationRate];
        else if (2 !== i.dilationRate.length) throw new v("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(i.dilationRate))
       } else if (3 === i.rank)
        if ("number" == typeof i.dilationRate) i.dilationRate = [i.dilationRate, i.dilationRate, i.dilationRate];
        else if (3 !== i.dilationRate.length) throw new v("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(i.dilationRate));
       return i
      }
      return a(e, t), e.verifyArgs = function(t) {
       if (b("kernelSize" in t, "required key 'kernelSize' not in config"), "number" != typeof t.kernelSize && !F(t.kernelSize, "number", 1, 3)) throw new v("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(t.kernelSize) + ".")
      }, e.prototype.getConfig = function() {
       var e = {
         kernelSize: this.kernelSize,
         strides: this.strides,
         padding: this.padding,
         dataFormat: this.dataFormat,
         dilationRate: this.dilationRate,
         activation: mi(this.activation),
         useBias: this.useBias,
         biasInitializer: pe(this.biasInitializer),
         biasRegularizer: ki(this.biasRegularizer),
         activityRegularizer: ki(this.activityRegularizer),
         biasConstraint: G(this.biasConstraint)
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e
     }(Ke),
     Ui = function(t) {
      function e(n, r) {
       var i = t.call(this, n, r) || this;
       return i.kernel = null, e.verifyArgs(r), i.filters = r.filters, M(i.filters, "filters"), i.kernelInitializer = fe(r.kernelInitializer || i.DEFAULT_KERNEL_INITIALIZER), i.kernelConstraint = K(r.kernelConstraint), i.kernelRegularizer = Oi(r.kernelRegularizer), i
      }
      return a(e, t), e.prototype.build = function(t) {
       var e;
       t = Le(t);
       var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
       if (null == t[n]) throw new v("The channel dimension of the input should be defined. Found " + t[n]);
       var r = t[n],
        i = this.kernelSize.concat([r, this.filters]);
       this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
        ndim: this.rank + 2,
        axes: (e = {}, e[n] = r, e)
       }], this.built = !0
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        var e;
        t = Me(t);
        var r = null == n.bias ? null : n.bias.read(),
         i = P(n.activation.getClassName());
        if (null != i && 2 === n.rank) e = ji(t, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, i);
        else {
         if (1 === n.rank) e = zi(t, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
         else if (2 === n.rank) e = ji(t, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
         else {
          if (3 !== n.rank) throw new m("convolutions greater than 3D are not implemented yet.");
          e = Wi(t, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate)
         }
         null != n.activation && (e = n.activation.apply(e))
        }
        return e
       }))
      }, e.prototype.computeOutputShape = function(t) {
       t = Le(t);
       for (var e = [], n = "channelsLast" === this.dataFormat ? t.slice(1, t.length - 1) : t.slice(2), r = 0; r < n.length; ++r) {
        var i = Mi(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
        e.push(i)
       }
       var o = [t[0]];
       return "channelsLast" === this.dataFormat ? (o = o.concat(e)).push(this.filters) : (o.push(this.filters), o = o.concat(e)), o
      }, e.prototype.getConfig = function() {
       var e = {
         filters: this.filters,
         kernelInitializer: pe(this.kernelInitializer),
         kernelRegularizer: ki(this.kernelRegularizer),
         kernelConstraint: G(this.kernelConstraint)
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e.verifyArgs = function(t) {
       if (!("filters" in t) || "number" != typeof t.filters || t.filters < 1) throw new v("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(t.filters))
      }, e
     }(Vi),
     Hi = function(t) {
      function e(n) {
       var r = t.call(this, 2, n) || this;
       return e.verifyArgs(n), r
      }
      return a(e, t), e.prototype.getConfig = function() {
       var e = t.prototype.getConfig.call(this);
       return delete e.rank, e
      }, e.verifyArgs = function(t) {
       if ("number" != typeof t.kernelSize && !F(t.kernelSize, "number", 1, 2)) throw new v("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(t.kernelSize) + ".")
      }, e.className = "Conv2D", e
     }(Ui);
    i["serialization"].registerClass(Hi);
    var $i = function(t) {
     function e(n) {
      var r = t.call(this, 3, n) || this;
      return e.verifyArgs(n), r
     }
     return a(e, t), e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this);
      return delete e.rank, e
     }, e.verifyArgs = function(t) {
      if ("number" != typeof t.kernelSize && (!Array.isArray(t.kernelSize) || 1 !== t.kernelSize.length && 3 !== t.kernelSize.length)) throw new v("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(t.kernelSize) + ".")
     }, e.className = "Conv3D", e
    }(Ui);
    i["serialization"].registerClass($i);
    var Gi = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      if (n.inputSpec = [new Ue({
        ndim: 4
       })], "same" !== n.padding && "valid" !== n.padding) throw new v("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n.padding);
      return n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e;
      if (4 !== (t = Le(t)).length) throw new v("Input should have rank 4; Received input shape: " + JSON.stringify(t));
      var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
      if (null == t[n]) throw new v("The channel dimension of the inputs should be defined. Found `None`.");
      var r = t[n],
       i = this.kernelSize.concat([this.filters, r]);
      this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new Ue({
       ndim: 4,
       axes: (e = {}, e[n] = r, e)
      })], this.built = !0
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var e = Me(t);
       if (4 !== e.shape.length) throw new v("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + e.shape.length);
       var r, o, a = e.shape,
        s = a[0];
       "channelsFirst" === n.dataFormat ? (r = 2, o = 3) : (r = 1, o = 2);
       var u = a[r],
        c = a[o],
        l = n.kernelSize[0],
        h = n.kernelSize[1],
        p = n.strides[0],
        f = n.strides[1],
        d = [s, Li(u, p, l, n.padding), Li(c, f, h, n.padding), n.filters];
       "channelsLast" !== n.dataFormat && (e = Object(i["transpose"])(e, [0, 2, 3, 1]));
       var m = Object(i["conv2dTranspose"])(e, n.kernel.read(), d, n.strides, n.padding);
       return "channelsLast" !== n.dataFormat && (m = Object(i["transpose"])(m, [0, 3, 1, 2])), null != n.bias && (m = Bt(m, n.bias.read(), n.dataFormat)), null != n.activation && (m = n.activation.apply(m)), m
      }))
     }, e.prototype.computeOutputShape = function(t) {
      var e, n, r, i = (t = Le(t)).slice();
      "channelsFirst" === this.dataFormat ? (e = 1, n = 2, r = 3) : (e = 3, n = 1, r = 2);
      var o = this.kernelSize[0],
       a = this.kernelSize[1],
       s = this.strides[0],
       u = this.strides[1];
      return i[e] = this.filters, i[n] = Li(i[n], s, o, this.padding), i[r] = Li(i[r], u, a, this.padding), i
     }, e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this);
      return delete e.dilationRate, e
     }, e.className = "Conv2DTranspose", e
    }(Hi);
    i["serialization"].registerClass(Gi);
    var qi = function(t) {
      function e(e, n) {
       var r = t.call(this, e, n) || this;
       if (r.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r.depthwiseKernel = null, r.pointwiseKernel = null, null == n.filters) throw new v("The `filters` configuration field is required by SeparableConv, but is unspecified.");
       if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint) throw new v("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
       if (null != n.padding && "same" !== n.padding && "valid" !== n.padding) throw new v("SeparableConv" + r.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n.padding));
       return r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier, r.depthwiseInitializer = fe(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER), r.depthwiseRegularizer = Oi(n.depthwiseRegularizer), r.depthwiseConstraint = K(n.depthwiseConstraint), r.pointwiseInitializer = fe(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER), r.pointwiseRegularizer = Oi(n.pointwiseRegularizer), r.pointwiseConstraint = K(n.pointwiseConstraint), r
      }
      return a(e, t), e.prototype.build = function(t) {
       var e;
       if ((t = Le(t)).length < this.rank + 2) throw new v("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(t));
       var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
       if (null == t[n] || t[n] < 0) throw new v("The channel dimension of the inputs should be defined, but found " + JSON.stringify(t[n]));
       for (var r = t[n], i = this.kernelSize.concat([r, this.depthMultiplier]), o = [], a = 0; a < this.rank; ++a) o.push(1);
       o.push(r * this.depthMultiplier, this.filters), this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", o, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, !0, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.inputSpec = [new Ue({
        ndim: this.rank + 2,
        axes: (e = {}, e[n] = r, e)
       })], this.built = !0
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        var e;
        if (t = Me(t), 1 === n.rank) throw new m("1D separable convolution is not implemented yet.");
        return 2 === n.rank && ("channelsFirst" === n.dataFormat && (t = Object(i["transpose"])(t, [0, 2, 3, 1])), e = Object(i["separableConv2d"])(t, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (e = Bt(e, n.bias.read(), n.dataFormat)), null != n.activation && (e = n.activation.apply(e)), "channelsFirst" === n.dataFormat && (e = Object(i["transpose"])(e, [0, 3, 1, 2])), e
       }))
      }, e.prototype.getConfig = function() {
       var e = t.prototype.getConfig.call(this);
       return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = pe(this.depthwiseInitializer), e.pointwiseInitializer = pe(this.pointwiseInitializer), e.depthwiseRegularizer = ki(this.depthwiseRegularizer), e.pointwiseRegularizer = ki(this.pointwiseRegularizer), e.depthwiseConstraint = G(this.depthwiseConstraint), e.pointwiseConstraint = G(this.pointwiseConstraint), e
      }, e.className = "SeparableConv", e
     }(Ui),
     Ki = function(t) {
      function e(e) {
       return t.call(this, 2, e) || this
      }
      return a(e, t), e.className = "SeparableConv2D", e
     }(qi);
    i["serialization"].registerClass(Ki);
    var Xi = function(t) {
     function e(n) {
      var r = t.call(this, 1, n) || this;
      return e.verifyArgs(n), r.inputSpec = [{
       ndim: 3
      }], r
     }
     return a(e, t), e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this);
      return delete e.rank, delete e.dataFormat, e
     }, e.verifyArgs = function(t) {
      if ("number" != typeof t.kernelSize && !F(t.kernelSize, "number", 1, 1)) throw new v("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(t.kernelSize) + ".")
     }, e.className = "Conv1D", e
    }(Ui);
    i["serialization"].registerClass(Xi);
    var Yi = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return "number" == typeof e.cropping ? n.cropping = [
       [e.cropping, e.cropping],
       [e.cropping, e.cropping]
      ] : "number" == typeof e.cropping[0] ? n.cropping = [
       [e.cropping[0], e.cropping[0]],
       [e.cropping[1], e.cropping[1]]
      ] : n.cropping = e.cropping, n.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, n.inputSpec = [{
       ndim: 4
      }], n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      return "channelsFirst" === this.dataFormat ? [t[0], t[1], t[2] - this.cropping[0][0] - this.cropping[0][1], t[3] - this.cropping[1][0] - this.cropping[1][1]] : [t[0], t[1] - this.cropping[0][0] - this.cropping[0][1], t[2] - this.cropping[1][0] - this.cropping[1][1], t[3]]
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       return t = Me(t), "channelsLast" === n.dataFormat ? At(At(t, n.cropping[0][0], t.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2), n.cropping[1][0], t.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3) : At(At(t, n.cropping[0][0], t.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3), n.cropping[1][0], t.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        cropping: this.cropping,
        dataFormat: this.dataFormat
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Cropping2D", e
    }(Ke);
    i["serialization"].registerClass(Yi);
    var Zi = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_SIZE = [2, 2], n.inputSpec = [{
       ndim: 4
      }], n.size = null == e.size ? n.DEFAULT_SIZE : e.size, n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      if ("channelsFirst" === this.dataFormat) {
       var e = null == t[2] ? null : this.size[0] * t[2],
        n = null == t[3] ? null : this.size[1] * t[3];
       return [t[0], t[1], e, n]
      }
      return e = null == t[1] ? null : this.size[0] * t[1], n = null == t[2] ? null : this.size[1] * t[2], [t[0], e, n, t[3]]
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var e = Me(t),
        r = e.shape;
       if ("channelsFirst" === n.dataFormat) {
        e = Object(i["transpose"])(e, [0, 2, 3, 1]);
        var o = n.size[0] * r[2],
         a = n.size[1] * r[3],
         s = e.resizeNearestNeighbor([o, a]);
        return Object(i["transpose"])(s, [0, 3, 1, 2])
       }
       return o = n.size[0] * r[1], a = n.size[1] * r[2], e.resizeNearestNeighbor([o, a])
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        size: this.size,
        dataFormat: this.dataFormat
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "UpSampling2D", e
    }(Ke);
 
    function Ji(t, e, n, r, o, a) {
     return void 0 === n && (n = [1, 1]), void 0 === r && (r = "valid"), Object(i["tidy"])((function() {
      null == o && (o = p()), it(o);
      var s = Bi(t, o);
      if (4 !== t.rank) throw new v("Input for depthwiseConv2d is required to be 4-D, but is instead " + t.rank + "-D");
      if (4 !== e.rank) throw new v("depthwiseKernel is required to be 4-D, but is instead " + e.rank + "-D");
      return s = Object(i["depthwiseConv2d"])(s, e, n, "same" === r ? "same" : "valid", "NHWC", a), "channelsFirst" === o && (s = Object(i["transpose"])(s, [0, 3, 1, 2])), s
     }))
    }
    i["serialization"].registerClass(Zi);
    var Qi = function(t) {
     function e(e) {
      var n = t.call(this, 2, e) || this;
      return n.depthwiseKernel = null, n.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, n.depthwiseInitializer = fe(e.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.depthwiseConstraint = K(e.depthwiseConstraint), n.depthwiseRegularizer = Oi(e.depthwiseRegularizer), n
     }
     return a(e, t), e.prototype.build = function(t) {
      if ((t = Le(t)).length < 4) throw new v("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(t) + ".");
      var e = "channelsFirst" === this.dataFormat ? 1 : 3;
      if (null == t[e] || t[e] < 0) throw new v("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + t[e] + ").");
      var n = t[e],
       r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var e = Ji(t = Me(t), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
       return n.useBias && (e = Bt(e, n.bias.read(), n.dataFormat)), null != n.activation && (e = n.activation.apply(e)), e
      }))
     }, e.prototype.computeOutputShape = function(t) {
      t = Le(t);
      var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
       n = "channelsFirst" === this.dataFormat ? t[3] : t[2],
       r = "channelsFirst" === this.dataFormat ? t[1] * this.depthMultiplier : t[3] * this.depthMultiplier,
       i = Mi(e, this.kernelSize[0], this.padding, this.strides[0]),
       o = Mi(n, this.kernelSize[1], this.padding, this.strides[1]);
      return "channelsFirst" === this.dataFormat ? [t[0], r, i, o] : [t[0], i, o, r]
     }, e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this);
      return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = pe(this.depthwiseInitializer), e.depthwiseRegularizer = ki(this.depthwiseRegularizer), e.depthwiseConstraint = G(this.depthwiseRegularizer), e
     }, e.className = "DepthwiseConv2D", e
    }(Vi);
    i["serialization"].registerClass(Qi);
    var to = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.rate = Math.max(Math.min(e.rate, 1), 0), n.noiseShape = e.noiseShape, n.seed = e.seed, n.supportsMasking = !0, n
     }
     return a(e, t), e.prototype.getNoiseShape = function(t) {
      if (null == this.noiseShape) return this.noiseShape;
      for (var e = t.shape, n = [], r = 0; r < this.noiseShape.length; ++r) n.push(null == this.noiseShape[r] ? e[r] : this.noiseShape[r]);
      return n
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t);
       if (0 < n.rate && n.rate < 1) {
        var i = null != e.training && e.training,
         o = n.getNoiseShape(r);
        return Vt((function() {
         return jt(r, n.rate, o, n.seed)
        }), (function() {
         return r
        }), i)
       }
       return t
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        rate: this.rate,
        noiseShape: this.noiseShape,
        seed: this.seed
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.prototype.dispose = function() {
      return t.prototype.dispose.call(this)
     }, e.className = "Dropout", e
    }(Ke);
    i["serialization"].registerClass(to);
    var eo = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.inputSpec = [{
       ndim: 3
      }], n
     }
     return a(e, t), e.prototype.getNoiseShape = function(t) {
      var e = t.shape;
      return [e[0], 1, e[2]]
     }, e.className = "SpatialDropout1D", e
    }(to);
    i["serialization"].registerClass(eo);
    var no = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      if (n.activation = null, n.useBias = !0, n.kernel = null, n.bias = null, n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
       var r = null;
       null != e.batchSize && (r = e.batchSize), n.batchInputShape = [r, e.inputDim]
      }
      return n.units = e.units, M(n.units, "units"), n.activation = yi(e.activation), null != e.useBias && (n.useBias = e.useBias), n.kernelInitializer = fe(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.biasInitializer = fe(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelConstraint = K(e.kernelConstraint), n.biasConstraint = K(e.biasConstraint), n.kernelRegularizer = Oi(e.kernelRegularizer), n.biasRegularizer = Oi(e.biasRegularizer), n.activityRegularizer = Oi(e.activityRegularizer), n.supportsMasking = !0, n.inputSpec = [{
       minNDim: 2
      }], n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e, n = (t = Le(t))[t.length - 1];
      null == this.kernel && (this.kernel = this.addWeight("kernel", [n, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
       minNDim: 2,
       axes: (e = {}, e[-1] = n, e)
      }], this.built = !0
     }, e.prototype.computeOutputShape = function(t) {
      var e = (t = Le(t)).slice();
      return e[e.length - 1] = this.units, e
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r, i = Me(t),
        o = P(n.activation.getClassName());
       return null != o ? r = Dt(i, n.kernel.read(), o, n.bias ? n.bias.read() : null) : (r = Dt(i, n.kernel.read()), null != n.bias && (r = Bt(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        units: this.units,
        activation: mi(this.activation),
        useBias: this.useBias,
        kernelInitializer: pe(this.kernelInitializer),
        biasInitializer: pe(this.biasInitializer),
        kernelRegularizer: ki(this.kernelRegularizer),
        biasRegularizer: ki(this.biasRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        kernelConstraint: G(this.kernelConstraint),
        biasConstraint: G(this.biasConstraint)
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Dense", e
    }(Ke);
    i["serialization"].registerClass(no);
    var ro = function(t) {
     function e(e) {
      var n = this;
      return e = e || {}, (n = t.call(this, e) || this).inputSpec = [{
       minNDim: 3
      }], n.dataFormat = e.dataFormat, n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      for (var e = 0, n = (t = Le(t)).slice(1); e < n.length; e++)
       if (null == n[e]) throw new v('The shape of the input to "Flatten" is not fully defined (got ' + t.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
      return [t[0], mt(t, 1)]
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t);
       if ("channelsFirst" === n.dataFormat && r.rank > 1) {
        for (var i = [0], o = 2; o < r.rank; ++o) i.push(o);
        i.push(1), r = r.transpose(i)
       }
       return kt(r)
      }))
     }, e.prototype.getConfig = function() {
      var e = {};
      null != this.dataFormat && (e.dataFormat = this.dataFormat);
      var n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Flatten", e
    }(Ke);
    i["serialization"].registerClass(ro);
    var io = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.activation = yi(e.activation), n
     }
     return a(e, t), e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t);
       return n.activation.apply(r)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        activation: mi(this.activation)
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Activation", e
    }(Ke);
    i["serialization"].registerClass(io);
    var oo = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.n = e.n, n.inputSpec = [{
       ndim: 2
      }], n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      return [t[0], this.n, t[1]]
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       return St(t = Me(t), n.n)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        n: this.n
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "RepeatVector", e
    }(Ke);
    i["serialization"].registerClass(oo);
    var ao = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      n.targetShape = e.targetShape;
      for (var r = 0; r < n.targetShape.length; ++r) n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);
      return n
     }
     return a(e, t), e.prototype.isUnknown = function(t) {
      return t < 0 || null == t
     }, e.prototype.fixUnknownDimension = function(t, e) {
      for (var n = "Total size of new array must be unchanged.", r = e.slice(), i = 1, o = null, a = 0; a < r.length; ++a) {
       var s = r[a];
       if (this.isUnknown(s)) {
        if (null !== o) throw new v("Can only specifiy one unknown dimension.");
        o = a
       } else i *= s
      }
      var u = mt(t);
      if (null !== o) {
       if (0 === i || u % i != 0) throw new v(n);
       r[o] = u / i
      } else if (u !== i) throw new v(n);
      return r
     }, e.prototype.computeOutputShape = function(t) {
      for (var e = !1, n = 0; n < t.length; ++n)
       if (this.isUnknown(t[n])) {
        e = !0;
        break
       } return e ? t.slice(0, 1).concat(this.targetShape) : t.slice(0, 1).concat(this.fixUnknownDimension(t.slice(1), this.targetShape))
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t),
        i = r.shape,
        o = i.slice(0, 1).concat(n.fixUnknownDimension(i.slice(1), n.targetShape));
       return r.reshape(o)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        targetShape: this.targetShape
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Reshape", e
    }(Ke);
    i["serialization"].registerClass(ao);
    var so = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      if (null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      if (!Array.isArray(e.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + e.dims + " instead.");
      var r = xt(1, e.dims.length + 1);
      if (!i["util"].arraysEqual(e.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
      return n.dims = e.dims, n.dimsIncludingBatch = [0].concat(n.dims), n.inputSpec = [new Ue({
       ndim: n.dims.length + 1
      })], n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      var e = (t = Le(t)).slice();
      return this.dims.forEach((function(n, r) {
       e[r + 1] = t[n]
      })), e
     }, e.prototype.call = function(t, e) {
      return Object(i["transpose"])(Me(t), this.dimsIncludingBatch)
     }, e.prototype.getConfig = function() {
      var e = {
        dims: this.dims
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Permute", e
    }(Ke);
    i["serialization"].registerClass(so);
    var uo = function(t) {
     function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.supportsMasking = !0, n.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0, n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this),
       n = {
        maskValue: this.maskValue
       };
      return Object.assign(n, e), n
     }, e.prototype.computeMask = function(t, e) {
      var n = Me(t);
      return Object(i["any"])(Object(i["notEqual"])(n, this.maskValue), -1)
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t),
        o = Object(i["any"])(Object(i["notEqual"])(r, n.maskValue), -1, !0);
       return r.mul(o.asType(r.dtype))
      }))
     }, e.className = "Masking", e
    }(Ke);
    i["serialization"].registerClass(uo);
    var co = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      if (n.embeddings = null, n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
       var r = null;
       null != e.batchSize && (r = e.batchSize), null == e.inputLength ? n.batchInputShape = [r, null] : n.batchInputShape = [r].concat(C(e.inputLength))
      }
      return n.inputDim = e.inputDim, M(n.inputDim, "inputDim"), n.outputDim = e.outputDim, M(n.outputDim, "outputDim"), n.embeddingsInitializer = fe(e.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER), n.embeddingsRegularizer = Oi(e.embeddingsRegularizer), n.activityRegularizer = Oi(e.activityRegularizer), n.embeddingsConstraint = K(e.embeddingsConstraint), n.maskZero = e.maskZero, n.supportsMasking = e.maskZero, n.inputLength = e.inputLength, n
     }
     return a(e, t), e.prototype.build = function(t) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0
     }, e.prototype.warnOnIncompatibleInputShape = function(t) {}, e.prototype.computeMask = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       return n.maskZero ? (t = Me(t), Object(i["notEqual"])(t, Object(i["zerosLike"])(t))) : null
      }))
     }, e.prototype.computeOutputShape = function(t) {
      if (t = Le(t), null == this.inputLength) return t.concat([this.outputDim]);
      var e = C(this.inputLength);
      if (e.length !== t.length - 1) throw new v('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + t);
      for (var n = 0, r = 0; r < e.length; ++r) {
       var i = e[r],
        o = t[r + 1];
       if (null != i && null != o && i !== o) throw new v('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + t);
       null == i && (e[n] = o), n++
      }
      return [t[0]].concat(e, [this.outputDim])
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t);
       return "int32" !== r.dtype && (r = wt(r, "int32")), Ft(n.embeddings.read(), r.as1D()).reshape(Le(n.computeOutputShape(r.shape)))
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        inputDim: this.inputDim,
        outputDim: this.outputDim,
        embeddingsInitializer: pe(this.embeddingsInitializer),
        embeddingsRegularizer: ki(this.embeddingsRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        embeddingsConstraint: G(this.embeddingsConstraint),
        maskZero: this.maskZero,
        inputLength: this.inputLength
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Embedding", e
    }(Ke);
    i["serialization"].registerClass(co);
    var lo = function(t) {
      function e(e) {
       var n = t.call(this, e || {}) || this;
       return n.supportsMasking = !0, n
      }
      return a(e, t), e.prototype.mergeFunction = function(t) {
       throw new m
      }, e.prototype.computeElementwiseOpOutputShape = function(t, e) {
       if (null == t || null == e) return null;
       if (t.length < e.length) return this.computeElementwiseOpOutputShape(e, t);
       if (0 === e.length) return t;
       for (var n = t.slice(0, t.length - e.length), r = 0; r < e.length; ++r) {
        var i = t[t.length - e.length + r],
         o = e[r];
        if (null == i || null == o || i < 0 || o < 0) n.push(null);
        else if (1 === i) n.push(o);
        else if (1 === o) n.push(i);
        else {
         if (i !== o) throw new v("Operands could not be broadcast together with shapes " + JSON.stringify(t) + " " + JSON.stringify(e));
         n.push(i)
        }
       }
       return n
      }, e.prototype.build = function(t) {
       if (Array.isArray(t) && !Array.isArray(t[0]) && (t = [Le(t)]), (t = t).length < 2) throw new v("A merge layer should be called on an Array of at least 2 inputs. Got " + t.length + " input(s).");
       for (var e = [], n = 0, r = t; n < r.length; n++) null != (a = r[n]) && null !== a[0] && e.push(a[0]);
       if ((e = T(e)).length > 1) throw new v("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(t) + ".");
       for (var i = null == t[0] ? null : t[0].slice(1), o = 1; o < t.length; ++o) {
        var a = null == t[o] ? null : t[o].slice(1);
        i = this.computeElementwiseOpOutputShape(i, a)
       }
       var s = t.map((function(t) {
        return t.length
       })); - 1 === t.indexOf(null) && 1 === T(s).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        if (t = t, n.reshapeRequired) {
         var e = [],
          r = t.map((function(t) {
           return t.rank
          }));
         if (-1 === r.indexOf(null)) {
          for (var o = bt(r), a = 0, s = t; a < s.length; a++) {
           for (var u = (f = s[a]).rank, c = 0; c < o - u; ++c) f = Ct(f, 1);
           e.push(f)
          }
          return n.mergeFunction(e)
         }
         for (var l = !1, h = 0, p = t; h < p.length; h++) {
          var f;
          if (null == (u = (f = p[h]).rank)) {
           var d = f.shape,
            v = d[0],
            m = d.slice(1).concat([v]),
            g = f.reshape([v].concat(mt(d.slice(1))));
           g = (g = Object(i["transpose"])(g, [1, 0])).reshape(m), e.push(g), l = !0
          } else if (u > 1) {
           var y = xt(1, u).concat([0]);
           e.push(Object(i["transpose"])(f, y)), l = !0
          } else e.push(f)
         }
         var b = n.mergeFunction(e),
          x = b.rank;
         if (l)
          if (null == x) {
           var w = b.shape;
           m = [v = w[w.length - 1]].concat(w.slice(0, w.length - 1)), b = Object(i["transpose"])(b.reshape([-1, v]), [1, 0]).reshape(m)
          } else x > 1 && (y = [x - 1].concat(xt(0, x - 1)), b = Object(i["transpose"])(b, y));
         return b
        }
        return n.mergeFunction(t)
       }))
      }, e.prototype.computeOutputShape = function(t) {
       var e;
       e = null == (t = t)[0] ? null : t[0].slice(1);
       for (var n = 1; n < t.length; ++n) {
        var r = null == t[n] ? null : t[n].slice(1);
        e = this.computeElementwiseOpOutputShape(e, r)
       }
       for (var i = [], o = 0, a = t; o < a.length; o++) null != (r = a[o]) && null !== r[0] && i.push(r[0]);
       return 1 === (i = T(i)).length ? i.concat(e) : [null].concat(e)
      }, e.prototype.computeMask = function(t, e) {
       return Object(i["tidy"])((function() {
        if (null == e) return null;
        if (!Array.isArray(e)) throw new v("`mask` should be an Array");
        if (!Array.isArray(t)) throw new v("`inputs` should be an Array");
        if (e.length !== t.length) throw new v("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + t.length + " vs " + e.length + ")");
        if (e.every((function(t) {
          return null == t
         }))) return null;
        for (var n = (e = e.map((function(t) {
          return null == t ? t : Object(i["expandDims"])(t, 0)
         })))[0], r = 1; r < e.length - 1; ++r) n = Object(i["logicalAnd"])(n, e[r]);
        return n
       }))
      }, e
     }(Ke),
     ho = function(t) {
      function e(e) {
       return t.call(this, e) || this
      }
      return a(e, t), e.prototype.mergeFunction = function(t) {
       return Object(i["tidy"])((function() {
        for (var e = t[0].clone(), n = 1; n < t.length; ++n) e = Object(i["add"])(e, t[n]);
        return e
       }))
      }, e.className = "Add", e
     }(lo);
    i["serialization"].registerClass(ho);
    var po = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.mergeFunction = function(t) {
      return Object(i["tidy"])((function() {
       for (var e = t[0].clone(), n = 1; n < t.length; ++n) e = Object(i["mul"])(e, t[n]);
       return e
      }))
     }, e.className = "Multiply", e
    }(lo);
    i["serialization"].registerClass(po);
    var fo = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.mergeFunction = function(t) {
      return Object(i["tidy"])((function() {
       for (var e = t[0].clone(), n = 1; n < t.length; ++n) e = Object(i["add"])(e, t[n]);
       return Object(i["mul"])(1 / t.length, e)
      }))
     }, e.className = "Average", e
    }(lo);
    i["serialization"].registerClass(fo);
    var vo = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.mergeFunction = function(t) {
      return Object(i["tidy"])((function() {
       for (var e = t[0], n = 1; n < t.length; ++n) e = Object(i["maximum"])(e, t[n]);
       return e
      }))
     }, e.className = "Maximum", e
    }(lo);
    i["serialization"].registerClass(vo);
    var mo = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.mergeFunction = function(t) {
      return Object(i["tidy"])((function() {
       for (var e = t[0], n = 1; n < t.length; ++n) e = Object(i["minimum"])(e, t[n]);
       return e
      }))
     }, e.className = "Minimum", e
    }(lo);
    i["serialization"].registerClass(mo);
    var go = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_AXIS = -1, null == e && (e = {}), n.axis = null == e.axis ? n.DEFAULT_AXIS : e.axis, n.supportsMasking = !0, n.reshapeRequired = !1, n
     }
     return a(e, t), e.prototype.build = function(t) {
      if (!Array.isArray(t) || !Array.isArray(t[0]) || 1 === t.length) throw new v("A `Concatenate` layer should be called on a list of at least 2 inputs");
      for (var e = !0, n = 0, r = t = t; n < r.length; n++)
       if (null != (h = r[n])) {
        e = !1;
        break
       } if (!e) {
       for (var o = [], a = 0; a < t.length; ++a) {
        var s = t[a].slice();
        s.splice(this.axis, 1);
        for (var u = !1, c = 0, l = o; c < l.length; c++) {
         var h = l[c];
         if (i["util"].arraysEqual(h, s)) {
          u = !0;
          break
         }
        }
        u || o.push(s)
       }
       if (o.length > 1) throw new v("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(t))
      }
     }, e.prototype.mergeFunction = function(t) {
      var e = this;
      return Object(i["tidy"])((function() {
       return Nt(t, e.axis)
      }))
     }, e.prototype.computeOutputShape = function(t) {
      if (!Array.isArray(t) || !Array.isArray(t[0])) throw new v("A `Concatenate` layer should be called on a list of inputs.");
      for (var e = t, n = e[0].slice(), r = this.axis < 0 ? n.length + this.axis : this.axis, i = 0, o = e.slice(1); i < o.length; i++) {
       var a = o[i];
       if (null == n[r] || null == a[r]) {
        n[r] = null;
        break
       }
       n[r] += a[r]
      }
      return n
     }, e.prototype.computeMask = function(t, e) {
      var n = this;
      if (null == e) return null;
      if (!Array.isArray(e)) throw new v("`mask` should be an array for Concatenate");
      if (!Array.isArray(t)) throw new v("`inputs` should be an array for Concatenate");
      if (e.length !== t.length) throw new v("Mismatch in the length of mask (" + e.length + ") and the legnth of inputs (" + t.length + ")");
      return Object(i["tidy"])((function() {
       var r = !0;
       if (e.forEach((function(t) {
         null == t || (r = !1)
        })), r) return null;
       for (var o = [], a = 0; a < t.length; ++a) null == e[a] ? o.push(Object(i["onesLike"])(t[a]).asType("bool")) : e[a].rank < t[a].rank ? o.push(Object(i["expandDims"])(e[a], -1)) : o.push(e[a]);
       var s = Object(i["concat"])(o, n.axis);
       return Object(i["all"])(s, -1, !1)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        axis: this.axis
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Concatenate", e
    }(lo);
 
    function yo(t, e) {
     for (; t < 0;) t += e;
     return t
    }
 
    function bo(t, e, n) {
     if (t.shape.length > 3 || e.shape.length > 3) throw new m("batchDot is not implemented for tensors of 4D or higher rank yet");
     if (i["util"].assert(t.shape.length >= 2, (function() {
       return "batchDot requires the rank of x to be >= 2, but got " + t.shape.length
      })), i["util"].assert(t.shape.length >= 2, (function() {
       return "batchDot requires the rank of y to be >= 2, but got " + e.shape.length
      })), "number" == typeof n && (n = [n, n]), "complex64" === t.dtype || "complex64" === e.dtype) throw new m("batchDot is not implemented for complex64-type Tensors yet.");
     var r = t.shape.length,
      o = e.shape.length;
     null == n && (n = [r - 1, o - 2]);
     var a = n;
     return Object(i["tidy"])((function() {
      var n, i;
      if (r > o) {
       n = r - o;
       for (var s = [], u = 0; u < n; ++u) s.push(1);
       e = e.reshape(e.shape.concat(s))
      } else if (o > r) {
       for (n = o - r, s = [], u = 0; u < n; ++u) s.push(1);
       t = t.reshape(t.shape.concat(s))
      } else n = 0;
      if (2 === t.shape.length && 2 === e.shape.length) i = a[0] === a[1] ? t.mulStrict(e).sum(a[0]) : t.transpose([1, 0]).mulStrict(e).sum(a[1]);
      else {
       var c = a[0] !== t.shape.length - 1,
        l = a[1] === e.shape.length - 1;
       i = t.matMul(e, c, l)
      }
      if (n > 0) {
       var h = void 0,
        p = [];
       for (u = h = r > o ? r + o - 3 : r - 1; u < h + n; ++u) p.push(u);
       i = i.squeeze(p)
      }
      return 1 === i.shape.length && (i = i.expandDims(1)), i
     }))
    }
    i["serialization"].registerClass(go);
    var xo = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.axes = e.axes, n.normalize = null != e.normalize && e.normalize, n.supportsMasking = !0, n.reshapeRequired = !1, n
     }
     return a(e, t), e.prototype.build = function(t) {
      i["util"].assert(Array.isArray(t) && 2 === t.length && Array.isArray(t[0]) && Array.isArray(t[1]), (function() {
       return "A `Dot` layer should be called on a list of exactly 2 inputs."
      }));
      var e = t[0],
       n = t[1];
      if (e.length > 3 || n.length > 3) throw new m("Dot layer does not support tensors of 4D or higher rank yet.");
      var r = this.interpretAxes(e, n);
      if (e[r[0]] !== n[r[1]]) throw new v("Dimension incompatibility: " + e[r[0]] + " !== " + n[r[1]])
     }, e.prototype.mergeFunction = function(t) {
      if (2 !== t.length) throw new v("A `Dot` layer must be called on exactly 2 inputs, but received " + t.length + " input(s).");
      var e, n = t[0],
       r = t[1];
      return e = Array.isArray(this.axes) ? this.axes.map((function(e, n) {
       return yo(e, t[n].shape.length)
      })) : [yo(this.axes, n.shape.length), yo(this.axes, r.shape.length)], this.normalize && (n = dn(n, e[0]), r = dn(r, e[1])), bo(n, r, e)
     }, e.prototype.interpretAxes = function(t, e) {
      return Array.isArray(this.axes) ? this.axes : [yo(this.axes, t.length), yo(this.axes, e.length)]
     }, e.prototype.computeOutputShape = function(t) {
      i["util"].assert(Array.isArray(t) && 2 === t.length && Array.isArray(t[0]) && Array.isArray(t[1]), (function() {
       return "A `Dot` layer should be called on a list of exactly 2 inputs."
      }));
      var e = t[0].slice(),
       n = t[1].slice();
      if (e.length > 3 || n.length > 3) throw new m("Dot layer does not support tensors of 4D or higher rank yet.");
      var r = this.interpretAxes(e, n);
      e.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
      var o = e.concat(n);
      return 1 === o.length && o.push(1), o
     }, e.prototype.computeMask = function(t, e) {
      return null
     }, e.prototype.getConfig = function() {
      var e = {
        axes: this.axes,
        normalize: this.normalize
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "Dot", e
    }(lo);
    i["serialization"].registerClass(xo);
    var wo = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.stddev = e.stddev, n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this),
       n = {
        stddev: this.stddev
       };
      return Object.assign(n, e), n
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t);
       return Vt((function() {
        return _t(r.shape, 0, n.stddev).add(r)
       }), (function() {
        return r
       }), e.training || !1)
      }))
     }, e.className = "GaussianNoise", e
    }(Ke);
    i["serialization"].registerClass(wo);
    var Co = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.rate = e.rate, n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this),
       n = {
        rate: this.rate
       };
      return Object.assign(n, e), n
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       n.invokeCallHook(t, e);
       var r = Me(t);
       return n.rate > 0 && n.rate < 1 ? Vt((function() {
        var t = Math.sqrt(n.rate / (1 - n.rate));
        return r.mul(_t(r.shape, 1, t))
       }), (function() {
        return r
       }), e.training || !1) : r
      }))
     }, e.className = "GaussianDropout", e
    }(Ke);
    i["serialization"].registerClass(Co);
    var So = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.rate = e.rate, n.noiseShape = e.noiseShape, n
     }
     return a(e, t), e.prototype._getNoiseShape = function(t) {
      return this.noiseShape || Me(t).shape
     }, e.prototype.computeOutputShape = function(t) {
      return t
     }, e.prototype.getConfig = function() {
      var e = t.prototype.getConfig.call(this),
       n = {
        rate: this.rate
       };
      return Object.assign(n, e), n
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       if (n.rate < 1 && n.rate > 0) {
        var r = n._getNoiseShape(t);
        return Vt((function() {
         var e = Me(t),
          o = -1.7580993408473766,
          a = Object(i["greaterEqual"])(Object(i["randomUniform"])(r), n.rate);
         a = wt(a, "float32");
         var s = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(o, 2)), -.5),
          u = -s * o * n.rate;
         return e.mul(a).add(a.add(-1).mul(o)).mul(s).add(u)
        }), (function() {
         return Me(t)
        }), e.training || !1)
       }
       return t
      }))
     }, e.className = "AlphaDropout", e
    }(Ke);
 
    function Eo(t, e, n, r, o, a) {
     var s;
     if (void 0 === a && (a = .001), 2 === t.rank) s = Object(i["batchNorm2d"])(t, e, n, r, o, a);
     else if (3 === t.rank) s = Object(i["batchNorm3d"])(t, e, n, r, o, a);
     else {
      if (4 !== t.rank) throw new m("batchNormalization is not implemented for array of rank " + t.rank + " yet");
      s = Object(i["batchNorm4d"])(t, e, n, r, o, a)
     }
     return s
    }
 
    function ko(t, e, n, r, o) {
     return void 0 === o && (o = .001), Object(i["tidy"])((function() {
      var a = Object(i["moments"])(t, r),
       s = a.mean,
       u = a.variance;
      return [Eo(t, s, u, n, e, o), s, u]
     }))
    }
 
    function Io(t, e, n, r, o) {
     return void 0 === o && (o = .001), Object(i["tidy"])((function() {
      for (var a = Object(i["moments"])(t, r), s = a.mean, u = a.variance, c = [], l = 0, h = xt(0, t.rank); l < h.length; l++) {
       var p = h[l]; - 1 !== r.indexOf(p) ? c.push(1) : c.push(t.shape[p])
      }
      var f = s.reshape(c),
       d = u.reshape(c),
       v = null == e ? null : e.reshape(c),
       m = null == n ? null : n.reshape(c);
      return [Eo(t, f, d, m, v, o), s, u]
     }))
    }
 
    function Oo(t, e, n, r, o) {
     return void 0 === o && (o = .001), i["util"].arraysEqual(r.slice().sort(), xt(0, t.rank - 1)) ? ko(t, e, n, r, o) : Io(t, e, n, r, o)
    }
    i["serialization"].registerClass(So);
    var Ao = function(t) {
     function e(e) {
      var n = this;
      return null == e && (e = {}), (n = t.call(this, e) || this).supportsMasking = !0, n.axis = null == e.axis ? -1 : e.axis, n.momentum = null == e.momentum ? .99 : e.momentum, n.epsilon = null == e.epsilon ? .001 : e.epsilon, n.center = null == e.center || e.center, n.scale = null == e.scale || e.scale, n.betaInitializer = fe(e.betaInitializer || "zeros"), n.gammaInitializer = fe(e.gammaInitializer || "ones"), n.movingMeanInitializer = fe(e.movingMeanInitializer || "zeros"), n.movingVarianceInitializer = fe(e.movingVarianceInitializer || "ones"), n.betaConstraint = K(e.betaConstraint), n.gammaConstraint = K(e.gammaConstraint), n.betaRegularizer = Oi(e.betaRegularizer), n.gammaRegularizer = Oi(e.gammaRegularizer), n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e;
      t = Le(t);
      var n = this.axis >= 0 ? this.axis : this.axis + t.length,
       r = t[n];
      if (null == r) throw new v("Axis " + n + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(t) + ".");
      this.inputSpec = [new Ue({
       ndim: t.length,
       axes: (e = {}, e[n] = r, e)
      })];
      var i = [r];
      this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, !1), this.built = !0
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var r = null != e.training && e.training,
        o = Me(t),
        a = o.shape,
        s = a.length,
        u = xt(0, s),
        c = n.axis >= 0 ? n.axis : n.axis + s;
       u.splice(c, 1);
       var l = y(1, s);
       l[c] = a[c];
       var h = u.slice();
       h.sort();
       var p = !i["util"].arraysEqual(h, xt(0, s).slice(0, s - 1));
       if (!r) return function() {
        if (p) {
         var t = n.movingMean.read().reshape(l),
          e = n.movingVariance.read().reshape(l),
          r = n.center ? n.beta.read().reshape(l) : null,
          i = n.scale ? n.gamma.read().reshape(l) : null;
         return Eo(o, t, e, r, i, n.epsilon)
        }
        return Eo(o, n.movingMean.read(), n.movingVariance.read(), null == n.beta ? null : n.beta.read(), null == n.gamma ? null : n.gamma.read(), n.epsilon)
       }();
       var f = Oo(o, n.gamma.read(), n.beta.read(), u, n.epsilon),
        d = f[0],
        v = f[1],
        m = f[2],
        g = function(t, e, n) {
         Object(i["tidy"])((function() {
          var r = 1 - n,
           i = t.read(),
           o = i.sub(e).mul(r);
          t.write(i.sub(o))
         }))
        };
       return g(n.movingMean, v, n.momentum), g(n.movingVariance, m, n.momentum), d
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        axis: this.axis,
        momentum: this.momentum,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: pe(this.betaInitializer),
        gammaInitializer: pe(this.gammaInitializer),
        movingMeanInitializer: pe(this.movingMeanInitializer),
        movingVarianceInitializer: pe(this.movingVarianceInitializer),
        betaRegularizer: ki(this.betaRegularizer),
        gammaRegularizer: ki(this.gammaRegularizer),
        betaConstraint: G(this.betaConstraint),
        gammaConstraint: G(this.gammaConstraint)
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "BatchNormalization", e
    }(Ke);
    i["serialization"].registerClass(Ao);
    var No = function(t) {
     function e(e) {
      var n = this;
      if (null == e && (e = {}), (n = t.call(this, e) || this).axis = null == e.axis ? -1 : e.axis, "number" == typeof n.axis) {
       if (!Number.isInteger(n.axis)) throw new Error("Expected axis to be an integer, but received " + n.axis)
      } else {
       if (!Array.isArray(n.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis));
       for (var r = 0, i = n.axis; r < i.length; r++) {
        var o = i[r];
        if (!Number.isInteger(o)) throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n.axis))
       }
      }
      return n.epsilon = null == e.epsilon ? .001 : e.epsilon, n.center = null == e.center || e.center, n.scale = null == e.scale || e.scale, n.betaInitializer = fe(e.betaInitializer || "zeros"), n.gammaInitializer = fe(e.gammaInitializer || "ones"), n.betaRegularizer = Oi(e.betaRegularizer), n.gammaRegularizer = Oi(e.gammaRegularizer), n.supportsMasking = !0, n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e = (t = Le(t)).length;
      "number" == typeof this.axis && (this.axis = [this.axis]);
      for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += e);
      for (var r = 0, i = this.axis; r < i.length; r++) {
       var o = i[r];
       if (o < 0 || o >= e) throw new Error("Invalid axis: " + o)
      }
      if (this.axis.length !== T(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
      var a = this.axis.map((function(e) {
       return t[e]
      }));
      this.scale ? this.gamma = this.addWeight("gamma", a, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", a, "float32", this.betaInitializer, this.betaRegularizer, !0) : this.beta = null, this.built = !0
     }, e.prototype.call = function(t, e) {
      var n = this,
       r = Me(t),
       o = r.shape,
       a = o.length;
      return Object(i["tidy"])((function() {
       for (var t = Object(i["moments"])(r, n.axis, !0), e = t.mean, s = t.variance, u = y(1, a), c = 0, l = n.axis; c < l.length; c++) {
        var h = l[c];
        u[h] = o[h]
       }
       for (var p = function(t) {
         return null != t && t.shape.length !== a && n.axis !== [a - 1] ? t.reshape(u) : t
        }, f = p(n.gamma.read()), d = p(n.beta.read()), v = [], m = [], g = 0; g < a; ++g) - 1 !== n.axis.indexOf(g) ? (v.push(o[g]), m.push(1)) : (v.push(1), m.push(o[g]));
       return e = e.tile(v), s = s.tile(v), f = f.tile(m), d = d.tile(m), Eo(r, e, s, d, f, n.epsilon)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        axis: this.axis,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: pe(this.betaInitializer),
        gammaInitializer: pe(this.gammaInitializer),
        betaRegularizer: ki(this.betaRegularizer),
        gammaRegularizer: ki(this.gammaRegularizer)
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "LayerNormalization", e
    }(Ke);
 
    function Ro(t, e, n) {
     return Object(i["tidy"])((function() {
      if (4 !== t.rank) throw new v("temporalPadding expects input tensor to be 4-D, but received a " + t.rank + "-D tensor.");
      if (null == e && (e = [
        [1, 1],
        [1, 1]
       ]), 2 !== e.length || 2 !== e[0].length || 2 !== e[1].length) throw new v("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
      if (null == n && (n = p()), "channelsLast" !== n && "channelsFirst" !== n) throw new v("Unknown data format: " + n + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
      var r;
      return r = "channelsFirst" === n ? [
       [0, 0],
       [0, 0], e[0], e[1]
      ] : [
       [0, 0], e[0], e[1],
       [0, 0]
      ], Object(i["pad"])(t, r)
     }))
    }
    i["serialization"].registerClass(No);
    var To = function(t) {
     function e(e) {
      var n = this;
      if (null == e && (e = {}), (n = t.call(this, e) || this).dataFormat = null == e.dataFormat ? p() : e.dataFormat, null == e.padding) n.padding = [
       [1, 1],
       [1, 1]
      ];
      else if ("number" == typeof e.padding) n.padding = [
       [e.padding, e.padding],
       [e.padding, e.padding]
      ];
      else {
       if (e.padding = e.padding, 2 !== e.padding.length) throw new v("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + e.padding.length + " array.");
       var r = void 0,
        i = void 0;
       if ("number" == typeof e.padding[0]) r = [e.padding[0], e.padding[0]], i = [e.padding[1], e.padding[1]];
       else {
        if (e.padding = e.padding, 2 !== e.padding[0].length) throw new v("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + e.padding[0].length + " array.");
        if (r = e.padding[0], 2 !== e.padding[1].length) throw new v("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + e.padding[1].length + " array.");
        i = e.padding[1]
       }
       n.padding = [r, i]
      }
      return n.inputSpec = [new Ue({
       ndim: 4
      })], n
     }
     return a(e, t), e.prototype.computeOutputShape = function(t) {
      var e, n;
      return t = Le(t), "channelsFirst" === this.dataFormat ? (e = null != t[2] && t[2] >= 0 ? t[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != t[3] && t[3] >= 0 ? t[3] + this.padding[1][0] + this.padding[1][1] : null, [t[0], t[1], e, n]) : (e = null != t[1] && t[1] >= 0 ? t[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != t[2] && t[2] >= 0 ? t[2] + this.padding[1][0] + this.padding[1][1] : null, [t[0], e, n, t[3]])
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       return Ro(Me(t), n.padding, n.dataFormat)
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        padding: this.padding,
        dataFormat: this.dataFormat
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "ZeroPadding2D", e
    }(Ke);
 
    function _o(t, e, n, r, o, a) {
     return Object(i["tidy"])((function() {
      var s;
      it(o), at(a), ot(r), null == n && (n = [1, 1]), null == r && (r = "valid"), null == o && (o = p()), null == a && (a = "max"), t = Bi(t, o);
      var u = "same" === r ? "same" : "valid";
      return s = "max" === a ? Object(i["maxPool"])(t, e, n, u) : Object(i["avgPool"])(t, e, n, u), "channelsFirst" === o && (s = Object(i["transpose"])(s, [0, 3, 1, 2])), s
     }))
    }
 
    function Do(t, e, n, r, o, a) {
     return Object(i["tidy"])((function() {
      var s;
      it(o), at(a), ot(r), null == n && (n = [1, 1, 1]), null == r && (r = "valid"), null == o && (o = p()), null == a && (a = "max"), t = Pi(t, o);
      var u = "same" === r ? "same" : "valid";
      return s = "max" === a ? Object(i["maxPool3d"])(t, e, n, u) : Object(i["avgPool3d"])(t, e, n, u), "channelsFirst" === o && (s = Object(i["transpose"])(s, [0, 4, 1, 2, 3])), s
     }))
    }
    i["serialization"].registerClass(To);
    var Fo = function(t) {
      function e(e) {
       var n = this;
       if (null == e.poolSize && (e.poolSize = 2), n = t.call(this, e) || this, "number" == typeof e.poolSize) n.poolSize = [e.poolSize];
       else {
        if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new v("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(e.poolSize));
        n.poolSize = e.poolSize
       }
       if (M(n.poolSize, "poolSize"), null == e.strides) n.strides = n.poolSize;
       else if ("number" == typeof e.strides) n.strides = [e.strides];
       else {
        if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new v("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(e.strides));
        n.strides = e.strides
       }
       return M(n.strides, "strides"), n.padding = null == e.padding ? "valid" : e.padding, ot(n.padding), n.inputSpec = [new Ue({
        ndim: 3
       })], n
      }
      return a(e, t), e.prototype.computeOutputShape = function(t) {
       var e = Mi((t = Le(t))[1], this.poolSize[0], this.padding, this.strides[0]);
       return [t[0], e, t[2]]
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        n.invokeCallHook(t, e), t = Ct(Me(t), 2);
        var r = n.poolingFunction(Me(t), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
        return Object(i["squeeze"])(r, [2])
       }))
      }, e.prototype.getConfig = function() {
       var e = {
         poolSize: this.poolSize,
         padding: this.padding,
         strides: this.strides
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e
     }(Ke),
     Mo = function(t) {
      function e(e) {
       return t.call(this, e) || this
      }
      return a(e, t), e.prototype.poolingFunction = function(t, e, n, r, i) {
       return it(i), ot(r), _o(t, e, n, r, i, "max")
      }, e.className = "MaxPooling1D", e
     }(Fo);
    i["serialization"].registerClass(Mo);
    var Lo = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.poolingFunction = function(t, e, n, r, i) {
      return it(i), ot(r), _o(t, e, n, r, i, "avg")
     }, e.className = "AveragePooling1D", e
    }(Fo);
    i["serialization"].registerClass(Lo);
    var Bo = function(t) {
      function e(e) {
       var n = this;
       if (null == e.poolSize && (e.poolSize = [2, 2]), (n = t.call(this, e) || this).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) n.strides = n.poolSize;
       else if (Array.isArray(e.strides)) {
        if (2 !== e.strides.length) throw new v("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + e.strides.length + ".");
        n.strides = e.strides
       } else n.strides = [e.strides, e.strides];
       return M(n.poolSize, "poolSize"), M(n.strides, "strides"), n.padding = null == e.padding ? "valid" : e.padding, n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, it(n.dataFormat), ot(n.padding), n.inputSpec = [new Ue({
        ndim: 4
       })], n
      }
      return a(e, t), e.prototype.computeOutputShape = function(t) {
       t = Le(t);
       var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
        n = "channelsFirst" === this.dataFormat ? t[3] : t[2];
       return e = Mi(e, this.poolSize[0], this.padding, this.strides[0]), n = Mi(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [t[0], t[1], e, n] : [t[0], e, n, t[3]]
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        return n.invokeCallHook(t, e), n.poolingFunction(Me(t), n.poolSize, n.strides, n.padding, n.dataFormat)
       }))
      }, e.prototype.getConfig = function() {
       var e = {
         poolSize: this.poolSize,
         padding: this.padding,
         strides: this.strides,
         dataFormat: this.dataFormat
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e
     }(Ke),
     Po = function(t) {
      function e(e) {
       return t.call(this, e) || this
      }
      return a(e, t), e.prototype.poolingFunction = function(t, e, n, r, i) {
       return it(i), ot(r), _o(t, e, n, r, i, "max")
      }, e.className = "MaxPooling2D", e
     }(Bo);
    i["serialization"].registerClass(Po);
    var zo = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.poolingFunction = function(t, e, n, r, i) {
      return it(i), ot(r), _o(t, e, n, r, i, "avg")
     }, e.className = "AveragePooling2D", e
    }(Bo);
    i["serialization"].registerClass(zo);
    var jo = function(t) {
      function e(e) {
       var n = this;
       if (null == e.poolSize && (e.poolSize = [2, 2, 2]), (n = t.call(this, e) || this).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) n.strides = n.poolSize;
       else if (Array.isArray(e.strides)) {
        if (3 !== e.strides.length) throw new v("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + e.strides.length + ".");
        n.strides = e.strides
       } else n.strides = [e.strides, e.strides, e.strides];
       return M(n.poolSize, "poolSize"), M(n.strides, "strides"), n.padding = null == e.padding ? "valid" : e.padding, n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, it(n.dataFormat), ot(n.padding), n.inputSpec = [new Ue({
        ndim: 5
       })], n
      }
      return a(e, t), e.prototype.computeOutputShape = function(t) {
       t = Le(t);
       var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
        n = "channelsFirst" === this.dataFormat ? t[3] : t[2],
        r = "channelsFirst" === this.dataFormat ? t[4] : t[3];
       return e = Mi(e, this.poolSize[0], this.padding, this.strides[0]), n = Mi(n, this.poolSize[1], this.padding, this.strides[1]), r = Mi(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [t[0], t[1], e, n, r] : [t[0], e, n, r, t[4]]
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        return n.invokeCallHook(t, e), n.poolingFunction(Me(t), n.poolSize, n.strides, n.padding, n.dataFormat)
       }))
      }, e.prototype.getConfig = function() {
       var e = {
         poolSize: this.poolSize,
         padding: this.padding,
         strides: this.strides,
         dataFormat: this.dataFormat
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e
     }(Ke),
     Wo = function(t) {
      function e(e) {
       return t.call(this, e) || this
      }
      return a(e, t), e.prototype.poolingFunction = function(t, e, n, r, i) {
       return it(i), ot(r), Do(t, e, n, r, i, "max")
      }, e.className = "MaxPooling3D", e
     }(jo);
    i["serialization"].registerClass(Wo);
    var Vo = function(t) {
     function e(e) {
      return t.call(this, e) || this
     }
     return a(e, t), e.prototype.poolingFunction = function(t, e, n, r, i) {
      return it(i), ot(r), Do(t, e, n, r, i, "avg")
     }, e.className = "AveragePooling3D", e
    }(jo);
    i["serialization"].registerClass(Vo);
    var Uo = function(t) {
      function e(e) {
       var n = t.call(this, e) || this;
       return n.inputSpec = [new Ue({
        ndim: 3
       })], n
      }
      return a(e, t), e.prototype.computeOutputShape = function(t) {
       return [t[0], t[2]]
      }, e.prototype.call = function(t, e) {
       throw new m
      }, e
     }(Ke),
     Ho = function(t) {
      function e(e) {
       return t.call(this, e || {}) || this
      }
      return a(e, t), e.prototype.call = function(t, e) {
       return Object(i["tidy"])((function() {
        var e = Me(t);
        return Object(i["mean"])(e, 1)
       }))
      }, e.className = "GlobalAveragePooling1D", e
     }(Uo);
    i["serialization"].registerClass(Ho);
    var $o = function(t) {
     function e(e) {
      return t.call(this, e || {}) || this
     }
     return a(e, t), e.prototype.call = function(t, e) {
      return Object(i["tidy"])((function() {
       var e = Me(t);
       return Object(i["max"])(e, 1)
      }))
     }, e.className = "GlobalMaxPooling1D", e
    }(Uo);
    i["serialization"].registerClass($o);
    var Go = function(t) {
      function e(e) {
       var n = t.call(this, e) || this;
       return n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, it(n.dataFormat), n.inputSpec = [new Ue({
        ndim: 4
       })], n
      }
      return a(e, t), e.prototype.computeOutputShape = function(t) {
       return t = t, "channelsLast" === this.dataFormat ? [t[0], t[3]] : [t[0], t[1]]
      }, e.prototype.call = function(t, e) {
       throw new m
      }, e.prototype.getConfig = function() {
       var e = {
         dataFormat: this.dataFormat
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e
     }(Ke),
     qo = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        var e = Me(t);
        return "channelsLast" === n.dataFormat ? Object(i["mean"])(e, [1, 2]) : Object(i["mean"])(e, [2, 3])
       }))
      }, e.className = "GlobalAveragePooling2D", e
     }(Go);
    i["serialization"].registerClass(qo);
    var Ko = function(t) {
     function e() {
      return null !== t && t.apply(this, arguments) || this
     }
     return a(e, t), e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var e = Me(t);
       return "channelsLast" === n.dataFormat ? Object(i["max"])(e, [1, 2]) : Object(i["max"])(e, [2, 3])
      }))
     }, e.className = "GlobalMaxPooling2D", e
    }(Go);
 
    function Xo(t, e, n, r) {
     if (Array.isArray(t)) {
      if (null != e || null != n) throw new v("When inputs is an array, neither initialState or constants should be provided");
      null != r && (n = t.slice(t.length - r, t.length), t = t.slice(0, t.length - r)), t.length > 1 && (e = t.slice(1, t.length)), t = t[0]
     }
 
     function i(t) {
      return null == t || Array.isArray(t) ? t : [t]
     }
     return {
      inputs: t,
      initialState: e = i(e),
      constants: n = i(n)
     }
    }
 
    function Yo(t, e, n, r, o, a, s, u) {
     return void 0 === r && (r = !1), void 0 === s && (s = !1), void 0 === u && (u = !1), Object(i["tidy"])((function() {
      var c = e.shape.length;
      if (c < 3) throw new v("Input should be at least 3D, but is " + c + "D.");
      var l = [1, 0].concat(xt(2, c));
      if (e = Object(i["transpose"])(e, l), null != a) throw new m("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
      s && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != o && ((o = o.asType("bool").asType("float32")).rank === c - 1 && (o = Object(i["expandDims"])(o, -1)), o = Object(i["transpose"])(o, l)), r && (e = Object(i["reverse"])(e, 0), null != o && (o = Object(i["reverse"])(o, 0)));
      var h, p, f = [],
       d = n,
       g = e.shape[0],
       y = Object(i["unstack"])(e);
      null != o && (p = Object(i["unstack"])(o));
      for (var b, x = function(e) {
        var n = y[e],
         r = Object(i["tidy"])((function() {
          return t(n, d)
         }));
        if (null == o) h = r[0], d = r[1];
        else {
         var a = Object(i["tidy"])((function() {
          var t = p[e],
           n = Object(i["onesLike"])(t).sub(t);
          return {
           output: r[0].mul(t).addStrict(d[0].mul(n)),
           newStates: d.map((function(e, i) {
            return r[1][i].mul(t).addStrict(e.mul(n))
           }))
          }
         }));
         h = a.output, d = a.newStates
        }
        u && f.push(h)
       }, w = 0; w < g; ++w) x(w);
      return u && (b = Object(i["stack"])(f, 1)), [h, b, d]
     }))
    }
    i["serialization"].registerClass(Ko);
    var Zo = function(t) {
     function e(e) {
      var n, r = t.call(this, e) || this;
      if (null == e.cell) throw new v("cell property is missing for the constructor of RNN.");
      if (null == (n = Array.isArray(e.cell) ? new oa({
        cells: e.cell
       }) : e.cell).stateSize) throw new v("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      return r.cell = n, r.returnSequences = null != e.returnSequences && e.returnSequences, r.returnState = null != e.returnState && e.returnState, r.goBackwards = null != e.goBackwards && e.goBackwards, r._stateful = null != e.stateful && e.stateful, r.unroll = null != e.unroll && e.unroll, r.supportsMasking = !0, r.inputSpec = [new Ue({
       ndim: 3
      })], r.stateSpec = null, r.states_ = null, r.numConstants = null, r.keptStates = [], r
     }
     return a(e, t), e.prototype.getStates = function() {
      return null == this.states_ ? xt(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map((function(t) {
       return null
      })) : this.states_
     }, e.prototype.setStates = function(t) {
      this.states_ = t
     }, e.prototype.computeOutputShape = function(t) {
      De(t) && (t = t[0]), t = t;
      var e = this.cell.stateSize;
      Array.isArray(e) || (e = [e]);
      var n, r = e[0];
      if (n = this.returnSequences ? [t[0], t[1], r] : [t[0], r], this.returnState) {
       for (var i = [], o = 0, a = e; o < a.length; o++) {
        var s = a[o];
        i.push([t[0], s])
       }
       return [n].concat(i)
      }
      return n
     }, e.prototype.computeMask = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       Array.isArray(e) && (e = e[0]);
       var t = n.returnSequences ? e : null;
       if (n.returnState) {
        var r = n.states.map((function(t) {
         return null
        }));
        return [t].concat(r)
       }
       return t
      }))
     }, Object.defineProperty(e.prototype, "states", {
      get: function() {
       if (null == this.states_) {
        for (var t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, e = [], n = 0; n < t; ++n) e.push(null);
        return e
       }
       return this.states_
      },
      set: function(t) {
       this.states_ = t
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.build = function(t) {
      if (null != this.numConstants) throw new m("Constants support is not implemented in RNN yet.");
      De(t) && (t = t[0]), t = t;
      var e = this.stateful ? t[0] : null,
       n = t[t.length - 1];
      this.inputSpec[0] = new Ue({
       shape: [e, null, n]
      });
      var r, o = [t[0]].concat(t.slice(2));
      if (this.cell.build(o), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
       if (!i["util"].arraysEqual(this.stateSpec.map((function(t) {
         return t.shape[t.shape.length - 1]
        })), r)) throw new v("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize)
      } else this.stateSpec = r.map((function(t) {
       return new Ue({
        shape: [null, t]
       })
      }));
      this.stateful && this.resetStates()
     }, e.prototype.resetStates = function(t, e) {
      var n = this;
      void 0 === e && (e = !1), Object(i["tidy"])((function() {
       if (!n.stateful) throw new f("Cannot call resetStates() on an RNN Layer that is not stateful.");
       var r = n.inputSpec[0].shape[0];
       if (null == r) throw new v("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
       if (null == n.states_) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map((function(t) {
        return Object(i["zeros"])([r, t])
       })) : n.states_ = [Object(i["zeros"])([r, n.cell.stateSize])];
       else if (null == t) Object(i["dispose"])(n.states_), null != n.keptStates && (Object(i["dispose"])(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map((function(t) {
        return Object(i["zeros"])([r, t])
       })) : n.states_[0] = Object(i["zeros"])([r, n.cell.stateSize]);
       else {
        if (Array.isArray(t) || (t = [t]), t.length !== n.states_.length) throw new v("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + t.length + " state value(s). Input received: " + t);
        !0 === e ? n.keptStates.push(n.states_.slice()) : Object(i["dispose"])(n.states_);
        for (var o = 0; o < n.states_.length; ++o) {
         var a = t[o],
          s = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[o] : n.cell.stateSize,
          u = [r, s];
         if (!i["util"].arraysEqual(a.shape, u)) throw new v("State " + o + " is incompatible with layer " + n.name + ": expected shape=" + u + ", received shape=" + a.shape);
         n.states_[o] = a
        }
       }
       n.states_ = n.states_.map((function(t) {
        return Object(i["keep"])(t.clone())
       }))
      }))
     }, e.prototype.apply = function(e, n) {
      var r = null == n ? null : n.initialState,
       i = null == n ? null : n.constants;
      null == n && (n = {});
      var o = Xo(e, r, i, this.numConstants);
      e = o.inputs, r = o.initialState, i = o.constants;
      var a = [],
       s = [];
      if (null != r) {
       n.initialState = r, a = a.concat(r), this.stateSpec = [];
       for (var u = 0, c = r; u < c.length; u++) {
        var l = c[u];
        this.stateSpec.push(new Ue({
         shape: l.shape
        }))
       }
       s = s.concat(this.stateSpec)
      }
      if (null != i && (n.constants = i, a = a.concat(i), this.numConstants = i.length), a[0] instanceof He) {
       var h = [e].concat(a),
        p = this.inputSpec.concat(s),
        f = this.inputSpec;
       this.inputSpec = p;
       var d = t.prototype.apply.call(this, h, n);
       return this.inputSpec = f, d
      }
      return t.prototype.apply.call(this, e, n)
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var r = null == e ? null : e.mask,
        i = null == e ? null : e.training,
        o = null == e ? null : e.initialState;
       t = Me(t), null == o && (o = n.stateful ? n.states_ : n.getInitialState(t));
       var a = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
       if (o.length !== a) throw new v("RNN Layer has " + a + " state(s) but was passed " + o.length + " initial state(s).");
       n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
       var s = {
         training: i
        },
        u = Yo((function(t, e) {
         var r = n.cell.call([t].concat(e), s);
         return [r[0], r.slice(1)]
        }), t, o, n.goBackwards, r, null, n.unroll, n.returnSequences),
        c = u[0],
        l = u[1],
        h = u[2];
       n.stateful && n.resetStates(h, i);
       var p = n.returnSequences ? l : c;
       return n.returnState ? [p].concat(h) : p
      }))
     }, e.prototype.getInitialState = function(t) {
      var e = this;
      return Object(i["tidy"])((function() {
       var n = Object(i["zeros"])(t.shape);
       return n = Ct(n = Object(i["sum"])(n, [1, 2])), Array.isArray(e.cell.stateSize) ? e.cell.stateSize.map((function(t) {
        return t > 1 ? Tt(n, [1, t]) : n
       })) : e.cell.stateSize > 1 ? [Tt(n, [1, e.cell.stateSize])] : [n]
      }))
     }, Object.defineProperty(e.prototype, "trainableWeights", {
      get: function() {
       return this.trainable ? this.cell.trainableWeights : []
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
      get: function() {
       return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.setFastWeightInitDuringBuild = function(e) {
      t.prototype.setFastWeightInitDuringBuild.call(this, e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e)
     }, e.prototype.getConfig = function() {
      var e = {
       returnSequences: this.returnSequences,
       returnState: this.returnState,
       goBackwards: this.goBackwards,
       stateful: this.stateful,
       unroll: this.unroll
      };
      null != this.numConstants && (e.numConstants = this.numConstants);
      var n = this.cell.getConfig();
      e.cell = {
       className: this.cell.getClassName(),
       config: n
      };
      var r = t.prototype.getConfig.call(this);
      return Object.assign(e, r), e
     }, e.fromConfig = function(t, e, n) {
      void 0 === n && (n = {});
      var r = fn(e.cell, n);
      return new t(Object.assign(e, {
       cell: r
      }))
     }, e.className = "RNN", e
    }(Ke);
    i["serialization"].registerClass(Zo);
    var Jo = function(t) {
      function e() {
       return null !== t && t.apply(this, arguments) || this
      }
      return a(e, t), e
     }(Ke),
     Qo = function(t) {
      function e(e) {
       var n = t.call(this, e) || this;
       return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = e.units, M(n.units, "units"), n.activation = yi(null == e.activation ? n.DEFAULT_ACTIVATION : e.activation), n.useBias = null == e.useBias || e.useBias, n.kernelInitializer = fe(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = fe(e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = fe(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = Oi(e.kernelRegularizer), n.recurrentRegularizer = Oi(e.recurrentRegularizer), n.biasRegularizer = Oi(e.biasRegularizer), n.kernelConstraint = K(e.kernelConstraint), n.recurrentConstraint = K(e.recurrentConstraint), n.biasConstraint = K(e.biasConstraint), n.dropout = yt([1, bt([0, null == e.dropout ? 0 : e.dropout])]), n.recurrentDropout = yt([1, bt([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n
      }
      return a(e, t), e.prototype.build = function(t) {
       t = Le(t), this.kernel = this.addWeight("kernel", [t[t.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        if (2 !== (t = t).length) throw new v("SimpleRNNCell expects 2 input Tensors, got " + t.length + ".");
        var r = t[1];
        t = t[0];
        var o, a = null != e.training && e.training;
        0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = aa((function() {
         return Object(i["onesLike"])(t)
        }), n.dropout, a)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = aa((function() {
         return Object(i["onesLike"])(r)
        }), n.recurrentDropout, a));
        var s = n.dropoutMask,
         u = n.recurrentDropoutMask;
        o = Dt(null != s ? Object(i["mul"])(t, s) : t, n.kernel.read()), null != n.bias && (o = Bt(o, n.bias.read())), null != u && (r = Object(i["mul"])(r, u));
        var c = Object(i["add"])(o, Dt(r, n.recurrentKernel.read()));
        return null != n.activation && (c = n.activation.apply(c)), [c, c]
       }))
      }, e.prototype.getConfig = function() {
       var e = {
         units: this.units,
         activation: mi(this.activation),
         useBias: this.useBias,
         kernelInitializer: pe(this.kernelInitializer),
         recurrentInitializer: pe(this.recurrentInitializer),
         biasInitializer: pe(this.biasInitializer),
         kernelRegularizer: ki(this.kernelRegularizer),
         recurrentRegularizer: ki(this.recurrentRegularizer),
         biasRegularizer: ki(this.biasRegularizer),
         activityRegularizer: ki(this.activityRegularizer),
         kernelConstraint: G(this.kernelConstraint),
         recurrentConstraint: G(this.recurrentConstraint),
         biasConstraint: G(this.biasConstraint),
         dropout: this.dropout,
         recurrentDropout: this.recurrentDropout
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e.className = "SimpleRNNCell", e
     }(Jo);
    i["serialization"].registerClass(Qo);
    var ta = function(t) {
     function e(e) {
      return e.cell = new Qo(e), t.call(this, e) || this
     }
     return a(e, t), e.prototype.call = function(e, n) {
      var r = this;
      return Object(i["tidy"])((function() {
       null != r.cell.dropoutMask && (Object(i["dispose"])(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Object(i["dispose"])(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
       var o = null == n ? null : n.mask,
        a = null == n ? null : n.training,
        s = null == n ? null : n.initialState;
       return t.prototype.call.call(r, e, {
        mask: o,
        training: a,
        initialState: s
       })
      }))
     }, Object.defineProperty(e.prototype, "units", {
      get: function() {
       return this.cell.units
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "activation", {
      get: function() {
       return this.cell.activation
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "useBias", {
      get: function() {
       return this.cell.useBias
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelInitializer", {
      get: function() {
       return this.cell.kernelInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentInitializer", {
      get: function() {
       return this.cell.recurrentInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasInitializer", {
      get: function() {
       return this.cell.biasInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelRegularizer", {
      get: function() {
       return this.cell.kernelRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentRegularizer", {
      get: function() {
       return this.cell.recurrentRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasRegularizer", {
      get: function() {
       return this.cell.biasRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelConstraint", {
      get: function() {
       return this.cell.kernelConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentConstraint", {
      get: function() {
       return this.cell.recurrentConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasConstraint", {
      get: function() {
       return this.cell.biasConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "dropout", {
      get: function() {
       return this.cell.dropout
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentDropout", {
      get: function() {
       return this.cell.recurrentDropout
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.getConfig = function() {
      var e = {
        units: this.units,
        activation: mi(this.activation),
        useBias: this.useBias,
        kernelInitializer: pe(this.kernelInitializer),
        recurrentInitializer: pe(this.recurrentInitializer),
        biasInitializer: pe(this.biasInitializer),
        kernelRegularizer: ki(this.kernelRegularizer),
        recurrentRegularizer: ki(this.recurrentRegularizer),
        biasRegularizer: ki(this.biasRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        kernelConstraint: G(this.kernelConstraint),
        recurrentConstraint: G(this.recurrentConstraint),
        biasConstraint: G(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout
       },
       n = t.prototype.getConfig.call(this);
      return delete n.cell, Object.assign(e, n), e
     }, e.fromConfig = function(t, e) {
      return new t(e)
     }, e.className = "SimpleRNN", e
    }(Zo);
    i["serialization"].registerClass(ta);
    var ea = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = e.units, M(n.units, "units"), n.activation = yi(void 0 === e.activation ? n.DEFAULT_ACTIVATION : e.activation), n.recurrentActivation = yi(void 0 === e.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), n.useBias = null == e.useBias || e.useBias, n.kernelInitializer = fe(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = fe(e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = fe(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = Oi(e.kernelRegularizer), n.recurrentRegularizer = Oi(e.recurrentRegularizer), n.biasRegularizer = Oi(e.biasRegularizer), n.kernelConstraint = K(e.kernelConstraint), n.recurrentConstraint = K(e.recurrentConstraint), n.biasConstraint = K(e.biasConstraint), n.dropout = yt([1, bt([0, null == e.dropout ? 0 : e.dropout])]), n.recurrentDropout = yt([1, bt([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), n.implementation = e.implementation, n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e = (t = Le(t))[t.length - 1];
      this.kernel = this.addWeight("kernel", [e, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       if (2 !== (t = t).length) throw new v("GRUCell expects 2 input Tensors (inputs, h, c), got " + t.length + ".");
       var r = null != e.training && e.training,
        o = t[1];
       t = t[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = aa((function() {
        return Object(i["onesLike"])(t)
       }), n.dropout, r, 3)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = aa((function() {
        return Object(i["onesLike"])(o)
       }), n.recurrentDropout, r, 3));
       var a, s, u, c = n.dropoutMask,
        l = n.recurrentDropoutMask;
       0 < n.dropout && n.dropout < 1 && (t = Object(i["mul"])(t, c[0]));
       var h = Dt(t, n.kernel.read());
       n.useBias && (h = Bt(h, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (o = Object(i["mul"])(o, l[0]));
       var p = n.recurrentKernel.read(),
        f = Object(i["split"])(p, [2 * n.units, n.units], p.rank - 1),
        d = f[0],
        m = f[1],
        g = Dt(o, d),
        y = Object(i["split"])(h, 3, h.rank - 1),
        b = y[0],
        x = y[1],
        w = y[2],
        C = Object(i["split"])(g, 2, g.rank - 1),
        S = C[0],
        E = C[1];
       a = n.recurrentActivation.apply(Object(i["add"])(b, S)), s = n.recurrentActivation.apply(Object(i["add"])(x, E));
       var k = Dt(Object(i["mul"])(s, o), m);
       u = n.activation.apply(Object(i["add"])(w, k));
       var I = Object(i["add"])(Object(i["mul"])(a, o), Object(i["mul"])(Object(i["add"])(1, Object(i["neg"])(a)), u));
       return [I, I]
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        units: this.units,
        activation: mi(this.activation),
        recurrentActivation: mi(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: pe(this.kernelInitializer),
        recurrentInitializer: pe(this.recurrentInitializer),
        biasInitializer: pe(this.biasInitializer),
        kernelRegularizer: ki(this.kernelRegularizer),
        recurrentRegularizer: ki(this.recurrentRegularizer),
        biasRegularizer: ki(this.biasRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        kernelConstraint: G(this.kernelConstraint),
        recurrentConstraint: G(this.recurrentConstraint),
        biasConstraint: G(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "GRUCell", e
    }(Jo);
    i["serialization"].registerClass(ea);
    var na = function(t) {
     function e(e) {
      return 0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new ea(e), t.call(this, e) || this
     }
     return a(e, t), e.prototype.call = function(e, n) {
      var r = this;
      return Object(i["tidy"])((function() {
       null != r.cell.dropoutMask && (Object(i["dispose"])(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Object(i["dispose"])(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
       var o = null == n ? null : n.mask,
        a = null == n ? null : n.training,
        s = null == n ? null : n.initialState;
       return t.prototype.call.call(r, e, {
        mask: o,
        training: a,
        initialState: s
       })
      }))
     }, Object.defineProperty(e.prototype, "units", {
      get: function() {
       return this.cell.units
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "activation", {
      get: function() {
       return this.cell.activation
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentActivation", {
      get: function() {
       return this.cell.recurrentActivation
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "useBias", {
      get: function() {
       return this.cell.useBias
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelInitializer", {
      get: function() {
       return this.cell.kernelInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentInitializer", {
      get: function() {
       return this.cell.recurrentInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasInitializer", {
      get: function() {
       return this.cell.biasInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelRegularizer", {
      get: function() {
       return this.cell.kernelRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentRegularizer", {
      get: function() {
       return this.cell.recurrentRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasRegularizer", {
      get: function() {
       return this.cell.biasRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelConstraint", {
      get: function() {
       return this.cell.kernelConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentConstraint", {
      get: function() {
       return this.cell.recurrentConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasConstraint", {
      get: function() {
       return this.cell.biasConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "dropout", {
      get: function() {
       return this.cell.dropout
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentDropout", {
      get: function() {
       return this.cell.recurrentDropout
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "implementation", {
      get: function() {
       return this.cell.implementation
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.getConfig = function() {
      var e = {
        units: this.units,
        activation: mi(this.activation),
        recurrentActivation: mi(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: pe(this.kernelInitializer),
        recurrentInitializer: pe(this.recurrentInitializer),
        biasInitializer: pe(this.biasInitializer),
        kernelRegularizer: ki(this.kernelRegularizer),
        recurrentRegularizer: ki(this.recurrentRegularizer),
        biasRegularizer: ki(this.biasRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        kernelConstraint: G(this.kernelConstraint),
        recurrentConstraint: G(this.recurrentConstraint),
        biasConstraint: G(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
       },
       n = t.prototype.getConfig.call(this);
      return delete n.cell, Object.assign(e, n), e
     }, e.fromConfig = function(t, e) {
      return 0 === e.implmentation && (e.implementation = 1), new t(e)
     }, e.className = "GRU", e
    }(Zo);
    i["serialization"].registerClass(na);
    var ra = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = e.units, M(n.units, "units"), n.activation = yi(void 0 === e.activation ? n.DEFAULT_ACTIVATION : e.activation), n.recurrentActivation = yi(void 0 === e.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), n.useBias = null == e.useBias || e.useBias, n.kernelInitializer = fe(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = fe(e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = fe(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.unitForgetBias = e.unitForgetBias, n.kernelRegularizer = Oi(e.kernelRegularizer), n.recurrentRegularizer = Oi(e.recurrentRegularizer), n.biasRegularizer = Oi(e.biasRegularizer), n.kernelConstraint = K(e.kernelConstraint), n.recurrentConstraint = K(e.recurrentConstraint), n.biasConstraint = K(e.biasConstraint), n.dropout = yt([1, bt([0, null == e.dropout ? 0 : e.dropout])]), n.recurrentDropout = yt([1, bt([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), n.implementation = e.implementation, n.stateSize = [n.units, n.units], n.dropoutMask = null, n.recurrentDropoutMask = null, n
     }
     return a(e, t), e.prototype.build = function(t) {
      var e, n, r = (t = Le(t))[t.length - 1];
      if (this.kernel = this.addWeight("kernel", [r, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
       if (this.unitForgetBias) {
        var i = this.biasInitializer,
         o = this.units;
        n = new((e = function(t) {
         function e() {
          return null !== t && t.apply(this, arguments) || this
         }
         return a(e, t), e.prototype.apply = function(t, e) {
          var n = i.apply([o]),
           r = (new Xt).apply([o]),
           a = i.apply([2 * o]);
          return Rt(Rt(n, r), a)
         }, e
        }(qt)).className = "CustomInit", e)
       } else n = this.biasInitializer;
       this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint)
      } else this.bias = null;
      this.built = !0
     }, e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       var r = null != e.training && e.training;
       if (3 !== (t = t).length) throw new v("LSTMCell expects 3 input Tensors (inputs, h, c), got " + t.length + ".");
       var o = t[1],
        a = t[2];
       t = t[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = aa((function() {
        return Object(i["onesLike"])(t)
       }), n.dropout, r, 4)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = aa((function() {
        return Object(i["onesLike"])(o)
       }), n.recurrentDropout, r, 4));
       var s, u, c, l, h = n.dropoutMask,
        p = n.recurrentDropoutMask;
       0 < n.dropout && n.dropout < 1 && (t = Object(i["mul"])(t, h[0]));
       var f = Dt(t, n.kernel.read());
       0 < n.recurrentDropout && n.recurrentDropout < 1 && (o = Object(i["mul"])(o, p[0])), f = Object(i["add"])(f, Dt(o, n.recurrentKernel.read())), n.useBias && (f = Bt(f, n.bias.read()));
       var d = Object(i["split"])(f, 4, f.rank - 1),
        m = d[0],
        g = d[1],
        y = d[2],
        b = d[3];
       s = n.recurrentActivation.apply(m), u = n.recurrentActivation.apply(g), c = Object(i["add"])(Object(i["mul"])(u, a), Object(i["mul"])(s, n.activation.apply(y))), l = n.recurrentActivation.apply(b);
       var x = Object(i["mul"])(l, n.activation.apply(c));
       return [x, x, c]
      }))
     }, e.prototype.getConfig = function() {
      var e = {
        units: this.units,
        activation: mi(this.activation),
        recurrentActivation: mi(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: pe(this.kernelInitializer),
        recurrentInitializer: pe(this.recurrentInitializer),
        biasInitializer: pe(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: ki(this.kernelRegularizer),
        recurrentRegularizer: ki(this.recurrentRegularizer),
        biasRegularizer: ki(this.biasRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        kernelConstraint: G(this.kernelConstraint),
        recurrentConstraint: G(this.recurrentConstraint),
        biasConstraint: G(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
       },
       n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
     }, e.className = "LSTMCell", e
    }(Jo);
    i["serialization"].registerClass(ra);
    var ia = function(t) {
     function e(e) {
      return 0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new ra(e), t.call(this, e) || this
     }
     return a(e, t), e.prototype.call = function(e, n) {
      var r = this;
      return Object(i["tidy"])((function() {
       null != r.cell.dropoutMask && (Object(i["dispose"])(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Object(i["dispose"])(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
       var o = null == n ? null : n.mask,
        a = null == n ? null : n.training,
        s = null == n ? null : n.initialState;
       return t.prototype.call.call(r, e, {
        mask: o,
        training: a,
        initialState: s
       })
      }))
     }, Object.defineProperty(e.prototype, "units", {
      get: function() {
       return this.cell.units
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "activation", {
      get: function() {
       return this.cell.activation
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentActivation", {
      get: function() {
       return this.cell.recurrentActivation
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "useBias", {
      get: function() {
       return this.cell.useBias
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelInitializer", {
      get: function() {
       return this.cell.kernelInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentInitializer", {
      get: function() {
       return this.cell.recurrentInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasInitializer", {
      get: function() {
       return this.cell.biasInitializer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "unitForgetBias", {
      get: function() {
       return this.cell.unitForgetBias
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelRegularizer", {
      get: function() {
       return this.cell.kernelRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentRegularizer", {
      get: function() {
       return this.cell.recurrentRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasRegularizer", {
      get: function() {
       return this.cell.biasRegularizer
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "kernelConstraint", {
      get: function() {
       return this.cell.kernelConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentConstraint", {
      get: function() {
       return this.cell.recurrentConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "biasConstraint", {
      get: function() {
       return this.cell.biasConstraint
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "dropout", {
      get: function() {
       return this.cell.dropout
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "recurrentDropout", {
      get: function() {
       return this.cell.recurrentDropout
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "implementation", {
      get: function() {
       return this.cell.implementation
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.getConfig = function() {
      var e = {
        units: this.units,
        activation: mi(this.activation),
        recurrentActivation: mi(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: pe(this.kernelInitializer),
        recurrentInitializer: pe(this.recurrentInitializer),
        biasInitializer: pe(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: ki(this.kernelRegularizer),
        recurrentRegularizer: ki(this.recurrentRegularizer),
        biasRegularizer: ki(this.biasRegularizer),
        activityRegularizer: ki(this.activityRegularizer),
        kernelConstraint: G(this.kernelConstraint),
        recurrentConstraint: G(this.recurrentConstraint),
        biasConstraint: G(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
       },
       n = t.prototype.getConfig.call(this);
      return delete n.cell, Object.assign(e, n), e
     }, e.fromConfig = function(t, e) {
      return 0 === e.implmentation && (e.implementation = 1), new t(e)
     }, e.className = "LSTM", e
    }(Zo);
    i["serialization"].registerClass(ia);
    var oa = function(t) {
     function e(e) {
      var n = t.call(this, e) || this;
      return n.cells = e.cells, n
     }
     return a(e, t), Object.defineProperty(e.prototype, "stateSize", {
      get: function() {
       for (var t = [], e = 0, n = this.cells.slice().reverse(); e < n.length; e++) {
        var r = n[e];
        Array.isArray(r.stateSize) ? t.push.apply(t, r.stateSize) : t.push(r.stateSize)
       }
       return t
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.call = function(t, e) {
      var n = this;
      return Object(i["tidy"])((function() {
       for (var r = (t = t).slice(1), i = [], o = 0, a = n.cells.slice().reverse(); o < a.length; o++) {
        var s = a[o];
        Array.isArray(s.stateSize) ? i.push(r.splice(0, s.stateSize.length)) : i.push(r.splice(0, 1))
       }
       i.reverse();
       for (var u, c = [], l = 0; l < n.cells.length; ++l) s = n.cells[l], r = i[l], u = 0 === l ? [t[0]].concat(r) : [u[0]].concat(r), u = s.call(u, e), c.push(u.slice(1));
       r = [];
       for (var h = 0, p = c.slice().reverse(); h < p.length; h++) {
        var f = p[h];
        r.push.apply(r, f)
       }
       return [u[0]].concat(r)
      }))
     }, e.prototype.build = function(t) {
      var e;
      De(t) && (t = t[0]), t = t, this.cells.forEach((function(n, r) {
       ct("RNNCell_" + r, (function() {
        n.build(t), e = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, t = [t[0], e]
       }))
      })), this.built = !0
     }, e.prototype.getConfig = function() {
      for (var e = [], n = 0, r = this.cells; n < r.length; n++) {
       var i = r[n];
       e.push({
        className: i.getClassName(),
        config: i.getConfig()
       })
      }
      var o = {
        cells: e
       },
       a = t.prototype.getConfig.call(this);
      return Object.assign(o, a), o
     }, e.fromConfig = function(t, e, n) {
      void 0 === n && (n = {});
      for (var r = [], i = 0, o = e.cells; i < o.length; i++) {
       var a = o[i];
       r.push(fn(a, n))
      }
      return new t({
       cells: r
      })
     }, Object.defineProperty(e.prototype, "trainableWeights", {
      get: function() {
       if (!this.trainable) return [];
       for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
        var r = n[e];
        t.push.apply(t, r.trainableWeights)
       }
       return t
      },
      enumerable: !0,
      configurable: !0
     }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
      get: function() {
       for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
        var r = n[e];
        t.push.apply(t, r.nonTrainableWeights)
       }
       if (!this.trainable) {
        for (var i = [], o = 0, a = this.cells; o < a.length; o++) r = a[o], i.push.apply(i, r.trainableWeights);
        return i.concat(t)
       }
       return t
      },
      enumerable: !0,
      configurable: !0
     }), e.prototype.getWeights = function() {
      for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
       var r = n[e];
       t.push.apply(t, r.weights)
      }
      return We(t)
     }, e.prototype.setWeights = function(t) {
      for (var e = [], n = 0, r = this.cells; n < r.length; n++)
       for (var i = r[n], o = i.weights.length, a = t.splice(o), s = 0; s < i.weights.length; ++s) e.push([i.weights[s], a[s]]);
      Ve(e)
     }, e.className = "StackedRNNCells", e
    }(Jo);
 
    function aa(t, e, n, r) {
     function o() {
      return jt(t(), e)
     }
     if (void 0 === n && (n = null), void 0 === r && (r = 1), r > 1) {
      for (var a = [], s = 0; s < r; s++) a.push(Vt(o, t, n));
      return a.map((function(t) {
       return Object(i["keep"])(t.clone())
      }))
     }
     return Object(i["keep"])(Vt(o, t, n).clone())
    }
    i["serialization"].registerClass(oa);
    var sa = function(t) {
      function e(e) {
       var n = t.call(this, e) || this;
       return n.layer = e.layer, n
      }
      return a(e, t), e.prototype.build = function(t) {
       this.built = !0
      }, Object.defineProperty(e.prototype, "trainable", {
       get: function() {
        return null != this.layer && this.layer.trainable
       },
       set: function(t) {
        null != this.layer && (this.layer.trainable = t)
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "trainableWeights", {
       get: function() {
        return this.layer.trainableWeights
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
       get: function() {
        return this.layer.nonTrainableWeights
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "updates", {
       get: function() {
        return this.layer._updates
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "losses", {
       get: function() {
        return this.layer.losses
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.getWeights = function() {
       return this.layer.getWeights()
      }, e.prototype.setWeights = function(t) {
       this.layer.setWeights(t)
      }, e.prototype.getConfig = function() {
       var e = {
         layer: {
          className: this.layer.getClassName(),
          config: this.layer.getConfig()
         }
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e.prototype.setFastWeightInitDuringBuild = function(e) {
       t.prototype.setFastWeightInitDuringBuild.call(this, e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e)
      }, e.fromConfig = function(t, e, n) {
       void 0 === n && (n = {});
       var r = fn(e.layer, n);
       delete e.layer;
       var i = {
        layer: r
       };
       return Object.assign(i, e), new t(i)
      }, e
     }(Ke),
     ua = function(t) {
      function e(e) {
       var n = t.call(this, e) || this;
       return n.supportsMasking = !0, n
      }
      return a(e, t), e.prototype.build = function(e) {
       if ((e = Le(e)).length < 3) throw new v("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(e));
       this.inputSpec = [{
        shape: e
       }];
       var n = [e[0]].concat(e.slice(2));
       this.layer.built || (this.layer.build(n), this.layer.built = !0), t.prototype.build.call(this, e)
      }, e.prototype.computeOutputShape = function(t) {
       var e = [(t = Le(t))[0]].concat(t.slice(2)),
        n = this.layer.computeOutputShape(e),
        r = t[1];
       return [n[0], r].concat(n.slice(1))
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        return Yo((function(t, r) {
         return [Me(n.layer.call(t, e)), []]
        }), t = Me(t), [], !1, null, null, !1, !0)[1]
       }))
      }, e.className = "TimeDistributed", e
     }(sa);
 
    function ca(t) {
     D(nt, "BidirectionalMergeMode", t)
    }
    i["serialization"].registerClass(ua);
    var la = "concat",
     ha = function(t) {
      function e(e) {
       var n = t.call(this, e) || this,
        r = e.layer.getConfig(),
        i = {};
       i.className = e.layer.getClassName(), i.config = r, n.forwardLayer = fn(i), r.goBackwards = !0 !== r.goBackwards;
       var o = {};
       if (o.className = e.layer.getClassName(), o.config = r, n.backwardLayer = fn(o), n.forwardLayer.name = "forward_" + n.forwardLayer.name, n.backwardLayer.name = "backward_" + n.backwardLayer.name, n.mergeMode = void 0 === e.mergeMode ? la : e.mergeMode, ca(n.mergeMode), e.weights) throw new m("weights support is not implemented for Bidirectional layer yet.");
       return n._stateful = e.layer.stateful, n.returnSequences = e.layer.returnSequences, n.returnState = e.layer.returnState, n.supportsMasking = !0, n._trainable = !0, n.inputSpec = e.layer.inputSpec, n.numConstants = null, n
      }
      return a(e, t), Object.defineProperty(e.prototype, "trainable", {
       get: function() {
        return this._trainable
       },
       set: function(t) {
        this._trainable = t, null != this.forwardLayer && (this.forwardLayer.trainable = t), null != this.backwardLayer && (this.backwardLayer.trainable = t)
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.getWeights = function() {
       return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
      }, e.prototype.setWeights = function(t) {
       var e = t.length,
        n = Math.floor(e / 2);
       this.forwardLayer.setWeights(t.slice(0, n)), this.backwardLayer.setWeights(t.slice(n))
      }, e.prototype.computeOutputShape = function(t) {
       var e, n, r, i = this.forwardLayer.computeOutputShape(t);
       return Array.isArray(i) && Array.isArray(i[0]) || (i = [i]), i = i, this.returnState ? (r = i.slice(1), e = i[0]) : e = i[0], e = e, "concat" === this.mergeMode ? (e[e.length - 1] *= 2, n = [e]) : n = null == this.mergeMode ? [e, e.slice()] : [e], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [e].concat(r).concat(r.slice()) : w(n)
      }, e.prototype.apply = function(e, n) {
       var r = null == n ? null : n.initialState,
        i = null == n ? null : n.constants;
       null == n && (n = {});
       var o = Xo(e, r, i, this.numConstants);
       if (e = o.inputs, r = o.initialState, i = o.constants, Array.isArray(e) && (r = e.slice(1), e = e[0]), (null == r || 0 === r.length) && null == i) return t.prototype.apply.call(this, e, n);
       var a = [],
        s = [];
       if (null != r) {
        var u = r.length;
        if (u % 2 > 0) throw new v("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        n.initialState = r, a.push.apply(a, r);
        var c = r.map((function(t) {
         return new Ue({
          shape: t.shape
         })
        }));
        this.forwardLayer.stateSpec = c.slice(0, u / 2), this.backwardLayer.stateSpec = c.slice(u / 2), s.push.apply(s, c)
       }
       if (null != i) throw new m("Support for constants in Bidirectional layers is not implemented yet.");
       for (var l = a[0] instanceof He, h = 0, p = a; h < p.length; h++)
        if (p[h] instanceof He !== l) throw new v("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
       if (l) {
        var f = [e].concat(a),
         d = this.inputSpec.concat(s),
         g = this.inputSpec;
        this.inputSpec = d;
        var y = t.prototype.apply.call(this, f, n);
        return this.inputSpec = g, y
       }
       return t.prototype.apply.call(this, e, n)
      }, e.prototype.call = function(t, e) {
       var n = this;
       return Object(i["tidy"])((function() {
        var r, o, a, s, u = e.initialState;
        if (null == u) r = n.forwardLayer.call(t, e), o = n.backwardLayer.call(t, e);
        else {
         var c = u.slice(0, u.length / 2),
          l = u.slice(u.length / 2);
         r = n.forwardLayer.call(t, Object.assign(e, {
          initialState: c
         })), o = n.backwardLayer.call(t, Object.assign(e, {
          initialState: l
         }))
        }
        return n.returnState && (Array.isArray(r) && (a = r.slice(1).concat(o.slice(1))), r = r[0], o = o[0]), n.returnSequences && (o = Object(i["reverse"])(o, 1)), "concat" === n.mergeMode ? s = Nt([r, o]) : "sum" === n.mergeMode ? s = Object(i["add"])(r, o) : "ave" === n.mergeMode ? s = Object(i["mul"])(.5, Object(i["add"])(r, o)) : "mul" === n.mergeMode ? s = Object(i["mul"])(r, o) : null == n.mergeMode && (s = [r, o]), n.returnState ? null == n.mergeMode ? s.concat(a) : [s].concat(a) : s
       }))
      }, e.prototype.resetStates = function(t) {
       this.forwardLayer.resetStates(), this.backwardLayer.resetStates()
      }, e.prototype.build = function(t) {
       var e = this;
       ct(this.forwardLayer.name, (function() {
        e.forwardLayer.build(t)
       })), ct(this.backwardLayer.name, (function() {
        e.backwardLayer.build(t)
       })), this.built = !0
      }, e.prototype.computeMask = function(t, e) {
       var n;
       if (Array.isArray(e) && (e = e[0]), n = this.returnSequences ? null == this.mergeMode ? [e, e] : e : null == this.mergeMode ? [null, null] : null, this.returnState) {
        var r = this.forwardLayer.states.map((function(t) {
         return null
        }));
        return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r)
       }
       return n
      }, Object.defineProperty(e.prototype, "trainableWeights", {
       get: function() {
        return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
       get: function() {
        return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
       },
       enumerable: !0,
       configurable: !0
      }), e.prototype.setFastWeightInitDuringBuild = function(e) {
       t.prototype.setFastWeightInitDuringBuild.call(this, e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e)
      }, e.prototype.getConfig = function() {
       var e = {
         mergeMode: this.mergeMode
        },
        n = t.prototype.getConfig.call(this);
       return Object.assign(e, n), e
      }, e.fromConfig = function(t, e) {
       var n = fn(e.layer);
       if (delete e.layer, null != e.numConstants) throw new m("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
       var r = e;
       return r.layer = n, new t(r)
      }, e.className = "Bidirectional", e
     }(sa);
 
    function pa(t) {
     return new Qe(t)
    }
 
    function fa(t) {
     return new Ti(t)
    }
 
    function da(t) {
     return new Ai(t)
    }
 
    function va(t) {
     return new Ni(t)
    }
 
    function ma(t) {
     return new Ri(t)
    }
 
    function ga(t) {
     return new Di(t)
    }
 
    function ya(t) {
     return new _i(t)
    }
 
    function ba(t) {
     return new Xi(t)
    }
 
    function xa(t) {
     return new Hi(t)
    }
 
    function wa(t) {
     return new Gi(t)
    }
 
    function Ca(t) {
     return new $i(t)
    }
 
    function Sa(t) {
     return new Ki(t)
    }
 
    function Ea(t) {
     return new Yi(t)
    }
 
    function ka(t) {
     return new Zi(t)
    }
 
    function Ia(t) {
     return new Qi(t)
    }
 
    function Oa(t) {
     return new io(t)
    }
 
    function Aa(t) {
     return new no(t)
    }
 
    function Na(t) {
     return new to(t)
    }
 
    function Ra(t) {
     return new eo(t)
    }
 
    function Ta(t) {
     return new ro(t)
    }
 
    function _a(t) {
     return new oo(t)
    }
 
    function Da(t) {
     return new ao(t)
    }
 
    function Fa(t) {
     return new so(t)
    }
 
    function Ma(t) {
     return new co(t)
    }
 
    function La(t) {
     return new ho(t)
    }
 
    function Ba(t) {
     return new fo(t)
    }
 
    function Pa(t) {
     return new go(t)
    }
 
    function za(t) {
     return new vo(t)
    }
 
    function ja(t) {
     return new mo(t)
    }
 
    function Wa(t) {
     return new po(t)
    }
 
    function Va(t) {
     return new xo(t)
    }
 
    function Ua(t) {
     return new Ao(t)
    }
 
    function Ha(t) {
     return new No(t)
    }
 
    function $a(t) {
     return new To(t)
    }
 
    function Ga(t) {
     return new Lo(t)
    }
 
    function qa(t) {
     return Ga(t)
    }
 
    function Ka(t) {
     return Ga(t)
    }
 
    function Xa(t) {
     return new zo(t)
    }
 
    function Ya(t) {
     return Xa(t)
    }
 
    function Za(t) {
     return Xa(t)
    }
 
    function Ja(t) {
     return new Vo(t)
    }
 
    function Qa(t) {
     return Ja(t)
    }
 
    function ts(t) {
     return Ja(t)
    }
 
    function es(t) {
     return new Ho(t)
    }
 
    function ns(t) {
     return new qo(t)
    }
 
    function rs(t) {
     return new $o(t)
    }
 
    function is(t) {
     return new Ko(t)
    }
 
    function os(t) {
     return new Mo(t)
    }
 
    function as(t) {
     return new Po(t)
    }
 
    function ss(t) {
     return new Wo(t)
    }
 
    function us(t) {
     return new na(t)
    }
 
    function cs(t) {
     return new ea(t)
    }
 
    function ls(t) {
     return new ia(t)
    }
 
    function hs(t) {
     return new ra(t)
    }
 
    function ps(t) {
     return new ta(t)
    }
 
    function fs(t) {
     return new Qo(t)
    }
 
    function ds(t) {
     return new Zo(t)
    }
 
    function vs(t) {
     return new oa(t)
    }
 
    function ms(t) {
     return new ha(t)
    }
 
    function gs(t) {
     return new ua(t)
    }
    i["serialization"].registerClass(ha);
    var ys = rs,
     bs = is,
     xs = os,
     ws = as;
 
    function Cs(t) {
     return new wo(t)
    }
 
    function Ss(t) {
     return new Co(t)
    }
 
    function Es(t) {
     return new So(t)
    }
 
    function ks(t) {
     return new uo(t)
    }
    Object.freeze({
     inputLayer: pa,
     elu: fa,
     reLU: da,
     leakyReLU: va,
     prelu: ma,
     softmax: ga,
     thresholdedReLU: ya,
     conv1d: ba,
     conv2d: xa,
     conv2dTranspose: wa,
     conv3d: Ca,
     separableConv2d: Sa,
     cropping2D: Ea,
     upSampling2d: ka,
     depthwiseConv2d: Ia,
     activation: Oa,
     dense: Aa,
     dropout: Na,
     spatialDropout1d: Ra,
     flatten: Ta,
     repeatVector: _a,
     reshape: Da,
     permute: Fa,
     embedding: Ma,
     add: La,
     average: Ba,
     concatenate: Pa,
     maximum: za,
     minimum: ja,
     multiply: Wa,
     dot: Va,
     batchNormalization: Ua,
     layerNormalization: Ha,
     zeroPadding2d: $a,
     averagePooling1d: Ga,
     avgPool1d: qa,
     avgPooling1d: Ka,
     averagePooling2d: Xa,
     avgPool2d: Ya,
     avgPooling2d: Za,
     averagePooling3d: Ja,
     avgPool3d: Qa,
     avgPooling3d: ts,
     globalAveragePooling1d: es,
     globalAveragePooling2d: ns,
     globalMaxPooling1d: rs,
     globalMaxPooling2d: is,
     maxPooling1d: os,
     maxPooling2d: as,
     maxPooling3d: ss,
     gru: us,
     gruCell: cs,
     lstm: ls,
     lstmCell: hs,
     simpleRNN: ps,
     simpleRNNCell: fs,
     rnn: ds,
     stackedRNNCells: vs,
     bidirectional: ms,
     timeDistributed: gs,
     globalMaxPool1d: ys,
     globalMaxPool2d: bs,
     maxPool1d: xs,
     maxPool2d: ws,
     Layer: Ke,
     RNN: Zo,
     RNNCell: Jo,
     input: ni,
     gaussianNoise: Cs,
     gaussianDropout: Ss,
     alphaDropout: Es,
     masking: ks
    });
 
    function Is(t, e) {
     return _n(t, e)
    }
 
    function Os(t, e) {
     return zn(t, e)
    }
 
    function As(t, e) {
     return jn(t, e)
    }
 
    function Ns(t, e) {
     return Dn(t, e)
    }
 
    function Rs(t, e) {
     return qn(t, e)
    }
 
    function Ts(t, e) {
     return Bn(t, e)
    }
 
    function _s(t, e) {
     return Pn(t, e)
    }
 
    function Ds(t, e) {
     return Nn(t, e)
    }
 
    function Fs(t, e) {
     return mn(t, e)
    }
 
    function Ms(t, e) {
     return gn(t, e)
    }
 
    function Ls(t, e) {
     return gn(t, e)
    }
 
    function Bs(t, e) {
     return gn(t, e)
    }
 
    function Ps(t, e) {
     return vn(t, e)
    }
 
    function zs(t, e) {
     return vn(t, e)
    }
 
    function js(t, e) {
     return vn(t, e)
    }
    Object.freeze({
     binaryAccuracy: Is,
     binaryCrossentropy: Os,
     sparseCategoricalAccuracy: As,
     categoricalAccuracy: Ns,
     categoricalCrossentropy: Rs,
     precision: Ts,
     recall: _s,
     cosineProximity: Ds,
     meanAbsoluteError: Fs,
     meanAbsolutePercentageError: Ms,
     MAPE: Ls,
     mape: Bs,
     meanSquaredError: Ps,
     MSE: zs,
     mse: js
    }), Object.freeze({
     modelFromJSON: ti
    });
 
    function Ws(t) {
     return new wi(t)
    }
 
    function Vs(t) {
     return Ci(t)
    }
 
    function Us(t) {
     return Si(t)
    }
    Object.freeze({
     l1l2: Ws,
     l1: Vs,
     l2: Us
    });
    var Hs = function(t) {
     function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.model = null, e
     }
     return a(e, t), e.prototype.setModel = function(t) {
      if (!(t instanceof Qr)) throw new Error("model must be a LayersModel, not some other Container");
      this.model = t
     }, e
    }(on);
 
    function $s(t, e) {
     return t < e
    }
 
    function Gs(t, e) {
     return t > e
    }(function(t) {
     function e(e) {
      var n = t.call(this) || this;
      if (null == e && (e = {}), e.restoreBestWeights) throw new m("restoreBestWeights = True is not implemented in EarlyStopping yet.");
      return n.monitor = e.monitor || "val_loss", n.minDelta = Math.abs(e.minDelta || 0), n.patience = e.patience || 0, n.verbose = e.verbose || 0, n.mode = e.mode || "auto", n.baseline = e.baseline, -1 === ["auto", "min", "max"].indexOf(n.mode) && (console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."), n.mode = "auto"), "min" === n.mode ? n.monitorFunc = $s : "max" === n.mode ? n.monitorFunc = Gs : -1 !== n.monitor.indexOf("acc") ? n.monitorFunc = Gs : n.monitorFunc = $s, n.monitorFunc === $s && (n.minDelta *= -1), n
     }
     a(e, t), e.prototype.onTrainBegin = function(t) {
      return c(this, void 0, void 0, (function() {
       return l(this, (function(t) {
        return this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === $s ? 1 / 0 : -1 / 0, [2]
       }))
      }))
     }, e.prototype.onEpochEnd = function(t, e) {
      return c(this, void 0, void 0, (function() {
       var n;
       return l(this, (function(r) {
        switch (r.label) {
         case 0:
          return [4, en(e)];
         case 1:
          return r.sent(), null == (n = this.getMonitorValue(e)) ? [2] : (this.monitorFunc(n - this.minDelta, this.best) ? (this.best = n, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = t, this.model.stopTraining = !0)), [2])
        }
       }))
      }))
     }, e.prototype.onTrainEnd = function(t) {
      return c(this, void 0, void 0, (function() {
       return l(this, (function(t) {
        return this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping."), [2]
       }))
      }))
     }, e.prototype.getMonitorValue = function(t) {
      null == t && (t = {});
      var e = t[this.monitor];
      return null == e && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(t)), e
     }
    })(Hs);
    var qs = n("b605"),
     Ks = n("377e"),
     Xs = "1.5.2";
    r["a"], Ks["a"], qs["b"]
   },
   "0bc6": function(t, e, n) {},
   "0cfb": function(t, e, n) {
    var r = n("83ab"),
     i = n("d039"),
     o = n("cc12");
    t.exports = !r && !i((function() {
     return 7 != Object.defineProperty(o("div"), "a", {
      get: function() {
       return 7
      }
     }).a
    }))
   },
   "0d21": function(t, e, n) {
    "use strict";
 
    function r(t) {
     if (Array.isArray(t)) return t
    }
    n.d(e, "a", (function() {
     return r
    }))
   },
   "0df6": function(t, e, n) {
    "use strict";
    t.exports = function(t) {
     return function(e) {
      return t.apply(null, e)
     }
    }
   },
   "0fd9": function(t, e, n) {
    "use strict";
    n("99af"), n("4160"), n("caad"), n("13d5"), n("4ec9"), n("b64b"), n("d3b7"), n("ac1f"), n("2532"), n("3ca3"), n("5319"), n("159b"), n("ddb0");
    var r = n("ade3"),
     i = n("5530"),
     o = (n("4b85"), n("2b0e")),
     a = n("d9f7"),
     s = n("80d2"),
     u = ["sm", "md", "lg", "xl"],
     c = ["start", "end", "center"];
 
    function l(t, e) {
     return u.reduce((function(n, r) {
      return n[t + Object(s["v"])(r)] = e(), n
     }), {})
    }
    var h = function(t) {
      return [].concat(c, ["baseline", "stretch"]).includes(t)
     },
     p = l("align", (function() {
      return {
       type: String,
       default: null,
       validator: h
      }
     })),
     f = function(t) {
      return [].concat(c, ["space-between", "space-around"]).includes(t)
     },
     d = l("justify", (function() {
      return {
       type: String,
       default: null,
       validator: f
      }
     })),
     v = function(t) {
      return [].concat(c, ["space-between", "space-around", "stretch"]).includes(t)
     },
     m = l("alignContent", (function() {
      return {
       type: String,
       default: null,
       validator: v
      }
     })),
     g = {
      align: Object.keys(p),
      justify: Object.keys(d),
      alignContent: Object.keys(m)
     },
     y = {
      align: "align",
      justify: "justify",
      alignContent: "align-content"
     };
 
    function b(t, e, n) {
     var r = y[t];
     if (null != n) {
      if (e) {
       var i = e.replace(t, "");
       r += "-".concat(i)
      }
      return r += "-".concat(n), r.toLowerCase()
     }
    }
    var x = new Map;
    e["a"] = o["a"].extend({
     name: "v-row",
     functional: !0,
     props: Object(i["a"])({
      tag: {
       type: String,
       default: "div"
      },
      dense: Boolean,
      noGutters: Boolean,
      align: {
       type: String,
       default: null,
       validator: h
      }
     }, p, {
      justify: {
       type: String,
       default: null,
       validator: f
      }
     }, d, {
      alignContent: {
       type: String,
       default: null,
       validator: v
      }
     }, m),
     render: function(t, e) {
      var n = e.props,
       i = e.data,
       o = e.children,
       s = "";
      for (var u in n) s += String(n[u]);
      var c = x.get(s);
      return c || function() {
       var t, e;
       for (e in c = [], g) g[e].forEach((function(t) {
        var r = n[t],
         i = b(e, t, r);
        i && c.push(i)
       }));
       c.push((t = {
        "no-gutters": n.noGutters,
        "row--dense": n.dense
       }, Object(r["a"])(t, "align-".concat(n.align), n.align), Object(r["a"])(t, "justify-".concat(n.justify), n.justify), Object(r["a"])(t, "align-content-".concat(n.alignContent), n.alignContent), t)), x.set(s, c)
      }(), t(n.tag, Object(a["a"])(i, {
       staticClass: "row",
       class: c
      }), o)
     }
    })
   },
   "10d2": function(t, e, n) {
    "use strict";
    var r = n("8dd9");
    e["a"] = r["a"]
   },
   1148: function(t, e, n) {
    "use strict";
    var r = n("a691"),
     i = n("1d80");
    t.exports = "".repeat || function(t) {
     var e = String(i(this)),
      n = "",
      o = r(t);
     if (o < 0 || o == 1 / 0) throw RangeError("Wrong number of repetitions");
     for (; o > 0;
      (o >>>= 1) && (e += e)) 1 & o && (n += e);
     return n
    }
   },
   1276: function(t, e, n) {
    "use strict";
    var r = n("d784"),
     i = n("44e7"),
     o = n("825a"),
     a = n("1d80"),
     s = n("4840"),
     u = n("8aa5"),
     c = n("50c4"),
     l = n("14c3"),
     h = n("9263"),
     p = n("d039"),
     f = [].push,
     d = Math.min,
     v = 4294967295,
     m = !p((function() {
      return !RegExp(v, "y")
     }));
    r("split", 2, (function(t, e, n) {
     var r;
     return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t, n) {
      var r = String(a(this)),
       o = void 0 === n ? v : n >>> 0;
      if (0 === o) return [];
      if (void 0 === t) return [r];
      if (!i(t)) return e.call(r, t, o);
      var s, u, c, l = [],
       p = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""),
       d = 0,
       m = new RegExp(t.source, p + "g");
      while (s = h.call(m, r)) {
       if (u = m.lastIndex, u > d && (l.push(r.slice(d, s.index)), s.length > 1 && s.index < r.length && f.apply(l, s.slice(1)), c = s[0].length, d = u, l.length >= o)) break;
       m.lastIndex === s.index && m.lastIndex++
      }
      return d === r.length ? !c && m.test("") || l.push("") : l.push(r.slice(d)), l.length > o ? l.slice(0, o) : l
     } : "0".split(void 0, 0).length ? function(t, n) {
      return void 0 === t && 0 === n ? [] : e.call(this, t, n)
     } : e, [function(e, n) {
      var i = a(this),
       o = void 0 == e ? void 0 : e[t];
      return void 0 !== o ? o.call(e, i, n) : r.call(String(i), e, n)
     }, function(t, i) {
      var a = n(r, t, this, i, r !== e);
      if (a.done) return a.value;
      var h = o(t),
       p = String(this),
       f = s(h, RegExp),
       g = h.unicode,
       y = (h.ignoreCase ? "i" : "") + (h.multiline ? "m" : "") + (h.unicode ? "u" : "") + (m ? "y" : "g"),
       b = new f(m ? h : "^(?:" + h.source + ")", y),
       x = void 0 === i ? v : i >>> 0;
      if (0 === x) return [];
      if (0 === p.length) return null === l(b, p) ? [p] : [];
      var w = 0,
       C = 0,
       S = [];
      while (C < p.length) {
       b.lastIndex = m ? C : 0;
       var E, k = l(b, m ? p : p.slice(C));
       if (null === k || (E = d(c(b.lastIndex + (m ? 0 : C)), p.length)) === w) C = u(p, C, g);
       else {
        if (S.push(p.slice(w, C)), S.length === x) return S;
        for (var I = 1; I <= k.length - 1; I++)
         if (S.push(k[I]), S.length === x) return S;
        C = w = E
       }
      }
      return S.push(p.slice(w)), S
     }]
    }), !m)
   },
   "131a": function(t, e, n) {
    var r = n("23e7"),
     i = n("d2bb");
    r({
     target: "Object",
     stat: !0
    }, {
     setPrototypeOf: i
    })
   },
   "132d": function(t, e, n) {
    "use strict";
    n("7db0"), n("caad"), n("c975"), n("fb6a"), n("45fc"), n("a9e3"), n("2532"), n("498a"), n("c96a");
    var r, i = n("5530"),
     o = (n("4804"), n("7e2b")),
     a = n("a9ad"),
     s = n("af2b"),
     u = n("7560"),
     c = n("80d2"),
     l = n("2b0e"),
     h = n("58df");
 
    function p(t) {
     return ["fas", "far", "fal", "fab", "fad"].some((function(e) {
      return t.includes(e)
     }))
    }
 
    function f(t) {
     return /^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(t) && /[\dz]$/i.test(t) && t.length > 4
    }(function(t) {
     t["xSmall"] = "12px", t["small"] = "16px", t["default"] = "24px", t["medium"] = "28px", t["large"] = "36px", t["xLarge"] = "40px"
    })(r || (r = {}));
    var d = Object(h["a"])(o["a"], a["a"], s["a"], u["a"]).extend({
     name: "v-icon",
     props: {
      dense: Boolean,
      disabled: Boolean,
      left: Boolean,
      right: Boolean,
      size: [Number, String],
      tag: {
       type: String,
       required: !1,
       default: "i"
      }
     },
     computed: {
      medium: function() {
       return !1
      },
      hasClickListener: function() {
       return Boolean(this.listeners$.click || this.listeners$["!click"])
      }
     },
     methods: {
      getIcon: function() {
       var t = "";
       return this.$slots.default && (t = this.$slots.default[0].text.trim()), Object(c["u"])(this, t)
      },
      getSize: function() {
       var t = {
         xSmall: this.xSmall,
         small: this.small,
         medium: this.medium,
         large: this.large,
         xLarge: this.xLarge
        },
        e = Object(c["r"])(t).find((function(e) {
         return t[e]
        }));
       return e && r[e] || Object(c["f"])(this.size)
      },
      getDefaultData: function() {
       var t = {
        staticClass: "v-icon notranslate",
        class: {
         "v-icon--disabled": this.disabled, "v-icon--left": this.left, "v-icon--link": this.hasClickListener, "v-icon--right": this.right, "v-icon--dense": this.dense
        },
        attrs: Object(i["a"])({
         "aria-hidden": !this.hasClickListener,
         disabled: this.hasClickListener && this.disabled,
         type: this.hasClickListener ? "button" : void 0
        }, this.attrs$),
        on: this.listeners$
       };
       return t
      },
      applyColors: function(t) {
       t.class = Object(i["a"])({}, t.class, {}, this.themeClasses), this.setTextColor(this.color, t)
      },
      renderFontIcon: function(t, e) {
       var n = [],
        r = this.getDefaultData(),
        i = "material-icons",
        o = t.indexOf("-"),
        a = o <= -1;
       a ? n.push(t) : (i = t.slice(0, o), p(i) && (i = "")), r.class[i] = !0, r.class[t] = !a;
       var s = this.getSize();
       return s && (r.style = {
        fontSize: s
       }), this.applyColors(r), e(this.hasClickListener ? "button" : this.tag, r, n)
      },
      renderSvgIcon: function(t, e) {
       var n = this.getSize(),
        r = Object(i["a"])({}, this.getDefaultData(), {
         style: n ? {
          fontSize: n,
          height: n,
          width: n
         } : void 0
        });
       r.class["v-icon--svg"] = !0, this.applyColors(r);
       var o = {
        attrs: {
         xmlns: "http://www.w3.org/2000/svg",
         viewBox: "0 0 24 24",
         height: n || "32",
         width: n || "32",
         role: "img",
         "aria-hidden": !0
        }
       };
       return e(this.hasClickListener ? "button" : "span", r, [e("svg", o, [e("path", {
        attrs: {
         d: t
        }
       })])])
      },
      renderSvgIconComponent: function(t, e) {
       var n = this.getDefaultData();
       n.class["v-icon--is-component"] = !0;
       var r = this.getSize();
       r && (n.style = {
        fontSize: r,
        height: r
       }), this.applyColors(n);
       var i = t.component;
       return n.props = t.props, n.nativeOn = n.on, e(i, n)
      }
     },
     render: function(t) {
      var e = this.getIcon();
      return "string" === typeof e ? f(e) ? this.renderSvgIcon(e, t) : this.renderFontIcon(e, t) : this.renderSvgIconComponent(e, t)
     }
    });
    e["a"] = l["a"].extend({
     name: "v-icon",
     $_wrapperFor: d,
     functional: !0,
     render: function(t, e) {
      var n = e.data,
       r = e.children,
       i = "";
      return n.domProps && (i = n.domProps.textContent || n.domProps.innerHTML || i, delete n.domProps.textContent, delete n.domProps.innerHTML), t(d, n, i ? [i] : r)
     }
    })
   },
   "13d5": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("d58f").left,
     o = n("a640"),
     a = n("ae40"),
     s = o("reduce"),
     u = a("reduce", {
      1: 0
     });
    r({
     target: "Array",
     proto: !0,
     forced: !s || !u
    }, {
     reduce: function(t) {
      return i(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   "14c3": function(t, e, n) {
    var r = n("c6b6"),
     i = n("9263");
    t.exports = function(t, e) {
     var n = t.exec;
     if ("function" === typeof n) {
      var o = n.call(t, e);
      if ("object" !== typeof o) throw TypeError("RegExp exec method returned something other than an Object or null");
      return o
     }
     if ("RegExp" !== r(t)) throw TypeError("RegExp#exec called on incompatible receiver");
     return i.call(t, e)
    }
   },
   "159b": function(t, e, n) {
    var r = n("da84"),
     i = n("fdbc"),
     o = n("17c2"),
     a = n("9112");
    for (var s in i) {
     var u = r[s],
      c = u && u.prototype;
     if (c && c.forEach !== o) try {
      a(c, "forEach", o)
     } catch (l) {
      c.forEach = o
     }
    }
   },
   "166a": function(t, e, n) {},
   "169a": function(t, e, n) {
    "use strict";
    n("caad"), n("45fc"), n("a9e3"), n("2532"), n("498a");
    var r = n("5530"),
     i = n("ade3"),
     o = (n("368e"), n("480e")),
     a = n("4ad4"),
     s = n("b848"),
     u = n("75eb"),
     c = (n("3c93"), n("a9ad")),
     l = n("7560"),
     h = n("f2e7"),
     p = n("58df"),
     f = Object(p["a"])(c["a"], l["a"], h["a"]).extend({
      name: "v-overlay",
      props: {
       absolute: Boolean,
       color: {
        type: String,
        default: "#212121"
       },
       dark: {
        type: Boolean,
        default: !0
       },
       opacity: {
        type: [Number, String],
        default: .46
       },
       value: {
        default: !0
       },
       zIndex: {
        type: [Number, String],
        default: 5
       }
      },
      computed: {
       __scrim: function() {
        var t = this.setBackgroundColor(this.color, {
         staticClass: "v-overlay__scrim",
         style: {
          opacity: this.computedOpacity
         }
        });
        return this.$createElement("div", t)
       },
       classes: function() {
        return Object(r["a"])({
         "v-overlay--absolute": this.absolute,
         "v-overlay--active": this.isActive
        }, this.themeClasses)
       },
       computedOpacity: function() {
        return Number(this.isActive ? this.opacity : 0)
       },
       styles: function() {
        return {
         zIndex: this.zIndex
        }
       }
      },
      methods: {
       genContent: function() {
        return this.$createElement("div", {
         staticClass: "v-overlay__content"
        }, this.$slots.default)
       }
      },
      render: function(t) {
       var e = [this.__scrim];
       return this.isActive && e.push(this.genContent()), t("div", {
        staticClass: "v-overlay",
        class: this.classes,
        style: this.styles
       }, e)
      }
     }),
     d = f,
     v = n("80d2"),
     m = n("2b0e"),
     g = m["a"].extend().extend({
      name: "overlayable",
      props: {
       hideOverlay: Boolean,
       overlayColor: String,
       overlayOpacity: [Number, String]
      },
      data: function() {
       return {
        overlay: null
       }
      },
      watch: {
       hideOverlay: function(t) {
        this.isActive && (t ? this.removeOverlay() : this.genOverlay())
       }
      },
      beforeDestroy: function() {
       this.removeOverlay()
      },
      methods: {
       createOverlay: function() {
        var t = new d({
         propsData: {
          absolute: this.absolute,
          value: !1,
          color: this.overlayColor,
          opacity: this.overlayOpacity
         }
        });
        t.$mount();
        var e = this.absolute ? this.$el.parentNode : document.querySelector("[data-app]");
        e && e.insertBefore(t.$el, e.firstChild), this.overlay = t
       },
       genOverlay: function() {
        var t = this;
        if (this.hideScroll(), !this.hideOverlay) return this.overlay || this.createOverlay(), requestAnimationFrame((function() {
         t.overlay && (void 0 !== t.activeZIndex ? t.overlay.zIndex = String(t.activeZIndex - 1) : t.$el && (t.overlay.zIndex = Object(v["o"])(t.$el)), t.overlay.value = !0)
        })), !0
       },
       removeOverlay: function() {
        var t = this,
         e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this.overlay && (Object(v["a"])(this.overlay.$el, "transitionend", (function() {
         t.overlay && t.overlay.$el && t.overlay.$el.parentNode && !t.overlay.value && (t.overlay.$el.parentNode.removeChild(t.overlay.$el), t.overlay.$destroy(), t.overlay = null)
        })), this.overlay.value = !1), e && this.showScroll()
       },
       scrollListener: function(t) {
        if ("keydown" === t.type) {
         if (["INPUT", "TEXTAREA", "SELECT"].includes(t.target.tagName) || t.target.isContentEditable) return;
         var e = [v["q"].up, v["q"].pageup],
          n = [v["q"].down, v["q"].pagedown];
         if (e.includes(t.keyCode)) t.deltaY = -1;
         else {
          if (!n.includes(t.keyCode)) return;
          t.deltaY = 1
         }
        }(t.target === this.overlay || "keydown" !== t.type && t.target === document.body || this.checkPath(t)) && t.preventDefault()
       },
       hasScrollbar: function(t) {
        if (!t || t.nodeType !== Node.ELEMENT_NODE) return !1;
        var e = window.getComputedStyle(t);
        return ["auto", "scroll"].includes(e.overflowY) && t.scrollHeight > t.clientHeight
       },
       shouldScroll: function(t, e) {
        return 0 === t.scrollTop && e < 0 || t.scrollTop + t.clientHeight === t.scrollHeight && e > 0
       },
       isInside: function(t, e) {
        return t === e || null !== t && t !== document.body && this.isInside(t.parentNode, e)
       },
       checkPath: function(t) {
        var e = t.path || this.composedPath(t),
         n = t.deltaY;
        if ("keydown" === t.type && e[0] === document.body) {
         var r = this.$refs.dialog,
          i = window.getSelection().anchorNode;
         return !(r && this.hasScrollbar(r) && this.isInside(i, r)) || this.shouldScroll(r, n)
        }
        for (var o = 0; o < e.length; o++) {
         var a = e[o];
         if (a === document) return !0;
         if (a === document.documentElement) return !0;
         if (a === this.$refs.content) return !0;
         if (this.hasScrollbar(a)) return this.shouldScroll(a, n)
        }
        return !0
       },
       composedPath: function(t) {
        if (t.composedPath) return t.composedPath();
        var e = [],
         n = t.target;
        while (n) {
         if (e.push(n), "HTML" === n.tagName) return e.push(document), e.push(window), e;
         n = n.parentElement
        }
        return e
       },
       hideScroll: function() {
        this.$vuetify.breakpoint.smAndDown ? document.documentElement.classList.add("overflow-y-hidden") : (Object(v["b"])(window, "wheel", this.scrollListener, {
         passive: !1
        }), window.addEventListener("keydown", this.scrollListener))
       },
       showScroll: function() {
        document.documentElement.classList.remove("overflow-y-hidden"), window.removeEventListener("wheel", this.scrollListener), window.removeEventListener("keydown", this.scrollListener)
       }
      }
     }),
     y = n("e4d3"),
     b = n("21be"),
     x = n("a293"),
     w = n("d9bd"),
     C = Object(p["a"])(a["a"], s["a"], u["a"], g, y["a"], b["a"], h["a"]);
    e["a"] = C.extend({
     name: "v-dialog",
     directives: {
      ClickOutside: x["a"]
     },
     props: {
      dark: Boolean,
      disabled: Boolean,
      fullscreen: Boolean,
      light: Boolean,
      maxWidth: {
       type: [String, Number],
       default: "none"
      },
      noClickAnimation: Boolean,
      origin: {
       type: String,
       default: "center center"
      },
      persistent: Boolean,
      retainFocus: {
       type: Boolean,
       default: !0
      },
      scrollable: Boolean,
      transition: {
       type: [String, Boolean],
       default: "dialog-transition"
      },
      width: {
       type: [String, Number],
       default: "auto"
      }
     },
     data: function() {
      return {
       activatedBy: null,
       animate: !1,
       animateTimeout: -1,
       isActive: !!this.value,
       stackMinZIndex: 200
      }
     },
     computed: {
      classes: function() {
       var t;
       return t = {}, Object(i["a"])(t, "v-dialog ".concat(this.contentClass).trim(), !0), Object(i["a"])(t, "v-dialog--active", this.isActive), Object(i["a"])(t, "v-dialog--persistent", this.persistent), Object(i["a"])(t, "v-dialog--fullscreen", this.fullscreen), Object(i["a"])(t, "v-dialog--scrollable", this.scrollable), Object(i["a"])(t, "v-dialog--animated", this.animate), t
      },
      contentClasses: function() {
       return {
        "v-dialog__content": !0,
        "v-dialog__content--active": this.isActive
       }
      },
      hasActivator: function() {
       return Boolean(!!this.$slots.activator || !!this.$scopedSlots.activator)
      }
     },
     watch: {
      isActive: function(t) {
       t ? (this.show(), this.hideScroll()) : (this.removeOverlay(), this.unbind())
      },
      fullscreen: function(t) {
       this.isActive && (t ? (this.hideScroll(), this.removeOverlay(!1)) : (this.showScroll(), this.genOverlay()))
      }
     },
     created: function() {
      this.$attrs.hasOwnProperty("full-width") && Object(w["d"])("full-width", this)
     },
     beforeMount: function() {
      var t = this;
      this.$nextTick((function() {
       t.isBooted = t.isActive, t.isActive && t.show()
      }))
     },
     beforeDestroy: function() {
      "undefined" !== typeof window && this.unbind()
     },
     methods: {
      animateClick: function() {
       var t = this;
       this.animate = !1, this.$nextTick((function() {
        t.animate = !0, window.clearTimeout(t.animateTimeout), t.animateTimeout = window.setTimeout((function() {
         return t.animate = !1
        }), 150)
       }))
      },
      closeConditional: function(t) {
       var e = t.target;
       return !(this._isDestroyed || !this.isActive || this.$refs.content.contains(e) || this.overlay && e && !this.overlay.$el.contains(e)) && this.activeZIndex >= this.getMaxZIndex()
      },
      hideScroll: function() {
       this.fullscreen ? document.documentElement.classList.add("overflow-y-hidden") : g.options.methods.hideScroll.call(this)
      },
      show: function() {
       var t = this;
       !this.fullscreen && !this.hideOverlay && this.genOverlay(), this.$nextTick((function() {
        t.$refs.content.focus(), t.bind()
       }))
      },
      bind: function() {
       window.addEventListener("focusin", this.onFocusin)
      },
      unbind: function() {
       window.removeEventListener("focusin", this.onFocusin)
      },
      onClickOutside: function(t) {
       this.$emit("click:outside", t), this.persistent ? this.noClickAnimation || this.animateClick() : this.isActive = !1
      },
      onKeydown: function(t) {
       if (t.keyCode === v["q"].esc && !this.getOpenDependents().length)
        if (this.persistent) this.noClickAnimation || this.animateClick();
        else {
         this.isActive = !1;
         var e = this.getActivator();
         this.$nextTick((function() {
          return e && e.focus()
         }))
        } this.$emit("keydown", t)
      },
      onFocusin: function(t) {
       if (t && this.retainFocus) {
        var e = t.target;
        if (e && ![document, this.$refs.content].includes(e) && !this.$refs.content.contains(e) && this.activeZIndex >= this.getMaxZIndex() && !this.getOpenDependentElements().some((function(t) {
          return t.contains(e)
         }))) {
         var n = this.$refs.content.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
         n.length && n[0].focus()
        }
       }
      },
      genContent: function() {
       var t = this;
       return this.showLazyContent((function() {
        return [t.$createElement(o["a"], {
         props: {
          root: !0,
          light: t.light,
          dark: t.dark
         }
        }, [t.$createElement("div", {
         class: t.contentClasses,
         attrs: Object(r["a"])({
          role: "document",
          tabindex: t.isActive ? 0 : void 0
         }, t.getScopeIdAttrs()),
         on: {
          keydown: t.onKeydown
         },
         style: {
          zIndex: t.activeZIndex
         },
         ref: "content"
        }, [t.genTransition()])])]
       }))
      },
      genTransition: function() {
       var t = this.genInnerContent();
       return this.transition ? this.$createElement("transition", {
        props: {
         name: this.transition,
         origin: this.origin,
         appear: !0
        }
       }, [t]) : t
      },
      genInnerContent: function() {
       var t = {
        class: this.classes,
        ref: "dialog",
        directives: [{
         name: "click-outside",
         value: this.onClickOutside,
         args: {
          closeConditional: this.closeConditional,
          include: this.getOpenDependentElements
         }
        }, {
         name: "show",
         value: this.isActive
        }],
        style: {}
       };
       return this.fullscreen || (t.style = {
        maxWidth: "none" === this.maxWidth ? void 0 : Object(v["f"])(this.maxWidth),
        width: "auto" === this.width ? void 0 : Object(v["f"])(this.width)
       }), this.$createElement("div", t, this.getContentSlot())
      }
     },
     render: function(t) {
      return t("div", {
       staticClass: "v-dialog__container",
       class: {
        "v-dialog__container--attached": "" === this.attach || !0 === this.attach || "attach" === this.attach
       },
       attrs: {
        role: "dialog"
       }
      }, [this.genActivator(), this.genContent()])
     }
    })
   },
   "16b7": function(t, e, n) {
    "use strict";
    n("a9e3");
    var r = n("2b0e");
    e["a"] = r["a"].extend().extend({
     name: "delayable",
     props: {
      openDelay: {
       type: [Number, String],
       default: 0
      },
      closeDelay: {
       type: [Number, String],
       default: 0
      }
     },
     data: function() {
      return {
       openTimeout: void 0,
       closeTimeout: void 0
      }
     },
     methods: {
      clearDelay: function() {
       clearTimeout(this.openTimeout), clearTimeout(this.closeTimeout)
      },
      runDelay: function(t, e) {
       var n = this;
       this.clearDelay();
       var r = parseInt(this["".concat(t, "Delay")], 10);
       this["".concat(t, "Timeout")] = setTimeout(e || function() {
        n.isActive = {
         open: !0,
         close: !1
        } [t]
       }, r)
      }
     }
    })
   },
   "17c2": function(t, e, n) {
    "use strict";
    var r = n("b727").forEach,
     i = n("a640"),
     o = n("ae40"),
     a = i("forEach"),
     s = o("forEach");
    t.exports = a && s ? [].forEach : function(t) {
     return r(this, t, arguments.length > 1 ? arguments[1] : void 0)
    }
   },
   1800: function(t, e, n) {
    "use strict";
    n("4de4");
    var r = n("2b0e");
    e["a"] = r["a"].extend({
     name: "v-list-item-action",
     functional: !0,
     render: function(t, e) {
      var n = e.data,
       r = e.children,
       i = void 0 === r ? [] : r;
      n.staticClass = n.staticClass ? "v-list-item__action ".concat(n.staticClass) : "v-list-item__action";
      var o = i.filter((function(t) {
       return !1 === t.isComment && " " !== t.text
      }));
      return o.length > 1 && (n.staticClass += " v-list-item__action--stack"), t("div", n, i)
     }
    })
   },
   "18a5": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("857a"),
     o = n("af03");
    r({
     target: "String",
     proto: !0,
     forced: o("anchor")
    }, {
     anchor: function(t) {
      return i(this, "a", "name", t)
     }
    })
   },
   "19aa": function(t, e) {
    t.exports = function(t, e, n) {
     if (!(t instanceof e)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
     return t
    }
   },
   "1b2c": function(t, e, n) {},
   "1be4": function(t, e, n) {
    var r = n("d066");
    t.exports = r("document", "documentElement")
   },
   "1c0b": function(t, e) {
    t.exports = function(t) {
     if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
     return t
    }
   },
   "1c7e": function(t, e, n) {
    var r = n("b622"),
     i = r("iterator"),
     o = !1;
    try {
     var a = 0,
      s = {
       next: function() {
        return {
         done: !!a++
        }
       },
       return: function() {
        o = !0
       }
      };
     s[i] = function() {
      return this
     }, Array.from(s, (function() {
      throw 2
     }))
    } catch (u) {}
    t.exports = function(t, e) {
     if (!e && !o) return !1;
     var n = !1;
     try {
      var r = {};
      r[i] = function() {
       return {
        next: function() {
         return {
          done: n = !0
         }
        }
       }
      }, t(r)
     } catch (u) {}
     return n
    }
   },
   "1c87": function(t, e, n) {
    "use strict";
    n("99af"), n("ac1f"), n("5319"), n("498a"), n("9911");
    var r = n("ade3"),
     i = n("5530"),
     o = n("2b0e"),
     a = n("5607"),
     s = n("80d2");
    e["a"] = o["a"].extend({
     name: "routable",
     directives: {
      Ripple: a["a"]
     },
     props: {
      activeClass: String,
      append: Boolean,
      disabled: Boolean,
      exact: {
       type: Boolean,
       default: void 0
      },
      exactActiveClass: String,
      link: Boolean,
      href: [String, Object],
      to: [String, Object],
      nuxt: Boolean,
      replace: Boolean,
      ripple: {
       type: [Boolean, Object],
       default: null
      },
      tag: String,
      target: String
     },
     data: function() {
      return {
       isActive: !1,
       proxyClass: ""
      }
     },
     computed: {
      classes: function() {
       var t = {};
       return this.to ? t : (this.activeClass && (t[this.activeClass] = this.isActive), this.proxyClass && (t[this.proxyClass] = this.isActive), t)
      },
      computedRipple: function() {
       return null != this.ripple ? this.ripple : !this.disabled && this.isClickable
      },
      isClickable: function() {
       return !this.disabled && Boolean(this.isLink || this.$listeners.click || this.$listeners["!click"] || this.$attrs.tabindex)
      },
      isLink: function() {
       return this.to || this.href || this.link
      },
      styles: function() {
       return {}
      }
     },
     watch: {
      $route: "onRouteChange"
     },
     methods: {
      click: function(t) {
       this.$emit("click", t)
      },
      generateRouteLink: function() {
       var t, e, n = this.exact,
        o = (t = {
         attrs: {
          tabindex: "tabindex" in this.$attrs ? this.$attrs.tabindex : void 0
         },
         class: this.classes,
         style: this.styles,
         props: {},
         directives: [{
          name: "ripple",
          value: this.computedRipple
         }]
        }, Object(r["a"])(t, this.to ? "nativeOn" : "on", Object(i["a"])({}, this.$listeners, {
         click: this.click
        })), Object(r["a"])(t, "ref", "link"), t);
       if ("undefined" === typeof this.exact && (n = "/" === this.to || this.to === Object(this.to) && "/" === this.to.path), this.to) {
        var a = this.activeClass,
         s = this.exactActiveClass || a;
        this.proxyClass && (a = "".concat(a, " ").concat(this.proxyClass).trim(), s = "".concat(s, " ").concat(this.proxyClass).trim()), e = this.nuxt ? "nuxt-link" : "router-link", Object.assign(o.props, {
         to: this.to,
         exact: n,
         activeClass: a,
         exactActiveClass: s,
         append: this.append,
         replace: this.replace
        })
       } else e = (this.href ? "a" : this.tag) || "div", "a" === e && this.href && (o.attrs.href = this.href);
       return this.target && (o.attrs.target = this.target), {
        tag: e,
        data: o
       }
      },
      onRouteChange: function() {
       var t = this;
       if (this.to && this.$refs.link && this.$route) {
        var e = "".concat(this.activeClass, " ").concat(this.proxyClass || "").trim(),
         n = "_vnode.data.class.".concat(e);
        this.$nextTick((function() {
         Object(s["k"])(t.$refs.link, n) && t.toggle()
        }))
       }
      },
      toggle: function() {}
     }
    })
   },
   "1cdc": function(t, e, n) {
    var r = n("342f");
    t.exports = /(iphone|ipod|ipad).*applewebkit/i.test(r)
   },
   "1d2b": function(t, e, n) {
    "use strict";
    t.exports = function(t, e) {
     return function() {
      for (var n = new Array(arguments.length), r = 0; r < n.length; r++) n[r] = arguments[r];
      return t.apply(e, n)
     }
    }
   },
   "1d80": function(t, e) {
    t.exports = function(t) {
     if (void 0 == t) throw TypeError("Can't call method on " + t);
     return t
    }
   },
   "1da1": function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return i
    }));
    n("d3b7"), n("e6cf");
 
    function r(t, e, n, r, i, o, a) {
     try {
      var s = t[o](a),
       u = s.value
     } catch (c) {
      return void n(c)
     }
     s.done ? e(u) : Promise.resolve(u).then(r, i)
    }
 
    function i(t) {
     return function() {
      var e = this,
       n = arguments;
      return new Promise((function(i, o) {
       var a = t.apply(e, n);
 
       function s(t) {
        r(a, i, o, s, u, "next", t)
       }
 
       function u(t) {
        r(a, i, o, s, u, "throw", t)
       }
       s(void 0)
      }))
     }
    }
   },
   "1dde": function(t, e, n) {
    var r = n("d039"),
     i = n("b622"),
     o = n("2d00"),
     a = i("species");
    t.exports = function(t) {
     return o >= 51 || !r((function() {
      var e = [],
       n = e.constructor = {};
      return n[a] = function() {
       return {
        foo: 1
       }
      }, 1 !== e[t](Boolean).foo
     }))
    }
   },
   "1f4f": function(t, e, n) {
    "use strict";
    n("a9e3");
    var r = n("5530"),
     i = (n("8b37"), n("80d2")),
     o = n("7560"),
     a = n("58df");
    e["a"] = Object(a["a"])(o["a"]).extend({
     name: "v-simple-table",
     props: {
      dense: Boolean,
      fixedHeader: Boolean,
      height: [Number, String]
     },
     computed: {
      classes: function() {
       return Object(r["a"])({
        "v-data-table--dense": this.dense,
        "v-data-table--fixed-height": !!this.height && !this.fixedHeader,
        "v-data-table--fixed-header": this.fixedHeader
       }, this.themeClasses)
      }
     },
     methods: {
      genWrapper: function() {
       return this.$slots.wrapper || this.$createElement("div", {
        staticClass: "v-data-table__wrapper",
        style: {
         height: Object(i["f"])(this.height)
        }
       }, [this.$createElement("table", this.$slots.default)])
      }
     },
     render: function(t) {
      return t("div", {
       staticClass: "v-data-table",
       class: this.classes
      }, [this.$slots.top, this.genWrapper(), this.$slots.bottom])
     }
    })
   },
   "1fb5": function(t, e, n) {
    "use strict";
    e.byteLength = l, e.toByteArray = p, e.fromByteArray = v;
    for (var r = [], i = [], o = "undefined" !== typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, u = a.length; s < u; ++s) r[s] = a[s], i[a.charCodeAt(s)] = s;
 
    function c(t) {
     var e = t.length;
     if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
     var n = t.indexOf("="); - 1 === n && (n = e);
     var r = n === e ? 0 : 4 - n % 4;
     return [n, r]
    }
 
    function l(t) {
     var e = c(t),
      n = e[0],
      r = e[1];
     return 3 * (n + r) / 4 - r
    }
 
    function h(t, e, n) {
     return 3 * (e + n) / 4 - n
    }
 
    function p(t) {
     var e, n, r = c(t),
      a = r[0],
      s = r[1],
      u = new o(h(t, a, s)),
      l = 0,
      p = s > 0 ? a - 4 : a;
     for (n = 0; n < p; n += 4) e = i[t.charCodeAt(n)] << 18 | i[t.charCodeAt(n + 1)] << 12 | i[t.charCodeAt(n + 2)] << 6 | i[t.charCodeAt(n + 3)], u[l++] = e >> 16 & 255, u[l++] = e >> 8 & 255, u[l++] = 255 & e;
     return 2 === s && (e = i[t.charCodeAt(n)] << 2 | i[t.charCodeAt(n + 1)] >> 4, u[l++] = 255 & e), 1 === s && (e = i[t.charCodeAt(n)] << 10 | i[t.charCodeAt(n + 1)] << 4 | i[t.charCodeAt(n + 2)] >> 2, u[l++] = e >> 8 & 255, u[l++] = 255 & e), u
    }
 
    function f(t) {
     return r[t >> 18 & 63] + r[t >> 12 & 63] + r[t >> 6 & 63] + r[63 & t]
    }
 
    function d(t, e, n) {
     for (var r, i = [], o = e; o < n; o += 3) r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), i.push(f(r));
     return i.join("")
    }
 
    function v(t) {
     for (var e, n = t.length, i = n % 3, o = [], a = 16383, s = 0, u = n - i; s < u; s += a) o.push(d(t, s, s + a > u ? u : s + a));
     return 1 === i ? (e = t[n - 1], o.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === i && (e = (t[n - 2] << 8) + t[n - 1], o.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")), o.join("")
    }
    i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
   },
   "20f6": function(t, e, n) {},
   "21be": function(t, e, n) {
    "use strict";
    n("99af"), n("caad"), n("2532");
    var r = n("2909"),
     i = n("2b0e"),
     o = n("80d2");
    e["a"] = i["a"].extend().extend({
     name: "stackable",
     data: function() {
      return {
       stackElement: null,
       stackExclude: null,
       stackMinZIndex: 0,
       isActive: !1
      }
     },
     computed: {
      activeZIndex: function() {
       if ("undefined" === typeof window) return 0;
       var t = this.stackElement || this.$refs.content,
        e = this.isActive ? this.getMaxZIndex(this.stackExclude || [t]) + 2 : Object(o["o"])(t);
       return null == e ? e : parseInt(e)
      }
     },
     methods: {
      getMaxZIndex: function() {
       for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = this.$el, n = [this.stackMinZIndex, Object(o["o"])(e)], i = [].concat(Object(r["a"])(document.getElementsByClassName("v-menu__content--active")), Object(r["a"])(document.getElementsByClassName("v-dialog__content--active"))), a = 0; a < i.length; a++) t.includes(i[a]) || n.push(Object(o["o"])(i[a]));
       return Math.max.apply(Math, n)
      }
     }
    })
   },
   2266: function(t, e, n) {
    var r = n("825a"),
     i = n("e95a"),
     o = n("50c4"),
     a = n("0366"),
     s = n("35a1"),
     u = n("9bdd"),
     c = function(t, e) {
      this.stopped = t, this.result = e
     },
     l = t.exports = function(t, e, n, l, h) {
      var p, f, d, v, m, g, y, b = a(e, n, l ? 2 : 1);
      if (h) p = t;
      else {
       if (f = s(t), "function" != typeof f) throw TypeError("Target is not iterable");
       if (i(f)) {
        for (d = 0, v = o(t.length); v > d; d++)
         if (m = l ? b(r(y = t[d])[0], y[1]) : b(t[d]), m && m instanceof c) return m;
        return new c(!1)
       }
       p = f.call(t)
      }
      g = p.next;
      while (!(y = g.call(p)).done)
       if (m = u(p, b, y.value, l), "object" == typeof m && m && m instanceof c) return m;
      return new c(!1)
     };
    l.stop = function(t) {
     return new c(!0, t)
    }
   },
   "22da": function(t, e, n) {
    "use strict";
    var r = n("490a");
    e["a"] = r["a"]
   },
   "23cb": function(t, e, n) {
    var r = n("a691"),
     i = Math.max,
     o = Math.min;
    t.exports = function(t, e) {
     var n = r(t);
     return n < 0 ? i(n + e, 0) : o(n, e)
    }
   },
   "23e7": function(t, e, n) {
    var r = n("da84"),
     i = n("06cf").f,
     o = n("9112"),
     a = n("6eeb"),
     s = n("ce4e"),
     u = n("e893"),
     c = n("94ca");
    t.exports = function(t, e) {
     var n, l, h, p, f, d, v = t.target,
      m = t.global,
      g = t.stat;
     if (l = m ? r : g ? r[v] || s(v, {}) : (r[v] || {}).prototype, l)
      for (h in e) {
       if (f = e[h], t.noTargetGet ? (d = i(l, h), p = d && d.value) : p = l[h], n = c(m ? h : v + (g ? "." : "#") + h, t.forced), !n && void 0 !== p) {
        if (typeof f === typeof p) continue;
        u(f, p)
       }(t.sham || p && p.sham) && o(f, "sham", !0), a(l, h, f, t)
      }
    }
   },
   "241c": function(t, e, n) {
    var r = n("ca84"),
     i = n("7839"),
     o = i.concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function(t) {
     return r(t, o)
    }
   },
   2444: function(t, e, n) {
    "use strict";
    (function(e) {
     var r = n("c532"),
      i = n("c8af"),
      o = {
       "Content-Type": "application/x-www-form-urlencoded"
      };
 
     function a(t, e) {
      !r.isUndefined(t) && r.isUndefined(t["Content-Type"]) && (t["Content-Type"] = e)
     }
 
     function s() {
      var t;
      return "undefined" !== typeof XMLHttpRequest ? t = n("b50d") : "undefined" !== typeof e && "[object process]" === Object.prototype.toString.call(e) && (t = n("b50d")), t
     }
     var u = {
      adapter: s(),
      transformRequest: [function(t, e) {
       return i(e, "Accept"), i(e, "Content-Type"), r.isFormData(t) || r.isArrayBuffer(t) || r.isBuffer(t) || r.isStream(t) || r.isFile(t) || r.isBlob(t) ? t : r.isArrayBufferView(t) ? t.buffer : r.isURLSearchParams(t) ? (a(e, "application/x-www-form-urlencoded;charset=utf-8"), t.toString()) : r.isObject(t) ? (a(e, "application/json;charset=utf-8"), JSON.stringify(t)) : t
      }],
      transformResponse: [function(t) {
       if ("string" === typeof t) try {
        t = JSON.parse(t)
       } catch (e) {}
       return t
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      validateStatus: function(t) {
       return t >= 200 && t < 300
      },
      headers: {
       common: {
        Accept: "application/json, text/plain, */*"
       }
      }
     };
     r.forEach(["delete", "get", "head"], (function(t) {
      u.headers[t] = {}
     })), r.forEach(["post", "put", "patch"], (function(t) {
      u.headers[t] = r.merge(o)
     })), t.exports = u
    }).call(this, n("4362"))
   },
   "24b2": function(t, e, n) {
    "use strict";
    n("a9e3");
    var r = n("80d2"),
     i = n("2b0e");
    e["a"] = i["a"].extend({
     name: "measurable",
     props: {
      height: [Number, String],
      maxHeight: [Number, String],
      maxWidth: [Number, String],
      minHeight: [Number, String],
      minWidth: [Number, String],
      width: [Number, String]
     },
     computed: {
      measurableStyles: function() {
       var t = {},
        e = Object(r["f"])(this.height),
        n = Object(r["f"])(this.minHeight),
        i = Object(r["f"])(this.minWidth),
        o = Object(r["f"])(this.maxHeight),
        a = Object(r["f"])(this.maxWidth),
        s = Object(r["f"])(this.width);
       return e && (t.height = e), n && (t.minHeight = n), i && (t.minWidth = i), o && (t.maxHeight = o), a && (t.maxWidth = a), s && (t.width = s), t
      }
     }
    })
   },
   "24e2": function(t, e, n) {
    "use strict";
    var r = n("e0c7");
    e["a"] = r["a"]
   },
   2532: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("5a34"),
     o = n("1d80"),
     a = n("ab13");
    r({
     target: "String",
     proto: !0,
     forced: !a("includes")
    }, {
     includes: function(t) {
      return !!~String(o(this)).indexOf(i(t), arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   "25a8": function(t, e, n) {},
   "25f0": function(t, e, n) {
    "use strict";
    var r = n("6eeb"),
     i = n("825a"),
     o = n("d039"),
     a = n("ad6d"),
     s = "toString",
     u = RegExp.prototype,
     c = u[s],
     l = o((function() {
      return "/a/b" != c.call({
       source: "a",
       flags: "b"
      })
     })),
     h = c.name != s;
    (l || h) && r(RegExp.prototype, s, (function() {
     var t = i(this),
      e = String(t.source),
      n = t.flags,
      r = String(void 0 === n && t instanceof RegExp && !("flags" in u) ? a.call(t) : n);
     return "/" + e + "/" + r
    }), {
     unsafe: !0
    })
   },
   2626: function(t, e, n) {
    "use strict";
    var r = n("d066"),
     i = n("9bf2"),
     o = n("b622"),
     a = n("83ab"),
     s = o("species");
    t.exports = function(t) {
     var e = r(t),
      n = i.f;
     a && e && !e[s] && n(e, s, {
      configurable: !0,
      get: function() {
       return this
      }
     })
    }
   },
   "269a": function(t, e) {
    t.exports = function(t, e) {
     var n = "function" === typeof t.exports ? t.exports.extendOptions : t.options;
     for (var r in "function" === typeof t.exports && (n.directives = t.exports.options.directives), n.directives = n.directives || {}, e) n.directives[r] = n.directives[r] || e[r]
    }
   },
   2877: function(t, e, n) {
    "use strict";
 
    function r(t, e, n, r, i, o, a, s) {
     var u, c = "function" === typeof t ? t.options : t;
     if (e && (c.render = e, c.staticRenderFns = n, c._compiled = !0), r && (c.functional = !0), o && (c._scopeId = "data-v-" + o), a ? (u = function(t) {
       t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, t || "undefined" === typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), i && i.call(this, t), t && t._registeredComponents && t._registeredComponents.add(a)
      }, c._ssrRegister = u) : i && (u = s ? function() {
       i.call(this, this.$root.$options.shadowRoot)
      } : i), u)
      if (c.functional) {
       c._injectStyles = u;
       var l = c.render;
       c.render = function(t, e) {
        return u.call(e), l(t, e)
       }
      } else {
       var h = c.beforeCreate;
       c.beforeCreate = h ? [].concat(h, u) : [u]
      } return {
      exports: t,
      options: c
     }
    }
    n.d(e, "a", (function() {
     return r
    }))
   },
   2909: function(t, e, n) {
    "use strict";
 
    function r(t) {
     if (Array.isArray(t)) {
      for (var e = 0, n = new Array(t.length); e < t.length; e++) n[e] = t[e];
      return n
     }
    }
    var i = n("db90");
 
    function o() {
     throw new TypeError("Invalid attempt to spread non-iterable instance")
    }
 
    function a(t) {
     return r(t) || Object(i["a"])(t) || o()
    }
    n.d(e, "a", (function() {
     return a
    }))
   },
   "297c": function(t, e, n) {
    "use strict";
    n("a9e3");
    var r = n("2b0e"),
     i = (n("c7cd"), n("5530")),
     o = n("ade3"),
     a = (n("6ece"), n("0789")),
     s = n("a9ad"),
     u = n("fe6c"),
     c = n("a452"),
     l = n("7560"),
     h = n("80d2"),
     p = n("58df"),
     f = Object(p["a"])(s["a"], Object(u["b"])(["absolute", "fixed", "top", "bottom"]), c["a"], l["a"]),
     d = f.extend({
      name: "v-progress-linear",
      props: {
       active: {
        type: Boolean,
        default: !0
       },
       backgroundColor: {
        type: String,
        default: null
       },
       backgroundOpacity: {
        type: [Number, String],
        default: null
       },
       bufferValue: {
        type: [Number, String],
        default: 100
       },
       color: {
        type: String,
        default: "primary"
       },
       height: {
        type: [Number, String],
        default: 4
       },
       indeterminate: Boolean,
       query: Boolean,
       rounded: Boolean,
       stream: Boolean,
       striped: Boolean,
       value: {
        type: [Number, String],
        default: 0
       }
      },
      data: function() {
       return {
        internalLazyValue: this.value || 0
       }
      },
      computed: {
       __cachedBackground: function() {
        return this.$createElement("div", this.setBackgroundColor(this.backgroundColor || this.color, {
         staticClass: "v-progress-linear__background",
         style: this.backgroundStyle
        }))
       },
       __cachedBar: function() {
        return this.$createElement(this.computedTransition, [this.__cachedBarType])
       },
       __cachedBarType: function() {
        return this.indeterminate ? this.__cachedIndeterminate : this.__cachedDeterminate
       },
       __cachedBuffer: function() {
        return this.$createElement("div", {
         staticClass: "v-progress-linear__buffer",
         style: this.styles
        })
       },
       __cachedDeterminate: function() {
        return this.$createElement("div", this.setBackgroundColor(this.color, {
         staticClass: "v-progress-linear__determinate",
         style: {
          width: Object(h["f"])(this.normalizedValue, "%")
         }
        }))
       },
       __cachedIndeterminate: function() {
        return this.$createElement("div", {
         staticClass: "v-progress-linear__indeterminate",
         class: {
          "v-progress-linear__indeterminate--active": this.active
         }
        }, [this.genProgressBar("long"), this.genProgressBar("short")])
       },
       __cachedStream: function() {
        return this.stream ? this.$createElement("div", this.setTextColor(this.color, {
         staticClass: "v-progress-linear__stream",
         style: {
          width: Object(h["f"])(100 - this.normalizedBuffer, "%")
         }
        })) : null
       },
       backgroundStyle: function() {
        var t, e = null == this.backgroundOpacity ? this.backgroundColor ? 1 : .3 : parseFloat(this.backgroundOpacity);
        return t = {
         opacity: e
        }, Object(o["a"])(t, this.$vuetify.rtl ? "right" : "left", Object(h["f"])(this.normalizedValue, "%")), Object(o["a"])(t, "width", Object(h["f"])(this.normalizedBuffer - this.normalizedValue, "%")), t
       },
       classes: function() {
        return Object(i["a"])({
         "v-progress-linear--absolute": this.absolute,
         "v-progress-linear--fixed": this.fixed,
         "v-progress-linear--query": this.query,
         "v-progress-linear--reactive": this.reactive,
         "v-progress-linear--rounded": this.rounded,
         "v-progress-linear--striped": this.striped
        }, this.themeClasses)
       },
       computedTransition: function() {
        return this.indeterminate ? a["c"] : a["d"]
       },
       normalizedBuffer: function() {
        return this.normalize(this.bufferValue)
       },
       normalizedValue: function() {
        return this.normalize(this.internalLazyValue)
       },
       reactive: function() {
        return Boolean(this.$listeners.change)
       },
       styles: function() {
        var t = {};
        return this.active || (t.height = 0), this.indeterminate || 100 === parseFloat(this.normalizedBuffer) || (t.width = Object(h["f"])(this.normalizedBuffer, "%")), t
       }
      },
      methods: {
       genContent: function() {
        var t = Object(h["m"])(this, "default", {
         value: this.internalLazyValue
        });
        return t ? this.$createElement("div", {
         staticClass: "v-progress-linear__content"
        }, t) : null
       },
       genListeners: function() {
        var t = this.$listeners;
        return this.reactive && (t.click = this.onClick), t
       },
       genProgressBar: function(t) {
        return this.$createElement("div", this.setBackgroundColor(this.color, {
         staticClass: "v-progress-linear__indeterminate",
         class: Object(o["a"])({}, t, !0)
        }))
       },
       onClick: function(t) {
        if (this.reactive) {
         var e = this.$el.getBoundingClientRect(),
          n = e.width;
         this.internalValue = t.offsetX / n * 100
        }
       },
       normalize: function(t) {
        return t < 0 ? 0 : t > 100 ? 100 : parseFloat(t)
       }
      },
      render: function(t) {
       var e = {
        staticClass: "v-progress-linear",
        attrs: {
         role: "progressbar",
         "aria-valuemin": 0,
         "aria-valuemax": this.normalizedBuffer,
         "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
        },
        class: this.classes,
        style: {
         bottom: this.bottom ? 0 : void 0,
         height: this.active ? Object(h["f"])(this.height) : 0,
         top: this.top ? 0 : void 0
        },
        on: this.genListeners()
       };
       return t("div", e, [this.__cachedStream, this.__cachedBackground, this.__cachedBuffer, this.__cachedBar, this.genContent()])
      }
     }),
     v = d;
    e["a"] = r["a"].extend().extend({
     name: "loadable",
     props: {
      loading: {
       type: [Boolean, String],
       default: !1
      },
      loaderHeight: {
       type: [Number, String],
       default: 2
      }
     },
     methods: {
      genProgress: function() {
       return !1 === this.loading ? null : this.$slots.progress || this.$createElement(v, {
        props: {
         absolute: !0,
         color: !0 === this.loading || "" === this.loading ? this.color || "primary" : this.loading,
         height: this.loaderHeight,
         indeterminate: !0
        }
       })
      }
     }
    })
   },
   "2a7f": function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return a
    })), n.d(e, "b", (function() {
     return o
    }));
    var r = n("71d9"),
     i = n("80d2"),
     o = Object(i["g"])("v-toolbar__title"),
     a = Object(i["g"])("v-toolbar__items");
    r["a"]
   },
   "2b0e": function(t, e, n) {
    "use strict";
    (function(t) {
     /*!
      * Vue.js v2.6.11
      * (c) 2014-2019 Evan You
      * Released under the MIT License.
      */
     var n = Object.freeze({});
 
     function r(t) {
      return void 0 === t || null === t
     }
 
     function i(t) {
      return void 0 !== t && null !== t
     }
 
     function o(t) {
      return !0 === t
     }
 
     function a(t) {
      return !1 === t
     }
 
     function s(t) {
      return "string" === typeof t || "number" === typeof t || "symbol" === typeof t || "boolean" === typeof t
     }
 
     function u(t) {
      return null !== t && "object" === typeof t
     }
     var c = Object.prototype.toString;
 
     function l(t) {
      return "[object Object]" === c.call(t)
     }
 
     function h(t) {
      return "[object RegExp]" === c.call(t)
     }
 
     function p(t) {
      var e = parseFloat(String(t));
      return e >= 0 && Math.floor(e) === e && isFinite(t)
     }
 
     function f(t) {
      return i(t) && "function" === typeof t.then && "function" === typeof t.catch
     }
 
     function d(t) {
      return null == t ? "" : Array.isArray(t) || l(t) && t.toString === c ? JSON.stringify(t, null, 2) : String(t)
     }
 
     function v(t) {
      var e = parseFloat(t);
      return isNaN(e) ? t : e
     }
 
     function m(t, e) {
      for (var n = Object.create(null), r = t.split(","), i = 0; i < r.length; i++) n[r[i]] = !0;
      return e ? function(t) {
       return n[t.toLowerCase()]
      } : function(t) {
       return n[t]
      }
     }
     m("slot,component", !0);
     var g = m("key,ref,slot,slot-scope,is");
 
     function y(t, e) {
      if (t.length) {
       var n = t.indexOf(e);
       if (n > -1) return t.splice(n, 1)
      }
     }
     var b = Object.prototype.hasOwnProperty;
 
     function x(t, e) {
      return b.call(t, e)
     }
 
     function w(t) {
      var e = Object.create(null);
      return function(n) {
       var r = e[n];
       return r || (e[n] = t(n))
      }
     }
     var C = /-(\w)/g,
      S = w((function(t) {
       return t.replace(C, (function(t, e) {
        return e ? e.toUpperCase() : ""
       }))
      })),
      E = w((function(t) {
       return t.charAt(0).toUpperCase() + t.slice(1)
      })),
      k = /\B([A-Z])/g,
      I = w((function(t) {
       return t.replace(k, "-$1").toLowerCase()
      }));
 
     function O(t, e) {
      function n(n) {
       var r = arguments.length;
       return r ? r > 1 ? t.apply(e, arguments) : t.call(e, n) : t.call(e)
      }
      return n._length = t.length, n
     }
 
     function A(t, e) {
      return t.bind(e)
     }
     var N = Function.prototype.bind ? A : O;
 
     function R(t, e) {
      e = e || 0;
      var n = t.length - e,
       r = new Array(n);
      while (n--) r[n] = t[n + e];
      return r
     }
 
     function T(t, e) {
      for (var n in e) t[n] = e[n];
      return t
     }
 
     function _(t) {
      for (var e = {}, n = 0; n < t.length; n++) t[n] && T(e, t[n]);
      return e
     }
 
     function D(t, e, n) {}
     var F = function(t, e, n) {
       return !1
      },
      M = function(t) {
       return t
      };
 
     function L(t, e) {
      if (t === e) return !0;
      var n = u(t),
       r = u(e);
      if (!n || !r) return !n && !r && String(t) === String(e);
      try {
       var i = Array.isArray(t),
        o = Array.isArray(e);
       if (i && o) return t.length === e.length && t.every((function(t, n) {
        return L(t, e[n])
       }));
       if (t instanceof Date && e instanceof Date) return t.getTime() === e.getTime();
       if (i || o) return !1;
       var a = Object.keys(t),
        s = Object.keys(e);
       return a.length === s.length && a.every((function(n) {
        return L(t[n], e[n])
       }))
      } catch (c) {
       return !1
      }
     }
 
     function B(t, e) {
      for (var n = 0; n < t.length; n++)
       if (L(t[n], e)) return n;
      return -1
     }
 
     function P(t) {
      var e = !1;
      return function() {
       e || (e = !0, t.apply(this, arguments))
      }
     }
     var z = "data-server-rendered",
      j = ["component", "directive", "filter"],
      W = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"],
      V = {
       optionMergeStrategies: Object.create(null),
       silent: !1,
       productionTip: !1,
       devtools: !1,
       performance: !1,
       errorHandler: null,
       warnHandler: null,
       ignoredElements: [],
       keyCodes: Object.create(null),
       isReservedTag: F,
       isReservedAttr: F,
       isUnknownElement: F,
       getTagNamespace: D,
       parsePlatformTagName: M,
       mustUseProp: F,
       async: !0,
       _lifecycleHooks: W
      },
      U = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
 
     function H(t) {
      var e = (t + "").charCodeAt(0);
      return 36 === e || 95 === e
     }
 
     function $(t, e, n, r) {
      Object.defineProperty(t, e, {
       value: n,
       enumerable: !!r,
       writable: !0,
       configurable: !0
      })
     }
     var G = new RegExp("[^" + U.source + ".$_\\d]");
 
     function q(t) {
      if (!G.test(t)) {
       var e = t.split(".");
       return function(t) {
        for (var n = 0; n < e.length; n++) {
         if (!t) return;
         t = t[e[n]]
        }
        return t
       }
      }
     }
     var K, X = "__proto__" in {},
      Y = "undefined" !== typeof window,
      Z = "undefined" !== typeof WXEnvironment && !!WXEnvironment.platform,
      J = Z && WXEnvironment.platform.toLowerCase(),
      Q = Y && window.navigator.userAgent.toLowerCase(),
      tt = Q && /msie|trident/.test(Q),
      et = Q && Q.indexOf("msie 9.0") > 0,
      nt = Q && Q.indexOf("edge/") > 0,
      rt = (Q && Q.indexOf("android"), Q && /iphone|ipad|ipod|ios/.test(Q) || "ios" === J),
      it = (Q && /chrome\/\d+/.test(Q), Q && /phantomjs/.test(Q), Q && Q.match(/firefox\/(\d+)/)),
      ot = {}.watch,
      at = !1;
     if (Y) try {
      var st = {};
      Object.defineProperty(st, "passive", {
       get: function() {
        at = !0
       }
      }), window.addEventListener("test-passive", null, st)
     } catch (Sa) {}
     var ut = function() {
       return void 0 === K && (K = !Y && !Z && "undefined" !== typeof t && (t["process"] && "server" === t["process"].env.VUE_ENV)), K
      },
      ct = Y && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
 
     function lt(t) {
      return "function" === typeof t && /native code/.test(t.toString())
     }
     var ht, pt = "undefined" !== typeof Symbol && lt(Symbol) && "undefined" !== typeof Reflect && lt(Reflect.ownKeys);
     ht = "undefined" !== typeof Set && lt(Set) ? Set : function() {
      function t() {
       this.set = Object.create(null)
      }
      return t.prototype.has = function(t) {
       return !0 === this.set[t]
      }, t.prototype.add = function(t) {
       this.set[t] = !0
      }, t.prototype.clear = function() {
       this.set = Object.create(null)
      }, t
     }();
     var ft = D,
      dt = 0,
      vt = function() {
       this.id = dt++, this.subs = []
      };
     vt.prototype.addSub = function(t) {
      this.subs.push(t)
     }, vt.prototype.removeSub = function(t) {
      y(this.subs, t)
     }, vt.prototype.depend = function() {
      vt.target && vt.target.addDep(this)
     }, vt.prototype.notify = function() {
      var t = this.subs.slice();
      for (var e = 0, n = t.length; e < n; e++) t[e].update()
     }, vt.target = null;
     var mt = [];
 
     function gt(t) {
      mt.push(t), vt.target = t
     }
 
     function yt() {
      mt.pop(), vt.target = mt[mt.length - 1]
     }
     var bt = function(t, e, n, r, i, o, a, s) {
       this.tag = t, this.data = e, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e && e.key, this.componentOptions = a, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1
      },
      xt = {
       child: {
        configurable: !0
       }
      };
     xt.child.get = function() {
      return this.componentInstance
     }, Object.defineProperties(bt.prototype, xt);
     var wt = function(t) {
      void 0 === t && (t = "");
      var e = new bt;
      return e.text = t, e.isComment = !0, e
     };
 
     function Ct(t) {
      return new bt(void 0, void 0, void 0, String(t))
     }
 
     function St(t) {
      var e = new bt(t.tag, t.data, t.children && t.children.slice(), t.text, t.elm, t.context, t.componentOptions, t.asyncFactory);
      return e.ns = t.ns, e.isStatic = t.isStatic, e.key = t.key, e.isComment = t.isComment, e.fnContext = t.fnContext, e.fnOptions = t.fnOptions, e.fnScopeId = t.fnScopeId, e.asyncMeta = t.asyncMeta, e.isCloned = !0, e
     }
     var Et = Array.prototype,
      kt = Object.create(Et),
      It = ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"];
     It.forEach((function(t) {
      var e = Et[t];
      $(kt, t, (function() {
       var n = [],
        r = arguments.length;
       while (r--) n[r] = arguments[r];
       var i, o = e.apply(this, n),
        a = this.__ob__;
       switch (t) {
        case "push":
        case "unshift":
         i = n;
         break;
        case "splice":
         i = n.slice(2);
         break
       }
       return i && a.observeArray(i), a.dep.notify(), o
      }))
     }));
     var Ot = Object.getOwnPropertyNames(kt),
      At = !0;
 
     function Nt(t) {
      At = t
     }
     var Rt = function(t) {
      this.value = t, this.dep = new vt, this.vmCount = 0, $(t, "__ob__", this), Array.isArray(t) ? (X ? Tt(t, kt) : _t(t, kt, Ot), this.observeArray(t)) : this.walk(t)
     };
 
     function Tt(t, e) {
      t.__proto__ = e
     }
 
     function _t(t, e, n) {
      for (var r = 0, i = n.length; r < i; r++) {
       var o = n[r];
       $(t, o, e[o])
      }
     }
 
     function Dt(t, e) {
      var n;
      if (u(t) && !(t instanceof bt)) return x(t, "__ob__") && t.__ob__ instanceof Rt ? n = t.__ob__ : At && !ut() && (Array.isArray(t) || l(t)) && Object.isExtensible(t) && !t._isVue && (n = new Rt(t)), e && n && n.vmCount++, n
     }
 
     function Ft(t, e, n, r, i) {
      var o = new vt,
       a = Object.getOwnPropertyDescriptor(t, e);
      if (!a || !1 !== a.configurable) {
       var s = a && a.get,
        u = a && a.set;
       s && !u || 2 !== arguments.length || (n = t[e]);
       var c = !i && Dt(n);
       Object.defineProperty(t, e, {
        enumerable: !0,
        configurable: !0,
        get: function() {
         var e = s ? s.call(t) : n;
         return vt.target && (o.depend(), c && (c.dep.depend(), Array.isArray(e) && Bt(e))), e
        },
        set: function(e) {
         var r = s ? s.call(t) : n;
         e === r || e !== e && r !== r || s && !u || (u ? u.call(t, e) : n = e, c = !i && Dt(e), o.notify())
        }
       })
      }
     }
 
     function Mt(t, e, n) {
      if (Array.isArray(t) && p(e)) return t.length = Math.max(t.length, e), t.splice(e, 1, n), n;
      if (e in t && !(e in Object.prototype)) return t[e] = n, n;
      var r = t.__ob__;
      return t._isVue || r && r.vmCount ? n : r ? (Ft(r.value, e, n), r.dep.notify(), n) : (t[e] = n, n)
     }
 
     function Lt(t, e) {
      if (Array.isArray(t) && p(e)) t.splice(e, 1);
      else {
       var n = t.__ob__;
       t._isVue || n && n.vmCount || x(t, e) && (delete t[e], n && n.dep.notify())
      }
     }
 
     function Bt(t) {
      for (var e = void 0, n = 0, r = t.length; n < r; n++) e = t[n], e && e.__ob__ && e.__ob__.dep.depend(), Array.isArray(e) && Bt(e)
     }
     Rt.prototype.walk = function(t) {
      for (var e = Object.keys(t), n = 0; n < e.length; n++) Ft(t, e[n])
     }, Rt.prototype.observeArray = function(t) {
      for (var e = 0, n = t.length; e < n; e++) Dt(t[e])
     };
     var Pt = V.optionMergeStrategies;
 
     function zt(t, e) {
      if (!e) return t;
      for (var n, r, i, o = pt ? Reflect.ownKeys(e) : Object.keys(e), a = 0; a < o.length; a++) n = o[a], "__ob__" !== n && (r = t[n], i = e[n], x(t, n) ? r !== i && l(r) && l(i) && zt(r, i) : Mt(t, n, i));
      return t
     }
 
     function jt(t, e, n) {
      return n ? function() {
       var r = "function" === typeof e ? e.call(n, n) : e,
        i = "function" === typeof t ? t.call(n, n) : t;
       return r ? zt(r, i) : i
      } : e ? t ? function() {
       return zt("function" === typeof e ? e.call(this, this) : e, "function" === typeof t ? t.call(this, this) : t)
      } : e : t
     }
 
     function Wt(t, e) {
      var n = e ? t ? t.concat(e) : Array.isArray(e) ? e : [e] : t;
      return n ? Vt(n) : n
     }
 
     function Vt(t) {
      for (var e = [], n = 0; n < t.length; n++) - 1 === e.indexOf(t[n]) && e.push(t[n]);
      return e
     }
 
     function Ut(t, e, n, r) {
      var i = Object.create(t || null);
      return e ? T(i, e) : i
     }
     Pt.data = function(t, e, n) {
      return n ? jt(t, e, n) : e && "function" !== typeof e ? t : jt(t, e)
     }, W.forEach((function(t) {
      Pt[t] = Wt
     })), j.forEach((function(t) {
      Pt[t + "s"] = Ut
     })), Pt.watch = function(t, e, n, r) {
      if (t === ot && (t = void 0), e === ot && (e = void 0), !e) return Object.create(t || null);
      if (!t) return e;
      var i = {};
      for (var o in T(i, t), e) {
       var a = i[o],
        s = e[o];
       a && !Array.isArray(a) && (a = [a]), i[o] = a ? a.concat(s) : Array.isArray(s) ? s : [s]
      }
      return i
     }, Pt.props = Pt.methods = Pt.inject = Pt.computed = function(t, e, n, r) {
      if (!t) return e;
      var i = Object.create(null);
      return T(i, t), e && T(i, e), i
     }, Pt.provide = jt;
     var Ht = function(t, e) {
      return void 0 === e ? t : e
     };
 
     function $t(t, e) {
      var n = t.props;
      if (n) {
       var r, i, o, a = {};
       if (Array.isArray(n)) {
        r = n.length;
        while (r--) i = n[r], "string" === typeof i && (o = S(i), a[o] = {
         type: null
        })
       } else if (l(n))
        for (var s in n) i = n[s], o = S(s), a[o] = l(i) ? i : {
         type: i
        };
       else 0;
       t.props = a
      }
     }
 
     function Gt(t, e) {
      var n = t.inject;
      if (n) {
       var r = t.inject = {};
       if (Array.isArray(n))
        for (var i = 0; i < n.length; i++) r[n[i]] = {
         from: n[i]
        };
       else if (l(n))
        for (var o in n) {
         var a = n[o];
         r[o] = l(a) ? T({
          from: o
         }, a) : {
          from: a
         }
        } else 0
      }
     }
 
     function qt(t) {
      var e = t.directives;
      if (e)
       for (var n in e) {
        var r = e[n];
        "function" === typeof r && (e[n] = {
         bind: r,
         update: r
        })
       }
     }
 
     function Kt(t, e, n) {
      if ("function" === typeof e && (e = e.options), $t(e, n), Gt(e, n), qt(e), !e._base && (e.extends && (t = Kt(t, e.extends, n)), e.mixins))
       for (var r = 0, i = e.mixins.length; r < i; r++) t = Kt(t, e.mixins[r], n);
      var o, a = {};
      for (o in t) s(o);
      for (o in e) x(t, o) || s(o);
 
      function s(r) {
       var i = Pt[r] || Ht;
       a[r] = i(t[r], e[r], n, r)
      }
      return a
     }
 
     function Xt(t, e, n, r) {
      if ("string" === typeof n) {
       var i = t[e];
       if (x(i, n)) return i[n];
       var o = S(n);
       if (x(i, o)) return i[o];
       var a = E(o);
       if (x(i, a)) return i[a];
       var s = i[n] || i[o] || i[a];
       return s
      }
     }
 
     function Yt(t, e, n, r) {
      var i = e[t],
       o = !x(n, t),
       a = n[t],
       s = te(Boolean, i.type);
      if (s > -1)
       if (o && !x(i, "default")) a = !1;
       else if ("" === a || a === I(t)) {
       var u = te(String, i.type);
       (u < 0 || s < u) && (a = !0)
      }
      if (void 0 === a) {
       a = Zt(r, i, t);
       var c = At;
       Nt(!0), Dt(a), Nt(c)
      }
      return a
     }
 
     function Zt(t, e, n) {
      if (x(e, "default")) {
       var r = e.default;
       return t && t.$options.propsData && void 0 === t.$options.propsData[n] && void 0 !== t._props[n] ? t._props[n] : "function" === typeof r && "Function" !== Jt(e.type) ? r.call(t) : r
      }
     }
 
     function Jt(t) {
      var e = t && t.toString().match(/^\s*function (\w+)/);
      return e ? e[1] : ""
     }
 
     function Qt(t, e) {
      return Jt(t) === Jt(e)
     }
 
     function te(t, e) {
      if (!Array.isArray(e)) return Qt(e, t) ? 0 : -1;
      for (var n = 0, r = e.length; n < r; n++)
       if (Qt(e[n], t)) return n;
      return -1
     }
 
     function ee(t, e, n) {
      gt();
      try {
       if (e) {
        var r = e;
        while (r = r.$parent) {
         var i = r.$options.errorCaptured;
         if (i)
          for (var o = 0; o < i.length; o++) try {
           var a = !1 === i[o].call(r, t, e, n);
           if (a) return
          } catch (Sa) {
           re(Sa, r, "errorCaptured hook")
          }
        }
       }
       re(t, e, n)
      } finally {
       yt()
      }
     }
 
     function ne(t, e, n, r, i) {
      var o;
      try {
       o = n ? t.apply(e, n) : t.call(e), o && !o._isVue && f(o) && !o._handled && (o.catch((function(t) {
        return ee(t, r, i + " (Promise/async)")
       })), o._handled = !0)
      } catch (Sa) {
       ee(Sa, r, i)
      }
      return o
     }
 
     function re(t, e, n) {
      if (V.errorHandler) try {
       return V.errorHandler.call(null, t, e, n)
      } catch (Sa) {
       Sa !== t && ie(Sa, null, "config.errorHandler")
      }
      ie(t, e, n)
     }
 
     function ie(t, e, n) {
      if (!Y && !Z || "undefined" === typeof console) throw t;
      console.error(t)
     }
     var oe, ae = !1,
      se = [],
      ue = !1;
 
     function ce() {
      ue = !1;
      var t = se.slice(0);
      se.length = 0;
      for (var e = 0; e < t.length; e++) t[e]()
     }
     if ("undefined" !== typeof Promise && lt(Promise)) {
      var le = Promise.resolve();
      oe = function() {
       le.then(ce), rt && setTimeout(D)
      }, ae = !0
     } else if (tt || "undefined" === typeof MutationObserver || !lt(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) oe = "undefined" !== typeof setImmediate && lt(setImmediate) ? function() {
      setImmediate(ce)
     } : function() {
      setTimeout(ce, 0)
     };
     else {
      var he = 1,
       pe = new MutationObserver(ce),
       fe = document.createTextNode(String(he));
      pe.observe(fe, {
       characterData: !0
      }), oe = function() {
       he = (he + 1) % 2, fe.data = String(he)
      }, ae = !0
     }
 
     function de(t, e) {
      var n;
      if (se.push((function() {
        if (t) try {
         t.call(e)
        } catch (Sa) {
         ee(Sa, e, "nextTick")
        } else n && n(e)
       })), ue || (ue = !0, oe()), !t && "undefined" !== typeof Promise) return new Promise((function(t) {
       n = t
      }))
     }
     var ve = new ht;
 
     function me(t) {
      ge(t, ve), ve.clear()
     }
 
     function ge(t, e) {
      var n, r, i = Array.isArray(t);
      if (!(!i && !u(t) || Object.isFrozen(t) || t instanceof bt)) {
       if (t.__ob__) {
        var o = t.__ob__.dep.id;
        if (e.has(o)) return;
        e.add(o)
       }
       if (i) {
        n = t.length;
        while (n--) ge(t[n], e)
       } else {
        r = Object.keys(t), n = r.length;
        while (n--) ge(t[r[n]], e)
       }
      }
     }
     var ye = w((function(t) {
      var e = "&" === t.charAt(0);
      t = e ? t.slice(1) : t;
      var n = "~" === t.charAt(0);
      t = n ? t.slice(1) : t;
      var r = "!" === t.charAt(0);
      return t = r ? t.slice(1) : t, {
       name: t,
       once: n,
       capture: r,
       passive: e
      }
     }));
 
     function be(t, e) {
      function n() {
       var t = arguments,
        r = n.fns;
       if (!Array.isArray(r)) return ne(r, null, arguments, e, "v-on handler");
       for (var i = r.slice(), o = 0; o < i.length; o++) ne(i[o], null, t, e, "v-on handler")
      }
      return n.fns = t, n
     }
 
     function xe(t, e, n, i, a, s) {
      var u, c, l, h;
      for (u in t) c = t[u], l = e[u], h = ye(u), r(c) || (r(l) ? (r(c.fns) && (c = t[u] = be(c, s)), o(h.once) && (c = t[u] = a(h.name, c, h.capture)), n(h.name, c, h.capture, h.passive, h.params)) : c !== l && (l.fns = c, t[u] = l));
      for (u in e) r(t[u]) && (h = ye(u), i(h.name, e[u], h.capture))
     }
 
     function we(t, e, n) {
      var a;
      t instanceof bt && (t = t.data.hook || (t.data.hook = {}));
      var s = t[e];
 
      function u() {
       n.apply(this, arguments), y(a.fns, u)
      }
      r(s) ? a = be([u]) : i(s.fns) && o(s.merged) ? (a = s, a.fns.push(u)) : a = be([s, u]), a.merged = !0, t[e] = a
     }
 
     function Ce(t, e, n) {
      var o = e.options.props;
      if (!r(o)) {
       var a = {},
        s = t.attrs,
        u = t.props;
       if (i(s) || i(u))
        for (var c in o) {
         var l = I(c);
         Se(a, u, c, l, !0) || Se(a, s, c, l, !1)
        }
       return a
      }
     }
 
     function Se(t, e, n, r, o) {
      if (i(e)) {
       if (x(e, n)) return t[n] = e[n], o || delete e[n], !0;
       if (x(e, r)) return t[n] = e[r], o || delete e[r], !0
      }
      return !1
     }
 
     function Ee(t) {
      for (var e = 0; e < t.length; e++)
       if (Array.isArray(t[e])) return Array.prototype.concat.apply([], t);
      return t
     }
 
     function ke(t) {
      return s(t) ? [Ct(t)] : Array.isArray(t) ? Oe(t) : void 0
     }
 
     function Ie(t) {
      return i(t) && i(t.text) && a(t.isComment)
     }
 
     function Oe(t, e) {
      var n, a, u, c, l = [];
      for (n = 0; n < t.length; n++) a = t[n], r(a) || "boolean" === typeof a || (u = l.length - 1, c = l[u], Array.isArray(a) ? a.length > 0 && (a = Oe(a, (e || "") + "_" + n), Ie(a[0]) && Ie(c) && (l[u] = Ct(c.text + a[0].text), a.shift()), l.push.apply(l, a)) : s(a) ? Ie(c) ? l[u] = Ct(c.text + a) : "" !== a && l.push(Ct(a)) : Ie(a) && Ie(c) ? l[u] = Ct(c.text + a.text) : (o(t._isVList) && i(a.tag) && r(a.key) && i(e) && (a.key = "__vlist" + e + "_" + n + "__"), l.push(a)));
      return l
     }
 
     function Ae(t) {
      var e = t.$options.provide;
      e && (t._provided = "function" === typeof e ? e.call(t) : e)
     }
 
     function Ne(t) {
      var e = Re(t.$options.inject, t);
      e && (Nt(!1), Object.keys(e).forEach((function(n) {
       Ft(t, n, e[n])
      })), Nt(!0))
     }
 
     function Re(t, e) {
      if (t) {
       for (var n = Object.create(null), r = pt ? Reflect.ownKeys(t) : Object.keys(t), i = 0; i < r.length; i++) {
        var o = r[i];
        if ("__ob__" !== o) {
         var a = t[o].from,
          s = e;
         while (s) {
          if (s._provided && x(s._provided, a)) {
           n[o] = s._provided[a];
           break
          }
          s = s.$parent
         }
         if (!s)
          if ("default" in t[o]) {
           var u = t[o].default;
           n[o] = "function" === typeof u ? u.call(e) : u
          } else 0
        }
       }
       return n
      }
     }
 
     function Te(t, e) {
      if (!t || !t.length) return {};
      for (var n = {}, r = 0, i = t.length; r < i; r++) {
       var o = t[r],
        a = o.data;
       if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, o.context !== e && o.fnContext !== e || !a || null == a.slot)(n.default || (n.default = [])).push(o);
       else {
        var s = a.slot,
         u = n[s] || (n[s] = []);
        "template" === o.tag ? u.push.apply(u, o.children || []) : u.push(o)
       }
      }
      for (var c in n) n[c].every(_e) && delete n[c];
      return n
     }
 
     function _e(t) {
      return t.isComment && !t.asyncFactory || " " === t.text
     }
 
     function De(t, e, r) {
      var i, o = Object.keys(e).length > 0,
       a = t ? !!t.$stable : !o,
       s = t && t.$key;
      if (t) {
       if (t._normalized) return t._normalized;
       if (a && r && r !== n && s === r.$key && !o && !r.$hasNormal) return r;
       for (var u in i = {}, t) t[u] && "$" !== u[0] && (i[u] = Fe(e, u, t[u]))
      } else i = {};
      for (var c in e) c in i || (i[c] = Me(e, c));
      return t && Object.isExtensible(t) && (t._normalized = i), $(i, "$stable", a), $(i, "$key", s), $(i, "$hasNormal", o), i
     }
 
     function Fe(t, e, n) {
      var r = function() {
       var t = arguments.length ? n.apply(null, arguments) : n({});
       return t = t && "object" === typeof t && !Array.isArray(t) ? [t] : ke(t), t && (0 === t.length || 1 === t.length && t[0].isComment) ? void 0 : t
      };
      return n.proxy && Object.defineProperty(t, e, {
       get: r,
       enumerable: !0,
       configurable: !0
      }), r
     }
 
     function Me(t, e) {
      return function() {
       return t[e]
      }
     }
 
     function Le(t, e) {
      var n, r, o, a, s;
      if (Array.isArray(t) || "string" === typeof t)
       for (n = new Array(t.length), r = 0, o = t.length; r < o; r++) n[r] = e(t[r], r);
      else if ("number" === typeof t)
       for (n = new Array(t), r = 0; r < t; r++) n[r] = e(r + 1, r);
      else if (u(t))
       if (pt && t[Symbol.iterator]) {
        n = [];
        var c = t[Symbol.iterator](),
         l = c.next();
        while (!l.done) n.push(e(l.value, n.length)), l = c.next()
       } else
        for (a = Object.keys(t), n = new Array(a.length), r = 0, o = a.length; r < o; r++) s = a[r], n[r] = e(t[s], s, r);
      return i(n) || (n = []), n._isVList = !0, n
     }
 
     function Be(t, e, n, r) {
      var i, o = this.$scopedSlots[t];
      o ? (n = n || {}, r && (n = T(T({}, r), n)), i = o(n) || e) : i = this.$slots[t] || e;
      var a = n && n.slot;
      return a ? this.$createElement("template", {
       slot: a
      }, i) : i
     }
 
     function Pe(t) {
      return Xt(this.$options, "filters", t, !0) || M
     }
 
     function ze(t, e) {
      return Array.isArray(t) ? -1 === t.indexOf(e) : t !== e
     }
 
     function je(t, e, n, r, i) {
      var o = V.keyCodes[e] || n;
      return i && r && !V.keyCodes[e] ? ze(i, r) : o ? ze(o, t) : r ? I(r) !== e : void 0
     }
 
     function We(t, e, n, r, i) {
      if (n)
       if (u(n)) {
        var o;
        Array.isArray(n) && (n = _(n));
        var a = function(a) {
         if ("class" === a || "style" === a || g(a)) o = t;
         else {
          var s = t.attrs && t.attrs.type;
          o = r || V.mustUseProp(e, s, a) ? t.domProps || (t.domProps = {}) : t.attrs || (t.attrs = {})
         }
         var u = S(a),
          c = I(a);
         if (!(u in o) && !(c in o) && (o[a] = n[a], i)) {
          var l = t.on || (t.on = {});
          l["update:" + a] = function(t) {
           n[a] = t
          }
         }
        };
        for (var s in n) a(s)
       } else;
      return t
     }
 
     function Ve(t, e) {
      var n = this._staticTrees || (this._staticTrees = []),
       r = n[t];
      return r && !e ? r : (r = n[t] = this.$options.staticRenderFns[t].call(this._renderProxy, null, this), He(r, "__static__" + t, !1), r)
     }
 
     function Ue(t, e, n) {
      return He(t, "__once__" + e + (n ? "_" + n : ""), !0), t
     }
 
     function He(t, e, n) {
      if (Array.isArray(t))
       for (var r = 0; r < t.length; r++) t[r] && "string" !== typeof t[r] && $e(t[r], e + "_" + r, n);
      else $e(t, e, n)
     }
 
     function $e(t, e, n) {
      t.isStatic = !0, t.key = e, t.isOnce = n
     }
 
     function Ge(t, e) {
      if (e)
       if (l(e)) {
        var n = t.on = t.on ? T({}, t.on) : {};
        for (var r in e) {
         var i = n[r],
          o = e[r];
         n[r] = i ? [].concat(i, o) : o
        }
       } else;
      return t
     }
 
     function qe(t, e, n, r) {
      e = e || {
       $stable: !n
      };
      for (var i = 0; i < t.length; i++) {
       var o = t[i];
       Array.isArray(o) ? qe(o, e, n) : o && (o.proxy && (o.fn.proxy = !0), e[o.key] = o.fn)
      }
      return r && (e.$key = r), e
     }
 
     function Ke(t, e) {
      for (var n = 0; n < e.length; n += 2) {
       var r = e[n];
       "string" === typeof r && r && (t[e[n]] = e[n + 1])
      }
      return t
     }
 
     function Xe(t, e) {
      return "string" === typeof t ? e + t : t
     }
 
     function Ye(t) {
      t._o = Ue, t._n = v, t._s = d, t._l = Le, t._t = Be, t._q = L, t._i = B, t._m = Ve, t._f = Pe, t._k = je, t._b = We, t._v = Ct, t._e = wt, t._u = qe, t._g = Ge, t._d = Ke, t._p = Xe
     }
 
     function Ze(t, e, r, i, a) {
      var s, u = this,
       c = a.options;
      x(i, "_uid") ? (s = Object.create(i), s._original = i) : (s = i, i = i._original);
      var l = o(c._compiled),
       h = !l;
      this.data = t, this.props = e, this.children = r, this.parent = i, this.listeners = t.on || n, this.injections = Re(c.inject, i), this.slots = function() {
       return u.$slots || De(t.scopedSlots, u.$slots = Te(r, i)), u.$slots
      }, Object.defineProperty(this, "scopedSlots", {
       enumerable: !0,
       get: function() {
        return De(t.scopedSlots, this.slots())
       }
      }), l && (this.$options = c, this.$slots = this.slots(), this.$scopedSlots = De(t.scopedSlots, this.$slots)), c._scopeId ? this._c = function(t, e, n, r) {
       var o = hn(s, t, e, n, r, h);
       return o && !Array.isArray(o) && (o.fnScopeId = c._scopeId, o.fnContext = i), o
      } : this._c = function(t, e, n, r) {
       return hn(s, t, e, n, r, h)
      }
     }
 
     function Je(t, e, r, o, a) {
      var s = t.options,
       u = {},
       c = s.props;
      if (i(c))
       for (var l in c) u[l] = Yt(l, c, e || n);
      else i(r.attrs) && tn(u, r.attrs), i(r.props) && tn(u, r.props);
      var h = new Ze(r, u, a, o, t),
       p = s.render.call(null, h._c, h);
      if (p instanceof bt) return Qe(p, r, h.parent, s, h);
      if (Array.isArray(p)) {
       for (var f = ke(p) || [], d = new Array(f.length), v = 0; v < f.length; v++) d[v] = Qe(f[v], r, h.parent, s, h);
       return d
      }
     }
 
     function Qe(t, e, n, r, i) {
      var o = St(t);
      return o.fnContext = n, o.fnOptions = r, e.slot && ((o.data || (o.data = {})).slot = e.slot), o
     }
 
     function tn(t, e) {
      for (var n in e) t[S(n)] = e[n]
     }
     Ye(Ze.prototype);
     var en = {
       init: function(t, e) {
        if (t.componentInstance && !t.componentInstance._isDestroyed && t.data.keepAlive) {
         var n = t;
         en.prepatch(n, n)
        } else {
         var r = t.componentInstance = on(t, Rn);
         r.$mount(e ? t.elm : void 0, e)
        }
       },
       prepatch: function(t, e) {
        var n = e.componentOptions,
         r = e.componentInstance = t.componentInstance;
        Mn(r, n.propsData, n.listeners, e, n.children)
       },
       insert: function(t) {
        var e = t.context,
         n = t.componentInstance;
        n._isMounted || (n._isMounted = !0, zn(n, "mounted")), t.data.keepAlive && (e._isMounted ? Jn(n) : Bn(n, !0))
       },
       destroy: function(t) {
        var e = t.componentInstance;
        e._isDestroyed || (t.data.keepAlive ? Pn(e, !0) : e.$destroy())
       }
      },
      nn = Object.keys(en);
 
     function rn(t, e, n, a, s) {
      if (!r(t)) {
       var c = n.$options._base;
       if (u(t) && (t = c.extend(t)), "function" === typeof t) {
        var l;
        if (r(t.cid) && (l = t, t = wn(l, c), void 0 === t)) return xn(l, e, n, a, s);
        e = e || {}, wr(t), i(e.model) && un(t.options, e);
        var h = Ce(e, t, s);
        if (o(t.options.functional)) return Je(t, h, e, n, a);
        var p = e.on;
        if (e.on = e.nativeOn, o(t.options.abstract)) {
         var f = e.slot;
         e = {}, f && (e.slot = f)
        }
        an(e);
        var d = t.options.name || s,
         v = new bt("vue-component-" + t.cid + (d ? "-" + d : ""), e, void 0, void 0, void 0, n, {
          Ctor: t,
          propsData: h,
          listeners: p,
          tag: s,
          children: a
         }, l);
        return v
       }
      }
     }
 
     function on(t, e) {
      var n = {
        _isComponent: !0,
        _parentVnode: t,
        parent: e
       },
       r = t.data.inlineTemplate;
      return i(r) && (n.render = r.render, n.staticRenderFns = r.staticRenderFns), new t.componentOptions.Ctor(n)
     }
 
     function an(t) {
      for (var e = t.hook || (t.hook = {}), n = 0; n < nn.length; n++) {
       var r = nn[n],
        i = e[r],
        o = en[r];
       i === o || i && i._merged || (e[r] = i ? sn(o, i) : o)
      }
     }
 
     function sn(t, e) {
      var n = function(n, r) {
       t(n, r), e(n, r)
      };
      return n._merged = !0, n
     }
 
     function un(t, e) {
      var n = t.model && t.model.prop || "value",
       r = t.model && t.model.event || "input";
      (e.attrs || (e.attrs = {}))[n] = e.model.value;
      var o = e.on || (e.on = {}),
       a = o[r],
       s = e.model.callback;
      i(a) ? (Array.isArray(a) ? -1 === a.indexOf(s) : a !== s) && (o[r] = [s].concat(a)) : o[r] = s
     }
     var cn = 1,
      ln = 2;
 
     function hn(t, e, n, r, i, a) {
      return (Array.isArray(n) || s(n)) && (i = r, r = n, n = void 0), o(a) && (i = ln), pn(t, e, n, r, i)
     }
 
     function pn(t, e, n, r, o) {
      if (i(n) && i(n.__ob__)) return wt();
      if (i(n) && i(n.is) && (e = n.is), !e) return wt();
      var a, s, u;
      (Array.isArray(r) && "function" === typeof r[0] && (n = n || {}, n.scopedSlots = {
       default: r[0]
      }, r.length = 0), o === ln ? r = ke(r) : o === cn && (r = Ee(r)), "string" === typeof e) ? (s = t.$vnode && t.$vnode.ns || V.getTagNamespace(e), a = V.isReservedTag(e) ? new bt(V.parsePlatformTagName(e), n, r, void 0, void 0, t) : n && n.pre || !i(u = Xt(t.$options, "components", e)) ? new bt(e, n, r, void 0, void 0, t) : rn(u, n, t, r, e)) : a = rn(e, n, t, r);
      return Array.isArray(a) ? a : i(a) ? (i(s) && fn(a, s), i(n) && dn(n), a) : wt()
     }
 
     function fn(t, e, n) {
      if (t.ns = e, "foreignObject" === t.tag && (e = void 0, n = !0), i(t.children))
       for (var a = 0, s = t.children.length; a < s; a++) {
        var u = t.children[a];
        i(u.tag) && (r(u.ns) || o(n) && "svg" !== u.tag) && fn(u, e, n)
       }
     }
 
     function dn(t) {
      u(t.style) && me(t.style), u(t.class) && me(t.class)
     }
 
     function vn(t) {
      t._vnode = null, t._staticTrees = null;
      var e = t.$options,
       r = t.$vnode = e._parentVnode,
       i = r && r.context;
      t.$slots = Te(e._renderChildren, i), t.$scopedSlots = n, t._c = function(e, n, r, i) {
       return hn(t, e, n, r, i, !1)
      }, t.$createElement = function(e, n, r, i) {
       return hn(t, e, n, r, i, !0)
      };
      var o = r && r.data;
      Ft(t, "$attrs", o && o.attrs || n, null, !0), Ft(t, "$listeners", e._parentListeners || n, null, !0)
     }
     var mn, gn = null;
 
     function yn(t) {
      Ye(t.prototype), t.prototype.$nextTick = function(t) {
       return de(t, this)
      }, t.prototype._render = function() {
       var t, e = this,
        n = e.$options,
        r = n.render,
        i = n._parentVnode;
       i && (e.$scopedSlots = De(i.data.scopedSlots, e.$slots, e.$scopedSlots)), e.$vnode = i;
       try {
        gn = e, t = r.call(e._renderProxy, e.$createElement)
       } catch (Sa) {
        ee(Sa, e, "render"), t = e._vnode
       } finally {
        gn = null
       }
       return Array.isArray(t) && 1 === t.length && (t = t[0]), t instanceof bt || (t = wt()), t.parent = i, t
      }
     }
 
     function bn(t, e) {
      return (t.__esModule || pt && "Module" === t[Symbol.toStringTag]) && (t = t.default), u(t) ? e.extend(t) : t
     }
 
     function xn(t, e, n, r, i) {
      var o = wt();
      return o.asyncFactory = t, o.asyncMeta = {
       data: e,
       context: n,
       children: r,
       tag: i
      }, o
     }
 
     function wn(t, e) {
      if (o(t.error) && i(t.errorComp)) return t.errorComp;
      if (i(t.resolved)) return t.resolved;
      var n = gn;
      if (n && i(t.owners) && -1 === t.owners.indexOf(n) && t.owners.push(n), o(t.loading) && i(t.loadingComp)) return t.loadingComp;
      if (n && !i(t.owners)) {
       var a = t.owners = [n],
        s = !0,
        c = null,
        l = null;
       n.$on("hook:destroyed", (function() {
        return y(a, n)
       }));
       var h = function(t) {
         for (var e = 0, n = a.length; e < n; e++) a[e].$forceUpdate();
         t && (a.length = 0, null !== c && (clearTimeout(c), c = null), null !== l && (clearTimeout(l), l = null))
        },
        p = P((function(n) {
         t.resolved = bn(n, e), s ? a.length = 0 : h(!0)
        })),
        d = P((function(e) {
         i(t.errorComp) && (t.error = !0, h(!0))
        })),
        v = t(p, d);
       return u(v) && (f(v) ? r(t.resolved) && v.then(p, d) : f(v.component) && (v.component.then(p, d), i(v.error) && (t.errorComp = bn(v.error, e)), i(v.loading) && (t.loadingComp = bn(v.loading, e), 0 === v.delay ? t.loading = !0 : c = setTimeout((function() {
        c = null, r(t.resolved) && r(t.error) && (t.loading = !0, h(!1))
       }), v.delay || 200)), i(v.timeout) && (l = setTimeout((function() {
        l = null, r(t.resolved) && d(null)
       }), v.timeout)))), s = !1, t.loading ? t.loadingComp : t.resolved
      }
     }
 
     function Cn(t) {
      return t.isComment && t.asyncFactory
     }
 
     function Sn(t) {
      if (Array.isArray(t))
       for (var e = 0; e < t.length; e++) {
        var n = t[e];
        if (i(n) && (i(n.componentOptions) || Cn(n))) return n
       }
     }
 
     function En(t) {
      t._events = Object.create(null), t._hasHookEvent = !1;
      var e = t.$options._parentListeners;
      e && An(t, e)
     }
 
     function kn(t, e) {
      mn.$on(t, e)
     }
 
     function In(t, e) {
      mn.$off(t, e)
     }
 
     function On(t, e) {
      var n = mn;
      return function r() {
       var i = e.apply(null, arguments);
       null !== i && n.$off(t, r)
      }
     }
 
     function An(t, e, n) {
      mn = t, xe(e, n || {}, kn, In, On, t), mn = void 0
     }
 
     function Nn(t) {
      var e = /^hook:/;
      t.prototype.$on = function(t, n) {
       var r = this;
       if (Array.isArray(t))
        for (var i = 0, o = t.length; i < o; i++) r.$on(t[i], n);
       else(r._events[t] || (r._events[t] = [])).push(n), e.test(t) && (r._hasHookEvent = !0);
       return r
      }, t.prototype.$once = function(t, e) {
       var n = this;
 
       function r() {
        n.$off(t, r), e.apply(n, arguments)
       }
       return r.fn = e, n.$on(t, r), n
      }, t.prototype.$off = function(t, e) {
       var n = this;
       if (!arguments.length) return n._events = Object.create(null), n;
       if (Array.isArray(t)) {
        for (var r = 0, i = t.length; r < i; r++) n.$off(t[r], e);
        return n
       }
       var o, a = n._events[t];
       if (!a) return n;
       if (!e) return n._events[t] = null, n;
       var s = a.length;
       while (s--)
        if (o = a[s], o === e || o.fn === e) {
         a.splice(s, 1);
         break
        } return n
      }, t.prototype.$emit = function(t) {
       var e = this,
        n = e._events[t];
       if (n) {
        n = n.length > 1 ? R(n) : n;
        for (var r = R(arguments, 1), i = 'event handler for "' + t + '"', o = 0, a = n.length; o < a; o++) ne(n[o], e, r, e, i)
       }
       return e
      }
     }
     var Rn = null;
 
     function Tn(t) {
      var e = Rn;
      return Rn = t,
       function() {
        Rn = e
       }
     }
 
     function _n(t) {
      var e = t.$options,
       n = e.parent;
      if (n && !e.abstract) {
       while (n.$options.abstract && n.$parent) n = n.$parent;
       n.$children.push(t)
      }
      t.$parent = n, t.$root = n ? n.$root : t, t.$children = [], t.$refs = {}, t._watcher = null, t._inactive = null, t._directInactive = !1, t._isMounted = !1, t._isDestroyed = !1, t._isBeingDestroyed = !1
     }
 
     function Dn(t) {
      t.prototype._update = function(t, e) {
       var n = this,
        r = n.$el,
        i = n._vnode,
        o = Tn(n);
       n._vnode = t, n.$el = i ? n.__patch__(i, t) : n.__patch__(n.$el, t, e, !1), o(), r && (r.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el)
      }, t.prototype.$forceUpdate = function() {
       var t = this;
       t._watcher && t._watcher.update()
      }, t.prototype.$destroy = function() {
       var t = this;
       if (!t._isBeingDestroyed) {
        zn(t, "beforeDestroy"), t._isBeingDestroyed = !0;
        var e = t.$parent;
        !e || e._isBeingDestroyed || t.$options.abstract || y(e.$children, t), t._watcher && t._watcher.teardown();
        var n = t._watchers.length;
        while (n--) t._watchers[n].teardown();
        t._data.__ob__ && t._data.__ob__.vmCount--, t._isDestroyed = !0, t.__patch__(t._vnode, null), zn(t, "destroyed"), t.$off(), t.$el && (t.$el.__vue__ = null), t.$vnode && (t.$vnode.parent = null)
       }
      }
     }
 
     function Fn(t, e, n) {
      var r;
      return t.$el = e, t.$options.render || (t.$options.render = wt), zn(t, "beforeMount"), r = function() {
       t._update(t._render(), n)
      }, new nr(t, r, D, {
       before: function() {
        t._isMounted && !t._isDestroyed && zn(t, "beforeUpdate")
       }
      }, !0), n = !1, null == t.$vnode && (t._isMounted = !0, zn(t, "mounted")), t
     }
 
     function Mn(t, e, r, i, o) {
      var a = i.data.scopedSlots,
       s = t.$scopedSlots,
       u = !!(a && !a.$stable || s !== n && !s.$stable || a && t.$scopedSlots.$key !== a.$key),
       c = !!(o || t.$options._renderChildren || u);
      if (t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i), t.$options._renderChildren = o, t.$attrs = i.data.attrs || n, t.$listeners = r || n, e && t.$options.props) {
       Nt(!1);
       for (var l = t._props, h = t.$options._propKeys || [], p = 0; p < h.length; p++) {
        var f = h[p],
         d = t.$options.props;
        l[f] = Yt(f, d, e, t)
       }
       Nt(!0), t.$options.propsData = e
      }
      r = r || n;
      var v = t.$options._parentListeners;
      t.$options._parentListeners = r, An(t, r, v), c && (t.$slots = Te(o, i.context), t.$forceUpdate())
     }
 
     function Ln(t) {
      while (t && (t = t.$parent))
       if (t._inactive) return !0;
      return !1
     }
 
     function Bn(t, e) {
      if (e) {
       if (t._directInactive = !1, Ln(t)) return
      } else if (t._directInactive) return;
      if (t._inactive || null === t._inactive) {
       t._inactive = !1;
       for (var n = 0; n < t.$children.length; n++) Bn(t.$children[n]);
       zn(t, "activated")
      }
     }
 
     function Pn(t, e) {
      if ((!e || (t._directInactive = !0, !Ln(t))) && !t._inactive) {
       t._inactive = !0;
       for (var n = 0; n < t.$children.length; n++) Pn(t.$children[n]);
       zn(t, "deactivated")
      }
     }
 
     function zn(t, e) {
      gt();
      var n = t.$options[e],
       r = e + " hook";
      if (n)
       for (var i = 0, o = n.length; i < o; i++) ne(n[i], t, null, t, r);
      t._hasHookEvent && t.$emit("hook:" + e), yt()
     }
     var jn = [],
      Wn = [],
      Vn = {},
      Un = !1,
      Hn = !1,
      $n = 0;
 
     function Gn() {
      $n = jn.length = Wn.length = 0, Vn = {}, Un = Hn = !1
     }
     var qn = 0,
      Kn = Date.now;
     if (Y && !tt) {
      var Xn = window.performance;
      Xn && "function" === typeof Xn.now && Kn() > document.createEvent("Event").timeStamp && (Kn = function() {
       return Xn.now()
      })
     }
 
     function Yn() {
      var t, e;
      for (qn = Kn(), Hn = !0, jn.sort((function(t, e) {
        return t.id - e.id
       })), $n = 0; $n < jn.length; $n++) t = jn[$n], t.before && t.before(), e = t.id, Vn[e] = null, t.run();
      var n = Wn.slice(),
       r = jn.slice();
      Gn(), Qn(n), Zn(r), ct && V.devtools && ct.emit("flush")
     }
 
     function Zn(t) {
      var e = t.length;
      while (e--) {
       var n = t[e],
        r = n.vm;
       r._watcher === n && r._isMounted && !r._isDestroyed && zn(r, "updated")
      }
     }
 
     function Jn(t) {
      t._inactive = !1, Wn.push(t)
     }
 
     function Qn(t) {
      for (var e = 0; e < t.length; e++) t[e]._inactive = !0, Bn(t[e], !0)
     }
 
     function tr(t) {
      var e = t.id;
      if (null == Vn[e]) {
       if (Vn[e] = !0, Hn) {
        var n = jn.length - 1;
        while (n > $n && jn[n].id > t.id) n--;
        jn.splice(n + 1, 0, t)
       } else jn.push(t);
       Un || (Un = !0, de(Yn))
      }
     }
     var er = 0,
      nr = function(t, e, n, r, i) {
       this.vm = t, i && (t._watcher = this), t._watchers.push(this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++er, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ht, this.newDepIds = new ht, this.expression = "", "function" === typeof e ? this.getter = e : (this.getter = q(e), this.getter || (this.getter = D)), this.value = this.lazy ? void 0 : this.get()
      };
     nr.prototype.get = function() {
      var t;
      gt(this);
      var e = this.vm;
      try {
       t = this.getter.call(e, e)
      } catch (Sa) {
       if (!this.user) throw Sa;
       ee(Sa, e, 'getter for watcher "' + this.expression + '"')
      } finally {
       this.deep && me(t), yt(), this.cleanupDeps()
      }
      return t
     }, nr.prototype.addDep = function(t) {
      var e = t.id;
      this.newDepIds.has(e) || (this.newDepIds.add(e), this.newDeps.push(t), this.depIds.has(e) || t.addSub(this))
     }, nr.prototype.cleanupDeps = function() {
      var t = this.deps.length;
      while (t--) {
       var e = this.deps[t];
       this.newDepIds.has(e.id) || e.removeSub(this)
      }
      var n = this.depIds;
      this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0
     }, nr.prototype.update = function() {
      this.lazy ? this.dirty = !0 : this.sync ? this.run() : tr(this)
     }, nr.prototype.run = function() {
      if (this.active) {
       var t = this.get();
       if (t !== this.value || u(t) || this.deep) {
        var e = this.value;
        if (this.value = t, this.user) try {
         this.cb.call(this.vm, t, e)
        } catch (Sa) {
         ee(Sa, this.vm, 'callback for watcher "' + this.expression + '"')
        } else this.cb.call(this.vm, t, e)
       }
      }
     }, nr.prototype.evaluate = function() {
      this.value = this.get(), this.dirty = !1
     }, nr.prototype.depend = function() {
      var t = this.deps.length;
      while (t--) this.deps[t].depend()
     }, nr.prototype.teardown = function() {
      if (this.active) {
       this.vm._isBeingDestroyed || y(this.vm._watchers, this);
       var t = this.deps.length;
       while (t--) this.deps[t].removeSub(this);
       this.active = !1
      }
     };
     var rr = {
      enumerable: !0,
      configurable: !0,
      get: D,
      set: D
     };
 
     function ir(t, e, n) {
      rr.get = function() {
       return this[e][n]
      }, rr.set = function(t) {
       this[e][n] = t
      }, Object.defineProperty(t, n, rr)
     }
 
     function or(t) {
      t._watchers = [];
      var e = t.$options;
      e.props && ar(t, e.props), e.methods && dr(t, e.methods), e.data ? sr(t) : Dt(t._data = {}, !0), e.computed && lr(t, e.computed), e.watch && e.watch !== ot && vr(t, e.watch)
     }
 
     function ar(t, e) {
      var n = t.$options.propsData || {},
       r = t._props = {},
       i = t.$options._propKeys = [],
       o = !t.$parent;
      o || Nt(!1);
      var a = function(o) {
       i.push(o);
       var a = Yt(o, e, n, t);
       Ft(r, o, a), o in t || ir(t, "_props", o)
      };
      for (var s in e) a(s);
      Nt(!0)
     }
 
     function sr(t) {
      var e = t.$options.data;
      e = t._data = "function" === typeof e ? ur(e, t) : e || {}, l(e) || (e = {});
      var n = Object.keys(e),
       r = t.$options.props,
       i = (t.$options.methods, n.length);
      while (i--) {
       var o = n[i];
       0, r && x(r, o) || H(o) || ir(t, "_data", o)
      }
      Dt(e, !0)
     }
 
     function ur(t, e) {
      gt();
      try {
       return t.call(e, e)
      } catch (Sa) {
       return ee(Sa, e, "data()"), {}
      } finally {
       yt()
      }
     }
     var cr = {
      lazy: !0
     };
 
     function lr(t, e) {
      var n = t._computedWatchers = Object.create(null),
       r = ut();
      for (var i in e) {
       var o = e[i],
        a = "function" === typeof o ? o : o.get;
       0, r || (n[i] = new nr(t, a || D, D, cr)), i in t || hr(t, i, o)
      }
     }
 
     function hr(t, e, n) {
      var r = !ut();
      "function" === typeof n ? (rr.get = r ? pr(e) : fr(n), rr.set = D) : (rr.get = n.get ? r && !1 !== n.cache ? pr(e) : fr(n.get) : D, rr.set = n.set || D), Object.defineProperty(t, e, rr)
     }
 
     function pr(t) {
      return function() {
       var e = this._computedWatchers && this._computedWatchers[t];
       if (e) return e.dirty && e.evaluate(), vt.target && e.depend(), e.value
      }
     }
 
     function fr(t) {
      return function() {
       return t.call(this, this)
      }
     }
 
     function dr(t, e) {
      t.$options.props;
      for (var n in e) t[n] = "function" !== typeof e[n] ? D : N(e[n], t)
     }
 
     function vr(t, e) {
      for (var n in e) {
       var r = e[n];
       if (Array.isArray(r))
        for (var i = 0; i < r.length; i++) mr(t, n, r[i]);
       else mr(t, n, r)
      }
     }
 
     function mr(t, e, n, r) {
      return l(n) && (r = n, n = n.handler), "string" === typeof n && (n = t[n]), t.$watch(e, n, r)
     }
 
     function gr(t) {
      var e = {
        get: function() {
         return this._data
        }
       },
       n = {
        get: function() {
         return this._props
        }
       };
      Object.defineProperty(t.prototype, "$data", e), Object.defineProperty(t.prototype, "$props", n), t.prototype.$set = Mt, t.prototype.$delete = Lt, t.prototype.$watch = function(t, e, n) {
       var r = this;
       if (l(e)) return mr(r, t, e, n);
       n = n || {}, n.user = !0;
       var i = new nr(r, t, e, n);
       if (n.immediate) try {
        e.call(r, i.value)
       } catch (o) {
        ee(o, r, 'callback for immediate watcher "' + i.expression + '"')
       }
       return function() {
        i.teardown()
       }
      }
     }
     var yr = 0;
 
     function br(t) {
      t.prototype._init = function(t) {
       var e = this;
       e._uid = yr++, e._isVue = !0, t && t._isComponent ? xr(e, t) : e.$options = Kt(wr(e.constructor), t || {}, e), e._renderProxy = e, e._self = e, _n(e), En(e), vn(e), zn(e, "beforeCreate"), Ne(e), or(e), Ae(e), zn(e, "created"), e.$options.el && e.$mount(e.$options.el)
      }
     }
 
     function xr(t, e) {
      var n = t.$options = Object.create(t.constructor.options),
       r = e._parentVnode;
      n.parent = e.parent, n._parentVnode = r;
      var i = r.componentOptions;
      n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag = i.tag, e.render && (n.render = e.render, n.staticRenderFns = e.staticRenderFns)
     }
 
     function wr(t) {
      var e = t.options;
      if (t.super) {
       var n = wr(t.super),
        r = t.superOptions;
       if (n !== r) {
        t.superOptions = n;
        var i = Cr(t);
        i && T(t.extendOptions, i), e = t.options = Kt(n, t.extendOptions), e.name && (e.components[e.name] = t)
       }
      }
      return e
     }
 
     function Cr(t) {
      var e, n = t.options,
       r = t.sealedOptions;
      for (var i in n) n[i] !== r[i] && (e || (e = {}), e[i] = n[i]);
      return e
     }
 
     function Sr(t) {
      this._init(t)
     }
 
     function Er(t) {
      t.use = function(t) {
       var e = this._installedPlugins || (this._installedPlugins = []);
       if (e.indexOf(t) > -1) return this;
       var n = R(arguments, 1);
       return n.unshift(this), "function" === typeof t.install ? t.install.apply(t, n) : "function" === typeof t && t.apply(null, n), e.push(t), this
      }
     }
 
     function kr(t) {
      t.mixin = function(t) {
       return this.options = Kt(this.options, t), this
      }
     }
 
     function Ir(t) {
      t.cid = 0;
      var e = 1;
      t.extend = function(t) {
       t = t || {};
       var n = this,
        r = n.cid,
        i = t._Ctor || (t._Ctor = {});
       if (i[r]) return i[r];
       var o = t.name || n.options.name;
       var a = function(t) {
        this._init(t)
       };
       return a.prototype = Object.create(n.prototype), a.prototype.constructor = a, a.cid = e++, a.options = Kt(n.options, t), a["super"] = n, a.options.props && Or(a), a.options.computed && Ar(a), a.extend = n.extend, a.mixin = n.mixin, a.use = n.use, j.forEach((function(t) {
        a[t] = n[t]
       })), o && (a.options.components[o] = a), a.superOptions = n.options, a.extendOptions = t, a.sealedOptions = T({}, a.options), i[r] = a, a
      }
     }
 
     function Or(t) {
      var e = t.options.props;
      for (var n in e) ir(t.prototype, "_props", n)
     }
 
     function Ar(t) {
      var e = t.options.computed;
      for (var n in e) hr(t.prototype, n, e[n])
     }
 
     function Nr(t) {
      j.forEach((function(e) {
       t[e] = function(t, n) {
        return n ? ("component" === e && l(n) && (n.name = n.name || t, n = this.options._base.extend(n)), "directive" === e && "function" === typeof n && (n = {
         bind: n,
         update: n
        }), this.options[e + "s"][t] = n, n) : this.options[e + "s"][t]
       }
      }))
     }
 
     function Rr(t) {
      return t && (t.Ctor.options.name || t.tag)
     }
 
     function Tr(t, e) {
      return Array.isArray(t) ? t.indexOf(e) > -1 : "string" === typeof t ? t.split(",").indexOf(e) > -1 : !!h(t) && t.test(e)
     }
 
     function _r(t, e) {
      var n = t.cache,
       r = t.keys,
       i = t._vnode;
      for (var o in n) {
       var a = n[o];
       if (a) {
        var s = Rr(a.componentOptions);
        s && !e(s) && Dr(n, o, r, i)
       }
      }
     }
 
     function Dr(t, e, n, r) {
      var i = t[e];
      !i || r && i.tag === r.tag || i.componentInstance.$destroy(), t[e] = null, y(n, e)
     }
     br(Sr), gr(Sr), Nn(Sr), Dn(Sr), yn(Sr);
     var Fr = [String, RegExp, Array],
      Mr = {
       name: "keep-alive",
       abstract: !0,
       props: {
        include: Fr,
        exclude: Fr,
        max: [String, Number]
       },
       created: function() {
        this.cache = Object.create(null), this.keys = []
       },
       destroyed: function() {
        for (var t in this.cache) Dr(this.cache, t, this.keys)
       },
       mounted: function() {
        var t = this;
        this.$watch("include", (function(e) {
         _r(t, (function(t) {
          return Tr(e, t)
         }))
        })), this.$watch("exclude", (function(e) {
         _r(t, (function(t) {
          return !Tr(e, t)
         }))
        }))
       },
       render: function() {
        var t = this.$slots.default,
         e = Sn(t),
         n = e && e.componentOptions;
        if (n) {
         var r = Rr(n),
          i = this,
          o = i.include,
          a = i.exclude;
         if (o && (!r || !Tr(o, r)) || a && r && Tr(a, r)) return e;
         var s = this,
          u = s.cache,
          c = s.keys,
          l = null == e.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : e.key;
         u[l] ? (e.componentInstance = u[l].componentInstance, y(c, l), c.push(l)) : (u[l] = e, c.push(l), this.max && c.length > parseInt(this.max) && Dr(u, c[0], c, this._vnode)), e.data.keepAlive = !0
        }
        return e || t && t[0]
       }
      },
      Lr = {
       KeepAlive: Mr
      };
 
     function Br(t) {
      var e = {
       get: function() {
        return V
       }
      };
      Object.defineProperty(t, "config", e), t.util = {
       warn: ft,
       extend: T,
       mergeOptions: Kt,
       defineReactive: Ft
      }, t.set = Mt, t.delete = Lt, t.nextTick = de, t.observable = function(t) {
       return Dt(t), t
      }, t.options = Object.create(null), j.forEach((function(e) {
       t.options[e + "s"] = Object.create(null)
      })), t.options._base = t, T(t.options.components, Lr), Er(t), kr(t), Ir(t), Nr(t)
     }
     Br(Sr), Object.defineProperty(Sr.prototype, "$isServer", {
      get: ut
     }), Object.defineProperty(Sr.prototype, "$ssrContext", {
      get: function() {
       return this.$vnode && this.$vnode.ssrContext
      }
     }), Object.defineProperty(Sr, "FunctionalRenderContext", {
      value: Ze
     }), Sr.version = "2.6.11";
     var Pr = m("style,class"),
      zr = m("input,textarea,option,select,progress"),
      jr = function(t, e, n) {
       return "value" === n && zr(t) && "button" !== e || "selected" === n && "option" === t || "checked" === n && "input" === t || "muted" === n && "video" === t
      },
      Wr = m("contenteditable,draggable,spellcheck"),
      Vr = m("events,caret,typing,plaintext-only"),
      Ur = function(t, e) {
       return Kr(e) || "false" === e ? "false" : "contenteditable" === t && Vr(e) ? e : "true"
      },
      Hr = m("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),
      $r = "http://www.w3.org/1999/xlink",
      Gr = function(t) {
       return ":" === t.charAt(5) && "xlink" === t.slice(0, 5)
      },
      qr = function(t) {
       return Gr(t) ? t.slice(6, t.length) : ""
      },
      Kr = function(t) {
       return null == t || !1 === t
      };
 
     function Xr(t) {
      var e = t.data,
       n = t,
       r = t;
      while (i(r.componentInstance)) r = r.componentInstance._vnode, r && r.data && (e = Yr(r.data, e));
      while (i(n = n.parent)) n && n.data && (e = Yr(e, n.data));
      return Zr(e.staticClass, e.class)
     }
 
     function Yr(t, e) {
      return {
       staticClass: Jr(t.staticClass, e.staticClass),
       class: i(t.class) ? [t.class, e.class] : e.class
      }
     }
 
     function Zr(t, e) {
      return i(t) || i(e) ? Jr(t, Qr(e)) : ""
     }
 
     function Jr(t, e) {
      return t ? e ? t + " " + e : t : e || ""
     }
 
     function Qr(t) {
      return Array.isArray(t) ? ti(t) : u(t) ? ei(t) : "string" === typeof t ? t : ""
     }
 
     function ti(t) {
      for (var e, n = "", r = 0, o = t.length; r < o; r++) i(e = Qr(t[r])) && "" !== e && (n && (n += " "), n += e);
      return n
     }
 
     function ei(t) {
      var e = "";
      for (var n in t) t[n] && (e && (e += " "), e += n);
      return e
     }
     var ni = {
       svg: "http://www.w3.org/2000/svg",
       math: "http://www.w3.org/1998/Math/MathML"
      },
      ri = m("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),
      ii = m("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0),
      oi = function(t) {
       return ri(t) || ii(t)
      };
 
     function ai(t) {
      return ii(t) ? "svg" : "math" === t ? "math" : void 0
     }
     var si = Object.create(null);
 
     function ui(t) {
      if (!Y) return !0;
      if (oi(t)) return !1;
      if (t = t.toLowerCase(), null != si[t]) return si[t];
      var e = document.createElement(t);
      return t.indexOf("-") > -1 ? si[t] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : si[t] = /HTMLUnknownElement/.test(e.toString())
     }
     var ci = m("text,number,password,search,email,tel,url");
 
     function li(t) {
      if ("string" === typeof t) {
       var e = document.querySelector(t);
       return e || document.createElement("div")
      }
      return t
     }
 
     function hi(t, e) {
      var n = document.createElement(t);
      return "select" !== t ? n : (e.data && e.data.attrs && void 0 !== e.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n)
     }
 
     function pi(t, e) {
      return document.createElementNS(ni[t], e)
     }
 
     function fi(t) {
      return document.createTextNode(t)
     }
 
     function di(t) {
      return document.createComment(t)
     }
 
     function vi(t, e, n) {
      t.insertBefore(e, n)
     }
 
     function mi(t, e) {
      t.removeChild(e)
     }
 
     function gi(t, e) {
      t.appendChild(e)
     }
 
     function yi(t) {
      return t.parentNode
     }
 
     function bi(t) {
      return t.nextSibling
     }
 
     function xi(t) {
      return t.tagName
     }
 
     function wi(t, e) {
      t.textContent = e
     }
 
     function Ci(t, e) {
      t.setAttribute(e, "")
     }
     var Si = Object.freeze({
       createElement: hi,
       createElementNS: pi,
       createTextNode: fi,
       createComment: di,
       insertBefore: vi,
       removeChild: mi,
       appendChild: gi,
       parentNode: yi,
       nextSibling: bi,
       tagName: xi,
       setTextContent: wi,
       setStyleScope: Ci
      }),
      Ei = {
       create: function(t, e) {
        ki(e)
       },
       update: function(t, e) {
        t.data.ref !== e.data.ref && (ki(t, !0), ki(e))
       },
       destroy: function(t) {
        ki(t, !0)
       }
      };
 
     function ki(t, e) {
      var n = t.data.ref;
      if (i(n)) {
       var r = t.context,
        o = t.componentInstance || t.elm,
        a = r.$refs;
       e ? Array.isArray(a[n]) ? y(a[n], o) : a[n] === o && (a[n] = void 0) : t.data.refInFor ? Array.isArray(a[n]) ? a[n].indexOf(o) < 0 && a[n].push(o) : a[n] = [o] : a[n] = o
      }
     }
     var Ii = new bt("", {}, []),
      Oi = ["create", "activate", "update", "remove", "destroy"];
 
     function Ai(t, e) {
      return t.key === e.key && (t.tag === e.tag && t.isComment === e.isComment && i(t.data) === i(e.data) && Ni(t, e) || o(t.isAsyncPlaceholder) && t.asyncFactory === e.asyncFactory && r(e.asyncFactory.error))
     }
 
     function Ni(t, e) {
      if ("input" !== t.tag) return !0;
      var n, r = i(n = t.data) && i(n = n.attrs) && n.type,
       o = i(n = e.data) && i(n = n.attrs) && n.type;
      return r === o || ci(r) && ci(o)
     }
 
     function Ri(t, e, n) {
      var r, o, a = {};
      for (r = e; r <= n; ++r) o = t[r].key, i(o) && (a[o] = r);
      return a
     }
 
     function Ti(t) {
      var e, n, a = {},
       u = t.modules,
       c = t.nodeOps;
      for (e = 0; e < Oi.length; ++e)
       for (a[Oi[e]] = [], n = 0; n < u.length; ++n) i(u[n][Oi[e]]) && a[Oi[e]].push(u[n][Oi[e]]);
 
      function l(t) {
       return new bt(c.tagName(t).toLowerCase(), {}, [], void 0, t)
      }
 
      function h(t, e) {
       function n() {
        0 === --n.listeners && p(t)
       }
       return n.listeners = e, n
      }
 
      function p(t) {
       var e = c.parentNode(t);
       i(e) && c.removeChild(e, t)
      }
 
      function f(t, e, n, r, a, s, u) {
       if (i(t.elm) && i(s) && (t = s[u] = St(t)), t.isRootInsert = !a, !d(t, e, n, r)) {
        var l = t.data,
         h = t.children,
         p = t.tag;
        i(p) ? (t.elm = t.ns ? c.createElementNS(t.ns, p) : c.createElement(p, t), C(t), b(t, h, e), i(l) && w(t, e), y(n, t.elm, r)) : o(t.isComment) ? (t.elm = c.createComment(t.text), y(n, t.elm, r)) : (t.elm = c.createTextNode(t.text), y(n, t.elm, r))
       }
      }
 
      function d(t, e, n, r) {
       var a = t.data;
       if (i(a)) {
        var s = i(t.componentInstance) && a.keepAlive;
        if (i(a = a.hook) && i(a = a.init) && a(t, !1), i(t.componentInstance)) return v(t, e), y(n, t.elm, r), o(s) && g(t, e, n, r), !0
       }
      }
 
      function v(t, e) {
       i(t.data.pendingInsert) && (e.push.apply(e, t.data.pendingInsert), t.data.pendingInsert = null), t.elm = t.componentInstance.$el, x(t) ? (w(t, e), C(t)) : (ki(t), e.push(t))
      }
 
      function g(t, e, n, r) {
       var o, s = t;
       while (s.componentInstance)
        if (s = s.componentInstance._vnode, i(o = s.data) && i(o = o.transition)) {
         for (o = 0; o < a.activate.length; ++o) a.activate[o](Ii, s);
         e.push(s);
         break
        } y(n, t.elm, r)
      }
 
      function y(t, e, n) {
       i(t) && (i(n) ? c.parentNode(n) === t && c.insertBefore(t, e, n) : c.appendChild(t, e))
      }
 
      function b(t, e, n) {
       if (Array.isArray(e)) {
        0;
        for (var r = 0; r < e.length; ++r) f(e[r], n, t.elm, null, !0, e, r)
       } else s(t.text) && c.appendChild(t.elm, c.createTextNode(String(t.text)))
      }
 
      function x(t) {
       while (t.componentInstance) t = t.componentInstance._vnode;
       return i(t.tag)
      }
 
      function w(t, n) {
       for (var r = 0; r < a.create.length; ++r) a.create[r](Ii, t);
       e = t.data.hook, i(e) && (i(e.create) && e.create(Ii, t), i(e.insert) && n.push(t))
      }
 
      function C(t) {
       var e;
       if (i(e = t.fnScopeId)) c.setStyleScope(t.elm, e);
       else {
        var n = t;
        while (n) i(e = n.context) && i(e = e.$options._scopeId) && c.setStyleScope(t.elm, e), n = n.parent
       }
       i(e = Rn) && e !== t.context && e !== t.fnContext && i(e = e.$options._scopeId) && c.setStyleScope(t.elm, e)
      }
 
      function S(t, e, n, r, i, o) {
       for (; r <= i; ++r) f(n[r], o, t, e, !1, n, r)
      }
 
      function E(t) {
       var e, n, r = t.data;
       if (i(r))
        for (i(e = r.hook) && i(e = e.destroy) && e(t), e = 0; e < a.destroy.length; ++e) a.destroy[e](t);
       if (i(e = t.children))
        for (n = 0; n < t.children.length; ++n) E(t.children[n])
      }
 
      function k(t, e, n) {
       for (; e <= n; ++e) {
        var r = t[e];
        i(r) && (i(r.tag) ? (I(r), E(r)) : p(r.elm))
       }
      }
 
      function I(t, e) {
       if (i(e) || i(t.data)) {
        var n, r = a.remove.length + 1;
        for (i(e) ? e.listeners += r : e = h(t.elm, r), i(n = t.componentInstance) && i(n = n._vnode) && i(n.data) && I(n, e), n = 0; n < a.remove.length; ++n) a.remove[n](t, e);
        i(n = t.data.hook) && i(n = n.remove) ? n(t, e) : e()
       } else p(t.elm)
      }
 
      function O(t, e, n, o, a) {
       var s, u, l, h, p = 0,
        d = 0,
        v = e.length - 1,
        m = e[0],
        g = e[v],
        y = n.length - 1,
        b = n[0],
        x = n[y],
        w = !a;
       while (p <= v && d <= y) r(m) ? m = e[++p] : r(g) ? g = e[--v] : Ai(m, b) ? (N(m, b, o, n, d), m = e[++p], b = n[++d]) : Ai(g, x) ? (N(g, x, o, n, y), g = e[--v], x = n[--y]) : Ai(m, x) ? (N(m, x, o, n, y), w && c.insertBefore(t, m.elm, c.nextSibling(g.elm)), m = e[++p], x = n[--y]) : Ai(g, b) ? (N(g, b, o, n, d), w && c.insertBefore(t, g.elm, m.elm), g = e[--v], b = n[++d]) : (r(s) && (s = Ri(e, p, v)), u = i(b.key) ? s[b.key] : A(b, e, p, v), r(u) ? f(b, o, t, m.elm, !1, n, d) : (l = e[u], Ai(l, b) ? (N(l, b, o, n, d), e[u] = void 0, w && c.insertBefore(t, l.elm, m.elm)) : f(b, o, t, m.elm, !1, n, d)), b = n[++d]);
       p > v ? (h = r(n[y + 1]) ? null : n[y + 1].elm, S(t, h, n, d, y, o)) : d > y && k(e, p, v)
      }
 
      function A(t, e, n, r) {
       for (var o = n; o < r; o++) {
        var a = e[o];
        if (i(a) && Ai(t, a)) return o
       }
      }
 
      function N(t, e, n, s, u, l) {
       if (t !== e) {
        i(e.elm) && i(s) && (e = s[u] = St(e));
        var h = e.elm = t.elm;
        if (o(t.isAsyncPlaceholder)) i(e.asyncFactory.resolved) ? _(t.elm, e, n) : e.isAsyncPlaceholder = !0;
        else if (o(e.isStatic) && o(t.isStatic) && e.key === t.key && (o(e.isCloned) || o(e.isOnce))) e.componentInstance = t.componentInstance;
        else {
         var p, f = e.data;
         i(f) && i(p = f.hook) && i(p = p.prepatch) && p(t, e);
         var d = t.children,
          v = e.children;
         if (i(f) && x(e)) {
          for (p = 0; p < a.update.length; ++p) a.update[p](t, e);
          i(p = f.hook) && i(p = p.update) && p(t, e)
         }
         r(e.text) ? i(d) && i(v) ? d !== v && O(h, d, v, n, l) : i(v) ? (i(t.text) && c.setTextContent(h, ""), S(h, null, v, 0, v.length - 1, n)) : i(d) ? k(d, 0, d.length - 1) : i(t.text) && c.setTextContent(h, "") : t.text !== e.text && c.setTextContent(h, e.text), i(f) && i(p = f.hook) && i(p = p.postpatch) && p(t, e)
        }
       }
      }
 
      function R(t, e, n) {
       if (o(n) && i(t.parent)) t.parent.data.pendingInsert = e;
       else
        for (var r = 0; r < e.length; ++r) e[r].data.hook.insert(e[r])
      }
      var T = m("attrs,class,staticClass,staticStyle,key");
 
      function _(t, e, n, r) {
       var a, s = e.tag,
        u = e.data,
        c = e.children;
       if (r = r || u && u.pre, e.elm = t, o(e.isComment) && i(e.asyncFactory)) return e.isAsyncPlaceholder = !0, !0;
       if (i(u) && (i(a = u.hook) && i(a = a.init) && a(e, !0), i(a = e.componentInstance))) return v(e, n), !0;
       if (i(s)) {
        if (i(c))
         if (t.hasChildNodes())
          if (i(a = u) && i(a = a.domProps) && i(a = a.innerHTML)) {
           if (a !== t.innerHTML) return !1
          } else {
           for (var l = !0, h = t.firstChild, p = 0; p < c.length; p++) {
            if (!h || !_(h, c[p], n, r)) {
             l = !1;
             break
            }
            h = h.nextSibling
           }
           if (!l || h) return !1
          }
        else b(e, c, n);
        if (i(u)) {
         var f = !1;
         for (var d in u)
          if (!T(d)) {
           f = !0, w(e, n);
           break
          }! f && u["class"] && me(u["class"])
        }
       } else t.data !== e.text && (t.data = e.text);
       return !0
      }
      return function(t, e, n, s) {
       if (!r(e)) {
        var u = !1,
         h = [];
        if (r(t)) u = !0, f(e, h);
        else {
         var p = i(t.nodeType);
         if (!p && Ai(t, e)) N(t, e, h, null, null, s);
         else {
          if (p) {
           if (1 === t.nodeType && t.hasAttribute(z) && (t.removeAttribute(z), n = !0), o(n) && _(t, e, h)) return R(e, h, !0), t;
           t = l(t)
          }
          var d = t.elm,
           v = c.parentNode(d);
          if (f(e, h, d._leaveCb ? null : v, c.nextSibling(d)), i(e.parent)) {
           var m = e.parent,
            g = x(e);
           while (m) {
            for (var y = 0; y < a.destroy.length; ++y) a.destroy[y](m);
            if (m.elm = e.elm, g) {
             for (var b = 0; b < a.create.length; ++b) a.create[b](Ii, m);
             var w = m.data.hook.insert;
             if (w.merged)
              for (var C = 1; C < w.fns.length; C++) w.fns[C]()
            } else ki(m);
            m = m.parent
           }
          }
          i(v) ? k([t], 0, 0) : i(t.tag) && E(t)
         }
        }
        return R(e, h, u), e.elm
       }
       i(t) && E(t)
      }
     }
     var _i = {
      create: Di,
      update: Di,
      destroy: function(t) {
       Di(t, Ii)
      }
     };
 
     function Di(t, e) {
      (t.data.directives || e.data.directives) && Fi(t, e)
     }
 
     function Fi(t, e) {
      var n, r, i, o = t === Ii,
       a = e === Ii,
       s = Li(t.data.directives, t.context),
       u = Li(e.data.directives, e.context),
       c = [],
       l = [];
      for (n in u) r = s[n], i = u[n], r ? (i.oldValue = r.value, i.oldArg = r.arg, Pi(i, "update", e, t), i.def && i.def.componentUpdated && l.push(i)) : (Pi(i, "bind", e, t), i.def && i.def.inserted && c.push(i));
      if (c.length) {
       var h = function() {
        for (var n = 0; n < c.length; n++) Pi(c[n], "inserted", e, t)
       };
       o ? we(e, "insert", h) : h()
      }
      if (l.length && we(e, "postpatch", (function() {
        for (var n = 0; n < l.length; n++) Pi(l[n], "componentUpdated", e, t)
       })), !o)
       for (n in s) u[n] || Pi(s[n], "unbind", t, t, a)
     }
     var Mi = Object.create(null);
 
     function Li(t, e) {
      var n, r, i = Object.create(null);
      if (!t) return i;
      for (n = 0; n < t.length; n++) r = t[n], r.modifiers || (r.modifiers = Mi), i[Bi(r)] = r, r.def = Xt(e.$options, "directives", r.name, !0);
      return i
     }
 
     function Bi(t) {
      return t.rawName || t.name + "." + Object.keys(t.modifiers || {}).join(".")
     }
 
     function Pi(t, e, n, r, i) {
      var o = t.def && t.def[e];
      if (o) try {
       o(n.elm, t, n, r, i)
      } catch (Sa) {
       ee(Sa, n.context, "directive " + t.name + " " + e + " hook")
      }
     }
     var zi = [Ei, _i];
 
     function ji(t, e) {
      var n = e.componentOptions;
      if ((!i(n) || !1 !== n.Ctor.options.inheritAttrs) && (!r(t.data.attrs) || !r(e.data.attrs))) {
       var o, a, s, u = e.elm,
        c = t.data.attrs || {},
        l = e.data.attrs || {};
       for (o in i(l.__ob__) && (l = e.data.attrs = T({}, l)), l) a = l[o], s = c[o], s !== a && Wi(u, o, a);
       for (o in (tt || nt) && l.value !== c.value && Wi(u, "value", l.value), c) r(l[o]) && (Gr(o) ? u.removeAttributeNS($r, qr(o)) : Wr(o) || u.removeAttribute(o))
      }
     }
 
     function Wi(t, e, n) {
      t.tagName.indexOf("-") > -1 ? Vi(t, e, n) : Hr(e) ? Kr(n) ? t.removeAttribute(e) : (n = "allowfullscreen" === e && "EMBED" === t.tagName ? "true" : e, t.setAttribute(e, n)) : Wr(e) ? t.setAttribute(e, Ur(e, n)) : Gr(e) ? Kr(n) ? t.removeAttributeNS($r, qr(e)) : t.setAttributeNS($r, e, n) : Vi(t, e, n)
     }
 
     function Vi(t, e, n) {
      if (Kr(n)) t.removeAttribute(e);
      else {
       if (tt && !et && "TEXTAREA" === t.tagName && "placeholder" === e && "" !== n && !t.__ieph) {
        var r = function(e) {
         e.stopImmediatePropagation(), t.removeEventListener("input", r)
        };
        t.addEventListener("input", r), t.__ieph = !0
       }
       t.setAttribute(e, n)
      }
     }
     var Ui = {
      create: ji,
      update: ji
     };
 
     function Hi(t, e) {
      var n = e.elm,
       o = e.data,
       a = t.data;
      if (!(r(o.staticClass) && r(o.class) && (r(a) || r(a.staticClass) && r(a.class)))) {
       var s = Xr(e),
        u = n._transitionClasses;
       i(u) && (s = Jr(s, Qr(u))), s !== n._prevClass && (n.setAttribute("class", s), n._prevClass = s)
      }
     }
     var $i, Gi = {
       create: Hi,
       update: Hi
      },
      qi = "__r",
      Ki = "__c";
 
     function Xi(t) {
      if (i(t[qi])) {
       var e = tt ? "change" : "input";
       t[e] = [].concat(t[qi], t[e] || []), delete t[qi]
      }
      i(t[Ki]) && (t.change = [].concat(t[Ki], t.change || []), delete t[Ki])
     }
 
     function Yi(t, e, n) {
      var r = $i;
      return function i() {
       var o = e.apply(null, arguments);
       null !== o && Qi(t, i, n, r)
      }
     }
     var Zi = ae && !(it && Number(it[1]) <= 53);
 
     function Ji(t, e, n, r) {
      if (Zi) {
       var i = qn,
        o = e;
       e = o._wrapper = function(t) {
        if (t.target === t.currentTarget || t.timeStamp >= i || t.timeStamp <= 0 || t.target.ownerDocument !== document) return o.apply(this, arguments)
       }
      }
      $i.addEventListener(t, e, at ? {
       capture: n,
       passive: r
      } : n)
     }
 
     function Qi(t, e, n, r) {
      (r || $i).removeEventListener(t, e._wrapper || e, n)
     }
 
     function to(t, e) {
      if (!r(t.data.on) || !r(e.data.on)) {
       var n = e.data.on || {},
        i = t.data.on || {};
       $i = e.elm, Xi(n), xe(n, i, Ji, Qi, Yi, e.context), $i = void 0
      }
     }
     var eo, no = {
      create: to,
      update: to
     };
 
     function ro(t, e) {
      if (!r(t.data.domProps) || !r(e.data.domProps)) {
       var n, o, a = e.elm,
        s = t.data.domProps || {},
        u = e.data.domProps || {};
       for (n in i(u.__ob__) && (u = e.data.domProps = T({}, u)), s) n in u || (a[n] = "");
       for (n in u) {
        if (o = u[n], "textContent" === n || "innerHTML" === n) {
         if (e.children && (e.children.length = 0), o === s[n]) continue;
         1 === a.childNodes.length && a.removeChild(a.childNodes[0])
        }
        if ("value" === n && "PROGRESS" !== a.tagName) {
         a._value = o;
         var c = r(o) ? "" : String(o);
         io(a, c) && (a.value = c)
        } else if ("innerHTML" === n && ii(a.tagName) && r(a.innerHTML)) {
         eo = eo || document.createElement("div"), eo.innerHTML = "<svg>" + o + "</svg>";
         var l = eo.firstChild;
         while (a.firstChild) a.removeChild(a.firstChild);
         while (l.firstChild) a.appendChild(l.firstChild)
        } else if (o !== s[n]) try {
         a[n] = o
        } catch (Sa) {}
       }
      }
     }
 
     function io(t, e) {
      return !t.composing && ("OPTION" === t.tagName || oo(t, e) || ao(t, e))
     }
 
     function oo(t, e) {
      var n = !0;
      try {
       n = document.activeElement !== t
      } catch (Sa) {}
      return n && t.value !== e
     }
 
     function ao(t, e) {
      var n = t.value,
       r = t._vModifiers;
      if (i(r)) {
       if (r.number) return v(n) !== v(e);
       if (r.trim) return n.trim() !== e.trim()
      }
      return n !== e
     }
     var so = {
       create: ro,
       update: ro
      },
      uo = w((function(t) {
       var e = {},
        n = /;(?![^(]*\))/g,
        r = /:(.+)/;
       return t.split(n).forEach((function(t) {
        if (t) {
         var n = t.split(r);
         n.length > 1 && (e[n[0].trim()] = n[1].trim())
        }
       })), e
      }));
 
     function co(t) {
      var e = lo(t.style);
      return t.staticStyle ? T(t.staticStyle, e) : e
     }
 
     function lo(t) {
      return Array.isArray(t) ? _(t) : "string" === typeof t ? uo(t) : t
     }
 
     function ho(t, e) {
      var n, r = {};
      if (e) {
       var i = t;
       while (i.componentInstance) i = i.componentInstance._vnode, i && i.data && (n = co(i.data)) && T(r, n)
      }(n = co(t.data)) && T(r, n);
      var o = t;
      while (o = o.parent) o.data && (n = co(o.data)) && T(r, n);
      return r
     }
     var po, fo = /^--/,
      vo = /\s*!important$/,
      mo = function(t, e, n) {
       if (fo.test(e)) t.style.setProperty(e, n);
       else if (vo.test(n)) t.style.setProperty(I(e), n.replace(vo, ""), "important");
       else {
        var r = yo(e);
        if (Array.isArray(n))
         for (var i = 0, o = n.length; i < o; i++) t.style[r] = n[i];
        else t.style[r] = n
       }
      },
      go = ["Webkit", "Moz", "ms"],
      yo = w((function(t) {
       if (po = po || document.createElement("div").style, t = S(t), "filter" !== t && t in po) return t;
       for (var e = t.charAt(0).toUpperCase() + t.slice(1), n = 0; n < go.length; n++) {
        var r = go[n] + e;
        if (r in po) return r
       }
      }));
 
     function bo(t, e) {
      var n = e.data,
       o = t.data;
      if (!(r(n.staticStyle) && r(n.style) && r(o.staticStyle) && r(o.style))) {
       var a, s, u = e.elm,
        c = o.staticStyle,
        l = o.normalizedStyle || o.style || {},
        h = c || l,
        p = lo(e.data.style) || {};
       e.data.normalizedStyle = i(p.__ob__) ? T({}, p) : p;
       var f = ho(e, !0);
       for (s in h) r(f[s]) && mo(u, s, "");
       for (s in f) a = f[s], a !== h[s] && mo(u, s, null == a ? "" : a)
      }
     }
     var xo = {
       create: bo,
       update: bo
      },
      wo = /\s+/;
 
     function Co(t, e) {
      if (e && (e = e.trim()))
       if (t.classList) e.indexOf(" ") > -1 ? e.split(wo).forEach((function(e) {
        return t.classList.add(e)
       })) : t.classList.add(e);
       else {
        var n = " " + (t.getAttribute("class") || "") + " ";
        n.indexOf(" " + e + " ") < 0 && t.setAttribute("class", (n + e).trim())
       }
     }
 
     function So(t, e) {
      if (e && (e = e.trim()))
       if (t.classList) e.indexOf(" ") > -1 ? e.split(wo).forEach((function(e) {
        return t.classList.remove(e)
       })) : t.classList.remove(e), t.classList.length || t.removeAttribute("class");
       else {
        var n = " " + (t.getAttribute("class") || "") + " ",
         r = " " + e + " ";
        while (n.indexOf(r) >= 0) n = n.replace(r, " ");
        n = n.trim(), n ? t.setAttribute("class", n) : t.removeAttribute("class")
       }
     }
 
     function Eo(t) {
      if (t) {
       if ("object" === typeof t) {
        var e = {};
        return !1 !== t.css && T(e, ko(t.name || "v")), T(e, t), e
       }
       return "string" === typeof t ? ko(t) : void 0
      }
     }
     var ko = w((function(t) {
       return {
        enterClass: t + "-enter",
        enterToClass: t + "-enter-to",
        enterActiveClass: t + "-enter-active",
        leaveClass: t + "-leave",
        leaveToClass: t + "-leave-to",
        leaveActiveClass: t + "-leave-active"
       }
      })),
      Io = Y && !et,
      Oo = "transition",
      Ao = "animation",
      No = "transition",
      Ro = "transitionend",
      To = "animation",
      _o = "animationend";
     Io && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (No = "WebkitTransition", Ro = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (To = "WebkitAnimation", _o = "webkitAnimationEnd"));
     var Do = Y ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(t) {
      return t()
     };
 
     function Fo(t) {
      Do((function() {
       Do(t)
      }))
     }
 
     function Mo(t, e) {
      var n = t._transitionClasses || (t._transitionClasses = []);
      n.indexOf(e) < 0 && (n.push(e), Co(t, e))
     }
 
     function Lo(t, e) {
      t._transitionClasses && y(t._transitionClasses, e), So(t, e)
     }
 
     function Bo(t, e, n) {
      var r = zo(t, e),
       i = r.type,
       o = r.timeout,
       a = r.propCount;
      if (!i) return n();
      var s = i === Oo ? Ro : _o,
       u = 0,
       c = function() {
        t.removeEventListener(s, l), n()
       },
       l = function(e) {
        e.target === t && ++u >= a && c()
       };
      setTimeout((function() {
       u < a && c()
      }), o + 1), t.addEventListener(s, l)
     }
     var Po = /\b(transform|all)(,|$)/;
 
     function zo(t, e) {
      var n, r = window.getComputedStyle(t),
       i = (r[No + "Delay"] || "").split(", "),
       o = (r[No + "Duration"] || "").split(", "),
       a = jo(i, o),
       s = (r[To + "Delay"] || "").split(", "),
       u = (r[To + "Duration"] || "").split(", "),
       c = jo(s, u),
       l = 0,
       h = 0;
      e === Oo ? a > 0 && (n = Oo, l = a, h = o.length) : e === Ao ? c > 0 && (n = Ao, l = c, h = u.length) : (l = Math.max(a, c), n = l > 0 ? a > c ? Oo : Ao : null, h = n ? n === Oo ? o.length : u.length : 0);
      var p = n === Oo && Po.test(r[No + "Property"]);
      return {
       type: n,
       timeout: l,
       propCount: h,
       hasTransform: p
      }
     }
 
     function jo(t, e) {
      while (t.length < e.length) t = t.concat(t);
      return Math.max.apply(null, e.map((function(e, n) {
       return Wo(e) + Wo(t[n])
      })))
     }
 
     function Wo(t) {
      return 1e3 * Number(t.slice(0, -1).replace(",", "."))
     }
 
     function Vo(t, e) {
      var n = t.elm;
      i(n._leaveCb) && (n._leaveCb.cancelled = !0, n._leaveCb());
      var o = Eo(t.data.transition);
      if (!r(o) && !i(n._enterCb) && 1 === n.nodeType) {
       var a = o.css,
        s = o.type,
        c = o.enterClass,
        l = o.enterToClass,
        h = o.enterActiveClass,
        p = o.appearClass,
        f = o.appearToClass,
        d = o.appearActiveClass,
        m = o.beforeEnter,
        g = o.enter,
        y = o.afterEnter,
        b = o.enterCancelled,
        x = o.beforeAppear,
        w = o.appear,
        C = o.afterAppear,
        S = o.appearCancelled,
        E = o.duration,
        k = Rn,
        I = Rn.$vnode;
       while (I && I.parent) k = I.context, I = I.parent;
       var O = !k._isMounted || !t.isRootInsert;
       if (!O || w || "" === w) {
        var A = O && p ? p : c,
         N = O && d ? d : h,
         R = O && f ? f : l,
         T = O && x || m,
         _ = O && "function" === typeof w ? w : g,
         D = O && C || y,
         F = O && S || b,
         M = v(u(E) ? E.enter : E);
        0;
        var L = !1 !== a && !et,
         B = $o(_),
         z = n._enterCb = P((function() {
          L && (Lo(n, R), Lo(n, N)), z.cancelled ? (L && Lo(n, A), F && F(n)) : D && D(n), n._enterCb = null
         }));
        t.data.show || we(t, "insert", (function() {
         var e = n.parentNode,
          r = e && e._pending && e._pending[t.key];
         r && r.tag === t.tag && r.elm._leaveCb && r.elm._leaveCb(), _ && _(n, z)
        })), T && T(n), L && (Mo(n, A), Mo(n, N), Fo((function() {
         Lo(n, A), z.cancelled || (Mo(n, R), B || (Ho(M) ? setTimeout(z, M) : Bo(n, s, z)))
        }))), t.data.show && (e && e(), _ && _(n, z)), L || B || z()
       }
      }
     }
 
     function Uo(t, e) {
      var n = t.elm;
      i(n._enterCb) && (n._enterCb.cancelled = !0, n._enterCb());
      var o = Eo(t.data.transition);
      if (r(o) || 1 !== n.nodeType) return e();
      if (!i(n._leaveCb)) {
       var a = o.css,
        s = o.type,
        c = o.leaveClass,
        l = o.leaveToClass,
        h = o.leaveActiveClass,
        p = o.beforeLeave,
        f = o.leave,
        d = o.afterLeave,
        m = o.leaveCancelled,
        g = o.delayLeave,
        y = o.duration,
        b = !1 !== a && !et,
        x = $o(f),
        w = v(u(y) ? y.leave : y);
       0;
       var C = n._leaveCb = P((function() {
        n.parentNode && n.parentNode._pending && (n.parentNode._pending[t.key] = null), b && (Lo(n, l), Lo(n, h)), C.cancelled ? (b && Lo(n, c), m && m(n)) : (e(), d && d(n)), n._leaveCb = null
       }));
       g ? g(S) : S()
      }
 
      function S() {
       C.cancelled || (!t.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[t.key] = t), p && p(n), b && (Mo(n, c), Mo(n, h), Fo((function() {
        Lo(n, c), C.cancelled || (Mo(n, l), x || (Ho(w) ? setTimeout(C, w) : Bo(n, s, C)))
       }))), f && f(n, C), b || x || C())
      }
     }
 
     function Ho(t) {
      return "number" === typeof t && !isNaN(t)
     }
 
     function $o(t) {
      if (r(t)) return !1;
      var e = t.fns;
      return i(e) ? $o(Array.isArray(e) ? e[0] : e) : (t._length || t.length) > 1
     }
 
     function Go(t, e) {
      !0 !== e.data.show && Vo(e)
     }
     var qo = Y ? {
       create: Go,
       activate: Go,
       remove: function(t, e) {
        !0 !== t.data.show ? Uo(t, e) : e()
       }
      } : {},
      Ko = [Ui, Gi, no, so, xo, qo],
      Xo = Ko.concat(zi),
      Yo = Ti({
       nodeOps: Si,
       modules: Xo
      });
     et && document.addEventListener("selectionchange", (function() {
      var t = document.activeElement;
      t && t.vmodel && ia(t, "input")
     }));
     var Zo = {
      inserted: function(t, e, n, r) {
       "select" === n.tag ? (r.elm && !r.elm._vOptions ? we(n, "postpatch", (function() {
        Zo.componentUpdated(t, e, n)
       })) : Jo(t, e, n.context), t._vOptions = [].map.call(t.options, ea)) : ("textarea" === n.tag || ci(t.type)) && (t._vModifiers = e.modifiers, e.modifiers.lazy || (t.addEventListener("compositionstart", na), t.addEventListener("compositionend", ra), t.addEventListener("change", ra), et && (t.vmodel = !0)))
      },
      componentUpdated: function(t, e, n) {
       if ("select" === n.tag) {
        Jo(t, e, n.context);
        var r = t._vOptions,
         i = t._vOptions = [].map.call(t.options, ea);
        if (i.some((function(t, e) {
          return !L(t, r[e])
         }))) {
         var o = t.multiple ? e.value.some((function(t) {
          return ta(t, i)
         })) : e.value !== e.oldValue && ta(e.value, i);
         o && ia(t, "change")
        }
       }
      }
     };
 
     function Jo(t, e, n) {
      Qo(t, e, n), (tt || nt) && setTimeout((function() {
       Qo(t, e, n)
      }), 0)
     }
 
     function Qo(t, e, n) {
      var r = e.value,
       i = t.multiple;
      if (!i || Array.isArray(r)) {
       for (var o, a, s = 0, u = t.options.length; s < u; s++)
        if (a = t.options[s], i) o = B(r, ea(a)) > -1, a.selected !== o && (a.selected = o);
        else if (L(ea(a), r)) return void(t.selectedIndex !== s && (t.selectedIndex = s));
       i || (t.selectedIndex = -1)
      }
     }
 
     function ta(t, e) {
      return e.every((function(e) {
       return !L(e, t)
      }))
     }
 
     function ea(t) {
      return "_value" in t ? t._value : t.value
     }
 
     function na(t) {
      t.target.composing = !0
     }
 
     function ra(t) {
      t.target.composing && (t.target.composing = !1, ia(t.target, "input"))
     }
 
     function ia(t, e) {
      var n = document.createEvent("HTMLEvents");
      n.initEvent(e, !0, !0), t.dispatchEvent(n)
     }
 
     function oa(t) {
      return !t.componentInstance || t.data && t.data.transition ? t : oa(t.componentInstance._vnode)
     }
     var aa = {
       bind: function(t, e, n) {
        var r = e.value;
        n = oa(n);
        var i = n.data && n.data.transition,
         o = t.__vOriginalDisplay = "none" === t.style.display ? "" : t.style.display;
        r && i ? (n.data.show = !0, Vo(n, (function() {
         t.style.display = o
        }))) : t.style.display = r ? o : "none"
       },
       update: function(t, e, n) {
        var r = e.value,
         i = e.oldValue;
        if (!r !== !i) {
         n = oa(n);
         var o = n.data && n.data.transition;
         o ? (n.data.show = !0, r ? Vo(n, (function() {
          t.style.display = t.__vOriginalDisplay
         })) : Uo(n, (function() {
          t.style.display = "none"
         }))) : t.style.display = r ? t.__vOriginalDisplay : "none"
        }
       },
       unbind: function(t, e, n, r, i) {
        i || (t.style.display = t.__vOriginalDisplay)
       }
      },
      sa = {
       model: Zo,
       show: aa
      },
      ua = {
       name: String,
       appear: Boolean,
       css: Boolean,
       mode: String,
       type: String,
       enterClass: String,
       leaveClass: String,
       enterToClass: String,
       leaveToClass: String,
       enterActiveClass: String,
       leaveActiveClass: String,
       appearClass: String,
       appearActiveClass: String,
       appearToClass: String,
       duration: [Number, String, Object]
      };
 
     function ca(t) {
      var e = t && t.componentOptions;
      return e && e.Ctor.options.abstract ? ca(Sn(e.children)) : t
     }
 
     function la(t) {
      var e = {},
       n = t.$options;
      for (var r in n.propsData) e[r] = t[r];
      var i = n._parentListeners;
      for (var o in i) e[S(o)] = i[o];
      return e
     }
 
     function ha(t, e) {
      if (/\d-keep-alive$/.test(e.tag)) return t("keep-alive", {
       props: e.componentOptions.propsData
      })
     }
 
     function pa(t) {
      while (t = t.parent)
       if (t.data.transition) return !0
     }
 
     function fa(t, e) {
      return e.key === t.key && e.tag === t.tag
     }
     var da = function(t) {
       return t.tag || Cn(t)
      },
      va = function(t) {
       return "show" === t.name
      },
      ma = {
       name: "transition",
       props: ua,
       abstract: !0,
       render: function(t) {
        var e = this,
         n = this.$slots.default;
        if (n && (n = n.filter(da), n.length)) {
         0;
         var r = this.mode;
         0;
         var i = n[0];
         if (pa(this.$vnode)) return i;
         var o = ca(i);
         if (!o) return i;
         if (this._leaving) return ha(t, i);
         var a = "__transition-" + this._uid + "-";
         o.key = null == o.key ? o.isComment ? a + "comment" : a + o.tag : s(o.key) ? 0 === String(o.key).indexOf(a) ? o.key : a + o.key : o.key;
         var u = (o.data || (o.data = {})).transition = la(this),
          c = this._vnode,
          l = ca(c);
         if (o.data.directives && o.data.directives.some(va) && (o.data.show = !0), l && l.data && !fa(o, l) && !Cn(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) {
          var h = l.data.transition = T({}, u);
          if ("out-in" === r) return this._leaving = !0, we(h, "afterLeave", (function() {
           e._leaving = !1, e.$forceUpdate()
          })), ha(t, i);
          if ("in-out" === r) {
           if (Cn(o)) return c;
           var p, f = function() {
            p()
           };
           we(u, "afterEnter", f), we(u, "enterCancelled", f), we(h, "delayLeave", (function(t) {
            p = t
           }))
          }
         }
         return i
        }
       }
      },
      ga = T({
       tag: String,
       moveClass: String
      }, ua);
     delete ga.mode;
     var ya = {
      props: ga,
      beforeMount: function() {
       var t = this,
        e = this._update;
       this._update = function(n, r) {
        var i = Tn(t);
        t.__patch__(t._vnode, t.kept, !1, !0), t._vnode = t.kept, i(), e.call(t, n, r)
       }
      },
      render: function(t) {
       for (var e = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), r = this.prevChildren = this.children, i = this.$slots.default || [], o = this.children = [], a = la(this), s = 0; s < i.length; s++) {
        var u = i[s];
        if (u.tag)
         if (null != u.key && 0 !== String(u.key).indexOf("__vlist")) o.push(u), n[u.key] = u, (u.data || (u.data = {})).transition = a;
         else;
       }
       if (r) {
        for (var c = [], l = [], h = 0; h < r.length; h++) {
         var p = r[h];
         p.data.transition = a, p.data.pos = p.elm.getBoundingClientRect(), n[p.key] ? c.push(p) : l.push(p)
        }
        this.kept = t(e, null, c), this.removed = l
       }
       return t(e, null, o)
      },
      updated: function() {
       var t = this.prevChildren,
        e = this.moveClass || (this.name || "v") + "-move";
       t.length && this.hasMove(t[0].elm, e) && (t.forEach(ba), t.forEach(xa), t.forEach(wa), this._reflow = document.body.offsetHeight, t.forEach((function(t) {
        if (t.data.moved) {
         var n = t.elm,
          r = n.style;
         Mo(n, e), r.transform = r.WebkitTransform = r.transitionDuration = "", n.addEventListener(Ro, n._moveCb = function t(r) {
          r && r.target !== n || r && !/transform$/.test(r.propertyName) || (n.removeEventListener(Ro, t), n._moveCb = null, Lo(n, e))
         })
        }
       })))
      },
      methods: {
       hasMove: function(t, e) {
        if (!Io) return !1;
        if (this._hasMove) return this._hasMove;
        var n = t.cloneNode();
        t._transitionClasses && t._transitionClasses.forEach((function(t) {
         So(n, t)
        })), Co(n, e), n.style.display = "none", this.$el.appendChild(n);
        var r = zo(n);
        return this.$el.removeChild(n), this._hasMove = r.hasTransform
       }
      }
     };
 
     function ba(t) {
      t.elm._moveCb && t.elm._moveCb(), t.elm._enterCb && t.elm._enterCb()
     }
 
     function xa(t) {
      t.data.newPos = t.elm.getBoundingClientRect()
     }
 
     function wa(t) {
      var e = t.data.pos,
       n = t.data.newPos,
       r = e.left - n.left,
       i = e.top - n.top;
      if (r || i) {
       t.data.moved = !0;
       var o = t.elm.style;
       o.transform = o.WebkitTransform = "translate(" + r + "px," + i + "px)", o.transitionDuration = "0s"
      }
     }
     var Ca = {
      Transition: ma,
      TransitionGroup: ya
     };
     Sr.config.mustUseProp = jr, Sr.config.isReservedTag = oi, Sr.config.isReservedAttr = Pr, Sr.config.getTagNamespace = ai, Sr.config.isUnknownElement = ui, T(Sr.options.directives, sa), T(Sr.options.components, Ca), Sr.prototype.__patch__ = Y ? Yo : D, Sr.prototype.$mount = function(t, e) {
      return t = t && Y ? li(t) : void 0, Fn(this, t, e)
     }, Y && setTimeout((function() {
      V.devtools && ct && ct.emit("init", Sr)
     }), 0), e["a"] = Sr
    }).call(this, n("c8ba"))
   },
   "2ca0": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("06cf").f,
     o = n("50c4"),
     a = n("5a34"),
     s = n("1d80"),
     u = n("ab13"),
     c = n("c430"),
     l = "".startsWith,
     h = Math.min,
     p = u("startsWith"),
     f = !c && !p && !! function() {
      var t = i(String.prototype, "startsWith");
      return t && !t.writable
     }();
    r({
     target: "String",
     proto: !0,
     forced: !f && !p
    }, {
     startsWith: function(t) {
      var e = String(s(this));
      a(t);
      var n = o(h(arguments.length > 1 ? arguments[1] : void 0, e.length)),
       r = String(t);
      return l ? l.call(e, r, n) : e.slice(n, n + r.length) === r
     }
    })
   },
   "2cf4": function(t, e, n) {
    var r, i, o, a = n("da84"),
     s = n("d039"),
     u = n("c6b6"),
     c = n("0366"),
     l = n("1be4"),
     h = n("cc12"),
     p = n("1cdc"),
     f = a.location,
     d = a.setImmediate,
     v = a.clearImmediate,
     m = a.process,
     g = a.MessageChannel,
     y = a.Dispatch,
     b = 0,
     x = {},
     w = "onreadystatechange",
     C = function(t) {
      if (x.hasOwnProperty(t)) {
       var e = x[t];
       delete x[t], e()
      }
     },
     S = function(t) {
      return function() {
       C(t)
      }
     },
     E = function(t) {
      C(t.data)
     },
     k = function(t) {
      a.postMessage(t + "", f.protocol + "//" + f.host)
     };
    d && v || (d = function(t) {
     var e = [],
      n = 1;
     while (arguments.length > n) e.push(arguments[n++]);
     return x[++b] = function() {
      ("function" == typeof t ? t : Function(t)).apply(void 0, e)
     }, r(b), b
    }, v = function(t) {
     delete x[t]
    }, "process" == u(m) ? r = function(t) {
     m.nextTick(S(t))
    } : y && y.now ? r = function(t) {
     y.now(S(t))
    } : g && !p ? (i = new g, o = i.port2, i.port1.onmessage = E, r = c(o.postMessage, o, 1)) : !a.addEventListener || "function" != typeof postMessage || a.importScripts || s(k) ? r = w in h("script") ? function(t) {
     l.appendChild(h("script"))[w] = function() {
      l.removeChild(this), C(t)
     }
    } : function(t) {
     setTimeout(S(t), 0)
    } : (r = k, a.addEventListener("message", E, !1))), t.exports = {
     set: d,
     clear: v
    }
   },
   "2d00": function(t, e, n) {
    var r, i, o = n("da84"),
     a = n("342f"),
     s = o.process,
     u = s && s.versions,
     c = u && u.v8;
    c ? (r = c.split("."), i = r[0] + r[1]) : a && (r = a.match(/Edge\/(\d+)/), (!r || r[1] >= 74) && (r = a.match(/Chrome\/(\d+)/), r && (i = r[1]))), t.exports = i && +i
   },
   "2d83": function(t, e, n) {
    "use strict";
    var r = n("387f");
    t.exports = function(t, e, n, i, o) {
     var a = new Error(t);
     return r(a, e, n, i, o)
    }
   },
   "2e67": function(t, e, n) {
    "use strict";
    t.exports = function(t) {
     return !(!t || !t.__CANCEL__)
    }
   },
   "2f62": function(t, e, n) {
    "use strict";
    (function(t) {
     /**
      * vuex v3.1.2
      * (c) 2019 Evan You
      * @license MIT
      */
     function r(t) {
      var e = Number(t.version.split(".")[0]);
      if (e >= 2) t.mixin({
       beforeCreate: r
      });
      else {
       var n = t.prototype._init;
       t.prototype._init = function(t) {
        void 0 === t && (t = {}), t.init = t.init ? [r].concat(t.init) : r, n.call(this, t)
       }
      }
 
      function r() {
       var t = this.$options;
       t.store ? this.$store = "function" === typeof t.store ? t.store() : t.store : t.parent && t.parent.$store && (this.$store = t.parent.$store)
      }
     }
     n.d(e, "b", (function() {
      return T
     }));
     var i = "undefined" !== typeof window ? window : "undefined" !== typeof t ? t : {},
      o = i.__VUE_DEVTOOLS_GLOBAL_HOOK__;
 
     function a(t) {
      o && (t._devtoolHook = o, o.emit("vuex:init", t), o.on("vuex:travel-to-state", (function(e) {
       t.replaceState(e)
      })), t.subscribe((function(t, e) {
       o.emit("vuex:mutation", t, e)
      })))
     }
 
     function s(t, e) {
      Object.keys(t).forEach((function(n) {
       return e(t[n], n)
      }))
     }
 
     function u(t) {
      return null !== t && "object" === typeof t
     }
 
     function c(t) {
      return t && "function" === typeof t.then
     }
 
     function l(t, e) {
      return function() {
       return t(e)
      }
     }
     var h = function(t, e) {
       this.runtime = e, this._children = Object.create(null), this._rawModule = t;
       var n = t.state;
       this.state = ("function" === typeof n ? n() : n) || {}
      },
      p = {
       namespaced: {
        configurable: !0
       }
      };
     p.namespaced.get = function() {
      return !!this._rawModule.namespaced
     }, h.prototype.addChild = function(t, e) {
      this._children[t] = e
     }, h.prototype.removeChild = function(t) {
      delete this._children[t]
     }, h.prototype.getChild = function(t) {
      return this._children[t]
     }, h.prototype.update = function(t) {
      this._rawModule.namespaced = t.namespaced, t.actions && (this._rawModule.actions = t.actions), t.mutations && (this._rawModule.mutations = t.mutations), t.getters && (this._rawModule.getters = t.getters)
     }, h.prototype.forEachChild = function(t) {
      s(this._children, t)
     }, h.prototype.forEachGetter = function(t) {
      this._rawModule.getters && s(this._rawModule.getters, t)
     }, h.prototype.forEachAction = function(t) {
      this._rawModule.actions && s(this._rawModule.actions, t)
     }, h.prototype.forEachMutation = function(t) {
      this._rawModule.mutations && s(this._rawModule.mutations, t)
     }, Object.defineProperties(h.prototype, p);
     var f = function(t) {
      this.register([], t, !1)
     };
 
     function d(t, e, n) {
      if (e.update(n), n.modules)
       for (var r in n.modules) {
        if (!e.getChild(r)) return void 0;
        d(t.concat(r), e.getChild(r), n.modules[r])
       }
     }
     f.prototype.get = function(t) {
      return t.reduce((function(t, e) {
       return t.getChild(e)
      }), this.root)
     }, f.prototype.getNamespace = function(t) {
      var e = this.root;
      return t.reduce((function(t, n) {
       return e = e.getChild(n), t + (e.namespaced ? n + "/" : "")
      }), "")
     }, f.prototype.update = function(t) {
      d([], this.root, t)
     }, f.prototype.register = function(t, e, n) {
      var r = this;
      void 0 === n && (n = !0);
      var i = new h(e, n);
      if (0 === t.length) this.root = i;
      else {
       var o = this.get(t.slice(0, -1));
       o.addChild(t[t.length - 1], i)
      }
      e.modules && s(e.modules, (function(e, i) {
       r.register(t.concat(i), e, n)
      }))
     }, f.prototype.unregister = function(t) {
      var e = this.get(t.slice(0, -1)),
       n = t[t.length - 1];
      e.getChild(n).runtime && e.removeChild(n)
     };
     var v;
     var m = function(t) {
       var e = this;
       void 0 === t && (t = {}), !v && "undefined" !== typeof window && window.Vue && R(window.Vue);
       var n = t.plugins;
       void 0 === n && (n = []);
       var r = t.strict;
       void 0 === r && (r = !1), this._committing = !1, this._actions = Object.create(null), this._actionSubscribers = [], this._mutations = Object.create(null), this._wrappedGetters = Object.create(null), this._modules = new f(t), this._modulesNamespaceMap = Object.create(null), this._subscribers = [], this._watcherVM = new v, this._makeLocalGettersCache = Object.create(null);
       var i = this,
        o = this,
        s = o.dispatch,
        u = o.commit;
       this.dispatch = function(t, e) {
        return s.call(i, t, e)
       }, this.commit = function(t, e, n) {
        return u.call(i, t, e, n)
       }, this.strict = r;
       var c = this._modules.root.state;
       w(this, c, [], this._modules.root), x(this, c), n.forEach((function(t) {
        return t(e)
       }));
       var l = void 0 !== t.devtools ? t.devtools : v.config.devtools;
       l && a(this)
      },
      g = {
       state: {
        configurable: !0
       }
      };
 
     function y(t, e) {
      return e.indexOf(t) < 0 && e.push(t),
       function() {
        var n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
       }
     }
 
     function b(t, e) {
      t._actions = Object.create(null), t._mutations = Object.create(null), t._wrappedGetters = Object.create(null), t._modulesNamespaceMap = Object.create(null);
      var n = t.state;
      w(t, n, [], t._modules.root, !0), x(t, n, e)
     }
 
     function x(t, e, n) {
      var r = t._vm;
      t.getters = {}, t._makeLocalGettersCache = Object.create(null);
      var i = t._wrappedGetters,
       o = {};
      s(i, (function(e, n) {
       o[n] = l(e, t), Object.defineProperty(t.getters, n, {
        get: function() {
         return t._vm[n]
        },
        enumerable: !0
       })
      }));
      var a = v.config.silent;
      v.config.silent = !0, t._vm = new v({
       data: {
        $$state: e
       },
       computed: o
      }), v.config.silent = a, t.strict && O(t), r && (n && t._withCommit((function() {
       r._data.$$state = null
      })), v.nextTick((function() {
       return r.$destroy()
      })))
     }
 
     function w(t, e, n, r, i) {
      var o = !n.length,
       a = t._modules.getNamespace(n);
      if (r.namespaced && (t._modulesNamespaceMap[a], t._modulesNamespaceMap[a] = r), !o && !i) {
       var s = A(e, n.slice(0, -1)),
        u = n[n.length - 1];
       t._withCommit((function() {
        v.set(s, u, r.state)
       }))
      }
      var c = r.context = C(t, a, n);
      r.forEachMutation((function(e, n) {
       var r = a + n;
       E(t, r, e, c)
      })), r.forEachAction((function(e, n) {
       var r = e.root ? n : a + n,
        i = e.handler || e;
       k(t, r, i, c)
      })), r.forEachGetter((function(e, n) {
       var r = a + n;
       I(t, r, e, c)
      })), r.forEachChild((function(r, o) {
       w(t, e, n.concat(o), r, i)
      }))
     }
 
     function C(t, e, n) {
      var r = "" === e,
       i = {
        dispatch: r ? t.dispatch : function(n, r, i) {
         var o = N(n, r, i),
          a = o.payload,
          s = o.options,
          u = o.type;
         return s && s.root || (u = e + u), t.dispatch(u, a)
        },
        commit: r ? t.commit : function(n, r, i) {
         var o = N(n, r, i),
          a = o.payload,
          s = o.options,
          u = o.type;
         s && s.root || (u = e + u), t.commit(u, a, s)
        }
       };
      return Object.defineProperties(i, {
       getters: {
        get: r ? function() {
         return t.getters
        } : function() {
         return S(t, e)
        }
       },
       state: {
        get: function() {
         return A(t.state, n)
        }
       }
      }), i
     }
 
     function S(t, e) {
      if (!t._makeLocalGettersCache[e]) {
       var n = {},
        r = e.length;
       Object.keys(t.getters).forEach((function(i) {
        if (i.slice(0, r) === e) {
         var o = i.slice(r);
         Object.defineProperty(n, o, {
          get: function() {
           return t.getters[i]
          },
          enumerable: !0
         })
        }
       })), t._makeLocalGettersCache[e] = n
      }
      return t._makeLocalGettersCache[e]
     }
 
     function E(t, e, n, r) {
      var i = t._mutations[e] || (t._mutations[e] = []);
      i.push((function(e) {
       n.call(t, r.state, e)
      }))
     }
 
     function k(t, e, n, r) {
      var i = t._actions[e] || (t._actions[e] = []);
      i.push((function(e) {
       var i = n.call(t, {
        dispatch: r.dispatch,
        commit: r.commit,
        getters: r.getters,
        state: r.state,
        rootGetters: t.getters,
        rootState: t.state
       }, e);
       return c(i) || (i = Promise.resolve(i)), t._devtoolHook ? i.catch((function(e) {
        throw t._devtoolHook.emit("vuex:error", e), e
       })) : i
      }))
     }
 
     function I(t, e, n, r) {
      t._wrappedGetters[e] || (t._wrappedGetters[e] = function(t) {
       return n(r.state, r.getters, t.state, t.getters)
      })
     }
 
     function O(t) {
      t._vm.$watch((function() {
       return this._data.$$state
      }), (function() {
       0
      }), {
       deep: !0,
       sync: !0
      })
     }
 
     function A(t, e) {
      return e.length ? e.reduce((function(t, e) {
       return t[e]
      }), t) : t
     }
 
     function N(t, e, n) {
      return u(t) && t.type && (n = e, e = t, t = t.type), {
       type: t,
       payload: e,
       options: n
      }
     }
 
     function R(t) {
      v && t === v || (v = t, r(v))
     }
     g.state.get = function() {
      return this._vm._data.$$state
     }, g.state.set = function(t) {
      0
     }, m.prototype.commit = function(t, e, n) {
      var r = this,
       i = N(t, e, n),
       o = i.type,
       a = i.payload,
       s = (i.options, {
        type: o,
        payload: a
       }),
       u = this._mutations[o];
      u && (this._withCommit((function() {
       u.forEach((function(t) {
        t(a)
       }))
      })), this._subscribers.forEach((function(t) {
       return t(s, r.state)
      })))
     }, m.prototype.dispatch = function(t, e) {
      var n = this,
       r = N(t, e),
       i = r.type,
       o = r.payload,
       a = {
        type: i,
        payload: o
       },
       s = this._actions[i];
      if (s) {
       try {
        this._actionSubscribers.filter((function(t) {
         return t.before
        })).forEach((function(t) {
         return t.before(a, n.state)
        }))
       } catch (c) {
        0
       }
       var u = s.length > 1 ? Promise.all(s.map((function(t) {
        return t(o)
       }))) : s[0](o);
       return u.then((function(t) {
        try {
         n._actionSubscribers.filter((function(t) {
          return t.after
         })).forEach((function(t) {
          return t.after(a, n.state)
         }))
        } catch (c) {
         0
        }
        return t
       }))
      }
     }, m.prototype.subscribe = function(t) {
      return y(t, this._subscribers)
     }, m.prototype.subscribeAction = function(t) {
      var e = "function" === typeof t ? {
       before: t
      } : t;
      return y(e, this._actionSubscribers)
     }, m.prototype.watch = function(t, e, n) {
      var r = this;
      return this._watcherVM.$watch((function() {
       return t(r.state, r.getters)
      }), e, n)
     }, m.prototype.replaceState = function(t) {
      var e = this;
      this._withCommit((function() {
       e._vm._data.$$state = t
      }))
     }, m.prototype.registerModule = function(t, e, n) {
      void 0 === n && (n = {}), "string" === typeof t && (t = [t]), this._modules.register(t, e), w(this, this.state, t, this._modules.get(t), n.preserveState), x(this, this.state)
     }, m.prototype.unregisterModule = function(t) {
      var e = this;
      "string" === typeof t && (t = [t]), this._modules.unregister(t), this._withCommit((function() {
       var n = A(e.state, t.slice(0, -1));
       v.delete(n, t[t.length - 1])
      })), b(this)
     }, m.prototype.hotUpdate = function(t) {
      this._modules.update(t), b(this, !0)
     }, m.prototype._withCommit = function(t) {
      var e = this._committing;
      this._committing = !0, t(), this._committing = e
     }, Object.defineProperties(m.prototype, g);
     var T = P((function(t, e) {
       var n = {};
       return L(e).forEach((function(e) {
        var r = e.key,
         i = e.val;
        n[r] = function() {
         var e = this.$store.state,
          n = this.$store.getters;
         if (t) {
          var r = z(this.$store, "mapState", t);
          if (!r) return;
          e = r.context.state, n = r.context.getters
         }
         return "function" === typeof i ? i.call(this, e, n) : e[i]
        }, n[r].vuex = !0
       })), n
      })),
      _ = P((function(t, e) {
       var n = {};
       return L(e).forEach((function(e) {
        var r = e.key,
         i = e.val;
        n[r] = function() {
         var e = [],
          n = arguments.length;
         while (n--) e[n] = arguments[n];
         var r = this.$store.commit;
         if (t) {
          var o = z(this.$store, "mapMutations", t);
          if (!o) return;
          r = o.context.commit
         }
         return "function" === typeof i ? i.apply(this, [r].concat(e)) : r.apply(this.$store, [i].concat(e))
        }
       })), n
      })),
      D = P((function(t, e) {
       var n = {};
       return L(e).forEach((function(e) {
        var r = e.key,
         i = e.val;
        i = t + i, n[r] = function() {
         if (!t || z(this.$store, "mapGetters", t)) return this.$store.getters[i]
        }, n[r].vuex = !0
       })), n
      })),
      F = P((function(t, e) {
       var n = {};
       return L(e).forEach((function(e) {
        var r = e.key,
         i = e.val;
        n[r] = function() {
         var e = [],
          n = arguments.length;
         while (n--) e[n] = arguments[n];
         var r = this.$store.dispatch;
         if (t) {
          var o = z(this.$store, "mapActions", t);
          if (!o) return;
          r = o.context.dispatch
         }
         return "function" === typeof i ? i.apply(this, [r].concat(e)) : r.apply(this.$store, [i].concat(e))
        }
       })), n
      })),
      M = function(t) {
       return {
        mapState: T.bind(null, t),
        mapGetters: D.bind(null, t),
        mapMutations: _.bind(null, t),
        mapActions: F.bind(null, t)
       }
      };
 
     function L(t) {
      return B(t) ? Array.isArray(t) ? t.map((function(t) {
       return {
        key: t,
        val: t
       }
      })) : Object.keys(t).map((function(e) {
       return {
        key: e,
        val: t[e]
       }
      })) : []
     }
 
     function B(t) {
      return Array.isArray(t) || u(t)
     }
 
     function P(t) {
      return function(e, n) {
       return "string" !== typeof e ? (n = e, e = "") : "/" !== e.charAt(e.length - 1) && (e += "/"), t(e, n)
      }
     }
 
     function z(t, e, n) {
      var r = t._modulesNamespaceMap[n];
      return r
     }
     var j = {
      Store: m,
      install: R,
      version: "3.1.2",
      mapState: T,
      mapMutations: _,
      mapGetters: D,
      mapActions: F,
      createNamespacedHelpers: M
     };
     e["a"] = j
    }).call(this, n("c8ba"))
   },
   "2fa4": function(t, e, n) {
    "use strict";
    n("20f6");
    var r = n("80d2");
    e["a"] = Object(r["g"])("spacer", "div", "v-spacer")
   },
   "30b5": function(t, e, n) {
    "use strict";
    var r = n("c532");
 
    function i(t) {
     return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    t.exports = function(t, e, n) {
     if (!e) return t;
     var o;
     if (n) o = n(e);
     else if (r.isURLSearchParams(e)) o = e.toString();
     else {
      var a = [];
      r.forEach(e, (function(t, e) {
       null !== t && "undefined" !== typeof t && (r.isArray(t) ? e += "[]" : t = [t], r.forEach(t, (function(t) {
        r.isDate(t) ? t = t.toISOString() : r.isObject(t) && (t = JSON.stringify(t)), a.push(i(e) + "=" + i(t))
       })))
      })), o = a.join("&")
     }
     if (o) {
      var s = t.indexOf("#"); - 1 !== s && (t = t.slice(0, s)), t += (-1 === t.indexOf("?") ? "?" : "&") + o
     }
     return t
    }
   },
   3206: function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return s
    }));
    n("99af");
    var r = n("ade3"),
     i = n("2b0e"),
     o = n("d9bd");
 
    function a(t, e) {
     return function() {
      return Object(o["c"])("The ".concat(t, " component must be used inside a ").concat(e))
     }
    }
 
    function s(t, e, n) {
     var o = e && n ? {
      register: a(e, n),
      unregister: a(e, n)
     } : null;
     return i["a"].extend({
      name: "registrable-inject",
      inject: Object(r["a"])({}, t, {
       default: o
      })
     })
    }
   },
   3408: function(t, e, n) {},
   3410: function(t, e, n) {
    var r = n("23e7"),
     i = n("d039"),
     o = n("7b0b"),
     a = n("e163"),
     s = n("e177"),
     u = i((function() {
      a(1)
     }));
    r({
     target: "Object",
     stat: !0,
     forced: u,
     sham: !s
    }, {
     getPrototypeOf: function(t) {
      return a(o(t))
     }
    })
   },
   "342f": function(t, e, n) {
    var r = n("d066");
    t.exports = r("navigator", "userAgent") || ""
   },
   "35a1": function(t, e, n) {
    var r = n("f5df"),
     i = n("3f8c"),
     o = n("b622"),
     a = o("iterator");
    t.exports = function(t) {
     if (void 0 != t) return t[a] || t["@@iterator"] || i[r(t)]
    }
   },
   "368e": function(t, e, n) {},
   "36a7": function(t, e, n) {},
   "377e": function(t, e, n) {
    "use strict";
    (function(t, r) {
     n.d(e, "a", (function() {
      return wt
     }));
     var i = n("45ef"),
      o = function(t, e) {
       return (o = Object.setPrototypeOf || {
         __proto__: []
        }
        instanceof Array && function(t, e) {
         t.__proto__ = e
        } || function(t, e) {
         for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        })(t, e)
      };
     /**
      * @license
      * Copyright 2020 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      */
     function a(t, e) {
      function n() {
       this.constructor = t
      }
      o(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
     }
 
     function s(t, e, n, r) {
      return new(n || (n = Promise))((function(i, o) {
       function a(t) {
        try {
         u(r.next(t))
        } catch (t) {
         o(t)
        }
       }
 
       function s(t) {
        try {
         u(r.throw(t))
        } catch (t) {
         o(t)
        }
       }
 
       function u(t) {
        t.done ? i(t.value) : new n((function(e) {
         e(t.value)
        })).then(a, s)
       }
       u((r = r.apply(t, e || [])).next())
      }))
     }
 
     function u(t, e) {
      var n, r, i, o, a = {
       label: 0,
       sent: function() {
        if (1 & i[0]) throw i[1];
        return i[1]
       },
       trys: [],
       ops: []
      };
      return o = {
       next: s(0),
       throw: s(1),
       return: s(2)
      }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
       return this
      }), o;
 
      function s(o) {
       return function(s) {
        return function(o) {
         if (n) throw new TypeError("Generator is already executing.");
         for (; a;) try {
          if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
          switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
           case 0:
           case 1:
            i = o;
            break;
           case 4:
            return a.label++, {
             value: o[1],
             done: !1
            };
           case 5:
            a.label++, r = o[1], o = [0];
            continue;
           case 7:
            o = a.ops.pop(), a.trys.pop();
            continue;
           default:
            if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
             a = 0;
             continue
            }
            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
             a.label = o[1];
             break
            }
            if (6 === o[0] && a.label < i[1]) {
             a.label = i[1], i = o;
             break
            }
            if (i && a.label < i[2]) {
             a.label = i[2], a.ops.push(o);
             break
            }
            i[2] && a.ops.pop(), a.trys.pop();
            continue
          }
          o = e.call(t, a)
         } catch (t) {
          o = [6, t], r = 0
         } finally {
          n = i = 0
         }
         if (5 & o[0]) throw o[1];
         return {
          value: o[0] ? o[1] : void 0,
          done: !0
         }
        }([o, s])
       }
      }
     }
     "undefined" != typeof window ? window : "undefined" != typeof t || "undefined" != typeof self && self;
 
     function c(t, e) {
      return t(e = {
       exports: {}
      }, e.exports), e.exports
     }
     var l = c((function(t) {
       ! function(t, e, n) {
        function r(t, e) {
         return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e
        }
 
        function i(t, e) {
         var n = new function(t) {
           var e, n = this,
            r = (e = 4022871197, function(t) {
             t = t.toString();
             for (var n = 0; n < t.length; n++) {
              var r = .02519603282416938 * (e += t.charCodeAt(n));
              r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
             }
             return 2.3283064365386963e-10 * (e >>> 0)
            });
           n.next = function() {
            var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
            return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t)
           }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null
          }(t),
          i = e && e.state,
          o = n.next;
         return o.int32 = function() {
          return 4294967296 * n.next() | 0
         }, o.double = function() {
          return o() + 11102230246251565e-32 * (2097152 * o() | 0)
         }, o.quick = o, i && ("object" == typeof i && r(i, n), o.state = function() {
          return r(n, {})
         }), o
        }
        e && e.exports ? e.exports = i : n && n.amd ? n((function() {
         return i
        })) : this.alea = i
       }(0, t, !1)
      })),
      h = c((function(t) {
       ! function(t, e, n) {
        function r(t, e) {
         return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
        }
 
        function i(t, e) {
         var n = new function(t) {
           var e = this,
            n = "";
           e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function() {
            var t = e.x ^ e.x << 11;
            return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8
           }, t === (0 | t) ? e.x = t : n += t;
           for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next()
          }(t),
          i = e && e.state,
          o = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return o.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, o.int32 = n.next, o.quick = o, i && ("object" == typeof i && r(i, n), o.state = function() {
          return r(n, {})
         }), o
        }
        e && e.exports ? e.exports = i : n && n.amd ? n((function() {
         return i
        })) : this.xor128 = i
       }(0, t, !1)
      })),
      p = c((function(t) {
       ! function(t, e, n) {
        function r(t, e) {
         return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e
        }
 
        function i(t, e) {
         var n = new function(t) {
           var e = this,
            n = "";
           e.next = function() {
            var t = e.x ^ e.x >>> 2;
            return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0
           }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;
           for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next()
          }(t),
          i = e && e.state,
          o = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return o.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, o.int32 = n.next, o.quick = o, i && ("object" == typeof i && r(i, n), o.state = function() {
          return r(n, {})
         }), o
        }
        e && e.exports ? e.exports = i : n && n.amd ? n((function() {
         return i
        })) : this.xorwow = i
       }(0, t, !1)
      })),
      f = c((function(t) {
       ! function(t, e, n) {
        function r(t, e) {
         return e.x = t.x.slice(), e.i = t.i, e
        }
 
        function i(t, e) {
         null == t && (t = +new Date);
         var n = new function(t) {
           var e = this;
           e.next = function() {
             var t, n, r = e.x,
              i = e.i;
             return t = r[i], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[i + 1 & 7]) ^ t >>> 10, n ^= (t = r[i + 3 & 7]) ^ t >>> 3, n ^= (t = r[i + 4 & 7]) ^ t << 7, t = r[i + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[i] = n, e.i = i + 1 & 7, n
            },
            function(t, e) {
             var n, r = [];
             if (e === (0 | e)) r[0] = e;
             else
              for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;
             for (; r.length < 8;) r.push(0);
             for (n = 0; n < 8 && 0 === r[n]; ++n);
             for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next()
            }(e, t)
          }(t),
          i = e && e.state,
          o = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return o.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, o.int32 = n.next, o.quick = o, i && (i.x && r(i, n), o.state = function() {
          return r(n, {})
         }), o
        }
        e && e.exports ? e.exports = i : n && n.amd ? n((function() {
         return i
        })) : this.xorshift7 = i
       }(0, t, !1)
      })),
      d = c((function(t) {
       ! function(t, e, n) {
        function r(t, e) {
         return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e
        }
 
        function i(t, e) {
         null == t && (t = +new Date);
         var n = new function(t) {
           var e = this;
           e.next = function() {
             var t, n, r = e.w,
              i = e.X,
              o = e.i;
             return e.w = r = r + 1640531527 | 0, n = i[o + 34 & 127], t = i[o = o + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = i[o] = n ^ t, e.i = o, n + (r ^ r >>> 16) | 0
            },
            function(t, e) {
             var n, r, i, o, a, s = [],
              u = 128;
             for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o) e && (r ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (a = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = 0 == (n = s[127 & o] ^= r + a) ? i + 1 : 0);
             for (i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o) r = s[i + 34 & 127], n = s[i = i + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[i] = r ^ n;
             t.w = a, t.X = s, t.i = i
            }(e, t)
          }(t),
          i = e && e.state,
          o = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return o.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, o.int32 = n.next, o.quick = o, i && (i.X && r(i, n), o.state = function() {
          return r(n, {})
         }), o
        }
        e && e.exports ? e.exports = i : n && n.amd ? n((function() {
         return i
        })) : this.xor4096 = i
       }(0, t, !1)
      })),
      v = c((function(t) {
       ! function(t, e, n) {
        function r(t, e) {
         return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e
        }
 
        function i(t, e) {
         var n = new function(t) {
           var e = this,
            n = "";
           e.next = function() {
            var t = e.b,
             n = e.c,
             r = e.d,
             i = e.a;
            return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ i, e.a = i - t | 0
           }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;
           for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next()
          }(t),
          i = e && e.state,
          o = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return o.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, o.int32 = n.next, o.quick = o, i && ("object" == typeof i && r(i, n), o.state = function() {
          return r(n, {})
         }), o
        }
        e && e.exports ? e.exports = i : n && n.amd ? n((function() {
         return i
        })) : this.tychei = i
       }(0, t, !1)
      })),
      m = c((function(t) {
       ! function(e, r) {
        var i, o = this,
         a = 256,
         s = 6,
         u = "random",
         c = r.pow(a, s),
         l = r.pow(2, 52),
         h = 2 * l,
         p = a - 1;
 
        function f(t, n, f) {
         var g = [],
          y = v(function t(e, n) {
           var r, i = [],
            o = typeof e;
           if (n && "object" == o)
            for (r in e) try {
             i.push(t(e[r], n - 1))
            } catch (t) {}
           return i.length ? i : "string" == o ? e : e + "\0"
          }((n = 1 == n ? {
           entropy: !0
          } : n || {}).entropy ? [t, m(e)] : null == t ? function() {
           try {
            var t;
            return i && (t = i.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), m(t)
           } catch (t) {
            var n = o.navigator,
             r = n && n.plugins;
            return [+new Date, o, r, o.screen, m(e)]
           }
          }() : t, 3), g),
          b = new function(t) {
           var e, n = t.length,
            r = this,
            i = 0,
            o = r.i = r.j = 0,
            s = r.S = [];
           for (n || (t = [n++]); i < a;) s[i] = i++;
           for (i = 0; i < a; i++) s[i] = s[o = p & o + t[i % n] + (e = s[i])], s[o] = e;
           (r.g = function(t) {
            for (var e, n = 0, i = r.i, o = r.j, s = r.S; t--;) e = s[i = p & i + 1], n = n * a + s[p & (s[i] = s[o = p & o + e]) + (s[o] = e)];
            return r.i = i, r.j = o, n
           })(a)
          }(g),
          x = function() {
           for (var t = b.g(s), e = c, n = 0; t < l;) t = (t + n) * a, e *= a, n = b.g(1);
           for (; t >= h;) t /= 2, e /= 2, n >>>= 1;
           return (t + n) / e
          };
         return x.int32 = function() {
          return 0 | b.g(4)
         }, x.quick = function() {
          return b.g(4) / 4294967296
         }, x.double = x, v(m(b.S), e), (n.pass || f || function(t, e, n, i) {
          return i && (i.S && d(i, b), t.state = function() {
           return d(b, {})
          }), n ? (r[u] = t, e) : t
         })(x, y, "global" in n ? n.global : this == r, n.state)
        }
 
        function d(t, e) {
         return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
        }
 
        function v(t, e) {
         for (var n, r = t + "", i = 0; i < r.length;) e[p & i] = p & (n ^= 19 * e[p & i]) + r.charCodeAt(i++);
         return m(e)
        }
 
        function m(t) {
         return String.fromCharCode.apply(0, t)
        }
        if (r["seed" + u] = f, v(r.random(), e), t.exports) {
         t.exports = f;
         try {
          i = n(7)
         } catch (t) {}
        }
       }([], Math)
      }));
     m.alea = l, m.xor128 = h, m.xorwow = p, m.xorshift7 = f, m.xor4096 = d, m.tychei = v;
     var g = m,
      y = g.alea;
 
     function b(t, e) {
      return x(t, e)
     }
 
     function x(t, e, n, r) {
      if (void 0 === n && (n = new Map), void 0 === r && (r = new Set), null == t) return null;
      if (r.has(t)) throw new Error("Circular references are not supported.");
      if (n.has(t)) return n.get(t);
      var i = e(t);
      if (i.recurse && null !== i.value) throw new Error("A deep map function may not return both a value and recurse=true.");
      if (i.recurse) {
       if (k(t)) {
        var o = Array.isArray(t) ? [] : {};
        for (var a in r.add(t), t) {
         var s = x(t[a], e, n, r);
         o[a] = s
        }
        return r.delete(t), o
       }
       throw new Error("Can't recurse into non-iterable type: " + t)
      }
      return n.set(t, i.value), i.value
     }
 
     function w(t, e) {
      return void 0 === e && (e = S), C(t, e)
     }
 
     function C(t, e, n) {
      void 0 === n && (n = new Set);
      var r = t[0];
      if (n.has(r)) throw new Error("Circular references are not supported.");
      var i = e(t);
      if (i.recurse && null !== i.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
      if (i.recurse) {
       if (k(r)) {
        var o = Array.isArray(r) ? [] : {};
        n.add(r);
        var a = function(r) {
         var i = C(t.map((function(t) {
          return t[r]
         })), e, n);
         o[r] = i
        };
        for (var s in r) a(s);
        return n.delete(r), o
       }
       throw new Error("Can't recurse into non-iterable type: " + r)
      }
      return i.value
     }
 
     function S(t) {
      return null === t ? null : k(t[0]) ? {
       value: null,
       recurse: !0
      } : {
       value: t,
       recurse: !1
      }
     }
 
     function E(t, e) {
      return s(this, void 0, void 0, (function() {
       var n, r, i, o, a, s;
       return u(this, (function(u) {
        switch (u.label) {
         case 0:
          n = new Map, x(t, e, n), r = 0, i = Array.from(n.keys()), u.label = 1;
         case 1:
          return r < i.length ? (o = i[r], (a = n.get(o)) instanceof Promise ? [4, a] : [3, 3]) : [3, 4];
         case 2:
          s = u.sent(), n.set(o, s), u.label = 3;
         case 3:
          return r++, [3, 1];
         case 4:
          return [2, x(t, e, n)]
        }
       }))
      }))
     }
 
     function k(t) {
      return null != t && !ArrayBuffer.isView(t) && (Array.isArray(t) || "object" == typeof t && !(t instanceof i["Tensor"]))
     }
 
     function I(t) {
      return null == t || O(t) || Array.isArray(t) || "object" == typeof t && t instanceof i["Tensor"] || i["util"].isTypedArray(t)
     }
 
     function O(t) {
      return null === t || "object" != typeof t && "function" != typeof t
     }
 
     function A(t) {
      return b(t, N)
     }
 
     function N(t) {
      return t instanceof i["Tensor"] ? {
       value: t.clone(),
       recurse: !1
      } : k(t) ? {
       value: null,
       recurse: !0
      } : {
       value: t,
       recurse: !1
      }
     }
     var R = function() {
       function t(t) {
        if (this.capacity = t, this.begin = 0, this.end = 0, null == t) throw new RangeError("Can't create a ring buffer of unknown capacity.");
        if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
        this.data = new Array(t), this.doubledCapacity = 2 * t
       }
       return t.prototype.wrap = function(t) {
        for (; t < 0;) t += this.doubledCapacity;
        return t % this.doubledCapacity
       }, t.prototype.get = function(t) {
        if (t < 0) throw new RangeError("Can't get item at a negative index.");
        return this.data[t % this.capacity]
       }, t.prototype.set = function(t, e) {
        if (t < 0) throw new RangeError("Can't set item at a negative index.");
        this.data[t % this.capacity] = e
       }, t.prototype.length = function() {
        var t = this.end - this.begin;
        return t < 0 && (t = this.doubledCapacity + t), t
       }, t.prototype.isFull = function() {
        return this.length() === this.capacity
       }, t.prototype.isEmpty = function() {
        return 0 === this.length()
       }, t.prototype.push = function(t) {
        if (this.isFull()) throw new RangeError("Ring buffer is full.");
        this.set(this.end, t), this.end = this.wrap(this.end + 1)
       }, t.prototype.pushAll = function(t) {
        for (var e = 0, n = t; e < n.length; e++) {
         var r = n[e];
         this.push(r)
        }
       }, t.prototype.pop = function() {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        this.end = this.wrap(this.end - 1);
        var t = this.get(this.end);
        return this.set(this.end, void 0), t
       }, t.prototype.unshift = function(t) {
        if (this.isFull()) throw new RangeError("Ring buffer is full.");
        this.begin = this.wrap(this.begin - 1), this.set(this.begin, t)
       }, t.prototype.shift = function() {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        var t = this.get(this.begin);
        return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t
       }, t.prototype.shuffleExcise = function(t) {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        var e = this.wrap(this.begin + t),
         n = this.get(e);
        return this.set(e, this.pop()), n
       }, t
      }(),
      T = function(t) {
       function e() {
        return t.call(this, e.INITIAL_CAPACITY) || this
       }
       return a(e, t), e.prototype.isFull = function() {
        return !1
       }, e.prototype.push = function(e) {
        t.prototype.isFull.call(this) && this.expand(), t.prototype.push.call(this, e)
       }, e.prototype.unshift = function(e) {
        t.prototype.isFull.call(this) && this.expand(), t.prototype.unshift.call(this, e)
       }, e.prototype.expand = function() {
        for (var t = 2 * this.capacity, e = new Array(t), n = this.length(), r = 0; r < n; r++) e[r] = this.get(this.wrap(this.begin + r));
        this.data = e, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n
       }, e.INITIAL_CAPACITY = 32, e
      }(R);
 
     function _(t) {
      return new B(t)
     }
 
     function D(t) {
      return new P(t)
     }
 
     function F(t, e) {
      return new X(t, e)
     }
     var M, L = function() {
       function t() {}
       return t.prototype.toArray = function() {
        return s(this, void 0, void 0, (function() {
         var t, e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return t = [], [4, this.next()];
           case 1:
            e = n.sent(), n.label = 2;
           case 2:
            return e.done ? [3, 4] : (t.push(e.value), [4, this.next()]);
           case 3:
            return e = n.sent(), [3, 2];
           case 4:
            return [2, t]
          }
         }))
        }))
       }, t.prototype.toArrayForTest = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return t = this.prefetch(100), e = [], [4, t.next()];
           case 1:
            n = r.sent(), r.label = 2;
           case 2:
            return n.done ? [3, 4] : (e.push(n.value), [4, t.next()]);
           case 3:
            return n = r.sent(), [3, 2];
           case 4:
            return [2, e]
          }
         }))
        }))
       }, t.prototype.resolveFully = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.next()];
           case 1:
            t = e.sent(), e.label = 2;
           case 2:
            return t.done ? [3, 4] : [4, this.next()];
           case 3:
            return t = e.sent(), [3, 2];
           case 4:
            return [2]
          }
         }))
        }))
       }, t.prototype.resolveWhile = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return [4, this.next()];
           case 1:
            e = r.sent(), n = t(e.value), r.label = 2;
           case 2:
            return e.done || !n ? [3, 4] : [4, this.next()];
           case 3:
            return e = r.sent(), n = t(e.value), [3, 2];
           case 4:
            return [2]
          }
         }))
        }))
       }, t.prototype.handleErrors = function(t) {
        return new $(this, t)
       }, t.prototype.filter = function(t) {
        return new U(this, t)
       }, t.prototype.map = function(t) {
        return new H(this, t)
       }, t.prototype.mapAsync = function(t) {
        return new G(this, t)
       }, t.prototype.serialMapAsync = function(t) {
        return new G(this, t).serial()
       }, t.prototype.flatmap = function(t) {
        return new K(this, t)
       }, t.prototype.forEachAsync = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          return [2, this.map(t).resolveFully()]
         }))
        }))
       }, t.prototype.serialForEach = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          return [2, this.serialMapAsync(t).resolveWhile((function(t) {
           return !0 === t
          }))]
         }))
        }))
       }, t.prototype.rowMajorBatch = function(t, e) {
        return void 0 === e && (e = !0), new V(this, t, e)
       }, t.prototype.columnMajorBatch = function(t, e, n) {
        return void 0 === e && (e = !0), void 0 === n && (n = S), this.rowMajorBatch(t, e).map((function(t) {
         return w(t, n)
        }))
       }, t.prototype.concatenate = function(t, e) {
        return new X(_([this, t]), e)
       }, t.prototype.take = function(t) {
        return t < 0 || null == t ? this : new W(this, t)
       }, t.prototype.skip = function(t) {
        return t < 0 || null == t ? this : new j(this, t)
       }, t.prototype.prefetch = function(t) {
        return new Y(this, t)
       }, t.prototype.shuffle = function(t, e) {
        return new Z(this, t, e)
       }, t.prototype.serial = function() {
        return new z(this)
       }, t
      }(),
      B = function(t) {
       function e(e) {
        var n = t.call(this) || this;
        return n.items = e, n.trav = 0, n
       }
       return a(e, t), e.prototype.summary = function() {
        return "Array of " + this.items.length + " items"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          return this.trav >= this.items.length ? [2, {
           value: null,
           done: !0
          }] : (t = this.items[this.trav], this.trav++, [2, {
           value: A(t),
           done: !1
          }])
         }))
        }))
       }, e
      }(L),
      P = function(t) {
       function e(e) {
        var n = t.call(this) || this;
        return n.nextFn = e, n
       }
       return a(e, t), e.prototype.summary = function() {
        return "Function call"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          try {
           return [2, this.nextFn()]
          } catch (t) {
           throw t.message = "Error thrown while iterating through a dataset: " + t.message, t
          }
          return [2]
         }))
        }))
       }, e
      }(L),
      z = function(t) {
       function e(e) {
        var n = t.call(this) || this;
        return n.upstream = e, n.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), n
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Serial"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return [2, this.upstream.next()]
         }))
        }))
       }, e
      }(L),
      j = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.maxCount = n, r.count = 0, r.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Skip"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return this.count++ < this.maxCount ? [4, this.upstream.next()] : [3, 2];
           case 1:
            return (t = e.sent()).done ? [2, t] : (Object(i["dispose"])(t.value), [3, 0]);
           case 2:
            return [2, this.upstream.next()]
          }
         }))
        }))
       }, e
      }(L),
      W = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.maxCount = n, r.count = 0, r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Take"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return this.count++ >= this.maxCount ? [2, {
           value: null,
           done: !0
          }] : [2, this.upstream.next()]
         }))
        }))
       }, e
      }(L),
      V = function(t) {
       function e(e, n, r) {
        void 0 === r && (r = !0);
        var i = t.call(this) || this;
        return i.upstream = e, i.batchSize = n, i.enableSmallLastBatch = r, i.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), i
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> RowMajorBatch"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         var t, e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            t = [], n.label = 1;
           case 1:
            return t.length < this.batchSize ? [4, this.upstream.next()] : [3, 3];
           case 2:
            return (e = n.sent()).done ? this.enableSmallLastBatch && t.length > 0 ? [2, {
             value: t,
             done: !1
            }] : [2, {
             value: null,
             done: !0
            }] : (t.push(e.value), [3, 1]);
           case 3:
            return [2, {
             value: t,
             done: !1
            }]
          }
         }))
        }))
       }, e
      }(L),
      U = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.predicate = n, r.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Filter"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.upstream.next()];
           case 1:
            return (t = e.sent()).done || this.predicate(t.value) ? [2, t] : (Object(i["dispose"])(t.value), [3, 0]);
           case 2:
            return [2]
          }
         }))
        }))
       }, e
      }(L),
      H = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.transform = n, r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Map"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, o, a, s;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return [4, this.upstream.next()];
           case 1:
            if ((t = u.sent()).done) return [2, {
             value: null,
             done: !0
            }];
            for (e = i["tensor_util"].getTensorsInContainer(t.value), n = this.transform(t.value), r = i["tensor_util"].getTensorsInContainer(n), o = 0, a = e; o < a.length; o++) s = a[o], i["tensor_util"].isTensorInList(s, r) || s.dispose();
            return [2, {
             value: n,
             done: !1
            }]
          }
         }))
        }))
       }, e
      }(L),
      $ = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.handler = n, r.count = 0, r.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> handleErrors"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            e.label = 1;
           case 1:
            return e.trys.push([1, 3, , 4]), [4, this.upstream.next()];
           case 2:
            return [2, e.sent()];
           case 3:
            return t = e.sent(), this.handler(t) ? [3, 4] : [2, {
             value: null,
             done: !0
            }];
           case 4:
            return [3, 0];
           case 5:
            return [2]
          }
         }))
        }))
       }, e
      }(L),
      G = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.transform = n, r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> AsyncMap"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, o, a, s;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return [4, this.upstream.next()];
           case 1:
            return (t = u.sent()).done ? [2, {
             value: null,
             done: !0
            }] : (e = i["tensor_util"].getTensorsInContainer(t.value), [4, this.transform(t.value)]);
           case 2:
            for (n = u.sent(), r = i["tensor_util"].getTensorsInContainer(n), o = 0, a = e; o < a.length; o++) s = a[o], i["tensor_util"].isTensorInList(s, r) || s.dispose();
            return [2, {
             value: n,
             done: !1
            }]
          }
         }))
        }))
       }, e
      }(L),
      q = function(t) {
       function e() {
        var e = t.call(this) || this;
        return e.outputQueue = new T, e.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), e
       }
       return a(e, t), e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return 0 !== this.outputQueue.length() ? [3, 2] : [4, this.pump()];
           case 1:
            return t.sent() ? [3, 0] : [2, {
             value: null,
             done: !0
            }];
           case 2:
            return [2, {
             value: this.outputQueue.shift(),
             done: !1
            }]
          }
         }))
        }))
       }, e
      }(L),
      K = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.transform = n, r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Flatmap"
       }, e.prototype.pump = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, o, a, s;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return [4, this.upstream.next()];
           case 1:
            if ((t = u.sent()).done) return [2, !1];
            for (e = i["tensor_util"].getTensorsInContainer(t.value), n = this.transform(t.value), r = i["tensor_util"].getTensorsInContainer(n), this.outputQueue.pushAll(n), o = 0, a = e; o < a.length; o++) s = a[o], i["tensor_util"].isTensorInList(s, r) || s.dispose();
            return [2, !0]
          }
         }))
        }))
       }, e
      }(q),
      X = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.baseErrorHandler = n, r.lastRead = null, r.iterator = null, r.moreIterators = e, r
       }
       return a(e, t), e.prototype.summary = function() {
        return "TODO: fill in upstream of chained summaries -> Chained"
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return this.lastRead = this.readFromChain(this.lastRead), [2, this.lastRead]
         }))
        }))
       }, e.prototype.readFromChain = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return [4, t];
           case 1:
            return r.sent(), null != this.iterator ? [3, 3] : [4, this.moreIterators.next()];
           case 2:
            if ((e = r.sent()).done) return [2, {
             value: null,
             done: !0
            }];
            this.iterator = e.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler)), r.label = 3;
           case 3:
            return [4, this.iterator.next()];
           case 4:
            return (n = r.sent()).done ? (this.iterator = null, [2, this.readFromChain(t)]) : [2, n]
          }
         }))
        }))
       }, e
      }(L);
     ! function(t) {
      t[t.FAIL = 0] = "FAIL", t[t.SHORTEST = 1] = "SHORTEST", t[t.LONGEST = 2] = "LONGEST"
     }(M || (M = {}));
     (function(t) {
      function e(e, n) {
       void 0 === n && (n = M.FAIL);
       var r = t.call(this) || this;
       return r.iterators = e, r.mismatchMode = n, r.count = 0, r.currentPromise = null, r
      }
      a(e, t), e.prototype.summary = function() {
       return "{TODO: fill in upstream of zip summaries} -> Zip"
      }, e.prototype.nextState = function(t) {
       return s(this, void 0, void 0, (function() {
        function e(t) {
         return t instanceof L ? {
          value: t.next().then((function(t) {
           return n++, t.done && r++, t.value
          })),
          recurse: !1
         } : {
          value: null,
          recurse: !0
         }
        }
        var n, r, i;
        return u(this, (function(o) {
         switch (o.label) {
          case 0:
           return [4, t];
          case 1:
           return o.sent(), n = 0, r = 0, [4, E(this.iterators, e)];
          case 2:
           if (i = o.sent(), n === r) return [2, {
            value: null,
            done: !0
           }];
           if (r > 0) switch (this.mismatchMode) {
            case M.FAIL:
             throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");
            case M.SHORTEST:
             return [2, {
              value: null,
              done: !0
             }];
            case M.LONGEST:
           }
           return this.count++, [2, {
            value: i,
            done: !1
           }]
         }
        }))
       }))
      }, e.prototype.next = function() {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         return this.currentPromise = this.nextState(this.currentPromise), [2, this.currentPromise]
        }))
       }))
      }
     })(L);
     var Y = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.bufferSize = n, r.buffer = new R(n), r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Prefetch"
       }, e.prototype.refill = function() {
        for (; !this.buffer.isFull();) {
         var t = this.upstream.next();
         this.buffer.push(t)
        }
       }, e.prototype.next = function() {
        return this.refill(), this.buffer.shift()
       }, e
      }(L),
      Z = function(t) {
       function e(e, n, r) {
        var o = t.call(this, e, n) || this;
        return o.upstream = e, o.windowSize = n, o.upstreamExhausted = !1, o.random = y(r || i["util"].now().toString()), o.lastRead = Promise.resolve({
         value: null,
         done: !1
        }), o
       }
       return a(e, t), e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return this.lastRead = this.lastRead.then((function() {
           return t.serialNext()
          })), [2, this.lastRead]
         }))
        }))
       }, e.prototype.randomInt = function(t) {
        return Math.floor(this.random() * t)
       }, e.prototype.chooseIndex = function() {
        return this.randomInt(this.buffer.length())
       }, e.prototype.serialNext = function() {
        return s(this, void 0, void 0, (function() {
         var t, e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            this.upstreamExhausted || this.refill(), n.label = 1;
           case 1:
            return this.buffer.isEmpty() ? [3, 3] : (t = this.chooseIndex(), [4, this.buffer.shuffleExcise(t)]);
           case 2:
            return (e = n.sent()).done ? (this.upstreamExhausted = !0, [3, 1]) : (this.refill(), [2, e]);
           case 3:
            return [2, {
             value: null,
             done: !0
            }]
          }
         }))
        }))
       }, e
      }(Y),
      J = function() {
       function t() {
        this.size = null
       }
       return t.prototype.batch = function(t, e) {
        var n = this;
        void 0 === e && (e = !0);
        var r = this;
        return i["util"].assert(t > 0, (function() {
         return "batchSize needs to be positive, but it is\n      " + t
        })), Q((function() {
         return s(n, void 0, void 0, (function() {
          return u(this, (function(n) {
           switch (n.label) {
            case 0:
             return [4, r.iterator()];
            case 1:
             return [2, n.sent().columnMajorBatch(t, e, tt)]
           }
          }))
         }))
        }), this.size === 1 / 0 || null == this.size ? this.size : e ? Math.ceil(this.size / t) : Math.floor(this.size / t))
       }, t.prototype.concatenate = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          var e, r;
          return u(this, (function(i) {
           switch (i.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return r = (e = i.sent()).concatenate, [4, t.iterator()];
            case 2:
             return [2, r.apply(e, [i.sent()])]
           }
          }))
         }))
        }), this.size === 1 / 0 || t.size === 1 / 0 ? 1 / 0 : null != this.size && null != t.size ? this.size + t.size : null)
       }, t.prototype.filter = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return [2, e.sent().filter((function(e) {
              return Object(i["tidy"])((function() {
               return t(e)
              }))
             }))]
           }
          }))
         }))
        }), this.size === 1 / 0 ? 1 / 0 : null)
       }, t.prototype.forEachAsync = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.iterator()];
           case 1:
            return [2, e.sent().forEachAsync(t)]
          }
         }))
        }))
       }, t.prototype.forEach = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          return Object(i["deprecationWarn"])("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"), [2, this.forEachAsync(t)]
         }))
        }))
       }, t.prototype.map = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return [2, e.sent().map((function(e) {
              return Object(i["tidy"])((function() {
               return t(e)
              }))
             }))]
           }
          }))
         }))
        }), this.size)
       }, t.prototype.mapAsync = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return [2, e.sent().mapAsync(t)]
           }
          }))
         }))
        }), this.size)
       }, t.prototype.prefetch = function(t) {
        var e = this;
        if (null == t) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
        var n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return [2, e.sent().prefetch(t)]
           }
          }))
         }))
        }), this.size)
       }, t.prototype.repeat = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          var e = this;
          return u(this, (function(r) {
           return [2, F(D((function() {
            return s(e, void 0, void 0, (function() {
             var t;
             return u(this, (function(e) {
              switch (e.label) {
               case 0:
                return t = {}, [4, n.iterator()];
               case 1:
                return [2, (t.value = e.sent(), t.done = !1, t)]
              }
             }))
            }))
           })).take(t))]
          }))
         }))
        }), null != this.size && t > 0 ? this.size * t : 0 === t ? 0 : null != this.size && (void 0 === t || t < 0) ? 1 / 0 : null)
       }, t.prototype.skip = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return [2, e.sent().skip(t)]
           }
          }))
         }))
        }), null != this.size && t >= 0 && this.size >= t ? this.size - t : null != this.size && (this.size < t || void 0 === t || t < 0) ? 0 : null)
       }, t.prototype.shuffle = function(t, e, n) {
        var r = this;
        if (void 0 === n && (n = !0), null == t || t < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
        var o = this,
         a = y(e || i["util"].now().toString());
        return Q((function() {
         return s(r, void 0, void 0, (function() {
          var e;
          return u(this, (function(r) {
           switch (r.label) {
            case 0:
             return e = a.int32(), n && (e += a.int32()), [4, o.iterator()];
            case 1:
             return [2, r.sent().shuffle(t, e.toString())]
           }
          }))
         }))
        }), this.size)
       }, t.prototype.take = function(t) {
        var e = this,
         n = this;
        return Q((function() {
         return s(e, void 0, void 0, (function() {
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, n.iterator()];
            case 1:
             return [2, e.sent().take(t)]
           }
          }))
         }))
        }), null != this.size && this.size > t ? t : null != this.size && this.size <= t ? this.size : null)
       }, t.prototype.toArray = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
            return [4, this.iterator()];
           case 1:
            return [2, t.sent().toArray()]
          }
         }))
        }))
       }, t.prototype.toArrayForTest = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
            return [4, this.iterator()];
           case 1:
            return [2, t.sent().toArrayForTest()]
          }
         }))
        }))
       }, t.MAX_BUFFER_SIZE = 1e4, t
      }();
 
     function Q(t, e) {
      return void 0 === e && (e = null), new(function(n) {
       function r() {
        var t = null !== n && n.apply(this, arguments) || this;
        return t.size = e, t
       }
       return a(r, n), r.prototype.iterator = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          return [2, t()]
         }))
        }))
       }, r
      }(J))
     }
 
     function tt(t) {
      return null === t ? null : I(t[0]) ? {
       value: et(t),
       recurse: !1
      } : {
       value: null,
       recurse: !0
      }
     }
 
     function et(t) {
      if (0 === t.length) throw new Error("Can't make a batch of zero elements.");
      return t[0] instanceof i["Tensor"] ? Object(i["stack"])(t) : Object(i["tensor"])(t)
     }
     var nt = function(t) {
       function e(e) {
        var n = t.call(this) || this;
        return n.input = e, n
       }
       return a(e, t), e.prototype.iterator = function() {
        return s(this, void 0, void 0, (function() {
         var t, e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return [4, this.input.iterator()];
           case 1:
            return t = n.sent(), e = t.decodeUTF8(), [2, e.split("\n").map((function(t) {
             return t.endsWith("\r") && (t = t.slice(0, -1)), t
            }))]
          }
         }))
        }))
       }, e
      }(J),
      rt = '"',
      it = Symbol("out"),
      ot = Symbol("field"),
      at = Symbol("quote"),
      st = Symbol("quoteafterquote"),
      ut = Symbol("quoteinquote"),
      ct = (function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.input = e, r.hasHeader = !0, r.fullColumnNames = null, r.columnNamesValidated = !1, r.columnConfigs = null, r.configuredColumnsOnly = !1, r.delimiter = ",", r.delimWhitespace = !1, r.base = new nt(e), n || (n = {}), r.hasHeader = !1 !== n.hasHeader, r.fullColumnNames = n.columnNames, r.columnConfigs = n.columnConfigs, r.configuredColumnsOnly = n.configuredColumnsOnly, n.delimWhitespace ? (i["util"].assert(null == n.delimiter, (function() {
         return "Delimiter should not be provided when delimWhitespace is true."
        })), r.delimWhitespace = !0, r.delimiter = " ") : r.delimiter = n.delimiter ? n.delimiter : ",", r
       }
       a(e, t), e.prototype.columnNames = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];
           case 1:
            t.sent(), t.label = 2;
           case 2:
            return [2, this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames]
          }
         }))
        }))
       }, e.prototype.setColumnNames = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, o, a, s = this;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return [4, this.maybeReadHeaderLine()];
           case 1:
            if (t = u.sent(), !this.fullColumnNames && !t) throw new Error("Column names must be provided if there is no header line.");
            if (this.fullColumnNames && t && i["util"].assert(t.length === this.fullColumnNames.length, (function() {
              return "The length of provided columnNames (" + s.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ")."
             })), this.fullColumnNames || (this.fullColumnNames = t), e = this.fullColumnNames.reduce((function(t, e) {
              return t[e] = t[e] + 1 || 1, t
             }), {}), n = Object.keys(e).filter((function(t) {
              return e[t] > 1
             })), i["util"].assert(0 === n.length, (function() {
              return "Duplicate column names found: " + n.toString()
             })), this.columnConfigs)
             for (r = 0, o = Object.keys(this.columnConfigs); r < o.length; r++)
              if (a = o[r], -1 === this.fullColumnNames.indexOf(a)) throw new Error('The key "' + a + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
            return this.columnNamesValidated = !0, [2]
          }
         }))
        }))
       }, e.prototype.maybeReadHeaderLine = function() {
        return s(this, void 0, void 0, (function() {
         var t, e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return this.hasHeader ? [4, this.base.iterator()] : [3, 3];
           case 1:
            return [4, n.sent().next()];
           case 2:
            if ((t = n.sent()).done) throw new Error("No data was found for CSV parsing.");
            return e = t.value, [2, this.parseRow(e, !1)];
           case 3:
            return [2, null]
          }
         }))
        }))
       }, e.prototype.iterator = function() {
        return s(this, void 0, void 0, (function() {
         var t, e = this;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];
           case 1:
            n.sent(), n.label = 2;
           case 2:
            return [4, this.base.iterator()];
           case 3:
            return t = n.sent(), this.hasHeader && (t = t.skip(1)), [2, t.map((function(t) {
             return e.makeDataElement(t)
            }))]
          }
         }))
        }))
       }, e.prototype.makeDataElement = function(t) {
        for (var e = this.parseRow(t), n = {}, r = {}, i = 0; i < this.fullColumnNames.length; i++) {
         var o = this.fullColumnNames[i],
          a = this.columnConfigs ? this.columnConfigs[o] : null;
         if (!this.configuredColumnsOnly || a) {
          var s = e[i],
           u = null;
          if ("" === s)
           if (a && void 0 !== a.default) u = a.default;
           else {
            if (a && (a.required || a.isLabel)) throw new Error("Required column " + o + " is empty in this line: " + t);
            u = void 0
           }
          else {
           var c = Number(s);
           if (isNaN(c)) u = a && "bool" === a.dtype ? this.getBoolean(s) : s;
           else if (a && a.dtype) switch (a.dtype) {
            case "float32":
             u = c;
             break;
            case "int32":
             u = Math.floor(c);
             break;
            case "bool":
             u = this.getBoolean(s);
             break;
            default:
             u = c
           } else u = c
          }
          a && a.isLabel ? r[o] = u : n[o] = u
         }
        }
        return 0 === Object.keys(r).length ? n : {
         xs: n,
         ys: r
        }
       }, e.prototype.getBoolean = function(t) {
        return "1" === t || "true" === t.toLowerCase() ? 1 : 0
       }, e.prototype.parseRow = function(t, e) {
        void 0 === e && (e = !0);
        for (var n = [], r = 0, i = t.length, o = it, a = 0; a < i; a++) switch (o) {
         case it:
          switch (t.charAt(a)) {
           case rt:
            r = a + 1, o = at;
            break;
           case this.delimiter:
            if (r = a + 1, " " === this.delimiter && this.delimWhitespace) break;
            n.push(""), o = it;
            break;
           default:
            o = ot, r = a
          }
          break;
         case ot:
          switch (t.charAt(a)) {
           case this.delimiter:
            n.push(t.substring(r, a)), o = it, r = a + 1
          }
          break;
         case at:
          switch (t.charAt(a)) {
           case rt:
            o = st
          }
          break;
         case st:
          switch (t.charAt(a)) {
           case this.delimiter:
            n.push(t.substring(r, a - 1)), o = it, r = a + 1;
            break;
           case rt:
            o = at;
            break;
           default:
            o = ut
          }
          break;
         case ut:
          switch (t.charAt(a)) {
           case rt:
            o = at
          }
        }
        if (o === st ? n.push(t.substring(r, i - 1)) : n.push(t.substring(r)), e && n.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + n);
        return n
       }
      }(J), function(t) {
       function e(e) {
        var n = t.call(this) || this;
        n.microphoneConfig = e, n.isClosed = !1, n.fftSize = e.fftSize || 1024;
        var r = Math.log2(n.fftSize);
        if (n.fftSize < 0 || r < 4 || r > 14 || !Number.isInteger(r)) throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + n.fftSize);
        if (n.numFrames = e.numFramesPerSpectrogram || 43, n.sampleRateHz = e.sampleRateHz, n.columnTruncateLength = e.columnTruncateLength || n.fftSize, n.audioTrackConstraints = e.audioTrackConstraints, n.smoothingTimeConstant = e.smoothingTimeConstant || 0, n.includeSpectrogram = !1 !== e.includeSpectrogram, n.includeWaveform = !0 === e.includeWaveform, !n.includeSpectrogram && !n.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
        return n
       }
       a(e, t), e.prototype.summary = function() {
        return "microphone"
       }, e.create = function(t) {
        return void 0 === t && (t = {}), s(this, void 0, void 0, (function() {
         var n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            if (Object(i["env"])().get("IS_NODE")) throw new Error("microphone API is only supported in browser environment.");
            return [4, (n = new e(t)).start()];
           case 1:
            return r.sent(), [2, n]
          }
         }))
        }))
       }, e.prototype.start = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r;
         return u(this, (function(i) {
          switch (i.label) {
           case 0:
            return i.trys.push([0, 2, , 3]), t = this, [4, navigator.mediaDevices.getUserMedia({
             audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
             video: !1
            })];
           case 1:
            return t.stream = i.sent(), [3, 3];
           case 2:
            throw e = i.sent(), new Error("Error thrown while initializing video stream: " + e.message);
           case 3:
            if (!this.stream) throw new Error("Could not obtain audio from microphone.");
            if (n = window.AudioContext || window.webkitAudioContext, this.audioContext = new n, this.sampleRateHz) {
             if (this.audioContext.sampleRate !== this.sampleRateHz) throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate)
            } else this.sampleRateHz = this.audioContext.sampleRate;
            return r = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, r.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), [2]
          }
         }))
        }))
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, i;
         return u(this, (function(o) {
          switch (o.label) {
           case 0:
            return this.isClosed ? [2, {
             value: null,
             done: !0
            }] : [4, this.getAudioData()];
           case 1:
            return n = o.sent(), this.includeSpectrogram && (r = this.flattenQueue(n.freqDataQueue), t = this.getTensorFromAudioDataArray(r, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i = this.flattenQueue(n.timeDataQueue), e = this.getTensorFromAudioDataArray(i, [this.numFrames * this.fftSize, 1])), [2, {
             value: {
              spectrogram: t,
              waveform: e
             },
             done: !1
            }]
          }
         }))
        }))
       }, e.prototype.capture = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return [4, this.next()];
           case 1:
            return [2, t.sent().value]
          }
         }))
        }))
       }, e.prototype.getAudioData = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r = this;
         return u(this, (function(i) {
          return t = [], e = [], n = 0, [2, new Promise((function(i) {
           var o = setInterval((function() {
            r.includeSpectrogram && (r.analyser.getFloatFrequencyData(r.freqData), r.freqData[0] === -1 / 0 && i({
             freqDataQueue: t,
             timeDataQueue: e
            }), t.push(r.freqData.slice(0, r.columnTruncateLength))), r.includeWaveform && (r.analyser.getFloatTimeDomainData(r.timeData), e.push(r.timeData.slice())), ++n === r.numFrames && (clearInterval(o), i({
             freqDataQueue: t,
             timeDataQueue: e
            }))
           }), r.fftSize / r.sampleRateHz * 1e3)
          }))]
         }))
        }))
       }, e.prototype.stop = function() {
        this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop())
       }, e.prototype.toArray = function() {
        throw new Error("Can not convert infinite audio stream to array.")
       }, e.prototype.getSampleRate = function() {
        return this.sampleRateHz
       }, e.prototype.flattenQueue = function(t) {
        var e = t[0].length,
         n = new Float32Array(t.length * e);
        return t.forEach((function(t, r) {
         return n.set(t, r * e)
        })), n
       }, e.prototype.getTensorFromAudioDataArray = function(t, e) {
        var n = new Float32Array(i["util"].sizeFromShape(e));
        return n.set(t, n.length - t.length), Object(i["tensor"])(n, e)
       }
      }(L), function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        if (r.webcamVideoElement = e, r.webcamConfig = n, r.isClosed = !0, r.resize = !1, r.needToResize())
         if (r.resize = !0, r.cropSize = [r.webcamConfig.resizeHeight, r.webcamConfig.resizeWidth], r.cropBoxInd = Object(i["tensor1d"])([0], "int32"), r.webcamConfig.centerCrop) {
          var o = 1 * r.webcamConfig.resizeWidth / r.webcamVideoElement.width,
           a = 1 * r.webcamConfig.resizeHeight / r.webcamVideoElement.height,
           s = (1 - o) / 2,
           u = (1 - a) / 2,
           c = s + o,
           l = a + u;
          r.cropBox = Object(i["tensor2d"])([u, s, l, c], [1, 4])
         } else r.cropBox = Object(i["tensor2d"])([0, 0, 1, 1], [1, 4]);
        return r
       }
       a(e, t), e.prototype.summary = function() {
        return "webcam"
       }, e.create = function(t, n) {
        return void 0 === n && (n = {}), s(this, void 0, void 0, (function() {
         var r;
         return u(this, (function(o) {
          switch (o.label) {
           case 0:
            if (Object(i["env"])().get("IS_NODE")) throw new Error("tf.data.webcam is only supported in browser environment.");
            if (!t) {
             if (t = document.createElement("video"), !n.resizeWidth || !n.resizeHeight) throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
             t.width = n.resizeWidth, t.height = n.resizeHeight
            }
            return [4, (r = new e(t, n)).start()];
           case 1:
            return o.sent(), [2, r]
          }
         }))
        }))
       }, e.prototype.start = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n = this;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            this.webcamConfig.facingMode && i["util"].assert("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, (function() {
             return "Invalid webcam facing mode: " + n.webcamConfig.facingMode + ". Please provide 'user' or 'environment'"
            })), r.label = 1;
           case 1:
            return r.trys.push([1, 3, , 4]), t = this, [4, navigator.mediaDevices.getUserMedia({
             video: {
              deviceId: this.webcamConfig.deviceId,
              facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
              width: this.webcamVideoElement.width,
              height: this.webcamVideoElement.height
             }
            })];
           case 2:
            return t.stream = r.sent(), [3, 4];
           case 3:
            throw (e = r.sent()).message = "Error thrown while initializing video stream: " + e.message, e;
           case 4:
            if (!this.stream) throw new Error("Could not obtain video from webcam.");
            try {
             this.webcamVideoElement.srcObject = this.stream
            } catch (t) {
             console.log(t), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream)
            }
            return this.webcamVideoElement.play(), this.isClosed = !1, [2, new Promise((function(t) {
             n.webcamVideoElement.onloadedmetadata = function() {
              t()
             }
            }))]
          }
         }))
        }))
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          if (this.isClosed) return [2, {
           value: null,
           done: !0
          }];
          try {
           t = i["browser"].fromPixels(this.webcamVideoElement)
          } catch (t) {
           throw new Error("Error thrown converting video to pixels: " + JSON.stringify(t))
          }
          if (!this.resize) return [2, {
           value: t,
           done: !1
          }];
          try {
           return [2, {
            value: this.cropAndResizeFrame(t),
            done: !1
           }]
          } catch (t) {
           throw new Error("Error thrown cropping the video: " + t.message)
          } finally {
           t.dispose()
          }
          return [2]
         }))
        }))
       }, e.prototype.needToResize = function() {
        return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight)
       }, e.prototype.cropAndResizeFrame = function(t) {
        var e = this;
        return Object(i["tidy"])((function() {
         var n, r = t.toFloat().expandDims(0),
          o = (n = i["image"].cropAndResize(r, e.cropBox, e.cropBoxInd, e.cropSize, "bilinear")).shape;
         return n.reshape(o.slice(1))
        }))
       }, e.prototype.capture = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return [4, this.next()];
           case 1:
            return [2, t.sent().value]
          }
         }))
        }))
       }, e.prototype.stop = function() {
        this.stream.getTracks().forEach((function(t) {
         return t.stop()
        }));
        try {
         this.webcamVideoElement.srcObject = null
        } catch (t) {
         console.log(t), this.webcamVideoElement.src = null
        }
        this.isClosed = !0
       }, e.prototype.toArray = function() {
        throw new Error("Can not convert infinite video stream to array.")
       }
      }(L), function() {
       return function() {}
      }()),
      lt = function(t) {
       function e() {
        return null !== t && t.apply(this, arguments) || this
       }
       return a(e, t), e.prototype.split = function(t) {
        return new ht(this, t)
       }, e
      }(L),
      ht = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.impl = new pt(e, n), r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.impl.summary()
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return [2, this.impl.next()]
         }))
        }))
       }, e
      }(lt),
      pt = function(t) {
       function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.separator = n, r.carryover = "", r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Split('" + this.separator + "')"
       }, e.prototype.pump = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, i;
         return u(this, (function(o) {
          switch (o.label) {
           case 0:
            return [4, this.upstream.next()];
           case 1:
            if ((t = o.sent()).done) return "" === this.carryover ? [2, !1] : (this.outputQueue.push(this.carryover), this.carryover = "", [2, !0]);
            for ((e = t.value.split(this.separator))[0] = this.carryover + e[0], n = 0, r = e.slice(0, -1); n < r.length; n++) i = r[n], this.outputQueue.push(i);
            return this.carryover = e[e.length - 1], [2, !0]
          }
         }))
        }))
       }, e
      }(q),
      ft = function(t) {
       function e() {
        return null !== t && t.apply(this, arguments) || this
       }
       return a(e, t), e.prototype.decodeUTF8 = function() {
        return new dt(this)
       }, e
      }(L),
      dt = function(t) {
       function e(e) {
        var n = t.call(this) || this;
        return n.upstream = e, n.impl = new vt(e), n
       }
       return a(e, t), e.prototype.summary = function() {
        return this.impl.summary()
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return [2, this.impl.next()]
         }))
        }))
       }, e
      }(lt),
      vt = function(t) {
       function e(e) {
        var r = t.call(this) || this;
        if (r.upstream = e, Object(i["env"])().get("IS_BROWSER")) r.decoder = new TextDecoder("utf-8");
        else {
         var o = n(8).StringDecoder;
         r.decoder = new o("utf8")
        }
        return r
       }
       return a(e, t), e.prototype.summary = function() {
        return this.upstream.summary() + " -> Utf8"
       }, e.prototype.pump = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n;
         return u(this, (function(o) {
          switch (o.label) {
           case 0:
            return [4, this.upstream.next()];
           case 1:
            return (t = o.sent()).done ? [2, !1] : (e = t.value, n = Object(i["env"])().get("IS_BROWSER") ? this.decoder.decode(e, {
             stream: !0
            }) : this.decoder.write(r.from(e.buffer)), this.outputQueue.push(n), [2, !0])
          }
         }))
        }))
       }, e
      }(q),
      mt = function(t) {
       function e(e, n) {
        void 0 === n && (n = {});
        var r = t.call(this) || this;
        return r.file = e, r.options = n, i["util"].assert(e instanceof Uint8Array || !!Object(i["env"])().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), (function() {
         return "FileChunkIterator only supports File, Blob and Uint8Array right now."
        })), r.offset = n.offset || 0, r.chunkSize = n.chunkSize || 1048576, r
       }
       return a(e, t), e.prototype.summary = function() {
        return "FileChunks " + this.file
       }, e.prototype.next = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n = this;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? [2, {
             value: null,
             done: !0
            }] : (t = new Promise((function(t, e) {
             var r = n.offset + n.chunkSize;
             if (n.file instanceof Uint8Array) t(new Uint8Array(n.file.slice(n.offset, r)));
             else {
              var i = new FileReader;
              i.onload = function(n) {
               var r = i.result;
               if (r instanceof ArrayBuffer && (r = new Uint8Array(r)), !(r instanceof Uint8Array)) return e(new TypeError("FileReader returned unknown type."));
               t(r)
              }, i.onabort = function(t) {
               return e(new Error("Aborted"))
              }, i.onerror = function(t) {
               return e(new Error(t.type))
              };
              var o = n.file.slice(n.offset, r);
              i.readAsArrayBuffer(o)
             }
             n.offset = r
            })), e = {}, [4, t]);
           case 1:
            return [2, (e.value = r.sent(), e.done = !1, e)]
          }
         }))
        }))
       }, e
      }(ft);
 
     function gt(t, e) {
      return void 0 === e && (e = {}), s(this, void 0, void 0, (function() {
       var n, r, o, a, s;
       return u(this, (function(u) {
        switch (u.label) {
         case 0:
          return "string" == typeof t ? n = t : (n = t.url, r = yt(t)), [4, i["util"].fetch(n, r)];
         case 1:
          return (o = u.sent()).ok ? (s = Uint8Array.bind, [4, o.arrayBuffer()]) : [3, 3];
         case 2:
          return a = new(s.apply(Uint8Array, [void 0, u.sent()])), [2, new mt(a, e)];
         case 3:
          throw new Error(o.statusText)
        }
       }))
      }))
     }
     var yt = function(t) {
      return {
       method: t.method,
       headers: t.headers,
       body: t.body,
       mode: t.mode,
       credentials: t.credentials,
       cache: t.cache,
       redirect: t.redirect,
       referrer: t.referrer,
       integrity: t.integrity
      }
     };
 
     function bt(t) {
      return "string" == typeof t && "file://" === t.substr(0, 7)
     }
     var xt = function(t) {
      function e(e, n) {
       void 0 === n && (n = {});
       var r = t.call(this) || this;
       return r.input = e, r.options = n, r
      }
      return a(e, t), e.prototype.iterator = function() {
       return s(this, void 0, void 0, (function() {
        var t;
        return u(this, (function(e) {
         return bt(this.input) && Object(i["env"])().get("IS_NODE") && (t = n(9), this.input = t.readFileSync(this.input.substr(7))), [2, new mt(this.input, this.options)]
        }))
       }))
      }, e
     }(ct);
     (function(t) {
      function e(e, n) {
       void 0 === n && (n = {});
       var r = t.call(this) || this;
       return r.url = e, r.fileOptions = n, r
      }
      a(e, t), e.prototype.iterator = function() {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         return bt(this.url) ? [2, new xt(this.url, this.fileOptions).iterator()] : [2, gt(this.url, this.fileOptions)]
        }))
       }))
      }
     })(ct);
     var wt = "1.5.2"
    }).call(this, n("c8ba"), n("b639").Buffer)
   },
   "37e8": function(t, e, n) {
    var r = n("83ab"),
     i = n("9bf2"),
     o = n("825a"),
     a = n("df75");
    t.exports = r ? Object.defineProperties : function(t, e) {
     o(t);
     var n, r = a(e),
      s = r.length,
      u = 0;
     while (s > u) i.f(t, n = r[u++], e[n]);
     return t
    }
   },
   3835: function(t, e, n) {
    "use strict";
    var r = n("0d21");
    n("a4d3"), n("e01a"), n("d28b"), n("e260"), n("d3b7"), n("25f0"), n("3ca3"), n("ddb0");
 
    function i(t, e) {
     if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) {
      var n = [],
       r = !0,
       i = !1,
       o = void 0;
      try {
       for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done); r = !0)
        if (n.push(a.value), e && n.length === e) break
      } catch (u) {
       i = !0, o = u
      } finally {
       try {
        r || null == s["return"] || s["return"]()
       } finally {
        if (i) throw o
       }
      }
      return n
     }
    }
    var o = n("3d8c");
 
    function a(t, e) {
     return Object(r["a"])(t) || i(t, e) || Object(o["a"])()
    }
    n.d(e, "a", (function() {
     return a
    }))
   },
   "387f": function(t, e, n) {
    "use strict";
    t.exports = function(t, e, n, r, i) {
     return t.config = e, n && (t.code = n), t.request = r, t.response = i, t.isAxiosError = !0, t.toJSON = function() {
      return {
       message: this.message,
       name: this.name,
       description: this.description,
       number: this.number,
       fileName: this.fileName,
       lineNumber: this.lineNumber,
       columnNumber: this.columnNumber,
       stack: this.stack,
       config: this.config,
       code: this.code
      }
     }, t
    }
   },
   "38cf": function(t, e, n) {
    var r = n("23e7"),
     i = n("1148");
    r({
     target: "String",
     proto: !0
    }, {
     repeat: i
    })
   },
   3934: function(t, e, n) {
    "use strict";
    var r = n("c532");
    t.exports = r.isStandardBrowserEnv() ? function() {
     var t, e = /(msie|trident)/i.test(navigator.userAgent),
      n = document.createElement("a");
 
     function i(t) {
      var r = t;
      return e && (n.setAttribute("href", r), r = n.href), n.setAttribute("href", r), {
       href: n.href,
       protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
       host: n.host,
       search: n.search ? n.search.replace(/^\?/, "") : "",
       hash: n.hash ? n.hash.replace(/^#/, "") : "",
       hostname: n.hostname,
       port: n.port,
       pathname: "/" === n.pathname.charAt(0) ? n.pathname : "/" + n.pathname
      }
     }
     return t = i(window.location.href),
      function(e) {
       var n = r.isString(e) ? i(e) : e;
       return n.protocol === t.protocol && n.host === t.host
      }
    }() : function() {
     return function() {
      return !0
     }
    }()
   },
   "3ad0": function(t, e, n) {},
   "3bbe": function(t, e, n) {
    var r = n("861d");
    t.exports = function(t) {
     if (!r(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
     return t
    }
   },
   "3c93": function(t, e, n) {},
   "3ca3": function(t, e, n) {
    "use strict";
    var r = n("6547").charAt,
     i = n("69f3"),
     o = n("7dd0"),
     a = "String Iterator",
     s = i.set,
     u = i.getterFor(a);
    o(String, "String", (function(t) {
     s(this, {
      type: a,
      string: String(t),
      index: 0
     })
    }), (function() {
     var t, e = u(this),
      n = e.string,
      i = e.index;
     return i >= n.length ? {
      value: void 0,
      done: !0
     } : (t = r(n, i), e.index += t.length, {
      value: t,
      done: !1
     })
    }))
   },
   "3d8c": function(t, e, n) {
    "use strict";
 
    function r() {
     throw new TypeError("Invalid attempt to destructure non-iterable instance")
    }
    n.d(e, "a", (function() {
     return r
    }))
   },
   "3ea3": function(t, e, n) {
    var r = n("23e7"),
     i = n("f748"),
     o = Math.abs,
     a = Math.pow;
    r({
     target: "Math",
     stat: !0
    }, {
     cbrt: function(t) {
      return i(t = +t) * a(o(t), 1 / 3)
     }
    })
   },
   "3f8c": function(t, e) {
    t.exports = {}
   },
   4069: function(t, e, n) {
    var r = n("44d2");
    r("flat")
   },
   "408a": function(t, e, n) {
    var r = n("c6b6");
    t.exports = function(t) {
     if ("number" != typeof t && "Number" != r(t)) throw TypeError("Incorrect invocation");
     return +t
    }
   },
   "40dc": function(t, e, n) {
    "use strict";
    n("a9e3"), n("b680"), n("c7cd");
    var r = n("5530"),
     i = (n("8b0d"), n("71d9"));
 
    function o(t, e) {
     var n = e.value,
      r = e.options || {
       passive: !0
      },
      i = e.arg ? document.querySelector(e.arg) : window;
     i && (i.addEventListener("scroll", n, r), t._onScroll = {
      callback: n,
      options: r,
      target: i
     })
    }
 
    function a(t) {
     if (t._onScroll) {
      var e = t._onScroll,
       n = e.callback,
       r = e.options,
       i = e.target;
      i.removeEventListener("scroll", n, r), delete t._onScroll
     }
    }
    var s = {
      inserted: o,
      unbind: a
     },
     u = s,
     c = n("fe6c"),
     l = n("58df");
 
    function h(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
     return Object(l["a"])(Object(c["b"])(["absolute", "fixed"])).extend({
      name: "applicationable",
      props: {
       app: Boolean
      },
      computed: {
       applicationProperty: function() {
        return t
       }
      },
      watch: {
       app: function(t, e) {
        e ? this.removeApplication(!0) : this.callUpdate()
       },
       applicationProperty: function(t, e) {
        this.$vuetify.application.unregister(this._uid, e)
       }
      },
      activated: function() {
       this.callUpdate()
      },
      created: function() {
       for (var t = 0, n = e.length; t < n; t++) this.$watch(e[t], this.callUpdate);
       this.callUpdate()
      },
      mounted: function() {
       this.callUpdate()
      },
      deactivated: function() {
       this.removeApplication()
      },
      destroyed: function() {
       this.removeApplication()
      },
      methods: {
       callUpdate: function() {
        this.app && this.$vuetify.application.register(this._uid, this.applicationProperty, this.updateApplication())
       },
       removeApplication: function() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        (t || this.app) && this.$vuetify.application.unregister(this._uid, this.applicationProperty)
       },
       updateApplication: function() {
        return 0
       }
      }
     })
    }
    var p = n("d9bd"),
     f = n("2b0e"),
     d = f["a"].extend({
      name: "scrollable",
      directives: {
       Scroll: s
      },
      props: {
       scrollTarget: String,
       scrollThreshold: [String, Number]
      },
      data: function() {
       return {
        currentScroll: 0,
        currentThreshold: 0,
        isActive: !1,
        isScrollingUp: !1,
        previousScroll: 0,
        savedScroll: 0,
        target: null
       }
      },
      computed: {
       canScroll: function() {
        return "undefined" !== typeof window
       },
       computedScrollThreshold: function() {
        return this.scrollThreshold ? Number(this.scrollThreshold) : 300
       }
      },
      watch: {
       isScrollingUp: function() {
        this.savedScroll = this.savedScroll || this.currentScroll
       },
       isActive: function() {
        this.savedScroll = 0
       }
      },
      mounted: function() {
       this.scrollTarget && (this.target = document.querySelector(this.scrollTarget), this.target || Object(p["c"])("Unable to locate element with identifier ".concat(this.scrollTarget), this))
      },
      methods: {
       onScroll: function() {
        var t = this;
        this.canScroll && (this.previousScroll = this.currentScroll, this.currentScroll = this.target ? this.target.scrollTop : window.pageYOffset, this.isScrollingUp = this.currentScroll < this.previousScroll, this.currentThreshold = Math.abs(this.currentScroll - this.computedScrollThreshold), this.$nextTick((function() {
         Math.abs(t.currentScroll - t.savedScroll) > t.computedScrollThreshold && t.thresholdMet()
        })))
       },
       thresholdMet: function() {}
      }
     }),
     v = n("d10f"),
     m = n("f2e7"),
     g = n("80d2"),
     y = Object(l["a"])(i["a"], d, v["a"], m["a"], h("top", ["clippedLeft", "clippedRight", "computedHeight", "invertedScroll", "isExtended", "isProminent", "value"]));
    e["a"] = y.extend({
     name: "v-app-bar",
     directives: {
      Scroll: u
     },
     props: {
      clippedLeft: Boolean,
      clippedRight: Boolean,
      collapseOnScroll: Boolean,
      elevateOnScroll: Boolean,
      fadeImgOnScroll: Boolean,
      hideOnScroll: Boolean,
      invertedScroll: Boolean,
      scrollOffScreen: Boolean,
      shrinkOnScroll: Boolean,
      value: {
       type: Boolean,
       default: !0
      }
     },
     data: function() {
      return {
       isActive: this.value
      }
     },
     computed: {
      applicationProperty: function() {
       return this.bottom ? "bottom" : "top"
      },
      canScroll: function() {
       return d.options.computed.canScroll.call(this) && (this.invertedScroll || this.elevateOnScroll || this.hideOnScroll || this.collapseOnScroll || this.isBooted || !this.value)
      },
      classes: function() {
       return Object(r["a"])({}, i["a"].options.computed.classes.call(this), {
        "v-toolbar--collapse": this.collapse || this.collapseOnScroll,
        "v-app-bar": !0,
        "v-app-bar--clipped": this.clippedLeft || this.clippedRight,
        "v-app-bar--fade-img-on-scroll": this.fadeImgOnScroll,
        "v-app-bar--elevate-on-scroll": this.elevateOnScroll,
        "v-app-bar--fixed": !this.absolute && (this.app || this.fixed),
        "v-app-bar--hide-shadow": this.hideShadow,
        "v-app-bar--is-scrolled": this.currentScroll > 0,
        "v-app-bar--shrink-on-scroll": this.shrinkOnScroll
       })
      },
      computedContentHeight: function() {
       if (!this.shrinkOnScroll) return i["a"].options.computed.computedContentHeight.call(this);
       var t = this.computedOriginalHeight,
        e = this.dense ? 48 : 56,
        n = t,
        r = n - e,
        o = r / this.computedScrollThreshold,
        a = this.currentScroll * o;
       return Math.max(e, n - a)
      },
      computedFontSize: function() {
       if (this.isProminent) {
        var t = this.dense ? 96 : 128,
         e = t - this.computedContentHeight,
         n = .00347;
        return Number((1.5 - e * n).toFixed(2))
       }
      },
      computedLeft: function() {
       return !this.app || this.clippedLeft ? 0 : this.$vuetify.application.left
      },
      computedMarginTop: function() {
       return this.app ? this.$vuetify.application.bar : 0
      },
      computedOpacity: function() {
       if (this.fadeImgOnScroll) {
        var t = Math.max((this.computedScrollThreshold - this.currentScroll) / this.computedScrollThreshold, 0);
        return Number(parseFloat(t).toFixed(2))
       }
      },
      computedOriginalHeight: function() {
       var t = i["a"].options.computed.computedContentHeight.call(this);
       return this.isExtended && (t += parseInt(this.extensionHeight)), t
      },
      computedRight: function() {
       return !this.app || this.clippedRight ? 0 : this.$vuetify.application.right
      },
      computedScrollThreshold: function() {
       return this.scrollThreshold ? Number(this.scrollThreshold) : this.computedOriginalHeight - (this.dense ? 48 : 56)
      },
      computedTransform: function() {
       if (!this.canScroll || this.elevateOnScroll && 0 === this.currentScroll && this.isActive) return 0;
       if (this.isActive) return 0;
       var t = this.scrollOffScreen ? this.computedHeight : this.computedContentHeight;
       return this.bottom ? t : -t
      },
      hideShadow: function() {
       return this.elevateOnScroll && this.isExtended ? this.currentScroll < this.computedScrollThreshold : this.elevateOnScroll ? 0 === this.currentScroll || this.computedTransform < 0 : (!this.isExtended || this.scrollOffScreen) && 0 !== this.computedTransform
      },
      isCollapsed: function() {
       return this.collapseOnScroll ? this.currentScroll > 0 : i["a"].options.computed.isCollapsed.call(this)
      },
      isProminent: function() {
       return i["a"].options.computed.isProminent.call(this) || this.shrinkOnScroll
      },
      styles: function() {
       return Object(r["a"])({}, i["a"].options.computed.styles.call(this), {
        fontSize: Object(g["f"])(this.computedFontSize, "rem"),
        marginTop: Object(g["f"])(this.computedMarginTop),
        transform: "translateY(".concat(Object(g["f"])(this.computedTransform), ")"),
        left: Object(g["f"])(this.computedLeft),
        right: Object(g["f"])(this.computedRight)
       })
      }
     },
     watch: {
      canScroll: "onScroll",
      computedTransform: function() {
       this.canScroll && (this.clippedLeft || this.clippedRight) && this.callUpdate()
      },
      invertedScroll: function(t) {
       this.isActive = !t
      }
     },
     created: function() {
      this.invertedScroll && (this.isActive = !1)
     },
     methods: {
      genBackground: function() {
       var t = i["a"].options.methods.genBackground.call(this);
       return t.data = this._b(t.data || {}, t.tag, {
        style: {
         opacity: this.computedOpacity
        }
       }), t
      },
      updateApplication: function() {
       return this.invertedScroll ? 0 : this.computedHeight + this.computedTransform
      },
      thresholdMet: function() {
       this.invertedScroll ? this.isActive = this.currentScroll > this.computedScrollThreshold : this.currentThreshold < this.computedScrollThreshold || (this.hideOnScroll && (this.isActive = this.isScrollingUp), this.savedScroll = this.currentScroll)
      }
     },
     render: function(t) {
      var e = i["a"].options.render.call(this, t);
      return e.data = e.data || {}, this.canScroll && (e.data.directives = e.data.directives || [], e.data.directives.push({
       arg: this.scrollTarget,
       name: "scroll",
       value: this.onScroll
      })), e
     }
    })
   },
   4160: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("17c2");
    r({
     target: "Array",
     proto: !0,
     forced: [].forEach != i
    }, {
     forEach: i
    })
   },
   "428f": function(t, e, n) {
    var r = n("da84");
    t.exports = r
   },
   4362: function(t, e, n) {
    e.nextTick = function(t) {
      var e = Array.prototype.slice.call(arguments);
      e.shift(), setTimeout((function() {
       t.apply(null, e)
      }), 0)
     }, e.platform = e.arch = e.execPath = e.title = "browser", e.pid = 1, e.browser = !0, e.env = {}, e.argv = [], e.binding = function(t) {
      throw new Error("No such module. (Possibly not yet loaded)")
     },
     function() {
      var t, r = "/";
      e.cwd = function() {
       return r
      }, e.chdir = function(e) {
       t || (t = n("df7c")), r = t.resolve(e, r)
      }
     }(), e.exit = e.kill = e.umask = e.dlopen = e.uptime = e.memoryUsage = e.uvCounters = function() {}, e.features = {}
   },
   "44ad": function(t, e, n) {
    var r = n("d039"),
     i = n("c6b6"),
     o = "".split;
    t.exports = r((function() {
     return !Object("z").propertyIsEnumerable(0)
    })) ? function(t) {
     return "String" == i(t) ? o.call(t, "") : Object(t)
    } : Object
   },
   "44d2": function(t, e, n) {
    var r = n("b622"),
     i = n("7c73"),
     o = n("9bf2"),
     a = r("unscopables"),
     s = Array.prototype;
    void 0 == s[a] && o.f(s, a, {
     configurable: !0,
     value: i(null)
    }), t.exports = function(t) {
     s[a][t] = !0
    }
   },
   "44de": function(t, e, n) {
    var r = n("da84");
    t.exports = function(t, e) {
     var n = r.console;
     n && n.error && (1 === arguments.length ? n.error(t) : n.error(t, e))
    }
   },
   "44e7": function(t, e, n) {
    var r = n("861d"),
     i = n("c6b6"),
     o = n("b622"),
     a = o("match");
    t.exports = function(t) {
     var e;
     return r(t) && (void 0 !== (e = t[a]) ? !!e : "RegExp" == i(t))
    }
   },
   "45ef": function(t, e, n) {
    "use strict";
    n.r(e),
     function(t, r, i) {
      n.d(e, "AdadeltaOptimizer", (function() {
       return mf
      })), n.d(e, "AdagradOptimizer", (function() {
       return gf
      })), n.d(e, "AdamOptimizer", (function() {
       return yf
      })), n.d(e, "AdamaxOptimizer", (function() {
       return bf
      })), n.d(e, "DataStorage", (function() {
       return wi
      })), n.d(e, "ENV", (function() {
       return p
      })), n.d(e, "Environment", (function() {
       return c
      })), n.d(e, "KernelBackend", (function() {
       return Ci
      })), n.d(e, "MomentumOptimizer", (function() {
       return wf
      })), n.d(e, "Optimizer", (function() {
       return vf
      })), n.d(e, "RMSPropOptimizer", (function() {
       return Cf
      })), n.d(e, "Rank", (function() {
       return kt
      })), n.d(e, "Reduction", (function() {
       return ah
      })), n.d(e, "SGDOptimizer", (function() {
       return xf
      })), n.d(e, "Tensor", (function() {
       return Et
      })), n.d(e, "TensorBuffer", (function() {
       return xt
      })), n.d(e, "Variable", (function() {
       return Rt
      })), n.d(e, "abs", (function() {
       return iu
      })), n.d(e, "acos", (function() {
       return ou
      })), n.d(e, "acosh", (function() {
       return au
      })), n.d(e, "add", (function() {
       return ic
      })), n.d(e, "addN", (function() {
       return oc
      })), n.d(e, "addStrict", (function() {
       return ac
      })), n.d(e, "all", (function() {
       return El
      })), n.d(e, "any", (function() {
       return kl
      })), n.d(e, "argMax", (function() {
       return Il
      })), n.d(e, "argMin", (function() {
       return Ol
      })), n.d(e, "asin", (function() {
       return su
      })), n.d(e, "asinh", (function() {
       return uu
      })), n.d(e, "atan", (function() {
       return cu
      })), n.d(e, "atan2", (function() {
       return sc
      })), n.d(e, "atanh", (function() {
       return lu
      })), n.d(e, "avgPool", (function() {
       return dl
      })), n.d(e, "avgPool3d", (function() {
       return gl
      })), n.d(e, "backend", (function() {
       return dn
      })), n.d(e, "backend_util", (function() {
       return Vi
      })), n.d(e, "basicLSTMCell", (function() {
       return Hl
      })), n.d(e, "batchNorm", (function() {
       return Ku
      })), n.d(e, "batchNorm2d", (function() {
       return Xu
      })), n.d(e, "batchNorm3d", (function() {
       return Yu
      })), n.d(e, "batchNorm4d", (function() {
       return Zu
      })), n.d(e, "batchNormalization", (function() {
       return qu
      })), n.d(e, "batchNormalization2d", (function() {
       return Hu
      })), n.d(e, "batchNormalization3d", (function() {
       return $u
      })), n.d(e, "batchNormalization4d", (function() {
       return Gu
      })), n.d(e, "batchToSpaceND", (function() {
       return yr
      })), n.d(e, "booleanMaskAsync", (function() {
       return Vc
      })), n.d(e, "broadcastTo", (function() {
       return br
      })), n.d(e, "browser", (function() {
       return ef
      })), n.d(e, "buffer", (function() {
       return mr
      })), n.d(e, "cast", (function() {
       return xr
      })), n.d(e, "ceil", (function() {
       return hu
      })), n.d(e, "clipByValue", (function() {
       return pu
      })), n.d(e, "clone", (function() {
       return wr
      })), n.d(e, "complex", (function() {
       return _n
      })), n.d(e, "concat", (function() {
       return Jn
      })), n.d(e, "concat1d", (function() {
       return Qn
      })), n.d(e, "concat2d", (function() {
       return tr
      })), n.d(e, "concat3d", (function() {
       return er
      })), n.d(e, "concat4d", (function() {
       return nr
      })), n.d(e, "conv1d", (function() {
       return Gc
      })), n.d(e, "conv2d", (function() {
       return qc
      })), n.d(e, "conv2dTranspose", (function() {
       return el
      })), n.d(e, "conv3d", (function() {
       return Kc
      })), n.d(e, "conv3dTranspose", (function() {
       return nl
      })), n.d(e, "cos", (function() {
       return fu
      })), n.d(e, "cosh", (function() {
       return du
      })), n.d(e, "cumsum", (function() {
       return Cr
      })), n.d(e, "customGrad", (function() {
       return gi
      })), n.d(e, "deprecationWarn", (function() {
       return Ze
      })), n.d(e, "depthToSpace", (function() {
       return Sr
      })), n.d(e, "depthwiseConv2d", (function() {
       return Zc
      })), n.d(e, "diag", (function() {
       return rh
      })), n.d(e, "disableDeprecationWarnings", (function() {
       return Ye
      })), n.d(e, "dispose", (function() {
       return rn
      })), n.d(e, "disposeVariables", (function() {
       return Je
      })), n.d(e, "div", (function() {
       return uc
      })), n.d(e, "divNoNan", (function() {
       return cc
      })), n.d(e, "divStrict", (function() {
       return lc
      })), n.d(e, "dot", (function() {
       return il
      })), n.d(e, "dropout", (function() {
       return ih
      })), n.d(e, "elu", (function() {
       return Ml
      })), n.d(e, "enableDebugMode", (function() {
       return Xe
      })), n.d(e, "enableProdMode", (function() {
       return Ke
      })), n.d(e, "engine", (function() {
       return Qe
      })), n.d(e, "env", (function() {
       return h
      })), n.d(e, "equal", (function() {
       return Ic
      })), n.d(e, "equalStrict", (function() {
       return Oc
      })), n.d(e, "erf", (function() {
       return vu
      })), n.d(e, "exp", (function() {
       return mu
      })), n.d(e, "expandDims", (function() {
       return Er
      })), n.d(e, "expm1", (function() {
       return gu
      })), n.d(e, "eye", (function() {
       return kr
      })), n.d(e, "fft", (function() {
       return Yl
      })), n.d(e, "fill", (function() {
       return qn
      })), n.d(e, "findBackend", (function() {
       return hn
      })), n.d(e, "findBackendFactory", (function() {
       return pn
      })), n.d(e, "floor", (function() {
       return yu
      })), n.d(e, "floorDiv", (function() {
       return hc
      })), n.d(e, "frame", (function() {
       return ch
      })), n.d(e, "fused", (function() {
       return Hh
      })), n.d(e, "gather", (function() {
       return jc
      })), n.d(e, "gatherND", (function() {
       return nh
      })), n.d(e, "gather_util", (function() {
       return Zr
      })), n.d(e, "getBackend", (function() {
       return cn
      })), n.d(e, "getGradient", (function() {
       return m
      })), n.d(e, "getKernel", (function() {
       return v
      })), n.d(e, "getKernelsForBackend", (function() {
       return g
      })), n.d(e, "grad", (function() {
       return pi
      })), n.d(e, "grads", (function() {
       return fi
      })), n.d(e, "greater", (function() {
       return Ac
      })), n.d(e, "greaterEqual", (function() {
       return Nc
      })), n.d(e, "greaterEqualStrict", (function() {
       return Rc
      })), n.d(e, "greaterStrict", (function() {
       return Tc
      })), n.d(e, "hammingWindow", (function() {
       return uh
      })), n.d(e, "hannWindow", (function() {
       return sh
      })), n.d(e, "ifft", (function() {
       return Zl
      })), n.d(e, "imag", (function() {
       return Fn
      })), n.d(e, "image", (function() {
       return Lh
      })), n.d(e, "inTopKAsync", (function() {
       return ph
      })), n.d(e, "io", (function() {
       return Zp
      })), n.d(e, "irfft", (function() {
       return Ql
      })), n.d(e, "isFinite", (function() {
       return Ru
      })), n.d(e, "isInf", (function() {
       return Nu
      })), n.d(e, "isNaN", (function() {
       return Au
      })), n.d(e, "keep", (function() {
       return on
      })), n.d(e, "leakyRelu", (function() {
       return Ll
      })), n.d(e, "less", (function() {
       return _c
      })), n.d(e, "lessEqual", (function() {
       return Dc
      })), n.d(e, "lessEqualStrict", (function() {
       return Fc
      })), n.d(e, "lessStrict", (function() {
       return Mc
      })), n.d(e, "linalg", (function() {
       return Oh
      })), n.d(e, "linspace", (function() {
       return Kn
      })), n.d(e, "localResponseNormalization", (function() {
       return Vl
      })), n.d(e, "log", (function() {
       return bu
      })), n.d(e, "log1p", (function() {
       return xu
      })), n.d(e, "logSigmoid", (function() {
       return wu
      })), n.d(e, "logSoftmax", (function() {
       return xi
      })), n.d(e, "logSumExp", (function() {
       return Al
      })), n.d(e, "logicalAnd", (function() {
       return Ju
      })), n.d(e, "logicalNot", (function() {
       return Qu
      })), n.d(e, "logicalOr", (function() {
       return tc
      })), n.d(e, "logicalXor", (function() {
       return ec
      })), n.d(e, "losses", (function() {
       return Ch
      })), n.d(e, "matMul", (function() {
       return rl
      })), n.d(e, "math", (function() {
       return Qp
      })), n.d(e, "max", (function() {
       return Nl
      })), n.d(e, "maxPool", (function() {
       return fl
      })), n.d(e, "maxPool3d", (function() {
       return ml
      })), n.d(e, "maximum", (function() {
       return pc
      })), n.d(e, "maximumStrict", (function() {
       return fc
      })), n.d(e, "mean", (function() {
       return Rl
      })), n.d(e, "memory", (function() {
       return tn
      })), n.d(e, "min", (function() {
       return Tl
      })), n.d(e, "minimum", (function() {
       return dc
      })), n.d(e, "minimumStrict", (function() {
       return vc
      })), n.d(e, "mod", (function() {
       return mc
      })), n.d(e, "modStrict", (function() {
       return gc
      })), n.d(e, "moments", (function() {
       return _l
      })), n.d(e, "movingAverage", (function() {
       return Gl
      })), n.d(e, "mul", (function() {
       return yc
      })), n.d(e, "mulStrict", (function() {
       return bc
      })), n.d(e, "multiRNNCell", (function() {
       return $l
      })), n.d(e, "multinomial", (function() {
       return Ir
      })), n.d(e, "neg", (function() {
       return Cu
      })), n.d(e, "nextFrame", (function() {
       return If
      })), n.d(e, "norm", (function() {
       return Ul
      })), n.d(e, "notEqual", (function() {
       return Lc
      })), n.d(e, "notEqualStrict", (function() {
       return Bc
      })), n.d(e, "oneHot", (function() {
       return Or
      })), n.d(e, "ones", (function() {
       return $n
      })), n.d(e, "onesLike", (function() {
       return Yn
      })), n.d(e, "op", (function() {
       return Tn
      })), n.d(e, "outerProduct", (function() {
       return ol
      })), n.d(e, "pad", (function() {
       return Ar
      })), n.d(e, "pad1d", (function() {
       return Nr
      })), n.d(e, "pad2d", (function() {
       return Rr
      })), n.d(e, "pad3d", (function() {
       return Tr
      })), n.d(e, "pad4d", (function() {
       return _r
      })), n.d(e, "pool", (function() {
       return vl
      })), n.d(e, "pow", (function() {
       return xc
      })), n.d(e, "powStrict", (function() {
       return wc
      })), n.d(e, "prelu", (function() {
       return Bl
      })), n.d(e, "print", (function() {
       return gr
      })), n.d(e, "prod", (function() {
       return Fl
      })), n.d(e, "profile", (function() {
       return en
      })), n.d(e, "rand", (function() {
       return Dr
      })), n.d(e, "randomGamma", (function() {
       return Mr
      })), n.d(e, "randomNormal", (function() {
       return Fr
      })), n.d(e, "randomUniform", (function() {
       return Lr
      })), n.d(e, "range", (function() {
       return Xn
      })), n.d(e, "ready", (function() {
       return un
      })), n.d(e, "real", (function() {
       return Dn
      })), n.d(e, "reciprocal", (function() {
       return Su
      })), n.d(e, "registerBackend", (function() {
       return fn
      })), n.d(e, "registerGradient", (function() {
       return b
      })), n.d(e, "registerKernel", (function() {
       return y
      })), n.d(e, "relu", (function() {
       return Pl
      })), n.d(e, "relu6", (function() {
       return zl
      })), n.d(e, "removeBackend", (function() {
       return ln
      })), n.d(e, "reshape", (function() {
       return Br
      })), n.d(e, "reverse", (function() {
       return al
      })), n.d(e, "reverse1d", (function() {
       return sl
      })), n.d(e, "reverse2d", (function() {
       return ul
      })), n.d(e, "reverse3d", (function() {
       return cl
      })), n.d(e, "reverse4d", (function() {
       return ll
      })), n.d(e, "rfft", (function() {
       return Jl
      })), n.d(e, "round", (function() {
       return Eu
      })), n.d(e, "rsqrt", (function() {
       return ku
      })), n.d(e, "scalar", (function() {
       return Bn
      })), n.d(e, "scatterND", (function() {
       return Xl
      })), n.d(e, "scatter_util", (function() {
       return ri
      })), n.d(e, "selu", (function() {
       return jl
      })), n.d(e, "separableConv2d", (function() {
       return tl
      })), n.d(e, "serialization", (function() {
       return af
      })), n.d(e, "setBackend", (function() {
       return sn
      })), n.d(e, "setPlatform", (function() {
       return vn
      })), n.d(e, "setdiff1dAsync", (function() {
       return Hr
      })), n.d(e, "sigmoid", (function() {
       return Iu
      })), n.d(e, "sign", (function() {
       return Ou
      })), n.d(e, "signal", (function() {
       return hh
      })), n.d(e, "sin", (function() {
       return Tu
      })), n.d(e, "sinh", (function() {
       return _u
      })), n.d(e, "slice", (function() {
       return yl
      })), n.d(e, "slice1d", (function() {
       return bl
      })), n.d(e, "slice2d", (function() {
       return xl
      })), n.d(e, "slice3d", (function() {
       return wl
      })), n.d(e, "slice4d", (function() {
       return Cl
      })), n.d(e, "slice_util", (function() {
       return hi
      })), n.d(e, "softmax", (function() {
       return bi
      })), n.d(e, "softplus", (function() {
       return Du
      })), n.d(e, "spaceToBatchND", (function() {
       return Pr
      })), n.d(e, "sparseToDense", (function() {
       return eh
      })), n.d(e, "spectral", (function() {
       return th
      })), n.d(e, "split", (function() {
       return rr
      })), n.d(e, "sqrt", (function() {
       return Fu
      })), n.d(e, "square", (function() {
       return ru
      })), n.d(e, "squaredDifference", (function() {
       return Cc
      })), n.d(e, "squaredDifferenceStrict", (function() {
       return Sc
      })), n.d(e, "squeeze", (function() {
       return zr
      })), n.d(e, "stack", (function() {
       return jr
      })), n.d(e, "step", (function() {
       return Mu
      })), n.d(e, "stft", (function() {
       return lh
      })), n.d(e, "stridedSlice", (function() {
       return ql
      })), n.d(e, "sub", (function() {
       return Ec
      })), n.d(e, "subStrict", (function() {
       return kc
      })), n.d(e, "sum", (function() {
       return Dl
      })), n.d(e, "sumOutType", (function() {
       return Dt
      })), n.d(e, "tan", (function() {
       return Lu
      })), n.d(e, "tanh", (function() {
       return Bu
      })), n.d(e, "tensor", (function() {
       return Mn
      })), n.d(e, "tensor1d", (function() {
       return Pn
      })), n.d(e, "tensor2d", (function() {
       return zn
      })), n.d(e, "tensor3d", (function() {
       return jn
      })), n.d(e, "tensor4d", (function() {
       return Wn
      })), n.d(e, "tensor5d", (function() {
       return Vn
      })), n.d(e, "tensor6d", (function() {
       return Un
      })), n.d(e, "tensor_util", (function() {
       return Pt
      })), n.d(e, "test_util", (function() {
       return pf
      })), n.d(e, "tidy", (function() {
       return nn
      })), n.d(e, "tile", (function() {
       return Wr
      })), n.d(e, "time", (function() {
       return an
      })), n.d(e, "topk", (function() {
       return Kl
      })), n.d(e, "train", (function() {
       return Ef
      })), n.d(e, "transpose", (function() {
       return Wl
      })), n.d(e, "truncatedNormal", (function() {
       return Vr
      })), n.d(e, "unregisterGradient", (function() {
       return w
      })), n.d(e, "unregisterKernel", (function() {
       return x
      })), n.d(e, "unsortedSegmentSum", (function() {
       return Wc
      })), n.d(e, "unstack", (function() {
       return Ur
      })), n.d(e, "util", (function() {
       return lt
      })), n.d(e, "valueAndGrad", (function() {
       return di
      })), n.d(e, "valueAndGrads", (function() {
       return vi
      })), n.d(e, "variable", (function() {
       return Hn
      })), n.d(e, "variableGrads", (function() {
       return mi
      })), n.d(e, "version_core", (function() {
       return ff
      })), n.d(e, "webgl", (function() {
       return df
      })), n.d(e, "where", (function() {
       return nc
      })), n.d(e, "whereAsync", (function() {
       return rc
      })), n.d(e, "zeros", (function() {
       return Gn
      })), n.d(e, "zerosLike", (function() {
       return Zn
      }));
      /**
       * @license
       * Copyright 2020 Google LLC. All Rights Reserved.
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       * =============================================================================
       */
      var o = function(t, e) {
       return (o = Object.setPrototypeOf || {
         __proto__: []
        }
        instanceof Array && function(t, e) {
         t.__proto__ = e
        } || function(t, e) {
         for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        })(t, e)
      };
 
      function a(t, e) {
       function n() {
        this.constructor = t
       }
       o(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
      }
 
      function s(t, e, n, r) {
       return new(n || (n = Promise))((function(i, o) {
        function a(t) {
         try {
          u(r.next(t))
         } catch (t) {
          o(t)
         }
        }
 
        function s(t) {
         try {
          u(r.throw(t))
         } catch (t) {
          o(t)
         }
        }
 
        function u(t) {
         t.done ? i(t.value) : new n((function(e) {
          e(t.value)
         })).then(a, s)
        }
        u((r = r.apply(t, e || [])).next())
       }))
      }
 
      function u(t, e) {
       var n, r, i, o, a = {
        label: 0,
        sent: function() {
         if (1 & i[0]) throw i[1];
         return i[1]
        },
        trys: [],
        ops: []
       };
       return o = {
        next: s(0),
        throw: s(1),
        return: s(2)
       }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
        return this
       }), o;
 
       function s(o) {
        return function(s) {
         return function(o) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; a;) try {
           if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
           switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
            case 0:
            case 1:
             i = o;
             break;
            case 4:
             return a.label++, {
              value: o[1],
              done: !1
             };
            case 5:
             a.label++, r = o[1], o = [0];
             continue;
            case 7:
             o = a.ops.pop(), a.trys.pop();
             continue;
            default:
             if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
              a = 0;
              continue
             }
             if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
              a.label = o[1];
              break
             }
             if (6 === o[0] && a.label < i[1]) {
              a.label = i[1], i = o;
              break
             }
             if (i && a.label < i[2]) {
              a.label = i[2], a.ops.push(o);
              break
             }
             i[2] && a.ops.pop(), a.trys.pop();
             continue
           }
           o = e.call(t, a)
          } catch (t) {
           o = [6, t], r = 0
          } finally {
           n = i = 0
          }
          if (5 & o[0]) throw o[1];
          return {
           value: o[0] ? o[1] : void 0,
           done: !0
          }
         }([o, s])
        }
       }
      }
      var c = function() {
       function t(t) {
        this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags()
       }
       return t.prototype.setPlatform = function(t, e) {
        null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e + "."), this.platformName = t, this.platform = e
       }, t.prototype.registerFlag = function(t, e, n) {
        if (this.flagRegistry[t] = {
          evaluationFn: e,
          setHook: n
         }, null != this.urlFlags[t]) {
         var r = this.urlFlags[t];
         console.warn("Setting feature override from URL " + t + ": " + r + "."), this.set(t, r)
        }
       }, t.prototype.get = function(t) {
        return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t])
       }, t.prototype.getNumber = function(t) {
        return this.get(t)
       }, t.prototype.getBool = function(t) {
        return this.get(t)
       }, t.prototype.getFlags = function() {
        return this.flags
       }, Object.defineProperty(t.prototype, "features", {
        get: function() {
         return this.flags
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.set = function(t, e) {
        if (null == this.flagRegistry[t]) throw new Error("Cannot set flag " + t + " as it has not been registered.");
        this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e)
       }, t.prototype.evaluateFlag = function(t) {
        if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.");
        return this.flagRegistry[t].evaluationFn()
       }, t.prototype.setFlags = function(t) {
        this.flags = Object.assign({}, t)
       }, t.prototype.reset = function() {
        this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
       }, t.prototype.populateURLFlags = function() {
        var t = this;
        if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
         var e, n, r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (function(t) {
          for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
          return l(n, e[0], e[1]), e.join("=")
         })), n);
         "tfjsflags" in r && r.tfjsflags.split(",").forEach((function(e) {
          var n = e.split(":"),
           r = n[0],
           i = n[1];
          t.urlFlags[r] = function(t, e) {
           if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
           if ("" + +e === e) return +e;
           throw new Error("Could not parse value flag value " + e + " for flag " + t + ".")
          }(r, i)
         }))
        }
       }, t
      }();
 
      function l(t, e, n) {
       t[decodeURIComponent(e)] = decodeURIComponent(n || "")
      }
 
      function h() {
       return p
      }
      var p = null,
       f = new Map,
       d = new Map;
 
      function v(t, e) {
       var n = C(t, e);
       return f.get(n)
      }
 
      function m(t) {
       return d.get(t)
      }
 
      function g(t) {
       for (var e = f.entries(), n = [];;) {
        var r = e.next(),
         i = r.done,
         o = r.value;
        if (i) break;
        var a = o[0],
         s = o[1];
        a.split("_")[0] === t && n.push(s)
       }
       return n
      }
 
      function y(t) {
       var e = t.kernelName,
        n = t.backendName,
        r = C(e, n);
       if (f.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered");
       f.set(r, t)
      }
 
      function b(t) {
       var e = t.kernelName;
       d.has(e) && console.warn("Overriding the gradient for '" + e + "'"), d.set(e, t)
      }
 
      function x(t, e) {
       var n = C(t, e);
       if (!f.has(n)) throw new Error("The kernel '" + t + "' for backend '" + e + "' is not registered");
       f.delete(n)
      }
 
      function w(t) {
       if (!d.has(t)) throw new Error("The gradient '" + t + "' for backend is not registered");
       d.delete(t)
      }
 
      function C(t, e) {
       return e + "_" + t
      }
 
      function S(t) {
       for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n
      }
 
      function E(t, e, n) {
       return Math.max(t, Math.min(e, n))
      }
 
      function k(t) {
       return t % 2 == 0 ? t : t + 1
      }
 
      function I(t) {
       for (var e = 0, n = 0; n < t.length; n++) e += t[n];
       return e
      }
 
      function O(t, e) {
       if (!t) throw new Error("string" == typeof e ? e : e())
      }
 
      function A(t, e, n) {
       void 0 === n && (n = ""), O(_(t, e), (function() {
        return n + " Shapes " + t + " and " + e + " must match"
       }))
      }
 
      function N(t) {
       O(null != t, (function() {
        return "The input to the tensor constructor must be a non-null value."
       }))
      }
 
      function R(t, e, n) {
       if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || G(t) && !n)
        for (var r = 0; r < t.length; ++r) R(t[r], e, n);
       else e.push(t);
       return e
      }
 
      function T(t) {
       if (0 === t.length) return 1;
       for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];
       return e
      }
 
      function _(t, e) {
       if (t === e) return !0;
       if (null == t || null == e) return !1;
       if (t.length !== e.length) return !1;
       for (var n = 0; n < t.length; n++)
        if (t[n] !== e[n]) return !1;
       return !0
      }
 
      function D(t) {
       return t % 1 == 0
      }
 
      function F(t) {
       if (null != Math.tanh) return Math.tanh(t);
       if (t === 1 / 0) return 1;
       if (t === -1 / 0) return -1;
       var e = Math.exp(2 * t);
       return (e - 1) / (e + 1)
      }
 
      function M(t) {
       var e = Math.ceil(Math.sqrt(t));
       return [e, Math.ceil(t / e)]
      }
 
      function L(t, e) {
       return e <= t.length ? t : t + " ".repeat(e - t.length)
      }
 
      function B(t, e, n) {
       return void 0 === e && (e = function(t) {
        return 0
       }), new Promise((function(r, i) {
        var o = 0,
         a = function() {
          if (t()) r();
          else {
           o++;
           var s = e(o);
           null != n && o >= n ? i() : setTimeout(a, s)
          }
         };
        a()
       }))
      }
 
      function P(t, e) {
       for (var n = 1, r = -1, i = 0; i < t.length; ++i)
        if (t[i] >= 0) n *= t[i];
        else if (-1 === t[i]) {
        if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + i);
        r = i
       } else if (t[i] < 0) throw Error("Shapes can not be < 0. Found " + t[i] + " at dim " + i);
       if (-1 === r) {
        if (e > 0 && e !== n) throw Error("Size(" + e + ") must match the product of shape " + t);
        return t
       }
       if (0 === n) throw Error("Cannot infer the missing size in [" + t + "] when there are 0 elements");
       if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + n);
       var o = t.slice();
       return o[r] = e / n, o
      }
 
      function z(t, e) {
       var n = e.length;
       return O((t = null == t ? e.map((function(t, e) {
        return e
       })) : [].concat(t)).every((function(t) {
        return t >= -n && t < n
       })), (function() {
        return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + t
       })), O(t.every((function(t) {
        return D(t)
       })), (function() {
        return "All values in axis param must be integers but got axis " + t
       })), t.map((function(t) {
        return t < 0 ? n + t : t
       }))
      }
 
      function j(t, e) {
       for (var n = [], r = [], i = null != e && Array.isArray(e) && 0 === e.length, o = null == e || i ? null : z(e, t).sort(), a = 0, s = 0; s < t.length; ++s) {
        if (null != o) {
         if (o[a] === s && 1 !== t[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + t[s] + "' is not 1");
         (null == o[a] || o[a] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), o[a] <= s && a++
        }
        1 !== t[s] && (n.push(t[s]), r.push(s))
       }
       return {
        newShape: n,
        keptDims: r
       }
      }
 
      function W(t, e) {
       var n = null;
       if (null == t || "float32" === t) n = new Float32Array(e);
       else if ("int32" === t) n = new Int32Array(e);
       else {
        if ("bool" !== t) throw new Error("Unknown data type " + t);
        n = new Uint8Array(e)
       }
       return n
      }
 
      function V(t, e) {
       var n = null;
       if (null == t || "float32" === t) n = new Float32Array(e);
       else if ("int32" === t) n = new Int32Array(e);
       else if ("bool" === t) n = new Uint8Array(e);
       else {
        if ("string" !== t) throw new Error("Unknown data type " + t);
        n = new Array(e)
       }
       return n
      }
 
      function U(t, e) {
       for (var n = 0; n < t.length; n++) {
        var r = t[n];
        if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".")
       }
      }
 
      function H(t) {
       return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t
      }
 
      function $(t, e) {
       return "complex64" !== e && ("float32" !== e || "complex64" === t) && ("int32" !== e || "float32" === t || "complex64" === t) && ("bool" !== e || "bool" !== t)
      }
 
      function G(t) {
       return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array
      }
 
      function q(t) {
       if ("float32" === t || "int32" === t) return 4;
       if ("complex64" === t) return 8;
       if ("bool" === t) return 1;
       throw new Error("Unknown dtype " + t)
      }
 
      function K(t) {
       if (null == t) return 0;
       var e = 0;
       return t.forEach((function(t) {
        return e += t.length
       })), e
      }
 
      function X(t) {
       return "string" == typeof t || t instanceof String
      }
 
      function Y(t) {
       return "boolean" == typeof t
      }
 
      function Z(t) {
       return "number" == typeof t
      }
 
      function J(t) {
       return Array.isArray(t) ? J(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : Z(t) ? "float32" : X(t) ? "string" : Y(t) ? "bool" : "float32"
      }
 
      function Q(t) {
       return !!(t && t.constructor && t.call && t.apply)
      }
 
      function tt(t, e) {
       for (var n = e; n < t; ++n)
        if (t % n == 0) return n;
       return t
      }
 
      function et(t) {
       var e = t.length;
       if (e < 2) return [];
       var n = new Array(e - 1);
       n[e - 2] = t[e - 1];
       for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];
       return n
      }
 
      function nt(t, e, n) {
       if ("string" === e) throw new Error("Cannot convert a string[] to a TypedArray");
       if (Array.isArray(t) && (t = R(t)), n && U(t, e), function(t, e) {
         return t instanceof Float32Array && "float32" === e || t instanceof Int32Array && "int32" === e || t instanceof Uint8Array && "bool" === e
        }(t, e)) return t;
       if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
       if ("int32" === e) return new Int32Array(t);
       if ("bool" === e) {
        for (var r = new Uint8Array(t.length), i = 0; i < r.length; ++i) 0 !== Math.round(t[i]) && (r[i] = 1);
        return r
       }
       throw new Error("Unknown data type " + e)
      }
 
      function rt(t, e) {
       if (0 === t.length) return e[0];
       var n = t.reduce((function(t, e) {
        return t * e
       }));
       if (0 === n) return [];
       if (n !== e.length) throw new Error("[" + t + "] does not match the input size.");
       return function t(e, n, r) {
        var i = new Array;
        if (1 === n.length)
         for (var o = n[0], a = 0; a < o; a++) i[a] = r[e + a];
        else {
         o = n[0];
         var s = n.slice(1),
          u = s.reduce((function(t, e) {
           return t * e
          }));
         for (a = 0; a < o; a++) i[a] = t(e + a * u, s, r)
        }
        return i
       }(0, t, e)
      }
 
      function it(t, e) {
       for (var n = ot(t, e), r = 0; r < n.length; r++) n[r] = 1;
       return n
      }
 
      function ot(t, e) {
       if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
       if ("int32" === e) return new Int32Array(t);
       if ("bool" === e) return new Uint8Array(t);
       throw new Error("Unknown data type " + e)
      }
 
      function at() {
       return h().platform.now()
      }
 
      function st(t) {
       t.forEach((function(e) {
        O(Number.isInteger(e) && e >= 0, (function() {
         return "Tensor must have a shape comprised of positive integers but got shape [" + t + "]."
        }))
       }))
      }
 
      function ut(t, e) {
       return void 0 === e && (e = "utf-8"), e = e || "utf-8", h().platform.encode(t, e)
      }
 
      function ct(t, e) {
       return void 0 === e && (e = "utf-8"), e = e || "utf-8", h().platform.decode(t, e)
      }
      var lt = Object.freeze({
        shuffle: S,
        clamp: E,
        nearestLargerEven: k,
        sum: I,
        randUniform: function(t, e) {
         var n = Math.random();
         return e * n + (1 - n) * t
        },
        distSquared: function(t, e) {
         for (var n = 0, r = 0; r < t.length; r++) {
          var i = Number(t[r]) - Number(e[r]);
          n += i * i
         }
         return n
        },
        assert: O,
        assertShapesMatch: A,
        assertNonNull: N,
        flatten: R,
        sizeFromShape: T,
        isScalarShape: function(t) {
         return 0 === t.length
        },
        arraysEqual: _,
        isInt: D,
        tanh: F,
        sizeToSquarishShape: M,
        createShuffledIndices: function(t) {
         for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;
         return S(e), e
        },
        rightPad: L,
        repeatedTry: B,
        inferFromImplicitShape: P,
        parseAxisParam: z,
        squeezeShape: j,
        getTypedArrayFromDType: W,
        getArrayFromDType: V,
        checkConversionForErrors: U,
        isValidDtype: H,
        hasEncodingLoss: $,
        isTypedArray: G,
        bytesPerElement: q,
        bytesFromStringArray: K,
        isString: X,
        isBoolean: Y,
        isNumber: Z,
        inferDtype: J,
        isFunction: Q,
        nearestDivisor: tt,
        computeStrides: et,
        toTypedArray: nt,
        toNestedArray: rt,
        makeOnesTypedArray: it,
        makeZerosTypedArray: ot,
        now: at,
        assertNonNegativeIntegerDimensions: st,
        fetch: function(t, e) {
         return h().platform.fetch(t, e)
        },
        encodeString: ut,
        decodeString: ct
       }),
       ht = function() {
        function t(t, e) {
         this.backendTimer = t, this.logger = e, null == e && (this.logger = new pt)
        }
        return t.prototype.profileKernel = function(t, e, n) {
         var r, i = this,
          o = this.backendTimer.time((function() {
           r = n()
          }));
         return r.forEach((function(n) {
          n.data().then((function(r) {
           ! function(t, e, n) {
            if ("float32" !== e) return !1;
            for (var r = 0; r < t.length; r++) {
             var i = t[r];
             if (isNaN(i) || !isFinite(i)) return console.warn("Found " + i + " in the result of '" + n + "'"), !0
            }
           }(r, n.dtype, t), o.then((function(o) {
            var a = "";
            null != o.getExtraProfileInfo && (a = o.getExtraProfileInfo()), i.logger.logKernelProfile(t, n, r, o.kernelMs, e, a)
           }))
          }))
         })), r
        }, t
       }(),
       pt = function() {
        function t() {}
        return t.prototype.logKernelProfile = function(t, e, n, r, i, o) {
         var a = L(r + "ms", 9),
          s = L(t, 25),
          u = e.rank,
          c = e.size,
          l = L(e.shape.toString(), 14),
          h = "";
         for (var p in i) {
          var f = i[p].shape || e.shape,
           d = f.length;
          h += p + ": " + d + "D " + (d > 0 ? f : "") + " "
         }
         console.log("%c" + s + "\t%c" + a + "\t%c" + u + "D " + l + "\t%c" + c + "\t%c" + h + "\t%c" + o, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
        }, t
       }(),
       ft = 20,
       dt = 3,
       vt = 7;
 
      function mt(t, e, n, r) {
       var i = et(e),
        o = function(t, e, n, r) {
         var i = T(e),
          o = r[r.length - 1],
          a = new Array(o).fill(0),
          s = e.length,
          u = "complex64" === n ? bt(t) : t;
         if (s > 1)
          for (var c = 0; c < i / o; c++)
           for (var l = c * o, h = 0; h < o; h++) a[h] = Math.max(a[h], gt(u[l + h], 0, n).length);
         return a
        }(t, e, n, i),
        a = e.length,
        s = function t(e, n, r, i, o, a) {
         void 0 === a && (a = !0);
         var s = "complex64" === r ? 2 : 1,
          u = n[0],
          c = n.length;
         if (0 === c) return "complex64" === r ? [gt(bt(e)[0], 0, r)] : "bool" === r ? [yt(e[0])] : [e[0].toString()];
         if (1 === c) {
          if (u > ft) {
           var l = dt * s,
            h = Array.from(e.slice(0, l)),
            p = Array.from(e.slice((u - dt) * s, u * s));
           return "complex64" === r && (h = bt(h), p = bt(p)), ["[" + h.map((function(t, e) {
            return gt(t, o[e], r)
           })).join(", ") + ", ..., " + p.map((function(t, e) {
            return gt(t, o[u - dt + e], r)
           })).join(", ") + "]"]
          }
          return ["[" + ("complex64" === r ? bt(e) : Array.from(e)).map((function(t, e) {
           return gt(t, o[e], r)
          })).join(", ") + "]"]
         }
         var f = n.slice(1),
          d = i.slice(1),
          v = i[0] * s,
          m = [];
         if (u > ft) {
          for (var g = 0; g < dt; g++) {
           var y = (b = g * v) + v;
           m.push.apply(m, t(e.slice(b, y), f, r, d, o, !1))
          }
          for (m.push("..."), g = u - dt; g < u; g++) y = (b = g * v) + v, m.push.apply(m, t(e.slice(b, y), f, r, d, o, g === u - 1))
         } else
          for (g = 0; g < u; g++) {
           var b;
           y = (b = g * v) + v, m.push.apply(m, t(e.slice(b, y), f, r, d, o, g === u - 1))
          }
         var x = 2 === c ? "," : "";
         for (m[0] = "[" + m[0] + x, g = 1; g < m.length - 1; g++) m[g] = " " + m[g] + x;
         var w = ",\n";
         for (g = 2; g < c; g++) w += "\n";
         return m[m.length - 1] = " " + m[m.length - 1] + "]" + (a ? "" : w), m
        }(t, e, n, i, o),
        u = ["Tensor"];
       return r && (u.push("  dtype: " + n), u.push("  rank: " + a), u.push("  shape: [" + e + "]"), u.push("  values:")), u.push(s.map((function(t) {
        return "    " + t
       })).join("\n")), u.join("\n")
      }
 
      function gt(t, e, n) {
       return L(Array.isArray(t) ? parseFloat(t[0].toFixed(vt)) + " + " + parseFloat(t[1].toFixed(vt)) + "j" : X(t) ? "'" + t + "'" : "bool" === n ? yt(t) : parseFloat(t.toFixed(vt)).toString(), e)
      }
 
      function yt(t) {
       return 0 === t ? "false" : "true"
      }
 
      function bt(t) {
       for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);
       return e
      }
      var xt = function() {
        function t(t, e, n) {
         var r = this;
         if (this.dtype = e, this.shape = t.slice(), this.size = T(t), null != n) {
          var i = n.length;
          O(i === this.size, (function() {
           return "Length of values '" + i + "' does not match the size inferred by the shape '" + r.size + "'."
          }))
         }
         if ("complex64" === e) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
         this.values = n || V(e, this.size), this.strides = et(t)
        }
        return t.prototype.set = function(t) {
         for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
         0 === n.length && (n = [0]), O(n.length === this.rank, (function() {
          return "The number of provided coordinates (" + n.length + ") must match the rank (" + e.rank + ")"
         }));
         var i = this.locToIndex(n);
         this.values[i] = t
        }, t.prototype.get = function() {
         for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
         0 === t.length && (t = [0]);
         for (var n = 0, r = 0, i = t; r < i.length; r++) {
          var o = i[r];
          if (o < 0 || o >= this.shape[n]) {
           var a = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
           throw new Error(a)
          }
          n++
         }
         for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u) s += this.strides[u] * t[u];
         return this.values[s]
        }, t.prototype.locToIndex = function(t) {
         if (0 === this.rank) return 0;
         if (1 === this.rank) return t[0];
         for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];
         return e
        }, t.prototype.indexToLoc = function(t) {
         if (0 === this.rank) return [];
         if (1 === this.rank) return [t];
         for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];
         return e[e.length - 1] = t, e
        }, Object.defineProperty(t.prototype, "rank", {
         get: function() {
          return this.shape.length
         },
         enumerable: !0,
         configurable: !0
        }), t.prototype.toTensor = function() {
         return wt().makeTensor(this.values, this.shape, this.dtype)
        }, t
       }(),
       wt = null,
       Ct = null,
       St = null,
       Et = function() {
        function t(t, e, n, r) {
         this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || "float32", this.size = T(t), this.strides = et(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
        }
        return t.prototype.flatten = function() {
         return this.throwIfDisposed(), this.as1D()
        }, t.prototype.asScalar = function() {
         return this.throwIfDisposed(), O(1 === this.size, (function() {
          return "The array must have only 1 element."
         })), this.reshape([])
        }, t.prototype.as1D = function() {
         return this.throwIfDisposed(), this.reshape([this.size])
        }, t.prototype.as2D = function(t, e) {
         return this.throwIfDisposed(), this.reshape([t, e])
        }, t.prototype.as3D = function(t, e, n) {
         return this.throwIfDisposed(), this.reshape([t, e, n])
        }, t.prototype.as4D = function(t, e, n, r) {
         return this.throwIfDisposed(), this.reshape([t, e, n, r])
        }, t.prototype.as5D = function(t, e, n, r, i) {
         return this.throwIfDisposed(), this.reshape([t, e, n, r, i])
        }, t.prototype.asType = function(t) {
         return this.throwIfDisposed(), Ct.cast(this, t)
        }, Object.defineProperty(t.prototype, "rank", {
         get: function() {
          return this.shape.length
         },
         enumerable: !0,
         configurable: !0
        }), t.prototype.buffer = function() {
         return s(this, void 0, void 0, (function() {
          var t;
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, this.data()];
            case 1:
             return t = e.sent(), [2, Ct.buffer(this.shape, this.dtype, t)]
           }
          }))
         }))
        }, t.prototype.bufferSync = function() {
         return Ct.buffer(this.shape, this.dtype, this.dataSync())
        }, t.prototype.array = function() {
         return s(this, void 0, void 0, (function() {
          var t;
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return [4, this.data()];
            case 1:
             return t = e.sent(), [2, rt(this.shape, t)]
           }
          }))
         }))
        }, t.prototype.arraySync = function() {
         return rt(this.shape, this.dataSync())
        }, t.prototype.data = function() {
         return s(this, void 0, void 0, (function() {
          var t, e;
          return u(this, (function(n) {
           switch (n.label) {
            case 0:
             return this.throwIfDisposed(), t = wt().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t];
            case 1:
             e = n.sent();
             try {
              return [2, e.map((function(t) {
               return ct(t)
              }))]
             } catch (t) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
             }
             n.label = 2;
            case 2:
             return [2, t]
           }
          }))
         }))
        }, t.prototype.dataSync = function() {
         this.throwIfDisposed();
         var t = wt().readSync(this.dataId);
         if ("string" === this.dtype) try {
          return t.map((function(t) {
           return ct(t)
          }))
         } catch (t) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
         }
         return t
        }, t.prototype.bytes = function() {
         return s(this, void 0, void 0, (function() {
          var t;
          return u(this, (function(e) {
           switch (e.label) {
            case 0:
             return this.throwIfDisposed(), [4, wt().read(this.dataId)];
            case 1:
             return t = e.sent(), "string" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)]
           }
          }))
         }))
        }, t.prototype.dispose = function() {
         this.isDisposed || (wt().disposeTensor(this), this.isDisposedInternal = !0)
        }, Object.defineProperty(t.prototype, "isDisposed", {
         get: function() {
          return this.isDisposedInternal
         },
         enumerable: !0,
         configurable: !0
        }), t.prototype.throwIfDisposed = function() {
         if (this.isDisposed) throw new Error("Tensor is disposed.")
        }, t.prototype.toFloat = function() {
         return this.asType("float32")
        }, t.prototype.toInt = function() {
         return this.asType("int32")
        }, t.prototype.toBool = function() {
         return this.asType("bool")
        }, t.prototype.print = function(t) {
         return void 0 === t && (t = !1), Ct.print(this, t)
        }, t.prototype.reshape = function(t) {
         return this.throwIfDisposed(), Ct.reshape(this, t)
        }, t.prototype.reshapeAs = function(t) {
         return this.throwIfDisposed(), this.reshape(t.shape)
        }, t.prototype.expandDims = function(t) {
         return void 0 === t && (t = 0), Ct.expandDims(this, t)
        }, t.prototype.cumsum = function(t, e, n) {
         return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), Ct.cumsum(this, t, e, n)
        }, t.prototype.squeeze = function(t) {
         return this.throwIfDisposed(), Ct.squeeze(this, t)
        }, t.prototype.clone = function() {
         return this.throwIfDisposed(), Ct.clone(this)
        }, t.prototype.oneHot = function(t, e, n) {
         return this.throwIfDisposed(), Ct.oneHot(this, t, e, n)
        }, t.prototype.toString = function(t) {
         return void 0 === t && (t = !1), mt(this.dataSync(), this.shape, this.dtype, t)
        }, t.prototype.tile = function(t) {
         return this.throwIfDisposed(), Ct.tile(this, t)
        }, t.prototype.gather = function(t, e) {
         return void 0 === e && (e = 0), this.throwIfDisposed(), Ct.gather(this, t, e)
        }, t.prototype.matMul = function(t, e, n) {
         return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), Ct.matMul(this, t, e, n)
        }, t.prototype.dot = function(t) {
         return this.throwIfDisposed(), Ct.dot(this, t)
        }, t.prototype.norm = function(t, e, n) {
         return void 0 === t && (t = "euclidean"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), Ct.norm(this, t, e, n)
        }, t.prototype.slice = function(t, e) {
         return this.throwIfDisposed(), Ct.slice(this, t, e)
        }, t.prototype.reverse = function(t) {
         return this.throwIfDisposed(), Ct.reverse(this, t)
        }, t.prototype.concat = function(e, n) {
         return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), Ct.concat([this].concat(e), n)
        }, t.prototype.split = function(t, e) {
         return void 0 === e && (e = 0), this.throwIfDisposed(), Ct.split(this, t, e)
        }, t.prototype.stack = function(t, e) {
         return void 0 === e && (e = 0), Ct.stack([this, t], e)
        }, t.prototype.unstack = function(t) {
         return void 0 === t && (t = 0), Ct.unstack(this, t)
        }, t.prototype.pad = function(t, e) {
         return void 0 === e && (e = 0), Ct.pad(this, t, e)
        }, t.prototype.batchNormalization = function(t, e, n, r, i) {
         return void 0 === n && (n = .001), St("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t, e, i, r, n)
        }, t.prototype.batchNorm = function(t, e, n, r, i) {
         return void 0 === i && (i = .001), this.throwIfDisposed(), Ct.batchNorm(this, t, e, n, r, i)
        }, t.prototype.all = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.all(this, t, e)
        }, t.prototype.any = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.any(this, t, e)
        }, t.prototype.logSumExp = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.logSumExp(this, t, e)
        }, t.prototype.sum = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.sum(this, t, e)
        }, t.prototype.prod = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.prod(this, t, e)
        }, t.prototype.mean = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.mean(this, t, e)
        }, t.prototype.min = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.min(this, t, e)
        }, t.prototype.max = function(t, e) {
         return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), Ct.max(this, t, e)
        }, t.prototype.argMin = function(t) {
         return void 0 === t && (t = null), this.throwIfDisposed(), Ct.argMin(this, t)
        }, t.prototype.argMax = function(t) {
         return void 0 === t && (t = null), this.throwIfDisposed(), Ct.argMax(this, t)
        }, t.prototype.cast = function(t) {
         return this.throwIfDisposed(), Ct.cast(this, t)
        }, t.prototype.add = function(t) {
         return this.throwIfDisposed(), Ct.add(this, t)
        }, t.prototype.addStrict = function(t) {
         return this.throwIfDisposed(), Ct.addStrict(this, t)
        }, t.prototype.atan2 = function(t) {
         return this.throwIfDisposed(), Ct.atan2(this, t)
        }, t.prototype.sub = function(t) {
         return this.throwIfDisposed(), Ct.sub(this, t)
        }, t.prototype.subStrict = function(t) {
         return this.throwIfDisposed(), Ct.subStrict(this, t)
        }, t.prototype.pow = function(t) {
         return this.throwIfDisposed(), Ct.pow(this, t)
        }, t.prototype.powStrict = function(t) {
         return this.throwIfDisposed(), Ct.powStrict(this, t)
        }, t.prototype.mul = function(t) {
         return this.throwIfDisposed(), Ct.mul(this, t)
        }, t.prototype.mulStrict = function(t) {
         return this.throwIfDisposed(), Ct.mulStrict(this, t)
        }, t.prototype.div = function(t) {
         return this.throwIfDisposed(), Ct.div(this, t)
        }, t.prototype.divNoNan = function(t) {
         return this.throwIfDisposed(), Ct.divNoNan(this, t)
        }, t.prototype.floorDiv = function(t) {
         return this.throwIfDisposed(), Ct.floorDiv(this, t)
        }, t.prototype.divStrict = function(t) {
         return this.throwIfDisposed(), Ct.divStrict(this, t)
        }, t.prototype.minimum = function(t) {
         return this.throwIfDisposed(), Ct.minimum(this, t)
        }, t.prototype.minimumStrict = function(t) {
         return this.throwIfDisposed(), Ct.minimumStrict(this, t)
        }, t.prototype.maximum = function(t) {
         return this.throwIfDisposed(), Ct.maximum(this, t)
        }, t.prototype.maximumStrict = function(t) {
         return this.throwIfDisposed(), Ct.maximumStrict(this, t)
        }, t.prototype.mod = function(t) {
         return this.throwIfDisposed(), Ct.mod(this, t)
        }, t.prototype.modStrict = function(t) {
         return this.throwIfDisposed(), Ct.modStrict(this, t)
        }, t.prototype.squaredDifference = function(t) {
         return this.throwIfDisposed(), Ct.squaredDifference(this, t)
        }, t.prototype.squaredDifferenceStrict = function(t) {
         return this.throwIfDisposed(), Ct.squaredDifferenceStrict(this, t)
        }, t.prototype.transpose = function(t) {
         return this.throwIfDisposed(), Ct.transpose(this, t)
        }, t.prototype.notEqual = function(t) {
         return this.throwIfDisposed(), Ct.notEqual(this, t)
        }, t.prototype.notEqualStrict = function(t) {
         return this.throwIfDisposed(), Ct.notEqualStrict(this, t)
        }, t.prototype.less = function(t) {
         return this.throwIfDisposed(), Ct.less(this, t)
        }, t.prototype.lessStrict = function(t) {
         return this.throwIfDisposed(), Ct.lessStrict(this, t)
        }, t.prototype.equal = function(t) {
         return this.throwIfDisposed(), Ct.equal(this, t)
        }, t.prototype.equalStrict = function(t) {
         return this.throwIfDisposed(), Ct.equalStrict(this, t)
        }, t.prototype.lessEqual = function(t) {
         return this.throwIfDisposed(), Ct.lessEqual(this, t)
        }, t.prototype.lessEqualStrict = function(t) {
         return this.throwIfDisposed(), Ct.lessEqualStrict(this, t)
        }, t.prototype.greater = function(t) {
         return this.throwIfDisposed(), Ct.greater(this, t)
        }, t.prototype.greaterStrict = function(t) {
         return this.throwIfDisposed(), Ct.greaterStrict(this, t)
        }, t.prototype.greaterEqual = function(t) {
         return this.throwIfDisposed(), Ct.greaterEqual(this, t)
        }, t.prototype.greaterEqualStrict = function(t) {
         return this.throwIfDisposed(), Ct.greaterEqualStrict(this, t)
        }, t.prototype.logicalAnd = function(t) {
         return this.throwIfDisposed(), Ct.logicalAnd(this, t)
        }, t.prototype.logicalOr = function(t) {
         return this.throwIfDisposed(), Ct.logicalOr(this, t)
        }, t.prototype.logicalNot = function() {
         return this.throwIfDisposed(), Ct.logicalNot(this)
        }, t.prototype.logicalXor = function(t) {
         return this.throwIfDisposed(), Ct.logicalXor(this, t)
        }, t.prototype.where = function(t, e) {
         return this.throwIfDisposed(), Ct.where(t, this, e)
        }, t.prototype.neg = function() {
         return this.throwIfDisposed(), Ct.neg(this)
        }, t.prototype.ceil = function() {
         return this.throwIfDisposed(), Ct.ceil(this)
        }, t.prototype.floor = function() {
         return this.throwIfDisposed(), Ct.floor(this)
        }, t.prototype.sign = function() {
         return this.throwIfDisposed(), Ct.sign(this)
        }, t.prototype.isNaN = function() {
         return this.throwIfDisposed(), Ct.isNaN(this)
        }, t.prototype.isInf = function() {
         return this.throwIfDisposed(), Ct.isInf(this)
        }, t.prototype.isFinite = function() {
         return this.throwIfDisposed(), Ct.isFinite(this)
        }, t.prototype.exp = function() {
         return this.throwIfDisposed(), Ct.exp(this)
        }, t.prototype.expm1 = function() {
         return this.throwIfDisposed(), Ct.expm1(this)
        }, t.prototype.log = function() {
         return this.throwIfDisposed(), Ct.log(this)
        }, t.prototype.log1p = function() {
         return this.throwIfDisposed(), Ct.log1p(this)
        }, t.prototype.sqrt = function() {
         return this.throwIfDisposed(), Ct.sqrt(this)
        }, t.prototype.rsqrt = function() {
         return this.throwIfDisposed(), Ct.rsqrt(this)
        }, t.prototype.square = function() {
         return this.throwIfDisposed(), Ct.square(this)
        }, t.prototype.reciprocal = function() {
         return this.throwIfDisposed(), Ct.reciprocal(this)
        }, t.prototype.abs = function() {
         return this.throwIfDisposed(), Ct.abs(this)
        }, t.prototype.clipByValue = function(t, e) {
         return this.throwIfDisposed(), Ct.clipByValue(this, t, e)
        }, t.prototype.relu = function() {
         return this.throwIfDisposed(), Ct.relu(this)
        }, t.prototype.relu6 = function() {
         return this.throwIfDisposed(), Ct.relu6(this)
        }, t.prototype.elu = function() {
         return this.throwIfDisposed(), Ct.elu(this)
        }, t.prototype.selu = function() {
         return this.throwIfDisposed(), Ct.selu(this)
        }, t.prototype.leakyRelu = function(t) {
         return void 0 === t && (t = .2), this.throwIfDisposed(), Ct.leakyRelu(this, t)
        }, t.prototype.prelu = function(t) {
         return this.throwIfDisposed(), Ct.prelu(this, t)
        }, t.prototype.sigmoid = function() {
         return this.throwIfDisposed(), Ct.sigmoid(this)
        }, t.prototype.logSigmoid = function() {
         return this.throwIfDisposed(), Ct.logSigmoid(this)
        }, t.prototype.softplus = function() {
         return this.throwIfDisposed(), Ct.softplus(this)
        }, t.prototype.zerosLike = function() {
         return this.throwIfDisposed(), Ct.zerosLike(this)
        }, t.prototype.onesLike = function() {
         return this.throwIfDisposed(), Ct.onesLike(this)
        }, t.prototype.sin = function() {
         return this.throwIfDisposed(), Ct.sin(this)
        }, t.prototype.cos = function() {
         return this.throwIfDisposed(), Ct.cos(this)
        }, t.prototype.tan = function() {
         return this.throwIfDisposed(), Ct.tan(this)
        }, t.prototype.asin = function() {
         return this.throwIfDisposed(), Ct.asin(this)
        }, t.prototype.acos = function() {
         return this.throwIfDisposed(), Ct.acos(this)
        }, t.prototype.atan = function() {
         return this.throwIfDisposed(), Ct.atan(this)
        }, t.prototype.sinh = function() {
         return this.throwIfDisposed(), Ct.sinh(this)
        }, t.prototype.cosh = function() {
         return this.throwIfDisposed(), Ct.cosh(this)
        }, t.prototype.tanh = function() {
         return this.throwIfDisposed(), Ct.tanh(this)
        }, t.prototype.asinh = function() {
         return this.throwIfDisposed(), Ct.asinh(this)
        }, t.prototype.acosh = function() {
         return this.throwIfDisposed(), Ct.acosh(this)
        }, t.prototype.atanh = function() {
         return this.throwIfDisposed(), Ct.atanh(this)
        }, t.prototype.erf = function() {
         return this.throwIfDisposed(), Ct.erf(this)
        }, t.prototype.round = function() {
         return this.throwIfDisposed(), Ct.round(this)
        }, t.prototype.step = function(t) {
         return void 0 === t && (t = 0), this.throwIfDisposed(), Ct.step(this, t)
        }, t.prototype.softmax = function(t) {
         return void 0 === t && (t = -1), this.throwIfDisposed(), Ct.softmax(this, t)
        }, t.prototype.logSoftmax = function(t) {
         return void 0 === t && (t = -1), this.throwIfDisposed(), Ct.logSoftmax(this, t)
        }, t.prototype.resizeBilinear = function(t, e) {
         return void 0 === e && (e = !1), this.throwIfDisposed(), Ct.image.resizeBilinear(this, t, e)
        }, t.prototype.resizeNearestNeighbor = function(t, e) {
         return void 0 === e && (e = !1), this.throwIfDisposed(), Ct.image.resizeNearestNeighbor(this, t, e)
        }, t.prototype.conv1d = function(t, e, n, r, i, o) {
         return void 0 === r && (r = "NWC"), void 0 === i && (i = 1), this.throwIfDisposed(), Ct.conv1d(this, t, e, n, r, i, o)
        }, t.prototype.conv2d = function(t, e, n, r, i, o) {
         return void 0 === r && (r = "NHWC"), void 0 === i && (i = [1, 1]), this.throwIfDisposed(), Ct.conv2d(this, t, e, n, r, i, o)
        }, t.prototype.conv2dTranspose = function(t, e, n, r, i) {
         return this.throwIfDisposed(), Ct.conv2dTranspose(this, t, e, n, r, i)
        }, t.prototype.depthwiseConv2D = function(t, e, n, r, i, o) {
         return void 0 === r && (r = "NHWC"), void 0 === i && (i = [1, 1]), this.throwIfDisposed(), Ct.depthwiseConv2d(this, t, e, n, r, i, o)
        }, t.prototype.separableConv2d = function(t, e, n, r, i, o) {
         return void 0 === i && (i = [1, 1]), void 0 === o && (o = "NHWC"), this.throwIfDisposed(), Ct.separableConv2d(this, t, e, n, r, i, o)
        }, t.prototype.avgPool = function(t, e, n, r) {
         return this.throwIfDisposed(), Ct.avgPool(this, t, e, n, r)
        }, t.prototype.maxPool = function(t, e, n, r) {
         return this.throwIfDisposed(), Ct.maxPool(this, t, e, n, r)
        }, t.prototype.localResponseNormalization = function(t, e, n, r) {
         return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), Ct.localResponseNormalization(this, t, e, n, r)
        }, t.prototype.pool = function(t, e, n, r, i) {
         return this.throwIfDisposed(), Ct.pool(this, t, e, n, r, i)
        }, t.prototype.variable = function(t, e, n) {
         return void 0 === t && (t = !0), this.throwIfDisposed(), wt().makeVariable(this, t, e, n)
        }, t.prototype.unsortedSegmentSum = function(t, e) {
         return this.throwIfDisposed(), Ct.unsortedSegmentSum(this, t, e)
        }, t.prototype.batchToSpaceND = function(t, e) {
         return this.throwIfDisposed(), Ct.batchToSpaceND(this, t, e)
        }, t.prototype.spaceToBatchND = function(t, e) {
         return this.throwIfDisposed(), Ct.spaceToBatchND(this, t, e)
        }, t.prototype.topk = function(t, e) {
         return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), Ct.topk(this, t, e)
        }, t.prototype.stridedSlice = function(t, e, n, r, i, o, a, s) {
         return void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), this.throwIfDisposed(), Ct.stridedSlice(this, t, e, n, r, i, o, a, s)
        }, t.prototype.depthToSpace = function(t, e) {
         return this.throwIfDisposed(), Ct.depthToSpace(this, t, e)
        }, t.prototype.fft = function() {
         return this.throwIfDisposed(), Ct.spectral.fft(this)
        }, t.prototype.ifft = function() {
         return this.throwIfDisposed(), Ct.spectral.ifft(this)
        }, t.prototype.rfft = function() {
         return this.throwIfDisposed(), Ct.spectral.rfft(this)
        }, t.prototype.irfft = function() {
         return this.throwIfDisposed(), Ct.spectral.irfft(this)
        }, t
       }();
      Object.defineProperty(Et, Symbol.hasInstance, {
       value: function(t) {
        return !!t && null != t.dataId && null != t.shape && null != t.dtype
       }
      });
      var kt, It, Ot, At, Nt, Rt = function(t) {
       function e(e, n, r, i) {
        var o = t.call(this, e.shape, e.dtype, e.dataId, i) || this;
        return o.trainable = n, o.name = r, o
       }
       return a(e, t), e.prototype.assign = function(t) {
        if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
        if (!_(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
        wt().disposeTensor(this), this.dataId = t.dataId, wt().incRef(this, null)
       }, e.prototype.dispose = function() {
        wt().disposeVariable(this), this.isDisposedInternal = !0
       }, e
      }(Et);
      Object.defineProperty(Rt, Symbol.hasInstance, {
        value: function(t) {
         return t instanceof Et && null != t.assign && t.assign instanceof Function
        }
       }),
       function(t) {
        t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6"
       }(kt || (kt = {})),
       function(t) {
        t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64"
       }(It || (It = {})),
       function(t) {
        t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64"
       }(Ot || (Ot = {})),
       function(t) {
        t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64"
       }(At || (At = {})),
       function(t) {
        t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64"
       }(Nt || (Nt = {}));
      var Tt = {
       float32: At,
       int32: It,
       bool: Ot,
       complex64: Nt
      };
 
      function _t(t, e) {
       if ("string" === t || "string" === e) {
        if ("string" === t && "string" === e) return "string";
        throw new Error("Can not upcast " + t + " with " + e)
       }
       return Tt[t][e]
      }
 
      function Dt(t) {
       return _t(t, "int32")
      }
 
      function Ft(t, e) {
       if (t.dtype === e.dtype) return [t, e];
       var n = _t(t.dtype, e.dtype);
       return [t.cast(n), e.cast(n)]
      }
 
      function Mt(t, e) {
       O(t.dtype === e.dtype, (function() {
        return "The dtypes of the first(" + t.dtype + ") and second(" + e.dtype + ") input must match"
       }))
      }
 
      function Lt(t) {
       var e = [];
       return function t(e, n, r) {
        if (null != e)
         if (e instanceof Et) n.push(e);
         else if (i = e, Array.isArray(i) || "object" == typeof i) {
         var i, o = e;
         for (var a in o) {
          var s = o[a];
          r.has(s) || (r.add(s), t(s, n, r))
         }
        }
       }(t, e, new Set), e
      }
      var Bt, Pt = Object.freeze({
        makeTypesMatch: Ft,
        assertTypesMatch: Mt,
        isTensorInList: function(t, e) {
         for (var n = 0; n < e.length; n++)
          if (e[n].id === t.id) return !0;
         return !1
        },
        getTensorsInContainer: Lt
       }),
       zt = function() {
        function t() {
         this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
          newBytes: 0,
          newTensors: 0,
          peakBytes: 0,
          kernels: [],
          result: null
         }
        }
        return t.prototype.dispose = function() {
         for (var t in this.registeredVariables) this.registeredVariables[t].dispose()
        }, t
       }(),
       jt = function() {
        function t(t) {
         this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new zt
        }
        return t.prototype.ready = function() {
         return s(this, void 0, void 0, (function() {
          var t, e, n;
          return u(this, (function(r) {
           switch (r.label) {
            case 0:
             if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then((function() {}))];
             if (null != this.backendInstance) return [2];
             t = this.getSortedBackends(), e = 0, r.label = 1;
            case 1:
             return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];
            case 2:
             return r.sent() ? [4, this.setBackend(n)] : [3, 4];
            case 3:
             return r.sent(), [2];
            case 4:
             return e++, [3, 1];
            case 5:
             throw new Error("Could not initialize any backends, all backend initializations failed.")
           }
          }))
         }))
        }, Object.defineProperty(t.prototype, "backend", {
         get: function() {
          if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
          if (null == this.backendInstance) {
           var t = this.initializeBackendsAndReturnBest(),
            e = t.name;
           if (t.asyncInit) throw new Error("The highest priority backend '" + e + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
           this.setBackend(e)
          }
          return this.backendInstance
         },
         enumerable: !0,
         configurable: !0
        }), t.prototype.backendNames = function() {
         return Object.keys(this.registryFactory)
        }, t.prototype.findBackend = function(t) {
         if (!(t in this.registry)) {
          if (!(t in this.registryFactory)) return null;
          if (this.initializeBackend(t).asyncInit) return null
         }
         return this.registry[t]
        }, t.prototype.findBackendFactory = function(t) {
         return t in this.registryFactory ? this.registryFactory[t].factory : null
        }, t.prototype.registerBackend = function(t, e, n) {
         return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t] = {
          factory: e,
          priority: n
         }, !0)
        }, t.prototype.setBackend = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n, r;
          return u(this, (function(i) {
           switch (i.label) {
            case 0:
             if (null == this.registryFactory[t]) throw new Error("Backend name '" + t + "' not found in registry");
             return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);
            case 1:
             return r = i.sent(), [3, 3];
            case 2:
             r = n, i.label = 3;
            case 3:
             if (!r) return [2, !1];
             i.label = 4;
            case 4:
             return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new ht(this.backendInstance), [2, !0]
           }
          }))
         }))
        }, t.prototype.setupRegisteredKernels = function() {
         var t = this;
         g(this.backendName).forEach((function(e) {
          null != e.setupFunc && e.setupFunc(t.backendInstance)
         }))
        }, t.prototype.disposeRegisteredKernels = function(t) {
         var e = this;
         g(t).forEach((function(n) {
          null != n.disposeFunc && n.disposeFunc(e.registry[t])
         }))
        }, t.prototype.initializeBackend = function(t) {
         var e = this,
          n = this.registryFactory[t];
         if (null == n) throw new Error("Cannot initialize backend " + t + ", no registration found.");
         try {
          var r = n.factory();
          if (Promise.resolve(r) === r) {
           var i = ++this.pendingBackendInitId,
            o = r.then((function(n) {
             return !(i < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0)
            })).catch((function(n) {
             return !(i < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn("Initialization of backend " + t + " failed"), console.warn(n.stack || n.message), !1)
            }));
           return this.pendingBackendInit = o, {
            success: o,
            asyncInit: !0
           }
          }
          return this.registry[t] = r, {
           success: !0,
           asyncInit: !1
          }
         } catch (e) {
          return console.warn("Initialization of backend " + t + " failed"), console.warn(e.stack || e.message), {
           success: !1,
           asyncInit: !1
          }
         }
        }, t.prototype.removeBackend = function(t) {
         if (!(t in this.registryFactory)) throw new Error(t + " backend not found in registry");
         this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
        }, t.prototype.getSortedBackends = function() {
         var t = this;
         if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
         return Object.keys(this.registryFactory).sort((function(e, n) {
          return t.registryFactory[n].priority - t.registryFactory[e].priority
         }))
        }, t.prototype.initializeBackendsAndReturnBest = function() {
         for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
          var n = t[e],
           r = this.initializeBackend(n),
           i = r.success,
           o = r.asyncInit;
          if (o || i) return {
           name: n,
           asyncInit: o
          }
         }
         throw new Error("Could not initialize any backends, all backend initializations failed.")
        }, t.prototype.moveData = function(t, e) {
         var n = this.state.tensorInfo.get(e),
          r = n.backend,
          i = this.readSync(e);
         r.disposeData(e), n.backend = t, t.move(e, i, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
        }, t.prototype.tidy = function(t, e) {
         var n, r = this,
          i = null;
         if (null == e) {
          if ("function" != typeof t) throw new Error("Please provide a function to tidy()");
          e = t
         } else {
          if ("string" != typeof t && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
          if ("function" != typeof e) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
          i = t
         }
         return this.scopedRun((function() {
          return r.startScope(i)
         }), (function() {
          return r.endScope(n)
         }), (function() {
          return (n = e()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n
         }))
        }, t.prototype.scopedRun = function(t, e, n) {
         t();
         try {
          var r = n();
          return e(), r
         } catch (t) {
          throw e(), t
         }
        }, t.prototype.nextTensorId = function() {
         return t.nextTensorId++
        }, t.prototype.nextVariableId = function() {
         return t.nextVariableId++
        }, t.prototype.clone = function(t) {
         var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
          n = {
           x: t
          };
         return this.addTapeNode(this.state.activeScope.name, n, [e], (function(t) {
          return {
           x: function() {
            return t.toFloat()
           }
          }
         }), []), e
        }, t.prototype.runKernel = function(t, e, n, r, i) {
         return this.runKernelFunc(null, e, null, t, n, r, i)
        }, t.prototype.shouldCheckForMemLeaks = function() {
         return this.ENV.getBool("IS_TEST")
        }, t.prototype.checkKernelForMemLeak = function(t, e, n) {
         var r = this.backend.numDataIds(),
          i = 0;
         n.forEach((function(t) {
          i += "complex64" === t.dtype ? 3 : 1
         }));
         var o = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
          a = r - e - i - o;
         if (a > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + a + " data ids) after running '" + t + "'")
        }, t.prototype.runKernelFunc = function(t, e, n, r, i, o, a) {
         var s, u = this;
         void 0 === o && (o = []), void 0 === a && (a = []);
         var c = [],
          l = this.isTapeOn();
         null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : "");
         var h, p = function(t) {
           l && (c = t.map((function(t) {
            return u.keep(u.clone(t))
           })))
          },
          f = this.state.numBytes,
          d = this.state.numTensors;
         this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
         var m, g = v(r, this.backendName);
         return h = null != g ? function() {
          var t = u.backend.numDataIds();
          m = g.kernelFunc({
           inputs: e,
           attrs: i,
           backend: u.backend
          });
          var n = Array.isArray(m) ? m : [m];
          u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);
          var s = n.map((function(t) {
            var e = t.dataId,
             n = t.shape,
             r = t.dtype;
            return u.makeTensorFromDataId(e, n, r)
           })),
           c = s.filter((function(t, e) {
            return a[e]
           }));
          return p((o || []).slice().concat(c)), s
         } : function() {
          var e = u.backend.numDataIds();
          m = u.tidy((function() {
           return t(u.backend, p)
          }));
          var n = Array.isArray(m) ? m : [m];
          return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n
         }, this.scopedRun((function() {
          return u.state.kernelDepth++
         }), (function() {
          return u.state.kernelDepth--
         }), (function() {
          s = u.ENV.getBool("DEBUG") ? u.profiler.profileKernel(r, e, (function() {
           return h()
          })) : h()
         })), l && this.addTapeNode(r, e, s, n, c), this.state.profiling && this.state.activeProfile.kernels.push({
          name: r,
          bytesAdded: this.state.numBytes - f,
          totalBytesSnapshot: this.state.numBytes,
          tensorsAdded: this.state.numTensors - d,
          totalTensorsSnapshot: this.state.numTensors,
          inputShapes: Object.keys(e).map((function(t) {
           return e[t].shape
          })),
          outputShapes: s.map((function(t) {
           return t.shape
          }))
         }), Array.isArray(m) ? s : s[0]
        }, t.prototype.makeTensor = function(t, e, n, r) {
         if (null == t) throw new Error("Values passed to engine.makeTensor() are null");
         n = n || "float32", r = r || this.backend;
         var i = t;
         "string" === n && X(t[0]) && (i = t.map((function(t) {
          return ut(t)
         })));
         var o = r.write(i, e, n),
          a = new Et(e, n, o, this.nextTensorId());
         if (this.incRef(a, r), "string" === n) {
          var s = this.state.tensorInfo.get(o),
           u = K(i);
          this.state.numBytes += u - s.bytes, s.bytes = u
         }
         return a
        }, t.prototype.makeTensorFromDataId = function(t, e, n, r) {
         var i = new Et(e, n = n || "float32", t, this.nextTensorId());
         return this.incRef(i, r), i
        }, t.prototype.makeVariable = function(t, e, n, r) {
         void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));
         var i = new Rt(t, e, n, this.nextTensorId());
         if (null != this.state.registeredVariables[i.name]) throw new Error("Variable with name " + i.name + " was already registered");
         return this.state.registeredVariables[i.name] = i, this.incRef(i, this.backend), i
        }, t.prototype.incRef = function(t, e) {
         var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;
         if (this.state.numTensors++, "string" === t.dtype && this.state.numStringTensors++, 0 === n) {
          this.state.numDataBuffers++;
          var r = 0;
          "complex64" !== t.dtype && "string" !== t.dtype && (r = t.size * q(t.dtype)), this.state.tensorInfo.set(t.dataId, {
           backend: e || this.backend,
           dtype: t.dtype,
           shape: t.shape,
           bytes: r,
           refCount: 0
          }), this.state.numBytes += r
         }
         this.state.tensorInfo.get(t.dataId).refCount++, t instanceof Rt || this.track(t)
        }, t.prototype.disposeTensor = function(t) {
         if (this.state.tensorInfo.has(t.dataId)) {
          this.state.numTensors--, "string" === t.dtype && this.state.numStringTensors--;
          var e = this.state.tensorInfo.get(t.dataId);
          e.refCount <= 1 ? ("complex64" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--
         }
        }, t.prototype.disposeVariables = function() {
         for (var t in this.state.registeredVariables) {
          var e = this.state.registeredVariables[t];
          this.disposeVariable(e)
         }
        }, t.prototype.disposeVariable = function(t) {
         this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name]
        }, t.prototype.memory = function() {
         var t = this.backend.memory();
         return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t
        }, t.prototype.profile = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n;
          return u(this, (function(r) {
           return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map((function(t) {
            return t.totalBytesSnapshot
           }))), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile]
          }))
         }))
        }, t.prototype.isTapeOn = function() {
         return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
        }, t.prototype.addTapeNode = function(t, e, n, r, i) {
         var o = this,
          a = {
           id: this.state.nextTapeNodeId++,
           kernelName: t,
           inputs: e,
           outputs: n,
           saved: i
          },
          s = m(t);
         null != s && (r = s.gradFunc), null != r && (a.gradient = function(t) {
          return t = t.map((function(t, e) {
           if (null == t) {
            var r = n[e],
             i = ot(r.size, r.dtype);
            return o.makeTensor(i, r.shape, r.dtype)
           }
           return t
          })), r(t.length > 1 ? t : t[0], i)
         }), this.state.activeTape.push(a)
        }, t.prototype.keep = function(t) {
         return t.kept = !0, t
        }, t.prototype.startTape = function() {
         0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
        }, t.prototype.endTape = function() {
         this.state.gradientDepth--
        }, t.prototype.startScope = function(t) {
         var e = {
          track: [],
          name: "unnamed scope",
          id: this.state.nextScopeId++
         };
         t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e
        }, t.prototype.endScope = function(t) {
         for (var e = this, n = Lt(t), r = new Set(n.map((function(t) {
           return t.id
          }))), i = 0; i < this.state.activeScope.track.length; i++) {
          var o = this.state.activeScope.track[i];
          o.kept || r.has(o.id) || o.dispose()
         }
         var a = this.state.scopeStack.pop();
         this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach((function(t) {
          t.kept || t.scopeId !== a.id || e.track(t)
         }))
        }, t.prototype.gradients = function(t, e, n, r) {
         var i = this;
         if (void 0 === r && (r = !1), O(e.length > 0, (function() {
           return "gradients() received an empty list of xs."
          })), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
         var o = this.scopedRun((function() {
          return i.startTape()
         }), (function() {
          return i.endTape()
         }), (function() {
          return i.tidy("forward", t)
         }));
         O(o instanceof Et, (function() {
          return "The result y returned by f() must be a tensor."
         }));
         var a = function(t, e, n) {
          for (var r = {}, i = {}, o = 0; o < e.length; o++) r[e[o].id] = !0;
          for (o = 0; o < t.length; o++) {
           var a = (d = t[o]).inputs;
           for (var s in a) {
            for (var u = a[s], c = !1, l = 0; l < e.length; l++)
             if (r[u.id]) {
              d.outputs.forEach((function(t) {
               return r[t.id] = !0
              })), c = !0, i[d.id] = !0;
              break
             } if (c) break
           }
          }
          var h = {};
          h[n.id] = !0;
          var p = {};
          for (o = t.length - 1; o >= 0; o--)
           for (a = (d = t[o]).inputs, l = 0; l < d.outputs.length; l++)
            if (h[d.outputs[l].id]) {
             for (var s in a) h[a[s].id] = !0, p[d.id] = !0;
             break
            } var f = [];
          for (o = 0; o < t.length; o++) {
           var d;
           if (i[(d = t[o]).id] && p[d.id]) {
            var v = {};
            for (var s in d.inputs) {
             var m = d.inputs[s];
             r[m.id] && (v[s] = m)
            }
            var g = Object.assign({}, d);
            g.inputs = v, g.outputs = d.outputs, f.push(g)
           }
          }
          return f
         }(this.state.activeTape, e, o);
         if (!r && 0 === a.length && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
         return this.tidy("backward", (function() {
          var t, r, s = {};
          s[o.id] = null == n ? (t = o.shape, r = it(T(t), "float32"), Wt.makeTensor(r, t, "float32")) : n,
           function(t, e, n) {
            for (var r = function(r) {
              var i = e[r],
               o = [];
              if (i.outputs.forEach((function(e) {
                var n = t[e.id];
                null != n ? o.push(n) : o.push(null)
               })), null == i.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + i.kernelName + ".");
              var a = i.gradient(o),
               s = function(e) {
                if (!(e in a)) throw new Error("Cannot backprop through input " + e + ". Available gradients found: " + Object.keys(a) + ".");
                var r = n((function() {
                 return a[e]()
                }));
                if ("float32" !== r.dtype) throw new Error("Error in gradient for op " + i.kernelName + ". The gradient of input " + e + " must have 'float32' dtype, but has '" + r.dtype + "'");
                var o = i.inputs[e];
                if (!_(r.shape, o.shape)) throw new Error("Error in gradient for op " + i.kernelName + ". The gradient of input '" + e + "' has shape '" + r.shape + "', which does not match the shape of the input '" + o.shape + "'");
                if (null == t[o.id]) t[o.id] = r;
                else {
                 var s = t[o.id];
                 t[o.id] = s.add(r), s.dispose()
                }
               };
              for (var u in i.inputs) s(u)
             }, i = e.length - 1; i >= 0; i--) r(i)
           }(s, a, (function(t) {
            return i.tidy(t)
           }));
          var u = e.map((function(t) {
           return s[t.id]
          }));
          return 0 === i.state.gradientDepth && (i.state.activeTape.forEach((function(t) {
           for (var e = 0, n = t.saved; e < n.length; e++) n[e].dispose()
          })), i.state.activeTape = null), {
           value: o,
           grads: u
          }
         }))
        }, t.prototype.customGrad = function(t) {
         var e = this;
         return O(Q(t), (function() {
           return "The f passed in customGrad(f) must be a function."
          })),
          function() {
           for (var n, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
           O(r.every((function(t) {
            return t instanceof Et
           })), (function() {
            return "The args passed in customGrad(f)(x1, x2,...) must all be tensors"
           }));
           var o = {};
           return r.forEach((function(t, e) {
            o[e] = t
           })), e.runKernelFunc((function(e, i) {
            return O((n = t.apply(void 0, r.concat([i]))).value instanceof Et, (function() {
             return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"
            })), O(Q(n.gradFunc), (function() {
             return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."
            })), n.value
           }), o, (function(t, e) {
            var i = n.gradFunc(t, e),
             o = Array.isArray(i) ? i : [i];
            O(o.length === r.length, (function() {
             return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."
            })), O(o.every((function(t) {
             return t instanceof Et
            })), (function() {
             return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."
            }));
            var a = {};
            return o.forEach((function(t, e) {
             a[e] = function() {
              return t
             }
            })), a
           }))
          }
        }, t.prototype.readSync = function(t) {
         return this.state.tensorInfo.get(t).backend.readSync(t)
        }, t.prototype.read = function(t) {
         return this.state.tensorInfo.get(t).backend.read(t)
        }, t.prototype.time = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n;
          return u(this, (function(r) {
           switch (r.label) {
            case 0:
             return e = at(), [4, this.backend.time(t)];
            case 1:
             return (n = r.sent()).wallMs = at() - e, [2, n]
           }
          }))
         }))
        }, t.prototype.track = function(t) {
         return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t
        }, Object.defineProperty(t.prototype, "registeredVariables", {
         get: function() {
          return this.state.registeredVariables
         },
         enumerable: !0,
         configurable: !0
        }), t.prototype.reset = function() {
         for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new zt, this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];
         this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
        }, t.nextTensorId = 0, t.nextVariableId = 0, t
       }(),
       Wt = function() {
        var e = function() {
         if (null == Bt) {
          var e = void 0;
          if ("undefined" != typeof window) e = window;
          else if ("undefined" != typeof t) e = t;
          else if ("undefined" != typeof r) e = r;
          else {
           if ("undefined" == typeof self) throw new Error("Could not find a global object");
           e = self
          }
          Bt = e
         }
         return Bt
        }();
        if (null == e._tfengine) {
         var n = new c(e);
         e._tfengine = new jt(n)
        }
        return function(t) {
         p = t
        }(e._tfengine.ENV), wt = function() {
         return e._tfengine
        }, e._tfengine
       }();
 
      function Vt() {
       return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
      }
      var Ut = h();
      Ut.registerFlag("DEBUG", (function() {
       return !1
      }), (function(t) {
       t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
      })), Ut.registerFlag("IS_BROWSER", (function() {
       return Vt()
      })), Ut.registerFlag("IS_NODE", (function() {
       return "undefined" != typeof r && void 0 !== r.versions && void 0 !== r.versions.node
      })), Ut.registerFlag("IS_CHROME", (function() {
       return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
      })), Ut.registerFlag("PROD", (function() {
       return !1
      })), Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", (function() {
       return Ut.getBool("DEBUG")
      })), Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED", (function() {
       return !0
      })), Ut.registerFlag("IS_TEST", (function() {
       return !1
      }));
      var Ht, $t, Gt, qt = {},
       Kt = {
        alpha: !1,
        antialias: !1,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !1,
        depth: !1,
        stencil: !1,
        failIfMajorPerformanceCaveat: !0
       };
 
      function Xt(t, e) {
       qt[t] = e
      }
 
      function Yt(t) {
       t in qt || (qt[t] = function(t) {
        if (1 !== t && 2 !== t) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
        var e = function(t) {
         if ("undefined" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);
         if ("undefined" != typeof document) return document.createElement("canvas");
         throw new Error("Cannot create a canvas in this context")
        }(t);
        return e.addEventListener("webglcontextlost", (function(e) {
         e.preventDefault(), delete qt[t]
        }), !1), 1 === t ? e.getContext("webgl", Kt) || e.getContext("experimental-webgl", Kt) : e.getContext("webgl2", Kt)
       }(t));
       var e = qt[t];
       return e.isContextLost() ? (delete qt[t], Yt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), qt[t])
      }
 
      function Zt(t, e) {
       return [e, t]
      }
 
      function Jt(t) {
       var e = T(t);
       return M(Math.ceil(e / 4))
      }
 
      function Qt(t, e) {
       return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))]
      }
 
      function te(t, e) {
       var n, r, i, o, a, s, u, c, l, p = t;
       return 2 === h().getNumber("WEBGL_VERSION") ? (n = p.R32F, r = p.R16F, i = p.RGBA16F, o = p.RGBA32F, a = p.RED, s = 4, u = 1, c = p.HALF_FLOAT, l = p.FLOAT) : (n = t.RGBA, r = t.RGBA, i = t.RGBA, o = p.RGBA, a = t.RGBA, s = 4, u = 4, c = null != e ? e.HALF_FLOAT_OES : null, l = t.FLOAT), {
        internalFormatFloat: n,
        internalFormatHalfFloat: r,
        internalFormatPackedHalfFloat: i,
        internalFormatPackedFloat: o,
        textureFormatFloat: a,
        downloadTextureFormat: t.RGBA,
        downloadUnpackNumChannels: s,
        defaultNumChannels: u,
        textureTypeHalfFloat: c,
        textureTypeFloat: l
       }
      }
 
      function ee(t, e, n) {
       var r = n();
       return e && function(t) {
        var e = t.getError();
        if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + oe(t, e))
       }(t), r
      }! function(t) {
       t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH"
      }(Ht || (Ht = {})),
      function(t) {
       t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD"
      }($t || ($t = {})),
      function(t) {
       t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
      }(Gt || (Gt = {}));
      var ne = 5.96e-8,
       re = 65504;
 
      function ie(t) {
       return !!(h().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t || ne < Math.abs(t) && Math.abs(t) < re)
      }
 
      function oe(t, e) {
       switch (e) {
        case t.NO_ERROR:
         return "NO_ERROR";
        case t.INVALID_ENUM:
         return "INVALID_ENUM";
        case t.INVALID_VALUE:
         return "INVALID_VALUE";
        case t.INVALID_OPERATION:
         return "INVALID_OPERATION";
        case t.INVALID_FRAMEBUFFER_OPERATION:
         return "INVALID_FRAMEBUFFER_OPERATION";
        case t.OUT_OF_MEMORY:
         return "OUT_OF_MEMORY";
        case t.CONTEXT_LOST_WEBGL:
         return "CONTEXT_LOST_WEBGL";
        default:
         return "Unknown error code " + e
       }
      }
 
      function ae(t, e, n) {
       return Ne(t, e, (function() {
        return t.getExtension(n)
       }), 'Extension "' + n + '" not supported on this browser.')
      }
 
      function se(t, e, n) {
       var r = Ne(t, e, (function() {
        return t.createShader(t.VERTEX_SHADER)
       }), "Unable to create vertex WebGLShader.");
       if (ee(t, e, (function() {
         return t.shaderSource(r, n)
        })), ee(t, e, (function() {
         return t.compileShader(r)
        })), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
       return r
      }
 
      function ue(t, e, n) {
       var r = Ne(t, e, (function() {
        return t.createShader(t.FRAGMENT_SHADER)
       }), "Unable to create fragment WebGLShader.");
       if (ee(t, e, (function() {
         return t.shaderSource(r, n)
        })), ee(t, e, (function() {
         return t.compileShader(r)
        })), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function(t, e) {
        var n = he.exec(e);
        if (null == n) return console.log("Couldn't parse line number in error: " + e), void console.log(t);
        for (var r = +n[1], i = t.split("\n"), o = i.length.toString().length + 2, a = i.map((function(t, e) {
          return L((e + 1).toString(), o) + t
         })), s = 0, u = 0; u < a.length; u++) s = Math.max(a[u].length, s);
        var c = a.slice(0, r - 1),
         l = a.slice(r - 1, r),
         h = a.slice(r);
        console.log(c.join("\n")), console.log(e.split("\n")[0]), console.log("%c " + L(l[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"))
       }(n, t.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
       return r
      }
      var ce, le, he = /ERROR: [0-9]+:([0-9]+):/g;
 
      function pe(t, e) {
       return Ne(t, e, (function() {
        return t.createProgram()
       }), "Unable to create WebGLProgram.")
      }
 
      function fe(t, e, n) {
       if (ee(t, e, (function() {
         return t.linkProgram(n)
        })), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Failed to link vertex and fragment shaders.")
      }
 
      function de(t, e, n) {
       if (ee(t, e, (function() {
         return t.validateProgram(n)
        })), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Shader program validation failed.")
      }
 
      function ve(t, e, n) {
       var r = Ne(t, e, (function() {
        return t.createBuffer()
       }), "Unable to create WebGLBuffer");
       return ee(t, e, (function() {
        return t.bindBuffer(t.ARRAY_BUFFER, r)
       })), ee(t, e, (function() {
        return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW)
       })), r
      }
 
      function me(t, e, n) {
       var r = Ne(t, e, (function() {
        return t.createBuffer()
       }), "Unable to create WebGLBuffer");
       return ee(t, e, (function() {
        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r)
       })), ee(t, e, (function() {
        return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW)
       })), r
      }
 
      function ge(t, e) {
       return Ne(t, e, (function() {
        return t.createTexture()
       }), "Unable to create WebGLTexture.")
      }
 
      function ye(t, e) {
       var n = h().getNumber("WEBGL_MAX_TEXTURE_SIZE");
       if (t <= 0 || e <= 0) {
        var r = "[" + t + "x" + e + "]";
        throw new Error("Requested texture size " + r + " is invalid.")
       }
       if (t > n || e > n) throw r = "[" + t + "x" + e + "]", new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU [" + n + "x" + n + "].")
      }
 
      function be(t, e) {
       return Ne(t, e, (function() {
        return t.createFramebuffer()
       }), "Unable to create WebGLFramebuffer.")
      }
 
      function xe(t, e, n, r, i, o, a, s) {
       var u = t.getAttribLocation(n, r);
       return -1 !== u && (ee(t, e, (function() {
        return t.bindBuffer(t.ARRAY_BUFFER, i)
       })), ee(t, e, (function() {
        return t.vertexAttribPointer(u, o, t.FLOAT, !1, a, s)
       })), ee(t, e, (function() {
        return t.enableVertexAttribArray(u)
       })), !0)
      }
 
      function we(t, e, n, r) {
       Re(t, r), ee(t, e, (function() {
        return t.activeTexture(t.TEXTURE0 + r)
       })), ee(t, e, (function() {
        return t.bindTexture(t.TEXTURE_2D, n)
       }))
      }
 
      function Ce(t, e, n, r) {
       return Ne(t, e, (function() {
        return t.getUniformLocation(n, r)
       }), 'uniform "' + r + '" not present in program.')
      }
 
      function Se(t, e, n) {
       return t.getUniformLocation(e, n)
      }
 
      function Ee(t, e, n, r, i, o) {
       ee(t, e, (function() {
        return we(t, e, r, o)
       })), ee(t, e, (function() {
        return t.uniform1i(i, o)
       }))
      }
 
      function ke(t, e, n, r) {
       ee(t, e, (function() {
        return t.bindFramebuffer(t.FRAMEBUFFER, r)
       })), ee(t, e, (function() {
        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
       }))
      }
 
      function Ie(t, e, n) {
       ee(t, e, (function() {
        return t.bindFramebuffer(t.FRAMEBUFFER, n)
       })), ee(t, e, (function() {
        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)
       }))
      }
 
      function Oe(t) {
       var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
       if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ae(t, e))
      }
 
      function Ae(t, e) {
       switch (e) {
        case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
         return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
        case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
         return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
        case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
         return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
        case t.FRAMEBUFFER_UNSUPPORTED:
         return "FRAMEBUFFER_UNSUPPORTED";
        default:
         return "unknown error " + e
       }
      }
 
      function Ne(t, e, n, r) {
       var i = ee(t, e, (function() {
        return n()
       }));
       if (null == i) throw new Error(r);
       return i
      }
 
      function Re(t, e) {
       var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
        r = e + t.TEXTURE0;
       if (r < t.TEXTURE0 || r > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE" + n + "].")
      }
 
      function Te(t, e) {
       return void 0 === e && (e = 2), T(t.slice(0, t.length - e))
      }
 
      function _e(t) {
       if (0 === t.length) throw Error("Cannot get rows and columns of an empty shape array.");
       return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]]
      }
 
      function De(t) {
       var e = [1, 1, 1];
       return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [Te(t)].concat(_e(t))), e
      }
 
      function Fe(t, e) {
       var n;
       void 0 === e && (e = !1);
       var r = h().getNumber("WEBGL_MAX_TEXTURE_SIZE");
       if (e && (r *= 2, 1 === (t = t.map((function(e, n) {
         return n >= t.length - 2 ? k(t[n]) : t[n]
        }))).length && (t = [2, t[0]])), 2 !== t.length) {
        var i = j(t);
        t = i.newShape
       }
       var o = T(t);
       if (t.length <= 1 && o <= r) return [1, o];
       if (2 === t.length && t[0] <= r && t[1] <= r) return t;
       if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];
       if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];
       if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];
       if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];
       if (e) {
        var a = Te(t),
         s = 2,
         u = 2;
        return t.length && (s = (n = _e(t))[0], u = n[1]), M(o = a * (s / 2) * (u / 2)).map((function(t) {
         return 2 * t
        }))
       }
       return M(o)
      }
 
      function Me(t) {
       return t % 2 == 0
      }
 
      function Le(t, e) {
       if (_(t = t.slice(-2), e = e.slice(-2))) return !0;
       if (!t.length || !e.length) return !0;
       if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;
       if (t.length !== e.length) {
        var n = t.slice(-1)[0],
         r = e.slice(-1)[0];
        if (n === r) return !0;
        if (Me(n) && Me(r) && (1 === t[0] || 1 === e[0])) return !0
       }
       return t[1] === e[1] && Me(t[0]) && Me(e[0])
      }
 
      function Be(t) {
       if (null == ce) {
        var e = Yt(t);
        ce = e.getParameter(e.MAX_TEXTURE_SIZE)
       }
       return ce
      }
 
      function Pe(t) {
       if (null == le) {
        var e = Yt(t);
        le = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
       }
       return Math.min(16, le)
      }
 
      function ze(t) {
       if (0 === t) return 0;
       var e = Yt(t);
       return je(e, "EXT_disjoint_timer_query_webgl2") && 2 === t ? 2 : je(e, "EXT_disjoint_timer_query") ? 1 : 0
      }
 
      function je(t, e) {
       return null != t.getExtension(e)
      }
 
      function We(t) {
       try {
        if (null != Yt(t)) return !0
       } catch (t) {
        return !1
       }
       return !1
      }
 
      function Ve(t) {
       if (0 === t) return !1;
       var e = Yt(t);
       if (1 === t) {
        if (!je(e, "OES_texture_float")) return !1
       } else if (!je(e, "EXT_color_buffer_float")) return !1;
       return He(e)
      }
 
      function Ue(t) {
       if (0 === t) return !1;
       var e = Yt(t);
       if (1 !== t) {
        if (je(e, "EXT_color_buffer_float")) return He(e);
        if (je(e, "EXT_color_buffer_half_float")) {
         var n = e.getExtension("EXT_color_buffer_half_float");
         return function(t, e) {
          var n = te(t, e),
           r = t.createTexture();
          t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
          var i = t.createFramebuffer();
          t.bindFramebuffer(t.FRAMEBUFFER, i), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);
          var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
          return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(i), o
         }(e, n)
        }
        return !1
       }
       return !!je(e, "OES_texture_float") && !!je(e, "WEBGL_color_buffer_float") && He(e)
      }
 
      function He(t) {
       var e = te(t),
        n = t.createTexture();
       t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
       var r = t.createFramebuffer();
       t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
       var i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
       return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), i
      }
 
      function $e(t) {
       return 2 === t && null != Yt(t).fenceSync
      }
      var Ge = Object.freeze({
        callAndCheck: ee,
        canBeRepresented: ie,
        getWebGLErrorMessage: oe,
        getExtensionOrThrow: ae,
        createVertexShader: se,
        createFragmentShader: ue,
        createProgram: pe,
        linkProgram: fe,
        validateProgram: de,
        createStaticVertexBuffer: ve,
        createStaticIndexBuffer: me,
        getNumChannels: function() {
         return 2 === h().getNumber("WEBGL_VERSION") ? 1 : 4
        },
        createTexture: ge,
        validateTextureSize: ye,
        createFramebuffer: be,
        bindVertexBufferToProgramAttribute: xe,
        bindTextureUnit: we,
        unbindTextureUnit: function(t, e, n) {
         Re(t, n), ee(t, e, (function() {
          return t.activeTexture(t.TEXTURE0 + n)
         })), ee(t, e, (function() {
          return t.bindTexture(t.TEXTURE_2D, null)
         }))
        },
        getProgramUniformLocationOrThrow: Ce,
        getProgramUniformLocation: Se,
        bindTextureToProgramUniformSampler: Ee,
        bindCanvasToFramebuffer: function(t, e) {
         ee(t, e, (function() {
          return t.bindFramebuffer(t.FRAMEBUFFER, null)
         })), ee(t, e, (function() {
          return t.viewport(0, 0, t.canvas.width, t.canvas.height)
         })), ee(t, e, (function() {
          return t.scissor(0, 0, t.canvas.width, t.canvas.height)
         }))
        },
        bindColorTextureToFramebuffer: ke,
        unbindColorTextureFromFramebuffer: Ie,
        validateFramebuffer: Oe,
        getFramebufferErrorMessage: Ae,
        getBatchDim: Te,
        getRowsCols: _e,
        getShapeAs3D: De,
        getTextureShapeFromLogicalShape: Fe,
        isReshapeFree: Le,
        getWebGLMaxTextureSize: Be,
        resetMaxTextureSize: function() {
         ce = null
        },
        resetMaxTexturesInShader: function() {
         le = null
        },
        getMaxTexturesInShader: Pe,
        getWebGLDisjointQueryTimerVersion: ze,
        hasExtension: je,
        isWebGLVersionEnabled: We,
        isCapableOfRenderingToFloatTexture: Ve,
        isDownloadFloatTextureEnabled: Ue,
        isWebGLFenceEnabled: $e
       }),
       qe = h();
 
      function Ke() {
       h().set("PROD", !0)
      }
 
      function Xe() {
       h().set("DEBUG", !0)
      }
 
      function Ye() {
       h().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.")
      }
 
      function Ze(t) {
       h().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
      }
 
      function Je() {
       Wt.disposeVariables()
      }
 
      function Qe() {
       return Wt
      }
 
      function tn() {
       return Wt.memory()
      }
 
      function en(t) {
       return Wt.profile(t)
      }
 
      function nn(t, e) {
       return Wt.tidy(t, e)
      }
 
      function rn(t) {
       Lt(t).forEach((function(t) {
        return t.dispose()
       }))
      }
 
      function on(t) {
       return Wt.keep(t)
      }
 
      function an(t) {
       return Wt.time(t)
      }
 
      function sn(t) {
       return Wt.setBackend(t)
      }
 
      function un() {
       return Wt.ready()
      }
 
      function cn() {
       return Wt.backendName
      }
 
      function ln(t) {
       Wt.removeBackend(t)
      }
 
      function hn(t) {
       return Wt.findBackend(t)
      }
 
      function pn(t) {
       return Wt.findBackendFactory(t)
      }
 
      function fn(t, e, n) {
       return void 0 === n && (n = 1), Wt.registerBackend(t, e, n)
      }
 
      function dn() {
       return Wt.backend
      }
 
      function vn(t, e) {
       h().setPlatform(t, e)
      }
 
      function mn() {
       for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
       h().getBool("IS_TEST") || console.warn.apply(console, t)
      }
 
      function gn(t, e) {
       var n = t;
       if (G(t)) return "string" === e ? [] : [t.length];
       if (!Array.isArray(t)) return [];
       for (var r = []; Array.isArray(n) || G(n) && "string" !== e;) r.push(n.length), n = n[0];
       return Array.isArray(t) && h().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t(e, n, r) {
        if (r = r || [], Array.isArray(e) || G(e)) {
         O(n.length > 0, (function() {
          return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + e.length + " elements"
         })), O(e.length === n[0], (function() {
          return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + e.length + " elements"
         }));
         for (var i = n.slice(1), o = 0; o < e.length; ++o) t(e[o], i, r.concat(o))
        } else O(0 === n.length, (function() {
         return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements"
        }))
       }(t, r, []), r
      }
 
      function yn(t, e, n, r) {
       if (null != t && ("numeric" !== t && t !== e || "numeric" === t && "string" === e)) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + " tensor, but got " + e + " tensor")
      }
 
      function bn(t, e, n, r) {
       if (void 0 === r && (r = "numeric"), t instanceof Et) return yn(r, t.dtype, e, n), t;
       var i = J(t);
       if ("string" !== i && ["bool", "int32", "float32"].indexOf(r) >= 0 && (i = r), yn(r, i, e, n), null == t || !G(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) {
        var o = null == t ? "null" : t.constructor.name;
        throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + o + "'")
       }
       var a = gn(t, i);
       G(t) || Array.isArray(t) || (t = [t]);
       var s = "string" !== i ? nt(t, i, h().getBool("DEBUG")) : R(t, [], !0);
       return Wt.makeTensor(s, a, i)
      }
 
      function xn(t, e, n, r) {
       if (void 0 === r && (r = "numeric"), !Array.isArray(t)) throw new Error("Argument " + e + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
       return t.map((function(t, r) {
        return bn(t, e + "[" + r + "]", n)
       }), r)
      }
 
      function wn(t, e) {
       for (var n = 0; n < t.length; ++n)
        if (t[t.length - n - 1] !== e - 1 - n) return !1;
       return !0
      }
 
      function Cn(t, e, n) {
       for (var r = t.length + e.length, i = [], o = 0, a = 0, s = 0; s < r; s++) - 1 === n.indexOf(s) ? i.push(t[o++]) : i.push(e[a++]);
       return i
      }
 
      function Sn(t, e) {
       for (var n = [], r = t.length, i = 0; i < r; i++) - 1 === e.indexOf(i) && n.push(t[i]);
       return [n, e.map((function(e) {
        return t[e]
       }))]
      }
 
      function En(t, e) {
       return Cn(t, e.map((function(t) {
        return 1
       })), e)
      }
 
      function kn(t, e, n) {
       O(wn(e, n), (function() {
        return t + " supports only inner-most axes for now. Got axes " + e + " and rank-" + n + " input."
       }))
      }
 
      function In(t, e) {
       if (wn(t, e)) return null;
       for (var n = [], r = 0; r < e; ++r) - 1 === t.indexOf(r) && n.push(r);
       return t.forEach((function(t) {
        return n.push(t)
       })), n
      }
 
      function On(t) {
       return t.map((function(t, e) {
        return [e, t]
       })).sort((function(t, e) {
        return t[1] - e[1]
       })).map((function(t) {
        return t[0]
       }))
      }
 
      function An(t, e) {
       for (var n = [], r = e - t; r < e; ++r) n.push(r);
       return n
      }
 
      function Nn(t, e) {
       var n = t[0].length;
       t.forEach((function(t, e) {
        O(t.length === n, (function() {
         return "Error in concat" + n + "D: rank of tensors[" + e + "] must be the same as the rank of the rest (" + n + ")"
        }))
       })), O(e >= 0 && e < n, (function() {
        return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + "."
       }));
       var r = t[0];
       t.forEach((function(t, i) {
        for (var o = 0; o < n; o++) O(o === e || t[o] === r[o], (function() {
         return "Error in concat" + n + "D: Shape of tensors[" + i + "] (" + t + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + i + "."
        }))
       }))
      }
 
      function Rn(t, e) {
       for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];
       return n
      }
 
      function Tn(t) {
       var e = Object.keys(t);
       if (1 !== e.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
       var n = e[0],
        r = t[n];
       n.endsWith("_") && (n = n.substring(0, n.length - 1));
       var i = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        Wt.startScope(n);
        try {
         var i = r.apply(void 0, t);
         return i instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Wt.endScope(i), i
        } catch (t) {
         throw Wt.endScope(null), t
        }
       };
       return Object.defineProperty(i, "name", {
        value: n,
        configurable: !0
       }), i
      }
      qe.registerFlag("HAS_WEBGL", (function() {
       return qe.getNumber("WEBGL_VERSION") > 0
      })), qe.registerFlag("WEBGL_VERSION", (function() {
       return We(2) ? 2 : We(1) ? 1 : 0
      })), qe.registerFlag("WEBGL_BUFFER_SUPPORTED", (function() {
       return 2 === qe.get("WEBGL_VERSION")
      })), qe.registerFlag("WEBGL_CPU_FORWARD", (function() {
       return !0
      })), qe.registerFlag("WEBGL_FORCE_F16_TEXTURES", (function() {
       return !1
      })), qe.registerFlag("WEBGL_PACK", (function() {
       return qe.getBool("HAS_WEBGL")
      })), qe.registerFlag("WEBGL_PACK_NORMALIZATION", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_PACK_CLIP", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_PACK_DEPTHWISECONV", (function() {
       return !1
      })), qe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_PACK_REDUCE", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_LAZILY_UNPACK", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_CONV_IM2COL", (function() {
       return qe.getBool("WEBGL_PACK")
      })), qe.registerFlag("WEBGL_MAX_TEXTURE_SIZE", (function() {
       return Be(qe.getNumber("WEBGL_VERSION"))
      })), qe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", (function() {
       return Pe(qe.getNumber("WEBGL_VERSION"))
      })), qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", (function() {
       var t = qe.getNumber("WEBGL_VERSION");
       return 0 === t ? 0 : ze(t)
      })), qe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", (function() {
       return qe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))));
       var t
      })), qe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", (function() {
       return Ve(qe.getNumber("WEBGL_VERSION"))
      })), qe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", (function() {
       return !qe.getBool("WEBGL_FORCE_F16_TEXTURES") && qe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")
      })), qe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", (function() {
       return Ue(qe.getNumber("WEBGL_VERSION"))
      })), qe.registerFlag("WEBGL_FENCE_API_ENABLED", (function() {
       return $e(qe.getNumber("WEBGL_VERSION"))
      })), qe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", (function() {
       return qe.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0
      })), St = Ze;
      var _n = Tn({
        complex_: function(t, e) {
         var n = bn(t, "real", "complex"),
          r = bn(e, "imag", "complex");
         return A(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."), Wt.runKernelFunc((function(t) {
          return t.complex(n, r)
         }), {
          $real: n,
          $imag: r
         })
        }
       }),
       Dn = Tn({
        real_: function(t) {
         var e = bn(t, "input", "real");
         return Wt.runKernelFunc((function(t) {
          return t.real(e)
         }), {
          $input: e
         })
        }
       }),
       Fn = Tn({
        imag_: function(t) {
         var e = bn(t, "input", "imag");
         return Wt.runKernelFunc((function(t) {
          return t.imag(e)
         }), {
          $input: e
         })
        }
       });
 
      function Mn(t, e, n) {
       return Ln(t, e, gn(t, n), n)
      }
 
      function Ln(t, e, n, r) {
       if (null == r && (r = J(t)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
       if (!G(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
       if (null != e) {
        st(e);
        var i = T(e),
         o = T(n);
        O(i === o, (function() {
         return "Based on the provided shape, [" + e + "], the tensor should have " + i + " values but has " + o
        }));
        for (var a = 0; a < n.length; ++a) {
         var s = n[a],
          u = a !== n.length - 1 || s !== T(e.slice(a));
         O(n[a] === e[a] || !u, (function() {
          return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + e + "). "
         }))
        }
       }
       return G(t) || Array.isArray(t) || (t = [t]), e = e || n, t = "string" !== r ? nt(t, r, h().getBool("DEBUG")) : R(t, [], !0), Wt.makeTensor(t, e, r)
      }
 
      function Bn(t, e) {
       if ((G(t) && "string" !== e || Array.isArray(t)) && "complex64" !== e) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
       if ("string" === e && G(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
       return Ln(t, [], [], e)
      }
 
      function Pn(t, e) {
       N(t);
       var n = gn(t, e);
       if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
       return Ln(t, null, n, e)
      }
 
      function zn(t, e, n) {
       if (N(t), null != e && 2 !== e.length) throw new Error("tensor2d() requires shape to have two numbers");
       var r = gn(t, n);
       if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
       if (1 === r.length && null == e) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
       return Ln(t, e, r, n)
      }
 
      function jn(t, e, n) {
       if (N(t), null != e && 3 !== e.length) throw new Error("tensor3d() requires shape to have three numbers");
       var r = gn(t, n);
       if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
       if (1 === r.length && null == e) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
       return Ln(t, e, r, n)
      }
 
      function Wn(t, e, n) {
       if (N(t), null != e && 4 !== e.length) throw new Error("tensor4d() requires shape to have four numbers");
       var r = gn(t, n);
       if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
       if (1 === r.length && null == e) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
       return Ln(t, e, r, n)
      }
 
      function Vn(t, e, n) {
       if (N(t), null != e && 5 !== e.length) throw new Error("tensor5d() requires shape to have five numbers");
       var r = gn(t, n);
       if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
       if (1 === r.length && null == e) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
       return Ln(t, e, r, n)
      }
 
      function Un(t, e, n) {
       if (N(t), null != e && 6 !== e.length) throw new Error("tensor6d() requires shape to have six numbers");
       var r = gn(t, n);
       if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
       if (1 === r.length && null == e) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
       return Ln(t, e = e || r, r, n)
      }
 
      function Hn(t, e, n, r) {
       return void 0 === e && (e = !0), Wt.makeVariable(t, e, n, r)
      }
 
      function $n(t, e) {
       if (void 0 === e && (e = "float32"), "complex64" === e) {
        var n = $n(t, "float32"),
         r = Gn(t, "float32");
        return _n(n, r)
       }
       var i = it(T(t), e);
       return Wt.makeTensor(i, t, e)
      }
 
      function Gn(t, e) {
       if (void 0 === e && (e = "float32"), "complex64" === e) {
        var n = Gn(t, "float32"),
         r = Gn(t, "float32");
        return _n(n, r)
       }
       var i = ot(T(t), e);
       return Wt.makeTensor(i, t, e)
      }
 
      function qn(t, e, n) {
       return Wt.runKernelFunc((function(r) {
        return r.fill(t, e, n)
       }), {})
      }
 
      function Kn(t, e, n) {
       if (n <= 0) throw new Error("The number of values should be positive.");
       return Wt.runKernelFunc((function(r) {
        return r.linspace(t, e, n)
       }), {})
      }
 
      function Xn(t, e, n, r) {
       if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
       if (t === e || t < e && n < 0 || e < t && n > 1) return Gn([0], r);
       var i = ot(Math.abs(Math.ceil((e - t) / n)), r);
       e < t && 1 === n && (n = -1), i[0] = t;
       for (var o = 1; o < i.length; o++) i[o] = i[o - 1] + n;
       return Pn(i, r)
      }
      var Yn = Tn({
        onesLike_: function(t) {
         var e = bn(t, "x", "onesLike");
         if ("complex64" === e.dtype) {
          var n = Yn(Dn(e)),
           r = Zn(Fn(e));
          return _n(n, r)
         }
         return Wt.runKernelFunc((function(t) {
          return t.onesLike(e)
         }), {
          $x: e
         }, (function(t, e) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Zn = Tn({
        zerosLike_: function(t) {
         var e = bn(t, "x", "zerosLike");
         return Wt.runKernelFunc((function(t) {
          return t.zerosLike(e)
         }), {
          $x: e
         }, (function(t, e) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Jn = Tn({
        concat_: function(t, e) {
         void 0 === e && (e = 0), O(t.length >= 1, (function() {
          return "Pass at least one tensor to concat"
         }));
         var n = xn(t, "tensors", "concat");
         "complex64" === n[0].dtype && n.forEach((function(t) {
          if ("complex64" !== t.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t.dtype + ". ")
         })), e = z(e, n[0].shape)[0];
         var r = Rn(n.map((function(t) {
          return t.shape
         })), e);
         if (0 === T(r)) return Mn([], r);
         if (1 === (n = n.filter((function(t) {
           return t.size > 0
          }))).length) return n[0];
         var i = n.map((function(t) {
          return t.shape
         }));
         Nn(i, e);
         var o = n,
          a = {
           axis: e
          };
         return Wt.runKernelFunc((function(t) {
          return t.concat(n, e)
         }), o, (function(t) {
          var n = i.map((function(t) {
           return t[e]
          }));
          return rr(t, n, e).map((function(t) {
           return function() {
            return t
           }
          }))
         }), "Concat", a)
        }
       }),
       Qn = Tn({
        concat1d_: function(t) {
         return Jn(t, 0)
        }
       }),
       tr = Tn({
        concat2d_: function(t, e) {
         return Jn(t, e)
        }
       }),
       er = Tn({
        concat3d_: function(t, e) {
         return Jn(t, e)
        }
       }),
       nr = Tn({
        concat4d_: function(t, e) {
         return Jn(t, e)
        }
       }),
       rr = Tn({
        split_: function(t, e, n) {
         void 0 === n && (n = 0);
         var r, i = bn(t, "x", "split");
         return n = z(n, i.shape)[0], "number" == typeof e ? (O(i.shape[n] % e == 0, (function() {
          return "Number of splits must evenly divide the axis."
         })), r = new Array(e).fill(i.shape[n] / e)) : (O(i.shape[n] === e.reduce((function(t, e) {
          return t + e
         })), (function() {
          return "The sum of sizes must match the size of the axis dimension."
         })), r = e), Wt.runKernelFunc((function(t) {
          return t.split(i, r, n)
         }), {
          $x: i
         }, (function(t) {
          return {
           $x: function() {
            return Jn(t, n)
           }
          }
         }))
        }
       });
 
      function ir(t, e) {
       return t(e = {
        exports: {}
       }, e.exports), e.exports
      }
      "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof t || "undefined" != typeof self && self;
      var or = ir((function(t) {
        ! function(t, e, n) {
         function r(t) {
          var e, n = this,
           r = (e = 4022871197, function(t) {
            t = t.toString();
            for (var n = 0; n < t.length; n++) {
             var r = .02519603282416938 * (e += t.charCodeAt(n));
             r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
            }
            return 2.3283064365386963e-10 * (e >>> 0)
           });
          n.next = function() {
           var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
           return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t)
          }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null
         }
 
         function i(t, e) {
          return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e
         }
 
         function o(t, e) {
          var n = new r(t),
           o = e && e.state,
           a = n.next;
          return a.int32 = function() {
           return 4294967296 * n.next() | 0
          }, a.double = function() {
           return a() + 11102230246251565e-32 * (2097152 * a() | 0)
          }, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
           return i(n, {})
          }), a
         }
         e && e.exports ? e.exports = o : n && n.amd ? n((function() {
          return o
         })) : this.alea = o
        }(0, t, !1)
       })),
       ar = ir((function(t) {
        ! function(t, e, n) {
         function r(t) {
          var e = this,
           n = "";
          e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function() {
           var t = e.x ^ e.x << 11;
           return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8
          }, t === (0 | t) ? e.x = t : n += t;
          for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next()
         }
 
         function i(t, e) {
          return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
         }
 
         function o(t, e) {
          var n = new r(t),
           o = e && e.state,
           a = function() {
            return (n.next() >>> 0) / 4294967296
           };
          return a.double = function() {
           do {
            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
           } while (0 === t);
           return t
          }, a.int32 = n.next, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
           return i(n, {})
          }), a
         }
         e && e.exports ? e.exports = o : n && n.amd ? n((function() {
          return o
         })) : this.xor128 = o
        }(0, t, !1)
       })),
       sr = ir((function(t) {
        ! function(t, e, n) {
         function r(t) {
          var e = this,
           n = "";
          e.next = function() {
           var t = e.x ^ e.x >>> 2;
           return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0
          }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;
          for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next()
         }
 
         function i(t, e) {
          return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e
         }
 
         function o(t, e) {
          var n = new r(t),
           o = e && e.state,
           a = function() {
            return (n.next() >>> 0) / 4294967296
           };
          return a.double = function() {
           do {
            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
           } while (0 === t);
           return t
          }, a.int32 = n.next, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
           return i(n, {})
          }), a
         }
         e && e.exports ? e.exports = o : n && n.amd ? n((function() {
          return o
         })) : this.xorwow = o
        }(0, t, !1)
       })),
       ur = ir((function(t) {
        ! function(t, e, n) {
         function r(t) {
          var e = this;
          e.next = function() {
            var t, n, r = e.x,
             i = e.i;
            return t = r[i], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[i + 1 & 7]) ^ t >>> 10, n ^= (t = r[i + 3 & 7]) ^ t >>> 3, n ^= (t = r[i + 4 & 7]) ^ t << 7, t = r[i + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[i] = n, e.i = i + 1 & 7, n
           },
           function(t, e) {
            var n, r = [];
            if (e === (0 | e)) r[0] = e;
            else
             for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;
            for (; r.length < 8;) r.push(0);
            for (n = 0; n < 8 && 0 === r[n]; ++n);
            for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next()
           }(e, t)
         }
 
         function i(t, e) {
          return e.x = t.x.slice(), e.i = t.i, e
         }
 
         function o(t, e) {
          null == t && (t = +new Date);
          var n = new r(t),
           o = e && e.state,
           a = function() {
            return (n.next() >>> 0) / 4294967296
           };
          return a.double = function() {
           do {
            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
           } while (0 === t);
           return t
          }, a.int32 = n.next, a.quick = a, o && (o.x && i(o, n), a.state = function() {
           return i(n, {})
          }), a
         }
         e && e.exports ? e.exports = o : n && n.amd ? n((function() {
          return o
         })) : this.xorshift7 = o
        }(0, t, !1)
       })),
       cr = ir((function(t) {
        ! function(t, e, n) {
         function r(t) {
          var e = this;
          e.next = function() {
            var t, n, r = e.w,
             i = e.X,
             o = e.i;
            return e.w = r = r + 1640531527 | 0, n = i[o + 34 & 127], t = i[o = o + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = i[o] = n ^ t, e.i = o, n + (r ^ r >>> 16) | 0
           },
           function(t, e) {
            var n, r, i, o, a, s = [],
             u = 128;
            for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o) e && (r ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (a = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = 0 == (n = s[127 & o] ^= r + a) ? i + 1 : 0);
            for (i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o) r = s[i + 34 & 127], n = s[i = i + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[i] = r ^ n;
            t.w = a, t.X = s, t.i = i
           }(e, t)
         }
 
         function i(t, e) {
          return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e
         }
 
         function o(t, e) {
          null == t && (t = +new Date);
          var n = new r(t),
           o = e && e.state,
           a = function() {
            return (n.next() >>> 0) / 4294967296
           };
          return a.double = function() {
           do {
            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
           } while (0 === t);
           return t
          }, a.int32 = n.next, a.quick = a, o && (o.X && i(o, n), a.state = function() {
           return i(n, {})
          }), a
         }
         e && e.exports ? e.exports = o : n && n.amd ? n((function() {
          return o
         })) : this.xor4096 = o
        }(0, t, !1)
       })),
       lr = ir((function(t) {
        ! function(t, e, n) {
         function r(t) {
          var e = this,
           n = "";
          e.next = function() {
           var t = e.b,
            n = e.c,
            r = e.d,
            i = e.a;
           return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ i, e.a = i - t | 0
          }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;
          for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next()
         }
 
         function i(t, e) {
          return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e
         }
 
         function o(t, e) {
          var n = new r(t),
           o = e && e.state,
           a = function() {
            return (n.next() >>> 0) / 4294967296
           };
          return a.double = function() {
           do {
            var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
           } while (0 === t);
           return t
          }, a.int32 = n.next, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
           return i(n, {})
          }), a
         }
         e && e.exports ? e.exports = o : n && n.amd ? n((function() {
          return o
         })) : this.tychei = o
        }(0, t, !1)
       })),
       hr = ir((function(t) {
        ! function(e, r) {
         var i, o = this,
          a = 256,
          s = 6,
          u = "random",
          c = r.pow(a, s),
          l = r.pow(2, 52),
          h = 2 * l,
          p = a - 1;
 
         function f(t, n, p) {
          var f = [],
           y = m(function t(e, n) {
            var r, i = [],
             o = typeof e;
            if (n && "object" == o)
             for (r in e) try {
              i.push(t(e[r], n - 1))
             } catch (t) {}
            return i.length ? i : "string" == o ? e : e + "\0"
           }((n = 1 == n ? {
            entropy: !0
           } : n || {}).entropy ? [t, g(e)] : null == t ? function() {
            try {
             var t;
             return i && (t = i.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), g(t)
            } catch (t) {
             var n = o.navigator,
              r = n && n.plugins;
             return [+new Date, o, r, o.screen, g(e)]
            }
           }() : t, 3), f),
           b = new d(f),
           x = function() {
            for (var t = b.g(s), e = c, n = 0; t < l;) t = (t + n) * a, e *= a, n = b.g(1);
            for (; t >= h;) t /= 2, e /= 2, n >>>= 1;
            return (t + n) / e
           };
          return x.int32 = function() {
           return 0 | b.g(4)
          }, x.quick = function() {
           return b.g(4) / 4294967296
          }, x.double = x, m(g(b.S), e), (n.pass || p || function(t, e, n, i) {
           return i && (i.S && v(i, b), t.state = function() {
            return v(b, {})
           }), n ? (r[u] = t, e) : t
          })(x, y, "global" in n ? n.global : this == r, n.state)
         }
 
         function d(t) {
          var e, n = t.length,
           r = this,
           i = 0,
           o = r.i = r.j = 0,
           s = r.S = [];
          for (n || (t = [n++]); i < a;) s[i] = i++;
          for (i = 0; i < a; i++) s[i] = s[o = p & o + t[i % n] + (e = s[i])], s[o] = e;
          (r.g = function(t) {
           for (var e, n = 0, i = r.i, o = r.j, s = r.S; t--;) e = s[i = p & i + 1], n = n * a + s[p & (s[i] = s[o = p & o + e]) + (s[o] = e)];
           return r.i = i, r.j = o, n
          })(a)
         }
 
         function v(t, e) {
          return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
         }
 
         function m(t, e) {
          for (var n, r = t + "", i = 0; i < r.length;) e[p & i] = p & (n ^= 19 * e[p & i]) + r.charCodeAt(i++);
          return g(e)
         }
 
         function g(t) {
          return String.fromCharCode.apply(0, t)
         }
         if (r["seed" + u] = f, m(r.random(), e), t.exports) {
          t.exports = f;
          try {
           i = n(1)
          } catch (t) {}
         }
        }([], Math)
       }));
      hr.alea = or, hr.xor128 = ar, hr.xorwow = sr, hr.xorshift7 = ur, hr.xor4096 = cr, hr.tychei = lr;
      var pr = hr.alea,
       fr = function() {
        function t(t, e, n, r, i) {
         this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
         var o = i || Math.random();
         this.random = pr(o.toString())
        }
        return t.prototype.nextValue = function() {
         if (!isNaN(this.nextVal)) {
          var t = this.nextVal;
          return this.nextVal = NaN, t
         }
         for (var e, n, r = !1; !r;) {
          var i = void 0,
           o = void 0,
           a = void 0;
          do {
           a = (i = 2 * this.random() - 1) * i + (o = 2 * this.random() - 1) * o
          } while (a >= 1 || 0 === a);
          var s = Math.sqrt(-2 * Math.log(a) / a);
          e = this.mean + this.stdDev * i * s, n = this.mean + this.stdDev * o * s, this.truncated && !this.isValidTruncated(e) || (r = !0)
         }
         return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e)
        }, t.prototype.convertValue = function(t) {
         return null == this.dtype || "float32" === this.dtype ? t : Math.round(t)
        }, t.prototype.isValidTruncated = function(t) {
         return t <= this.upper && t >= this.lower
        }, t
       }(),
       dr = function() {
        function t(t, e, n, r) {
         this.alpha = t, this.beta = 1 / e, this.dtype = n;
         var i = r || Math.random();
         this.randu = pr(i.toString()), this.randn = new fr(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d)
        }
        return t.prototype.nextValue = function() {
         for (var t, e, n, r, i, o;;) {
          do {
           r = this.randn.nextValue(), o = 1 + this.c * r
          } while (o <= 0);
          if (o *= o * o, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - o + Math.log(o)), (i = this.randu()) < e || Math.log(i) < n) break
         }
         return o = 1 / this.beta * this.d * o, this.alpha < 1 && (o *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(o)
        }, t.prototype.convertValue = function(t) {
         return "float32" === this.dtype ? t : Math.round(t)
        }, t
       }(),
       vr = function() {
        function t(t, e, n, r) {
         var i = this;
         if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function() {
           return null == i.dtype || "float32" === i.dtype
          }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t + " - " + e + " <= 1 and dtype is not float");
         this.random = pr(r)
        }
        return t.prototype.convertValue = function(t) {
         return this.canReturnFloat() ? t : Math.round(t)
        }, t.prototype.nextValue = function() {
         return this.convertValue(this.min + this.range * this.random())
        }, t
       }();
 
      function mr(t, e, n) {
       return void 0 === e && (e = "float32"), e = e || "float32", st(t), new xt(t, e, n)
      }
 
      function gr(t, e) {
       void 0 === e && (e = !1), console.log(t.toString(e))
      }
      var yr = Tn({
        batchToSpaceND_: function(t, e, n) {
         var r = bn(t, "x", "batchToSpaceND"),
          i = e.reduce((function(t, e) {
           return t * e
          }));
         return O(r.rank >= 1 + e.length, (function() {
          return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length
         })), O(n.length === e.length, (function() {
          return "crops.length is " + n.length + " but should be equal to blockShape.length  " + e.length
         })), O(r.shape[0] % i == 0, (function() {
          return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + i
         })), Wt.runKernelFunc((function(t) {
          return t.batchToSpaceND(r, e, n)
         }), {
          $x: r
         }, (function(t) {
          return {
           $x: function() {
            return t.spaceToBatchND(e, n)
           }
          }
         }))
        }
       }),
       br = Tn({
        broadcastTo_: function(t, e) {
         var n = bn(t, "broadcastTo", "x"),
          r = n.shape;
         if (e.some((function(t) {
           return !(t > 0) || t % 1 != 0
          }))) throw new Error("broadcastTo(): Invalid broadcast shape [" + e + "].");
         if (e.length < n.rank) throw new Error("broadcastTo(): shape.length=" + e.length + " < input.rank=" + n.rank + ".");
         if (e.length > n.rank) {
          for (var i = n.shape.slice(); i.length < e.length;) i.unshift(1);
          n = n.reshape(i)
         }
         for (var o = Array.from(e), a = e.length - 1; a >= 0; a--)
          if (n.shape[a] === e[a]) o[a] = 1;
          else if (1 !== n.shape[a]) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + e + "].");
         var s = o.map((function(t, e) {
          return t > 1 ? e : -1
         })).filter((function(t) {
          return t >= 0
         }));
         return 0 === s.length ? n.clone() : Wt.runKernelFunc((function(t) {
          return t.tile(n, o)
         }), {
          input: n
         }, (function(t) {
          return {
           input: function() {
            return t.sum(s, !0)
           }
          }
         }))
        }
       }),
       xr = Tn({
        cast_: function(t, e) {
         var n = bn(t, "x", "cast");
         if (!H(e)) throw new Error("Failed to cast to unknown dtype " + e);
         if ("string" === e && "string" !== n.dtype || "string" !== e && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
         var r = {
          dtype: e
         };
         return Wt.runKernelFunc((function(t) {
          return t.cast(n, e)
         }), {
          x: n
         }, (function(t) {
          return {
           x: function() {
            return t.clone()
           }
          }
         }), "Cast", r)
        }
       }),
       wr = Tn({
        clone_: function(t) {
         var e = bn(t, "x", "clone", null);
         return Wt.runKernelFunc((function() {
          return Wt.makeTensorFromDataId(e.dataId, e.shape, e.dtype)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return t.toFloat()
           }
          }
         }))
        }
       }),
       Cr = Tn({
        cumsum_: function(t, e, n, r) {
         void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
         var i = bn(t, "x", "cumsum"),
          o = In([e |= 0], i.rank),
          a = i;
         null != o && (a = i.transpose(o));
         var s = An(1, i.rank)[0],
          u = Wt.runKernelFunc((function(t) {
           return t.cumsum(a, s, n, r)
          }), {
           permutedX: a
          }, (function(t) {
           return {
            permutedX: function() {
             return t.cumsum(e, n, !r)
            }
           }
          }));
         return null != o && (u = u.transpose(o)), u
        }
       }),
       Sr = Tn({
        depthToSpace_: function(t, e, n) {
         void 0 === n && (n = "NHWC");
         var r = bn(t, "x", "depthToSpace"),
          i = "NHWC" === n ? r.shape[1] : r.shape[2],
          o = "NHWC" === n ? r.shape[2] : r.shape[3],
          a = "NHWC" === n ? r.shape[3] : r.shape[1];
         return O(i * e >= 0, (function() {
          return "Negative dimension size caused by overflow when multiplying\n      " + i + " and " + e + "  for depthToSpace with input shape\n      " + r.shape
         })), O(o * e >= 0, (function() {
          return "Negative dimension size caused by overflow when multiplying\n      " + o + " and " + e + " for depthToSpace with input shape\n          " + r.shape
         })), O(a % (e * e) == 0, (function() {
          return "Dimension size must be evenly divisible by " + e * e + " but is " + a + " for depthToSpace with input shape " + r.shape
         })), Wt.runKernelFunc((function(t) {
          return t.depthToSpace(r, e, n)
         }), {
          $x: r
         })
        }
       }),
       Er = Tn({
        expandDims_: function(t, e) {
         void 0 === e && (e = 0);
         var n = bn(t, "x", "expandDims", null);
         O(e <= n.rank, (function() {
          return "Axis must be <= rank of the tensor"
         }));
         var r = n.shape.slice();
         return e < 0 && (O(-(n.rank + 1) <= e, (function() {
          return "Axis must be in the interval [" + -(n.rank + 1) + ", " + n.rank + "]"
         })), e = n.rank + e + 1), r.splice(e, 0, 1), Br(n, r)
        }
       }),
       kr = Tn({
        eye_: function(t, e, n, r) {
         void 0 === r && (r = "float32"), null == e && (e = t);
         for (var i = mr([t, e], r), o = t <= e ? t : e, a = 0; a < o; ++a) i.set(1, a, a);
         var s = i.toTensor().as2D(t, e);
         if (null == n) return s;
         if (1 === n.length) return Wr(Er(s, 0), [n[0], 1, 1]);
         if (2 === n.length) return Wr(Er(Er(s, 0), 0), [n[0], n[1], 1, 1]);
         if (3 === n.length) return Wr(Er(Er(Er(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
         throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.")
        }
       }),
       Ir = Tn({
        multinomial_: function(t, e, n, r) {
         void 0 === r && (r = !1);
         var i = bn(t, "logits", "multinomial"),
          o = i.size,
          a = i.rank;
         if (o < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + o + ".");
         if (a > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + a);
         n = n || Math.random();
         var s = 1 === a ? i.as2D(1, -1) : i,
          u = Wt.runKernelFunc((function(t) {
           return t.multinomial(s, r, e, n)
          }), {
           logits2D: s
          });
         return 1 === a ? u.as1D() : u
        }
       }),
       Or = Tn({
        oneHot_: function(t, e, n, r) {
         if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
         var i = bn(t, "indices", "oneHot", "int32"),
          o = i.shape.concat([e]);
         return i = i.flatten(), Wt.runKernelFunc((function(t) {
          return t.oneHot(i, e, n, r)
         }), {
          $indices: i
         }, (function(t) {
          return {
           $indices: function() {
            return Gn(i.shape, "float32")
           }
          }
         })).reshape(o)
        }
       }),
       Ar = Tn({
        pad_: function(t, e, n) {
         void 0 === n && (n = 0);
         var r = bn(t, "x", "pad");
         if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
         var i = {
          paddings: e,
          constantValue: n
         };
         return Wt.runKernelFunc((function(t) {
          return t.pad(r, e, n)
         }), {
          x: r
         }, (function(t) {
          var n = e.map((function(t) {
           return t[0]
          }));
          return {
           x: function() {
            return t.slice(n, r.shape)
           }
          }
         }), "PadV2", i)
        }
       }),
       Nr = Tn({
        pad1d_: function(t, e, n) {
         return void 0 === n && (n = 0), O(2 === e.length, (function() {
          return "Invalid number of paddings. Must be length of 2."
         })), Ar(t, [e], n)
        }
       }),
       Rr = Tn({
        pad2d_: function(t, e, n) {
         return void 0 === n && (n = 0), O(2 === e.length && 2 === e[0].length && 2 === e[1].length, (function() {
          return "Invalid number of paddings. Must be length of 2 each."
         })), Ar(t, e, n)
        }
       }),
       Tr = Tn({
        pad3d_: function(t, e, n) {
         return void 0 === n && (n = 0), O(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, (function() {
          return "Invalid number of paddings. Must be length of 2 each."
         })), Ar(t, e, n)
        }
       }),
       _r = Tn({
        pad4d_: function(t, e, n) {
         return void 0 === n && (n = 0), O(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, (function() {
          return "Invalid number of paddings. Must be length of 2 each."
         })), Ar(t, e, n)
        }
       }),
       Dr = Tn({
        rand_: function(t, e, n) {
         var r = T(t),
          i = null;
         if (null == n || "float32" === n) i = new Float32Array(r);
         else if ("int32" === n) i = new Int32Array(r);
         else {
          if ("bool" !== n) throw new Error("Unknown data type " + n);
          i = new Uint8Array(r)
         }
         for (var o = 0; o < r; o++) i[o] = e();
         return Wt.makeTensor(i, t, n)
        }
       }),
       Fr = Tn({
        randomNormal_: function(t, e, n, r, i) {
         if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
         for (var o = new fr(e, n, r, !1, i), a = mr(t, r), s = 0; s < a.values.length; s++) a.values[s] = o.nextValue();
         return a.toTensor()
        }
       }),
       Mr = Tn({
        randomGamma_: function(t, e, n, r, i) {
         if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);
         for (var o = new dr(e, n, r, i), a = mr(t, r), s = 0; s < a.values.length; s++) a.values[s] = o.nextValue();
         return a.toTensor()
        }
       }),
       Lr = Tn({
        randomUniform_: function(t, e, n, r, i) {
         void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");
         for (var o = mr(t, r), a = new vr(e, n, null, i), s = 0; s < o.values.length; s++) o.values[s] = a.nextValue();
         return o.toTensor()
        }
       }),
       Br = Tn({
        reshape_: function(t, e) {
         var n = bn(t, "x", "reshape", null);
         e = P(e, n.size), O(n.size === T(e), (function() {
          return "new shape and old shape must have the same number of elements."
         }));
         var r = {
          shape: e
         };
         return Wt.runKernelFunc((function(t) {
          return t.reshape(n, e)
         }), {
          x: n
         }, (function(t) {
          return {
           x: function() {
            return t.reshape(n.shape)
           }
          }
         }), "Reshape", r)
        }
       }),
       Pr = Tn({
        spaceToBatchND_: function(t, e, n) {
         var r = bn(t, "x", "spaceToBatchND");
         return O(r.rank >= 1 + e.length, (function() {
          return "input rank " + r.rank + " should be > than [blockShape] " + e.length
         })), O(n.length === e.length, (function() {
          return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + e.length
         })), O(r.shape.reduce((function(t, r, i) {
          return i > 0 && i <= e.length ? t && (r + n[i - 1][0] + n[i - 1][1]) % e[i - 1] == 0 : t
         }), !0), (function() {
          return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + e.toString()
         })), Wt.runKernelFunc((function(t) {
          return t.spaceToBatchND(r, e, n)
         }), {
          $x: r
         }, (function(t) {
          return {
           $x: function() {
            return t.batchToSpaceND(e, n)
           }
          }
         }))
        }
       }),
       zr = Tn({
        squeeze_: function(t, e) {
         var n = bn(t, "x", "squeeze");
         return Br(n, j(n.shape, e).newShape)
        }
       }),
       jr = Tn({
        stack_: function(t, e) {
         void 0 === e && (e = 0);
         var n = xn(t, "tensors", "stack");
         if (O(n.length >= 1, (function() {
           return "Pass at least one tensor to tf.stack"
          })), 1 === n.length) return n[0].expandDims(e);
         var r = n[0].rank,
          i = n[0].shape,
          o = n[0].dtype;
         O(e <= r, (function() {
          return "Axis must be <= rank of the tensor"
         })), n.forEach((function(t) {
          A(i, t.shape, "All tensors passed to stack must have matching shapes")
         })), n.forEach((function(t) {
          O(o === t.dtype, (function() {
           return "All tensors passed to stack must have matching dtypes"
          }))
         }));
         var a = n.map((function(t) {
          return t.expandDims(e)
         }));
         return Jn(a, e)
        }
       }),
       Wr = Tn({
        tile_: function(t, e) {
         var n = bn(t, "x", "tile", null);
         O(n.rank === e.length, (function() {
          return "Error in transpose: rank of input " + n.rank + " must match length of reps " + e + "."
         }));
         var r = [n],
          i = {
           reps: e
          };
         return Wt.runKernelFunc((function(t, r) {
          var i = t.tile(n, e);
          return r([n]), i
         }), {
          x: n
         }, (function(t, n) {
          var r = n[0];
          return {
           x: function() {
            var n = Zn(r);
            if (1 === r.rank)
             for (var i = 0; i < e[0]; ++i) n = n.add(t.slice([i * r.shape[0]], [r.shape[0]]));
            else if (2 === r.rank)
             for (i = 0; i < e[0]; ++i)
              for (var o = 0; o < e[1]; ++o) n = n.add(t.slice([i * r.shape[0], o * r.shape[1]], [r.shape[0], r.shape[1]]));
            else if (3 === r.rank)
             for (i = 0; i < e[0]; ++i)
              for (o = 0; o < e[1]; ++o)
               for (var a = 0; a < e[2]; ++a) n = n.add(t.slice([i * r.shape[0], o * r.shape[1], a * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
            else {
             if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");
             for (i = 0; i < e[0]; ++i)
              for (o = 0; o < e[1]; ++o)
               for (a = 0; a < e[2]; ++a)
                for (var s = 0; s < e[3]; ++s) n = n.add(t.slice([i * r.shape[0], o * r.shape[1], a * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]))
            }
            return n
           }
          }
         }), "Tile", i, r)
        }
       }),
       Vr = Tn({
        truncatedNormal_: function(t, e, n, r, i) {
         if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
         for (var o = new fr(e, n, r, !0, i), a = mr(t, r), s = 0; s < a.values.length; s++) a.values[s] = o.nextValue();
         return a.toTensor()
        }
       }),
       Ur = Tn({
        unstack_: function(t, e) {
         void 0 === e && (e = 0), e = e || 0;
         var n = bn(t, "x", "unstack");
         O(e >= -n.shape.length && e < n.shape.length, (function() {
          return "Axis = " + e + " is not in [-" + n.shape.length + ", " + n.shape.length + ")"
         })), e < 0 && (e += n.shape.length);
         var r = {
          axis: e
         };
         return Wt.runKernelFunc((function(t) {
          return t.unstack(n, e)
         }), {
          x: n
         }, (function(t) {
          return {
           x: function() {
            return jr(t, e)
           }
          }
         }), "Unpack", r)
        }
       }),
       Hr = function(t, e) {
        return s(this, void 0, void 0, (function() {
         var n, r, i, o, a, s, c, l, h, p;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return n = bn(t, "x", "setdiff1d"), r = bn(e, "y", "setdiff1d"), O(n.dtype === r.dtype, (function() {
             return "x and y should have the same dtype, but got x (" + n.dtype + ") and y (" + r.dtype + ")."
            })), O(1 === n.rank, (function() {
             return "x should be 1D tensor, but got x (" + n.shape + ")."
            })), O(1 === r.rank, (function() {
             return "y should be 1D tensor, but got y (" + r.shape + ")."
            })), [4, n.data()];
           case 1:
            return i = u.sent(), [4, r.data()];
           case 2:
            for (o = u.sent(), a = new Set(o), s = 0, h = 0; h < i.length; h++) a.has(i[h]) || s++;
            for (c = new xt([s], n.dtype), l = new xt([s], "int32"), h = 0, p = 0; h < i.length; h++) a.has(i[h]) || (c.values[p] = i[h], l.values[p] = h, p++);
            return [2, [c.toTensor(), l.toTensor()]]
          }
         }))
        }))
       };
 
      function $r(t, e, n, r) {
       void 0 === r && (r = !0);
       var i = [];
       if (r)(i = i.concat(e.slice(0))).push(t[0] / n), i = i.concat(t.slice(1));
       else {
        i = i.concat(t[0]);
        for (var o = e.length, a = 0; a < o; ++a) i = i.concat([t[a + 1] / e[a], e[a]]);
        i = i.concat(t.slice(o + 1))
       }
       return i
      }
 
      function Gr(t, e, n) {
       void 0 === n && (n = !0);
       var r = [];
       if (n) {
        r.push(e);
        for (var i = e + 1; i < t; ++i) i <= 2 * e ? (r.push(i), r.push(i - (e + 1))) : r.push(i)
       } else {
        var o = [],
         a = [];
        for (i = 1; i < t; ++i) i >= 2 * e + 1 || i % 2 == 1 ? a.push(i) : o.push(i);
        r.push.apply(r, o), r.push(0), r.push.apply(r, a)
       }
       return r
      }
 
      function qr(t, e, n, r) {
       void 0 === r && (r = !0);
       var i = [];
       r ? i.push(t[0] / n) : i.push(t[0] * n);
       for (var o = 1; o < t.length; ++o) o <= e.length ? r ? i.push(e[o - 1] * t[o]) : i.push(t[o] / e[o - 1]) : i.push(t[o]);
       return i
      }
 
      function Kr(t, e) {
       for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);
       return n
      }
 
      function Xr(t, e, n) {
       for (var r = t.slice(0, 1), i = 0; i < n; ++i) r.push(t[i + 1] - e[i][0] - e[i][1]);
       return r
      }
 
      function Yr(t, e) {
       if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t.rank + ".");
       if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
       if ("int32" !== e.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
       if (e.shape[e.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + t.rank);
       if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t.shape + ".");
       for (var n = e.shape, r = n[n.length - 1], i = 1, o = 0; o < n.length - 1; ++o) i *= n[o];
       var a = t.shape,
        s = n.slice();
       s.pop();
       var u = 1;
       for (o = r; o < t.rank; ++o) u *= a[o], s.push(a[o]);
       var c = et(t.shape).map((function(t) {
        return t / u
       })).concat([1]).slice(0, r);
       return [s, i, u, c]
      }
      var Zr = Object.freeze({
        prepareAndValidate: Yr
       }),
       Jr = 30;
 
      function Qr(t) {
       return t <= Jr ? t : tt(t, Math.floor(Math.sqrt(t)))
      }
 
      function ti(t, e, n) {
       var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
        i = e.rank > 1 ? e.rank - 1 : 1,
        o = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + e.shape + ", shape: " + t + ", sliceDim: " + r + ", and batchDim: " + i + ".";
       if (n.rank < i) throw new Error(o + " update.rank < " + i + ". ");
       if (t.length < r + (n.rank - i)) throw new Error(o + " Output shape length < " + (r + (n.rank - i)));
       if (n.rank !== i + t.length - r) throw new Error(o + " update.rank != " + (i + t.length - r));
       for (var a = 0; a < i; ++a)
        if (n.shape[a] !== e.shape[a]) throw new Error(o + " updates.shape[" + a + "] (" + n.shape[a] + ") != indices.shape[" + a + "] (" + e.shape[a] + ").");
       for (a = 0; a < n.rank - i; ++a)
        if (n.shape[a + i] !== t[a + r]) throw new Error(o + " updates.shape[" + (a + i) + "] (" + n.shape[a + i] + ") != shape[" + (a + i) + "] (" + t[a + i] + ")")
      }
 
      function ei(t, e, n) {
       if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
       if (t.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t.rank + ".");
       if ("int32" !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
       if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);
       if (0 === n.length) {
        if (0 === e.size) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
        if (0 === t.size) throw new Error("Updates specified for empty output. updates shape: " + t.shape)
       }
       ti(n, e, t)
      }
 
      function ni(t, e, n) {
       for (var r = e.shape.length, i = r > 1 ? e.shape[r - 1] : 1, o = n.length, a = 1, s = i; s < o; ++s) a *= n[s];
       var u = i < 1 ? 1 : i;
       return {
        sliceRank: i,
        numUpdates: T(e.shape) / u,
        sliceSize: a,
        strides: et(n.slice(0, i)).concat([1]),
        outputSize: T(n)
       }
      }
      var ri = Object.freeze({
       validateUpdateShape: ti,
       validateInput: ei,
       calculateShapes: ni
      });
 
      function ii(t, e, n) {
       O(t.rank === e.length, (function() {
        return "Error in slice" + t.rank + "D: Length of begin " + e + " must match the rank of the array (" + t.rank + ")."
       })), O(t.rank === n.length, (function() {
        return "Error in slice" + t.rank + "D: Length of size " + n + " must match the rank of the array (" + t.rank + ")."
       }));
       for (var r = function(r) {
         O(e[r] + n[r] <= t.shape[r], (function() {
          return "Error in slice" + t.rank + "D: begin[" + r + "] + size[" + r + "] (" + (e[r] + n[r]) + ") would overflow input.shape[" + r + "] (" + t.shape[r] + ")"
         }))
        }, i = 0; i < t.rank; ++i) r(i)
      }
 
      function oi(t) {
       for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;
       return e
      }
 
      function ai(t, e, n) {
       for (var r = [], i = 0; i < t.length; i++) r[i] = Math.ceil((e[i] - t[i]) / n[i]);
       return r
      }
 
      function si(t, e, n, r, i) {
       var o = e[i],
        a = n[i] || 1;
       (t & 1 << i || null == o) && (o = a > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
       var s = r[i];
       return o < 0 && (o += s), E(0, o, s - 1)
      }
 
      function ui(t, e, n, r, i) {
       var o = e[i],
        a = n[i] || 1;
       (t & 1 << i || null == o) && (o = a > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
       var s = r[i];
       return o < 0 && (o += s), a > 0 ? E(0, o, s) : E(-1, o, s - 1)
      }
 
      function ci(t, e, n) {
       for (var r = n.length, i = 0; i < n.length; i++)
        if (n[i] > 1) {
         r = i;
         break
        } for (i = r + 1; i < n.length; i++)
        if (e[i] > 0 || n[i] !== t[i]) return !1;
       return !0
      }
 
      function li(t, e) {
       for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];
       return n
      }
      var hi = Object.freeze({
       assertParamsValid: ii,
       maskToAxes: oi,
       computeOutShape: ai,
       startForAxis: si,
       stopForAxis: ui,
       isSliceContinous: ci,
       computeFlatOffset: li
      });
 
      function pi(t) {
       return O(Q(t), (function() {
         return "The f passed in grad(f) must be a function"
        })),
        function(e, n) {
         var r = bn(e, "x", "tf.grad", null),
          i = null != n ? bn(n, "dy", "tf.grad") : null;
         return Wt.tidy((function() {
          var e = Wt.gradients((function() {
            return t(r)
           }), [r], i),
           n = e.value,
           o = e.grads;
          return null != i && A(n.shape, i.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), yi(o), o[0]
         }))
        }
      }
 
      function fi(t) {
       return O(Q(t), (function() {
         return "The f passed in grads(f) must be a function"
        })),
        function(e, n) {
         O(Array.isArray(e), (function() {
          return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"
         }));
         var r = xn(e, "args", "tf.grads", null),
          i = null != n ? bn(n, "dy", "tf.grads") : null;
         return Wt.tidy((function() {
          var e = Wt.gradients((function() {
            return t.apply(void 0, r)
           }), r, i),
           n = e.value,
           o = e.grads;
          return null != i && A(n.shape, i.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), yi(o), o
         }))
        }
      }
 
      function di(t) {
       return O(Q(t), (function() {
         return "The f passed in valueAndGrad(f) must be a function"
        })),
        function(e, n) {
         O(e instanceof Et, (function() {
          return "The x passed in valueAndGrad(f)(x) must be a tensor"
         })), O(null == n || n instanceof Et, (function() {
          return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor"
         }));
         var r = Wt.gradients((function() {
           return t(e)
          }), [e], n),
          i = r.grads,
          o = r.value;
         return yi(i), {
          grad: i[0],
          value: o
         }
        }
      }
 
      function vi(t) {
       return O(Q(t), (function() {
         return "The f passed in valueAndGrads(f) must be a function"
        })),
        function(e, n) {
         O(Array.isArray(e) && e.every((function(t) {
          return t instanceof Et
         })), (function() {
          return "The args passed in valueAndGrads(f)(args) must be array of tensors"
         })), O(null == n || n instanceof Et, (function() {
          return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor"
         }));
         var r = Wt.gradients((function() {
          return t.apply(void 0, e)
         }), e, n);
         return null != n && A(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), yi(r.grads), r
        }
      }
 
      function mi(t, e) {
       O(Q(t), (function() {
        return "The f passed in variableGrads(f) must be a function"
       })), O(null == e || Array.isArray(e) && e.every((function(t) {
        return t instanceof Rt
       })), (function() {
        return "The varList passed in variableGrads(f, varList) must be an array of variables"
       }));
       var n = null != e;
       if (!n)
        for (var r in e = [], Wt.registeredVariables) e.push(Wt.registeredVariables[r]);
       var i = n ? e.filter((function(t) {
         return !t.trainable
        })) : null,
        o = e.length;
       O((e = e.filter((function(t) {
        return t.trainable
       }))).length > 0, (function() {
        return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + o + " variables is trainable."
       }));
       var a = Wt.gradients(t, e, null, !0),
        s = a.value,
        u = a.grads;
       O(u.some((function(t) {
        return null != t
       })), (function() {
        return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."
       })), O(0 === s.rank, (function() {
        return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor"
       }));
       var c = {};
       return e.forEach((function(t, e) {
        null != u[e] && (c[t.name] = u[e])
       })), null != i && i.forEach((function(t) {
        return c[t.name] = null
       })), {
        value: s,
        grads: c
       }
      }
 
      function gi(t) {
       return Wt.customGrad(t)
      }
 
      function yi(t) {
       if (t.filter((function(t) {
         return null == t
        })).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")
      }
      var bi = Tn({
        softmax_: function(t, e) {
         void 0 === e && (e = -1);
         var n = bn(t, "logits", "softmax");
         if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + e);
         return gi((function(t, n) {
          var r = t.logSumExp([e], !0),
           i = t.toFloat().sub(r).exp();
          return n([i]), {
           value: i,
           gradFunc: function(t, n) {
            var r = n[0],
             i = t.mul(r);
            return i.sub(i.sum([e], !0).mul(r))
           }
          }
         }))(n)
        }
       }),
       xi = Tn({
        logSoftmax_: function(t, e) {
         void 0 === e && (e = -1);
         var n = bn(t, "logits", "logSoftmax");
         if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + e);
         return gi((function(t, n) {
          var r = t.max(e, !0),
           i = t.sub(r),
           o = i.toFloat().sub(i.exp().sum(e, !0).log());
          return n([o]), {
           value: o,
           gradFunc: function(t, n) {
            var r = n[0].exp();
            return t.sub(t.sum(e, !0).mul(r))
           }
          }
         }))(n)
        }
       }),
       wi = function() {
        function t(t, e) {
         this.backend = t, this.dataMover = e, this.data = new WeakMap, this.dataIdsCount = 0
        }
        return t.prototype.get = function(t) {
         return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t)
        }, t.prototype.set = function(t, e) {
         this.dataIdsCount++, this.data.set(t, e)
        }, t.prototype.has = function(t) {
         return this.data.has(t)
        }, t.prototype.delete = function(t) {
         return this.dataIdsCount--, this.data.delete(t)
        }, t.prototype.numDataIds = function() {
         return this.dataIdsCount
        }, t
       }(),
       Ci = function() {
        function t() {}
        return t.prototype.time = function(t) {
         return Si("time")
        }, t.prototype.read = function(t) {
         return Si("read")
        }, t.prototype.readSync = function(t) {
         return Si("readSync")
        }, t.prototype.numDataIds = function() {
         return Si("numDataIds")
        }, t.prototype.disposeData = function(t) {
         return Si("disposeData")
        }, t.prototype.write = function(t, e, n) {
         return Si("write")
        }, t.prototype.move = function(t, e, n, r) {
         return Si("move")
        }, t.prototype.memory = function() {
         return Si("memory")
        }, t.prototype.floatPrecision = function() {
         return Si("floatPrecision")
        }, t.prototype.epsilon = function() {
         return 32 === this.floatPrecision() ? 1e-7 : 1e-4
        }, t.prototype.batchMatMul = function(t, e, n, r) {
         return Si("batchMatMul")
        }, t.prototype.fusedBatchMatMul = function(t) {
         return t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights, Si("fusedBatchMatMul")
        }, t.prototype.slice = function(t, e, n) {
         return Si("slice")
        }, t.prototype.stridedSlice = function(t, e, n, r) {
         return Si("stridedSlice")
        }, t.prototype.unstack = function(t, e) {
         return Si("unstack")
        }, t.prototype.reverse = function(t, e) {
         return Si("reverse")
        }, t.prototype.concat = function(t, e) {
         return Si("concat")
        }, t.prototype.neg = function(t) {
         return Si("neg")
        }, t.prototype.add = function(t, e) {
         return Si("add")
        }, t.prototype.addN = function(t) {
         return Si("addN")
        }, t.prototype.subtract = function(t, e) {
         return Si("subtract")
        }, t.prototype.multiply = function(t, e) {
         return Si("multiply")
        }, t.prototype.realDivide = function(t, e) {
         return Si("realDivide")
        }, t.prototype.floorDiv = function(t, e) {
         return Si("floorDiv")
        }, t.prototype.sum = function(t, e) {
         return Si("sum")
        }, t.prototype.prod = function(t, e) {
         return Si("prod")
        }, t.prototype.unsortedSegmentSum = function(t, e, n) {
         return Si("unsortedSegmentSum")
        }, t.prototype.argMin = function(t, e) {
         return Si("argMin")
        }, t.prototype.argMax = function(t, e) {
         return Si("argMax")
        }, t.prototype.equal = function(t, e) {
         return Si("equal")
        }, t.prototype.notEqual = function(t, e) {
         return Si("notEqual")
        }, t.prototype.less = function(t, e) {
         return Si("less")
        }, t.prototype.lessEqual = function(t, e) {
         return Si("lessEqual")
        }, t.prototype.greater = function(t, e) {
         return Si("greater")
        }, t.prototype.greaterEqual = function(t, e) {
         return Si("greaterEqual")
        }, t.prototype.logicalNot = function(t) {
         return Si("logicalNot")
        }, t.prototype.logicalAnd = function(t, e) {
         return Si("logicalAnd")
        }, t.prototype.logicalOr = function(t, e) {
         return Si("logicalOr")
        }, t.prototype.where = function(t) {
         return Si("where")
        }, t.prototype.select = function(t, e, n) {
         return Si("select")
        }, t.prototype.topk = function(t, e, n) {
         return Si("topk")
        }, t.prototype.min = function(t, e) {
         return Si("min")
        }, t.prototype.minimum = function(t, e) {
         return Si("minimum")
        }, t.prototype.mod = function(t, e) {
         return Si("mod")
        }, t.prototype.max = function(t, e) {
         return Si("max")
        }, t.prototype.maximum = function(t, e) {
         return Si("maximum")
        }, t.prototype.all = function(t, e) {
         return Si("all")
        }, t.prototype.any = function(t, e) {
         return Si("any")
        }, t.prototype.squaredDifference = function(t, e) {
         return Si("squaredDifference")
        }, t.prototype.ceil = function(t) {
         return Si("ceil")
        }, t.prototype.floor = function(t) {
         return Si("floor")
        }, t.prototype.round = function(t) {
         return Si("round")
        }, t.prototype.sign = function(t) {
         return Si("sign")
        }, t.prototype.isNaN = function(t) {
         return Si("isNaN")
        }, t.prototype.isInf = function(t) {
         return Si("isInf")
        }, t.prototype.isFinite = function(t) {
         return Si("isFinite")
        }, t.prototype.pow = function(t, e) {
         return Si("pow")
        }, t.prototype.exp = function(t) {
         return Si("exp")
        }, t.prototype.expm1 = function(t) {
         return Si("expm1")
        }, t.prototype.log = function(t) {
         return Si("log")
        }, t.prototype.log1p = function(t) {
         return Si("log1p")
        }, t.prototype.sqrt = function(t) {
         return Si("sqrt")
        }, t.prototype.rsqrt = function(t) {
         return Si("rsqrt")
        }, t.prototype.square = function(t) {
         return Si("square")
        }, t.prototype.reciprocal = function(t) {
         return Si("reciprocal")
        }, t.prototype.relu = function(t) {
         return Si("relu")
        }, t.prototype.relu6 = function(t) {
         return Si("relu6")
        }, t.prototype.prelu = function(t, e) {
         return Si("prelu")
        }, t.prototype.elu = function(t) {
         return Si("elu")
        }, t.prototype.eluDer = function(t, e) {
         return Si("eluDer")
        }, t.prototype.selu = function(t) {
         return Si("selu")
        }, t.prototype.int = function(t) {
         return Si("int")
        }, t.prototype.clip = function(t, e, n) {
         return Si("clip")
        }, t.prototype.abs = function(t) {
         return Si("abs")
        }, t.prototype.complexAbs = function(t) {
         return Si("complexAbs")
        }, t.prototype.sigmoid = function(t) {
         return Si("sigmoid")
        }, t.prototype.softplus = function(t) {
         return Si("softplus")
        }, t.prototype.sin = function(t) {
         return Si("sin")
        }, t.prototype.cos = function(t) {
         return Si("cos")
        }, t.prototype.tan = function(t) {
         return Si("tan")
        }, t.prototype.asin = function(t) {
         return Si("asin")
        }, t.prototype.acos = function(t) {
         return Si("acos")
        }, t.prototype.atan = function(t) {
         return Si("atan")
        }, t.prototype.atan2 = function(t, e) {
         return Si("atan2")
        }, t.prototype.sinh = function(t) {
         return Si("sinh")
        }, t.prototype.cosh = function(t) {
         return Si("cosh")
        }, t.prototype.tanh = function(t) {
         return Si("tanh")
        }, t.prototype.asinh = function(t) {
         return Si("asinh")
        }, t.prototype.acosh = function(t) {
         return Si("acosh")
        }, t.prototype.atanh = function(t) {
         return Si("atanh")
        }, t.prototype.erf = function(t) {
         return Si("erf")
        }, t.prototype.step = function(t, e) {
         return Si("step")
        }, t.prototype.fusedConv2d = function(t) {
         return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Si("fusedConv2d")
        }, t.prototype.conv2d = function(t, e, n) {
         return Si("conv2d")
        }, t.prototype.conv2dDerInput = function(t, e, n) {
         return Si("conv2dDerInput")
        }, t.prototype.conv2dDerFilter = function(t, e, n) {
         return Si("conv2dDerFilter")
        }, t.prototype.fusedDepthwiseConv2D = function(t) {
         return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Si("fusedDepthwiseConv2D")
        }, t.prototype.depthwiseConv2D = function(t, e, n) {
         return Si("depthwiseConv2D")
        }, t.prototype.depthwiseConv2DDerInput = function(t, e, n) {
         return Si("depthwiseConv2DDerInput")
        }, t.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
         return Si("depthwiseConv2DDerFilter")
        }, t.prototype.conv3d = function(t, e, n) {
         return Si("conv3d")
        }, t.prototype.conv3dDerInput = function(t, e, n) {
         return Si("conv3dDerInput")
        }, t.prototype.conv3dDerFilter = function(t, e, n) {
         return Si("conv3dDerFilter")
        }, t.prototype.maxPool = function(t, e) {
         return Si("maxPool")
        }, t.prototype.maxPoolBackprop = function(t, e, n, r) {
         return Si("maxPoolBackprop")
        }, t.prototype.avgPool = function(t, e) {
         return Si("avgPool")
        }, t.prototype.avgPoolBackprop = function(t, e, n) {
         return Si("avgPoolBackprop")
        }, t.prototype.avgPool3d = function(t, e) {
         return Si("avgPool3d")
        }, t.prototype.avgPool3dBackprop = function(t, e, n) {
         return Si("avgPool3dBackprop")
        }, t.prototype.maxPool3d = function(t, e) {
         return Si("maxPool3d")
        }, t.prototype.maxPool3dBackprop = function(t, e, n, r) {
         return Si("maxPool3dBackprop")
        }, t.prototype.reshape = function(t, e) {
         return Si("reshape")
        }, t.prototype.cast = function(t, e) {
         return Si("cast")
        }, t.prototype.tile = function(t, e) {
         return Si("tile")
        }, t.prototype.pad = function(t, e, n) {
         return Si("pad")
        }, t.prototype.transpose = function(t, e) {
         return Si("transpose")
        }, t.prototype.gather = function(t, e, n) {
         return Si("gather")
        }, t.prototype.gatherND = function(t, e) {
         return Si("gatherND")
        }, t.prototype.scatterND = function(t, e, n) {
         return Si("scatterND")
        }, t.prototype.batchToSpaceND = function(t, e, n) {
         return Si("batchToSpaceND")
        }, t.prototype.spaceToBatchND = function(t, e, n) {
         return Si("spaceToBatchND")
        }, t.prototype.resizeBilinear = function(t, e, n, r) {
         return Si("resizeBilinear")
        }, t.prototype.resizeBilinearBackprop = function(t, e, n) {
         return Si("resizeBilinearBackprop")
        }, t.prototype.resizeNearestNeighbor = function(t, e, n, r) {
         return Si("resizeNearestNeighbor")
        }, t.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
         return Si("resizeNearestNeighborBackprop")
        }, t.prototype.batchNormalization = function(t, e, n, r, i, o) {
         return Si("batchNormalization")
        }, t.prototype.localResponseNormalization4D = function(t, e, n, r, i) {
         return Si("localResponseNormalization4D")
        }, t.prototype.LRNGrad = function(t, e, n, r, i, o, a) {
         return Si("LRNGrad")
        }, t.prototype.multinomial = function(t, e, n, r) {
         return Si("multinomial")
        }, t.prototype.oneHot = function(t, e, n, r) {
         return Si("oneHot")
        }, t.prototype.cumsum = function(t, e, n, r) {
         return Si("cumsum")
        }, t.prototype.nonMaxSuppression = function(t, e, n, r, i) {
         return Si("nonMaxSuppression")
        }, t.prototype.fft = function(t) {
         return Si("fft")
        }, t.prototype.ifft = function(t) {
         return Si("ifft")
        }, t.prototype.complex = function(t, e) {
         return Si("complex")
        }, t.prototype.real = function(t) {
         return Si("real")
        }, t.prototype.imag = function(t) {
         return Si("imag")
        }, t.prototype.cropAndResize = function(t, e, n, r, i, o) {
         return Si("cropAndResize")
        }, t.prototype.depthToSpace = function(t, e, n) {
         return Si("depthToSpace")
        }, t.prototype.split = function(t, e, n) {
         return Si("split")
        }, t.prototype.sparseToDense = function(t, e, n, r) {
         return Si("sparseToDense")
        }, t.prototype.diag = function(t) {
         return Si("diag")
        }, t.prototype.fill = function(t, e, n) {
         return Si("fill")
        }, t.prototype.onesLike = function(t) {
         return Si("onesLike")
        }, t.prototype.zerosLike = function(t) {
         return Si("zerosLike")
        }, t.prototype.linspace = function(t, e, n) {
         return Si("linspace")
        }, t.prototype.dispose = function() {
         return Si("dispose")
        }, t
       }();
 
      function Si(t) {
       throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?")
      }
 
      function Ei(t, e) {
       for (var n = t.length, r = [], i = 0; i < n; i++) {
        var o = n - 1 - i,
         a = t[o] || 1;
        (e[e.length - 1 - i] || 1) > 1 && 1 === a && r.unshift(o)
       }
       return r
      }
 
      function ki(t, e) {
       for (var n = [], r = 0; r < e.length; r++) {
        var i = t[t.length - r - 1],
         o = e.length - r - 1,
         a = e[o];
        (null == i || 1 === i && a > 1) && n.unshift(o)
       }
       return n
      }
 
      function Ii(t, e) {
       for (var n = [], r = Math.max(t.length, e.length), i = 0; i < r; i++) {
        var o = t[t.length - i - 1];
        null == o && (o = 1);
        var a = e[e.length - i - 1];
        if (null == a && (a = 1), 1 === o) n.unshift(a);
        else if (1 === a) n.unshift(o);
        else {
         if (o !== a) throw Error("Operands could not be broadcast together with shapes " + t + " and " + e + ".");
         n.unshift(o)
        }
       }
       return n
      }
 
      function Oi(t, e, n, r, i, o, a) {
       void 0 === a && (a = "channelsLast");
       var s, u = _i(e),
        c = u[0],
        l = u[1];
       if ("channelsLast" === a) s = [c, l, t[3], t[3]];
       else {
        if ("channelsFirst" !== a) throw new Error("Unknown dataFormat " + a);
        s = [c, l, t[1], t[1]]
       }
       return Ni(t, s, n, r, i, o, !1, a)
      }
 
      function Ai(t, e, n, r, i, o, a) {
       void 0 === a && (a = "NDHWC");
       var s, u, c = Di(e),
        l = c[0],
        h = c[1],
        p = c[2];
       if ("NDHWC" === a) u = "channelsLast", s = [l, h, p, t[4], t[4]];
       else {
        if ("NCDHW" !== a) throw new Error("Unknown dataFormat " + a);
        u = "channelsFirst", s = [l, h, p, t[1], t[1]]
       }
       return Ri(t, s, n, r, i, !1, u, o)
      }
 
      function Ni(t, e, n, r, i, o, a, s) {
       void 0 === a && (a = !1), void 0 === s && (s = "channelsLast");
       var u = [-1, -1, -1, -1],
        c = u[0],
        l = u[1],
        h = u[2],
        p = u[3];
       if ("channelsLast" === s) c = t[0], l = t[1], h = t[2], p = t[3];
       else {
        if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
        c = t[0], p = t[1], l = t[2], h = t[3]
       }
       var f, d = e[0],
        v = e[1],
        m = e[3],
        g = _i(n),
        y = g[0],
        b = g[1],
        x = _i(r),
        w = x[0],
        C = x[1],
        S = Fi(d, w),
        E = Fi(v, C),
        k = function(t, e, n, r, i, o, a, s) {
         var u, c, l;
         if ("number" == typeof t) {
          u = {
           top: t,
           bottom: t,
           left: t,
           right: t,
           type: 0 === t ? "VALID" : "NUMBER"
          };
          var h = function(t, e, n, r, i) {
           null == r && (r = Ti(t, e, n));
           var o = t[0],
            a = t[1],
            s = Mi((o - e + 2 * r) / n + 1, i);
           O(D(s), (function() {
            return "The output # of rows (" + s + ") must be an integer. Change the stride and/or zero pad parameters"
           }));
           var u = Mi((a - e + 2 * r) / n + 1, i);
           return O(D(u), (function() {
            return "The output # of columns (" + u + ") must be an integer. Change the stride and/or zero pad parameters"
           })), [s, u]
          }([e, n], o, r, t, s);
          c = h[0], l = h[1]
         } else if ("same" === t) {
          c = Math.ceil(e / r), l = Math.ceil(n / i);
          var p = Math.max(0, (c - 1) * r + o - e),
           f = Math.max(0, (l - 1) * i + a - n),
           d = Math.floor(p / 2),
           v = p - d,
           m = Math.floor(f / 2);
          u = {
           top: d,
           bottom: v,
           left: m,
           right: f - m,
           type: "SAME"
          }
         } else {
          if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
          u = {
           top: 0,
           bottom: 0,
           left: 0,
           right: 0,
           type: "VALID"
          }, c = Math.ceil((e - o + 1) / r), l = Math.ceil((n - a + 1) / i)
         }
         return {
          padInfo: u,
          outHeight: c,
          outWidth: l
         }
        }(i, l, h, y, b, S, E, o),
        I = k.padInfo,
        A = k.outHeight,
        N = k.outWidth,
        R = a ? m * p : m;
       return "channelsFirst" === s ? f = [c, R, A, N] : "channelsLast" === s && (f = [c, A, N, R]), {
        batchSize: c,
        dataFormat: s,
        inHeight: l,
        inWidth: h,
        inChannels: p,
        outHeight: A,
        outWidth: N,
        outChannels: R,
        padInfo: I,
        strideHeight: y,
        strideWidth: b,
        filterHeight: d,
        filterWidth: v,
        effectiveFilterHeight: S,
        effectiveFilterWidth: E,
        dilationHeight: w,
        dilationWidth: C,
        inShape: t,
        outShape: f,
        filterShape: e
       }
      }
 
      function Ri(t, e, n, r, i, o, a, s) {
       void 0 === o && (o = !1), void 0 === a && (a = "channelsLast");
       var u = [-1, -1, -1, -1, -1],
        c = u[0],
        l = u[1],
        h = u[2],
        p = u[3],
        f = u[4];
       if ("channelsLast" === a) c = t[0], l = t[1], h = t[2], p = t[3], f = t[4];
       else {
        if ("channelsFirst" !== a) throw new Error("Unknown dataFormat " + a);
        c = t[0], f = t[1], l = t[2], h = t[3], p = t[4]
       }
       var d, v = e[0],
        m = e[1],
        g = e[2],
        y = e[4],
        b = Di(n),
        x = b[0],
        w = b[1],
        C = b[2],
        S = Di(r),
        E = S[0],
        k = S[1],
        I = S[2],
        A = Fi(v, E),
        N = Fi(m, k),
        R = Fi(g, I),
        T = function(t, e, n, r, i, o, a, s, u, c, l) {
         var h, p, f, d;
         if ("number" == typeof t) {
          h = {
           top: t,
           bottom: t,
           left: t,
           right: t,
           front: t,
           back: t,
           type: 0 === t ? "VALID" : "NUMBER"
          };
          var v = function(t, e, n, r, i, o) {
           null == i && (i = Ti(t, e, r));
           var a = t[0],
            s = t[1],
            u = t[2],
            c = Mi((a - e + 2 * i) / r + 1, o);
           O(D(c), (function() {
            return "The output # of depths (" + c + ") must be an integer. Change the stride and/or zero pad parameters"
           }));
           var l = Mi((s - e + 2 * i) / r + 1, o);
           O(D(l), (function() {
            return "The output # of rows (" + l + ") must be an integer. Change the stride and/or zero pad parameters"
           }));
           var h = Mi((u - e + 2 * i) / r + 1, o);
           return O(D(h), (function() {
            return "The output # of columns (" + h + ") must be an integer. Change the stride and/or zero pad parameters"
           })), [c, l, h, n]
          }([e, n, r, 1], s, 1, i, t, l);
          p = v[0], f = v[1], d = v[2]
         } else if ("same" === t) {
          p = Math.ceil(e / i), f = Math.ceil(n / o), d = Math.ceil(r / a);
          var m = (p - 1) * i + s - e,
           g = (f - 1) * o + u - n,
           y = (d - 1) * a + c - r,
           b = Math.floor(m / 2),
           x = m - b,
           w = Math.floor(g / 2),
           C = g - w,
           S = Math.floor(y / 2);
          h = {
           top: w,
           bottom: C,
           left: S,
           right: y - S,
           front: b,
           back: x,
           type: "SAME"
          }
         } else {
          if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
          h = {
           top: 0,
           bottom: 0,
           left: 0,
           right: 0,
           front: 0,
           back: 0,
           type: "VALID"
          }, p = Math.ceil((e - s + 1) / i), f = Math.ceil((n - u + 1) / o), d = Math.ceil((r - c + 1) / a)
         }
         return {
          padInfo: h,
          outDepth: p,
          outHeight: f,
          outWidth: d
         }
        }(i, l, h, p, x, w, C, A, N, R, s),
        _ = T.padInfo,
        F = T.outDepth,
        M = T.outHeight,
        L = T.outWidth,
        B = o ? y * f : y;
       return "channelsFirst" === a ? d = [c, B, F, M, L] : "channelsLast" === a && (d = [c, F, M, L, B]), {
        batchSize: c,
        dataFormat: a,
        inDepth: l,
        inHeight: h,
        inWidth: p,
        inChannels: f,
        outDepth: F,
        outHeight: M,
        outWidth: L,
        outChannels: B,
        padInfo: _,
        strideDepth: x,
        strideHeight: w,
        strideWidth: C,
        filterDepth: v,
        filterHeight: m,
        filterWidth: g,
        effectiveFilterDepth: A,
        effectiveFilterHeight: N,
        effectiveFilterWidth: R,
        dilationDepth: E,
        dilationHeight: k,
        dilationWidth: I,
        inShape: t,
        outShape: d,
        filterShape: e
       }
      }
 
      function Ti(t, e, n, r) {
       void 0 === r && (r = 1);
       var i = Fi(e, r);
       return Math.floor((t[0] * (n - 1) - n + i) / 2)
      }
 
      function _i(t) {
       return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
      }
 
      function Di(t) {
       return "number" == typeof t ? [t, t, t] : t
      }
 
      function Fi(t, e) {
       return e <= 1 ? t : t + (t - 1) * (e - 1)
      }
 
      function Mi(t, e) {
       if (!e) return t;
       switch (e) {
        case "round":
         return Math.round(t);
        case "ceil":
         return Math.ceil(t);
        case "floor":
         return Math.floor(t);
        default:
         throw new Error("Unknown roundingMode " + e)
       }
      }
 
      function Li(t) {
       var e = _i(t),
        n = e[0],
        r = e[1],
        i = e[2];
       return 1 === n && 1 === r && 1 === i
      }
 
      function Bi(t, e) {
       return Li(t) || Li(e)
      }
 
      function Pi(t) {
       if ("NHWC" === t) return "channelsLast";
       if ("NCHW" === t) return "channelsFirst";
       throw new Error("Unknown dataFormat " + t)
      }
 
      function zi(t, e, n) {
       if ("complex64" === e) {
        if ("complex64" === t.dtype) return t.clone();
        var r = Gn(t.shape),
         i = t.toFloat(),
         o = n.complex(i, r);
        return r.dispose(), i.dispose(), o
       }
       if (!$(t.dtype, e)) return Wt.makeTensorFromDataId(t.dataId, t.shape, e);
       if ("complex64" === t.dtype) {
        var a = n.real(t);
        return o = a.cast(e), a.dispose(), o
       }
       if ("int32" === e) return n.int(t);
       if ("bool" === e) {
        var s = Bn(0, t.dtype);
        return o = n.notEqual(t, s), s.dispose(), o
       }
       throw new Error("Error in Cast: failed to cast " + t.dtype + " to " + e)
      }
 
      function ji(t, e) {
       return Wt.makeTensorFromDataId(t.dataId, e, t.dtype)
      }
 
      function Wi(t, e, n) {
       var r = (e - t) / (n - 1),
        i = ot(n, "float32");
       i[0] = t;
       for (var o = 1; o < i.length; o++) i[o] = i[o - 1] + r;
       return Pn(i, "float32")
      }
      var Vi = Object.freeze({
       castTensor: zi,
       reshapeTensor: ji,
       linspaceImpl: Wi,
       upcastType: _t,
       axesAreInnerMostDims: wn,
       combineLocations: Cn,
       computeOutAndReduceShapes: Sn,
       expandShapeToKeepDim: En,
       assertAxesAreInnerMostDims: kn,
       getAxesPermutation: In,
       getUndoAxesPermutation: On,
       getInnerMostAxes: An,
       getBroadcastDims: Ei,
       getReductionAxes: ki,
       assertAndGetBroadcastShape: Ii,
       assertParamsConsistent: Nn,
       computeOutShape: Rn,
       computePool2DInfo: Oi,
       computePool3DInfo: Ai,
       computeConv2DInfo: Ni,
       computeConv3DInfo: Ri,
       computeDefaultPad: Ti,
       tupleValuesAreOne: Li,
       eitherStridesOrDilationsAreOne: Bi,
       convertConv2DDataFormat: Pi,
       PARALLELIZE_THRESHOLD: Jr,
       computeOptimalWindowSize: Qr
      });
 
      function Ui(t, e) {
       if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t.length + ", imag: " + e.length + ".");
       for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];
       return n
      }
 
      function Hi(t, e) {
       return {
        real: t[2 * e],
        imag: t[2 * e + 1]
       }
      }
 
      function $i(t, e, n, r) {
       t[2 * r] = e, t[2 * r + 1] = n
      }
 
      function Gi(t, e, n) {
       var r = (n ? 2 : -2) * Math.PI * (t / e);
       return {
        real: Math.cos(r),
        imag: Math.sin(r)
       }
      }
 
      function qi(t, e, n) {
       var r = function(t, e, n) {
         return function(t, e, n) {
          for (var r = 0, i = t.length, o = 0, a = !1; r < i;) {
           var s = n(e, t[o = r + (i - r >>> 1)]);
           s > 0 ? r = o + 1 : (i = o, a = !s)
          }
          return a ? r : -r - 1
         }(t, e, n || Ki)
        }(t, e, n),
        i = r < 0 ? -(r + 1) : r;
       t.splice(i, 0, e)
      }
 
      function Ki(t, e) {
       return t > e ? 1 : t < e ? -1 : 0
      }
 
      function Xi(t, e, n, r, i) {
       return Zi(t, e, n, r, i, 0).selectedIndices
      }
 
      function Yi(t, e, n, r, i, o) {
       var a = Zi(t, e, n, r, i, o, !0);
       return a.numValidOutputs.dispose(), {
        selectedIndices: a.selectedIndices,
        selectedScores: a.selectedScores
       }
      }
 
      function Zi(t, e, n, r, i, o, a, s) {
       void 0 === a && (a = !1), void 0 === s && (s = !1);
       for (var u = Array.from(e).map((function(t, e) {
         return {
          score: t,
          boxIndex: e,
          suppressBeginIndex: 0
         }
        })).filter((function(t) {
         return t.score > i
        })).sort(to), c = o > 0 ? -.5 / o : 0, l = [], h = []; l.length < n && u.length > 0;) {
        var p = u.pop(),
         f = p.score,
         d = p.boxIndex,
         v = p.suppressBeginIndex;
        if (f < i) break;
        for (var m = !1, g = l.length - 1; g >= v; --g) {
         var y = Ji(t, d, l[g]);
         if (y >= r) {
          m = !0;
          break
         }
         if (p.score = p.score * Qi(r, c, y), p.score <= i) break
        }
        p.suppressBeginIndex = l.length, m || (p.score === f ? (l.push(d), h.push(p.score)) : p.score > i && qi(u, p, to))
       }
       var b = l.length;
       return s && (l.fill(0, b), h.fill(0, b)), {
        selectedIndices: Pn(l, "int32"),
        selectedScores: Pn(h, "float32"),
        numValidOutputs: Bn(b, "int32")
       }
      }
 
      function Ji(t, e, n) {
       var r = t.subarray(4 * e, 4 * e + 4),
        i = t.subarray(4 * n, 4 * n + 4),
        o = Math.min(r[0], r[2]),
        a = Math.min(r[1], r[3]),
        s = Math.max(r[0], r[2]),
        u = Math.max(r[1], r[3]),
        c = Math.min(i[0], i[2]),
        l = Math.min(i[1], i[3]),
        h = Math.max(i[0], i[2]),
        p = Math.max(i[1], i[3]),
        f = (s - o) * (u - a),
        d = (h - c) * (p - l);
       if (f <= 0 || d <= 0) return 0;
       var v = Math.max(o, c),
        m = Math.max(a, l),
        g = Math.min(s, h),
        y = Math.min(u, p),
        b = Math.max(g - v, 0) * Math.max(y - m, 0);
       return b / (f + d - b)
      }
 
      function Qi(t, e, n) {
       var r = Math.exp(e * n * n);
       return n <= t ? r : 0
      }
 
      function to(t, e) {
       return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex
      }
 
      function eo(t, e, n) {
       var r = new Array(t.rank).fill(0),
        i = t.shape.slice();
       return e.map((function(e) {
        i[n] = e;
        var o = t.slice(r, i);
        return r[n] += e, o
       }))
      }
 
      function no(t, e) {
       for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];
       var i = mr(n, t.dtype);
       for (r = 0; r < i.values.length; ++r) {
        for (var o = i.indexToLoc(r), a = new Array(t.rank), s = 0; s < a.length; s++) a[s] = o[s] % t.shape[s];
        var u = t.locToIndex(a);
        i.values[r] = t.values[u]
       }
       return i.toTensor()
      }
 
      function ro(t, e, n, r, i) {
       for (var o = e[e.length - 1], a = [t.length / o, o], s = a[0], u = a[1], c = W(n, s * r), l = W("int32", s * r), h = 0; h < s; h++) {
        for (var p = h * u, f = t.subarray(p, p + u), d = [], v = 0; v < f.length; v++) d.push({
         value: f[v],
         index: v
        });
        d.sort((function(t, e) {
         return e.value - t.value
        }));
        var m = h * r,
         g = c.subarray(m, m + r),
         y = l.subarray(m, m + r);
        for (v = 0; v < r; v++) g[v] = d[v].value, y[v] = d[v].index
       }
       var b = e.slice();
       return b[b.length - 1] = r, [Mn(c, b, n), Mn(l, b, "int32")]
      }
 
      function io(t, e) {
       for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);
       var i = mr(t, "int32"),
        o = mr([n.length, t.length], "int32");
       for (r = 0; r < n.length; r++) {
        var a = i.indexToLoc(n[r]),
         s = r * t.length;
        o.values.set(a, s)
       }
       return o.toTensor()
      }
      var oo = function(t, e) {
        this.outputShape = [], this.outputShape = t, this.variableNames = e.map((function(t, e) {
         return "T" + e
        }));
        var n = [];
        this.variableNames.forEach((function(t) {
         n.push("float v" + t + " = get" + t + "AtOutCoords();")
        }));
        var r = this.variableNames.map((function(t) {
         return "v" + t
        })).join(" + ");
        this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    "
       },
       ao = function(t, e) {
        this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map((function(t, e) {
         return "T" + e
        }));
        var n = [];
        this.variableNames.forEach((function(t) {
         n.push("vec4 v" + t + " = get" + t + "AtOutCoords();")
        }));
        var r = this.variableNames.map((function(t) {
         return "v" + t
        })).join(" + ");
        this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    "
       },
       so = function(t, e, n) {
        this.variableNames = ["A"];
        var r = t.windowSize,
         i = t.batchSize,
         o = t.inSize,
         a = Math.ceil(o / r);
        n || this.variableNames.push("bestIndicesA"), this.outputShape = [i, a];
        var s = "max" === e ? ">" : "<",
         u = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + u + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "
       };
 
      function uo(t, e) {
       return ["x", "y", "z", "w", "u", "v"].slice(0, e).map((function(e) {
        return t + "." + e
       }))
      }
 
      function co(t, e) {
       return 1 === e ? [t] : uo(t, e)
      }
 
      function lo() {
       var t, e, n, r, i, o, a, s, u, c;
       return 2 === h().getNumber("WEBGL_VERSION") ? (t = "#version 300 es", e = "in", n = "out", r = "in", i = "texture", o = "outputColor", a = "out vec4 outputColor;", s = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", u = "", c = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t = "", e = "attribute", n = "varying", r = "varying", i = "texture2D", o = "gl_FragColor", a = "", s = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", u = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", c = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
        version: t,
        attribute: e,
        varyingVs: n,
        varyingFs: r,
        texture2D: i,
        output: o,
        defineOutput: a,
        defineSpecialNaN: s,
        defineSpecialInf: u,
        defineRound: c
       }
      }
 
      function ho(t, e, n) {
       void 0 === n && (n = "index");
       var r = et(e);
       return r.map((function(e, i) {
        return "int " + t[i] + " = " + n + " / " + e + "; " + (i === r.length - 1 ? "int " + t[i + 1] + " = " + n + " - " + t[i] + " * " + e : "index -= " + t[i] + " * " + e) + ";"
       })).join("")
      }
 
      function po(t) {
       var e = et(t).map((function(t) {
        return t.toString()
       }));
       return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e[0] + " + coords.y * " + e[1] + " + coords.z;\n  }\n"
      }
      var fo = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
 
      function vo(t, e, n, r) {
       var i = [];
       t.forEach((function(t) {
        var e = T(t.shapeInfo.logicalShape);
        t.shapeInfo.isUniform ? i.push("uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";") : (i.push("uniform sampler2D " + t.name + ";"), i.push("uniform int offset" + t.name + ";"))
       }));
       var o, a, s = i.join("\n"),
        u = t.map((function(t) {
         return function(t, e, n) {
          void 0 === n && (n = !1);
          var r = "";
          r += n ? go(t) : mo(t);
          var i = t.shapeInfo.logicalShape,
           o = e.logicalShape;
          return i.length <= o.length && (r += n ? function(t, e) {
           var n, r = t.name,
            i = r.charAt(0).toUpperCase() + r.slice(1),
            o = "get" + i + "AtOutCoords",
            a = t.shapeInfo.logicalShape.length,
            s = e.logicalShape.length,
            u = Ei(t.shapeInfo.logicalShape, e.logicalShape),
            c = Eo(s),
            l = s - a,
            h = ["x", "y", "z", "w", "u", "v"];
           n = 0 === a ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map((function(t) {
            return "coords." + h[t + l] + " = 0;"
           })).join("\n");
           var p = "";
           p = s < 2 && a > 0 ? "coords" : t.shapeInfo.logicalShape.map((function(t, e) {
            return "coords." + h[e + l]
           })).join(", ");
           var f = "return outputValue;",
            d = 1 === T(t.shapeInfo.logicalShape),
            v = 1 === T(e.logicalShape);
           if (1 !== a || d || v) {
            if (d && !v) f = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
            else if (u.length) {
             var m = a - 2,
              g = a - 1;
             u.indexOf(m) > -1 && u.indexOf(g) > -1 ? f = "return vec4(outputValue.x);" : u.indexOf(m) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(g) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);")
            }
           } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
           return "\n    vec4 " + o + "() {\n      " + c + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + i + "(" + p + ");\n      " + f + "\n    }\n  "
          }(t, e) : function(t, e) {
           var n = t.name,
            r = n.charAt(0).toUpperCase() + n.slice(1),
            i = "get" + r + "AtOutCoords",
            o = e.texShape,
            a = t.shapeInfo.texShape,
            s = t.shapeInfo.logicalShape.length,
            u = e.logicalShape.length;
           if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && _(a, o)) return "\n      float " + i + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
           var c, l = Eo(u),
            h = Ei(t.shapeInfo.logicalShape, e.logicalShape),
            p = u - s,
            f = ["x", "y", "z", "w", "u", "v"];
           c = 0 === s ? "" : u < 2 && h.length >= 1 ? "coords = 0;" : h.map((function(t) {
            return "coords." + f[t + p] + " = 0;"
           })).join("\n");
           var d = "";
           return d = u < 2 && s > 0 ? "coords" : t.shapeInfo.logicalShape.map((function(t, e) {
            return "coords." + f[e + p]
           })).join(", "), "\n    float " + i + "() {\n      " + l + " coords = getOutputCoords();\n      " + c + "\n      return get" + r + "(" + d + ");\n    }\n  "
          }(t, e)), r
         }(t, e, r)
        })).join("\n"),
        c = e.texShape,
        l = lo(),
        h = function(t) {
         return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t.texture2D + "(textureSampler, uv).r;\n    }\n  "
        }(l),
        p = function(t) {
         return t.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t.varyingFs + " vec2 resultUV;\n    " + t.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t.defineSpecialNaN + "\n    " + t.defineSpecialInf + "\n    " + t.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + yo + "\n    " + bo + "\n    " + xo + "\n  "
        }(l);
       return e.isPacked ? (o = function(t, e) {
        switch (t.length) {
         case 0:
          return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
         case 1:
          return function(t, e) {
           var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
           return 1 === n[0] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    " : 1 === n[1] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  "
          }(0, e);
         case 2:
          return function(t, e) {
           var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
           if (_(t, e)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
           var r = Math.ceil(t[1] / 2);
           return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  "
          }(t, e);
         case 3:
          return n = t, r = e, i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], o = Math.ceil(n[2] / 2), a = o * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + i[0] + ", " + i[1] + "));\n      int index = resTexRC.x * " + i[1] + " + resTexRC.y;\n\n      int b = index / " + a + ";\n      index -= b * " + a + ";\n\n      int r = 2 * (index / " + o + ");\n      int c = imod(index, " + o + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
         default:
          return function(t, e) {
           for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), i = r * Math.ceil(t[t.length - 2] / 2), o = i, a = "", s = "b, r, c", u = 2; u < t.length - 1; u++) o *= t[t.length - u - 1], a = "\n      int b" + u + " = index / " + o + ";\n      index -= b" + u + " * " + o + ";\n    " + a, s = "b" + u + ", " + s;
           return "\n    ivec" + t.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + a + "\n\n      int b = index / " + i + ";\n      index -= b * " + i + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + t.length + "(" + s + ");\n    }\n  "
          }(t, e)
        }
        var n, r, i, o, a
       }(e.logicalShape, c), a = function(t) {
        return "\n    void setOutput(vec4 val) {\n      " + t.output + " = val;\n    }\n  "
       }(l)) : (o = function(t, e) {
        switch (t.length) {
         case 0:
          return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
         case 1:
          return function(t, e) {
           return 1 === e[0] ? "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e[1] + ".0);\n      }\n    " : 1 === e[1] ? "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      return resTexRC.x * " + e[1] + " + resTexRC.y;\n    }\n  "
          }(0, e);
         case 2:
          return function(t, e) {
           return _(t, e) ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e[0] + ", " + e[1] + "));\n      }\n    " : 1 === t[1] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : 1 === t[0] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      int r = index / " + t[1] + ";\n      int c = index - r * " + t[1] + ";\n      return ivec2(r, c);\n    }\n  "
          }(t, e);
         case 3:
          return n = e, r = ho(["r", "c", "d"], t), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";
         case 4:
          return function(t, e) {
           var n = ho(["r", "c", "d", "d2"], t);
           return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  "
          }(t, e);
         case 5:
          return function(t, e) {
           var n = ho(["r", "c", "d", "d2", "d3"], t);
           return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e[0] + ",\n                             " + e[1] + "));\n\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "
          }(t, e);
         case 6:
          return function(t, e) {
           var n = ho(["r", "c", "d", "d2", "d3", "d4"], t);
           return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "
          }(t, e);
         default:
          throw new Error(t.length + "-D output sampling is not yet supported")
        }
        var n, r
       }(e.logicalShape, c), a = function(t) {
        return "\n    void setOutput(float val) {\n      " + t.output + " = vec4(val, 0, 0, 0);\n    }\n  "
       }(l)), r && (p += wo), [p, h, a, s, o, u, n].join("\n")
      }
 
      function mo(t) {
       var e = t.shapeInfo.logicalShape;
       switch (e.length) {
        case 0:
         return function(t) {
          var e = t.name,
           n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
          if (t.shapeInfo.isUniform) return "float " + n + "() {return " + e + ";}";
          var r = t.shapeInfo.texShape,
           i = r[0],
           o = r[1];
          if (1 === i && 1 === o) return "\n      float " + n + "() {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
          var a = t.shapeInfo.texShape,
           s = a[0],
           u = a[1],
           c = Co(e);
          return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + s + ", " + u + ", " + c + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  "
         }(t);
        case 1:
         return function(t) {
          var e = t.name,
           n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
          if (t.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + So(t) + "\n      }\n    ";
          var r = t.shapeInfo.texShape,
           i = r[0],
           o = r[1];
          if (1 === o && 1 === i) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
          var a = Co(e);
          return 1 === o ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + a + ") + 0.5) / " + i + ".0);\n        return sampleTexture(" + e + ", uv);\n      }\n    " : 1 === i ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + a + ") + 0.5) / " + o + ".0, 0.5);\n        return sampleTexture(" + e + ", uv);\n      }\n    " : "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + i + ", " + o + ", index + " + a + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  "
         }(t);
        case 2:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = t.shapeInfo.texShape;
          if (null != i && _(e, i)) {
           var o = i[0],
            a = i[1];
           return "\n    float " + r + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  "
          }
          var s = j(e),
           u = s.newShape,
           c = s.keptDims,
           l = u;
          if (l.length < e.length) {
           var h = ko(t, l);
           return "\n      " + mo(h) + "\n      float " + r + "(int row, int col) {\n        return " + r + "(" + Io(["row", "col"], c) + ");\n      }\n    "
          }
          if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e[1] + ", 1)));\n        " + So(t) + "\n      }\n    ";
          var p = i[0],
           f = i[1],
           d = Co(n);
          return 1 === f ? "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + p + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  " : 1 === p ? "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + f + ".0, 0.5);\n      return sampleTexture(" + n + ", uv);\n    }\n  " : "\n  float " + r + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e[1] + " + col + " + d + ";\n    vec2 uv = uvFromFlat(" + p + ", " + f + ", index);\n    return sampleTexture(" + n + ", uv);\n  }\n"
         }(t);
        case 3:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = e[1] * e[2],
           o = e[2],
           a = j(e),
           s = a.newShape,
           u = a.keptDims,
           c = s;
          if (c.length < e.length) {
           var l = ko(t, c);
           return "\n        " + mo(l) + "\n        float " + r + "(int row, int col, int depth) {\n          return " + r + "(" + Io(["row", "col", "depth"], u) + ");\n        }\n      "
          }
          if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + i + ", " + o + ", 1)));\n        " + So(t) + "\n      }\n    ";
          var h = t.shapeInfo.texShape,
           p = h[0],
           f = h[1],
           d = t.shapeInfo.flatOffset;
          if (f === i && null == d) return "\n        float " + r + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + o + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + f + ".0, " + p + ".0);\n          return sampleTexture(" + n + ", uv);\n        }\n      ";
          if (f === o && null == d) return "\n    float " + r + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + f + ".0, " + p + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
          var v = Co(n);
          return "\n      float " + r + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + i + " + col * " + o + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + p + ", " + f + ", index);\n        return sampleTexture(" + n + ", uv);\n      }\n  "
         }(t);
        case 4:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = e[3],
           o = e[2] * i,
           a = e[1] * o,
           s = j(e),
           u = s.newShape,
           c = s.keptDims;
          if (u.length < e.length) {
           var l = ko(t, u);
           return "\n      " + mo(l) + "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        return " + r + "(" + Io(["row", "col", "depth", "depth2"], c) + ");\n      }\n    "
          }
          if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + a + ", " + o + ", " + i + ", 1)));\n        " + So(t) + "\n      }\n    ";
          var h = t.shapeInfo.flatOffset,
           p = t.shapeInfo.texShape,
           f = p[0],
           d = p[1];
          if (d === a && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + d + ".0, " + f + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
          if (d === i && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e[1] * e[2] + ", " + e[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + d + ".0, " + f + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
          var v = Co(n);
          return "\n    float " + r + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + a + " + col * " + o + " +\n          depth * " + i + " + depth2;\n      vec2 uv = uvFromFlat(" + f + ", " + d + ", index + " + v + ");\n      return sampleTexture(" + n + ", uv);\n    }\n  "
         }(t);
        case 5:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = e[4],
           o = e[3] * i,
           a = e[2] * o,
           s = e[1] * a,
           u = j(e),
           c = u.newShape,
           l = u.keptDims;
          if (c.length < e.length) {
           var h = ko(t, c);
           return "\n      " + mo(h) + "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r + "(" + Io(["row", "col", "depth", "depth2", "depth3"], l) + ");\n      }\n    "
          }
          if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s + ", " + a + ", " + o + ", " + i + ")) +\n          depth3;\n        " + So(t) + "\n      }\n    ";
          var p = t.shapeInfo.flatOffset,
           f = t.shapeInfo.texShape,
           d = f[0],
           v = f[1];
          if (v === s && null == p) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + a + ", " + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
          if (v === i && null == p) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] + ",\n               " + e[2] * e[3] + ", " + e[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
          var m = Co(n);
          return "\n    float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s + " + col * " + a + " + depth * " + o + " +\n          depth2 * " + i + " + depth3 + " + m + ";\n      vec2 uv = uvFromFlat(" + d + ", " + v + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  "
         }(t);
        case 6:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = j(e),
           o = i.newShape,
           a = i.keptDims;
          if (o.length < e.length) {
           var s = ko(t, o);
           return "\n      " + mo(s) + "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r + "(" + Io(["row", "col", "depth", "depth2", "depth3", "depth4"], a) + ");\n      }\n    "
          }
          var u = e[5],
           c = e[4] * u,
           l = e[3] * c,
           h = e[2] * l,
           p = e[1] * h;
          if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + p + ", " + h + ", " + l + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u + ", 1)));\n        " + So(t) + "\n      }\n    ";
          var f = t.shapeInfo.flatOffset,
           d = t.shapeInfo.texShape,
           v = d[0],
           m = d[1];
          if (m === p && null == f) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + l + ", " + c + ", " + u + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
          if (m === u && null == f) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] * e[4] + ",\n               " + e[2] * e[3] * e[4] + ",\n               " + e[3] * e[4] + ",\n               " + e[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
          var g = Co(n);
          return "\n    float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + p + " + col * " + h + " + depth * " + l + " +\n          depth2 * " + c + " + depth3 * " + u + " + depth4 + " + g + ";\n      vec2 uv = uvFromFlat(" + v + ", " + m + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  "
         }(t);
        default:
         throw new Error(e.length + "-D input sampling is not yet supported")
       }
      }
 
      function go(t) {
       var e, n, r;
       switch (t.shapeInfo.logicalShape.length) {
        case 0:
         return e = t.name, n = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = lo(), "\n    vec4 " + n + "() {\n      return " + r.texture2D + "(" + e + ", halfCR);\n    }\n  ";
        case 1:
         return function(t) {
          var e = t.name,
           n = "get" + e.charAt(0).toUpperCase() + e.slice(1),
           r = t.shapeInfo.texShape,
           i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
           o = lo();
          return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + i[0] + ", " + i[1] + ", index);\n      return " + o.texture2D + "(" + e + ", uv);\n    }\n  "
         }(t);
        case 2:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = t.shapeInfo.texShape,
           o = i[0],
           a = i[1],
           s = lo();
          if (null != i && _(e, i)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n\n        return " + s.texture2D + "(" + n + ", uv);\n      }\n    ";
          var u = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)],
           c = Math.ceil(e[1] / 2);
          return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c + ", " + u[0] + ", " + u[1] + ", row, col);\n      return " + s.texture2D + "(" + n + ", uv);\n    }\n  "
         }(t);
        case 3:
         return function(t) {
          var e = t.shapeInfo.logicalShape,
           n = t.name,
           r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
           i = t.shapeInfo.texShape,
           o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
          if (1 === e[0]) {
           var a = e.slice(1),
            s = ko(t, a);
           return "\n        " + go(s) + "\n        vec4 " + r + "(int b, int row, int col) {\n          return " + r + "(" + Io(["b", "row", "col"], [1, 2]) + ");\n        }\n      "
          }
          var u = o[0],
           c = o[1],
           l = Math.ceil(e[2] / 2),
           h = l * Math.ceil(e[1] / 2),
           p = lo();
          return "\n    vec4 " + r + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u + ", " + c + ", " + h + ", " + l + ", b, row, col);\n      return " + p.texture2D + "(" + n + ", uv);\n    }\n  "
         }(t);
        default:
         return function(t) {
          for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), o = t.shapeInfo.texShape, a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)], s = a[0], u = a[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = "int b, int row, int col", p = "b * " + l + " + (row / 2) * " + c + " + (col / 2)", f = 2; f < n - 1; f++) h = "int b" + f + ", " + h, l *= e[n - f - 1], p = "b" + f + " * " + l + " + " + p;
          var d = lo();
          return "\n    vec4 " + i + "(" + h + ") {\n      int index = " + p + ";\n      int texR = index / " + u + ";\n      int texC = index - texR * " + u + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u + ", " + s + ");\n      return " + d.texture2D + "(" + r + ", uv);\n    }\n  "
         }(t)
       }
      }
      var yo = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
       bo = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
       xo = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
       wo = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
 
      function Co(t) {
       return "offset" + t
      }
 
      function So(t) {
       var e = t.name,
        n = T(t.shapeInfo.logicalShape);
       return n < 2 ? "return " + e + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + e + "[i];\n      }\n    }\n  "
      }
 
      function Eo(t) {
       if (t <= 1) return "int";
       if (2 === t) return "ivec2";
       if (3 === t) return "ivec3";
       if (4 === t) return "ivec4";
       if (5 === t) return "ivec5";
       if (6 === t) return "ivec6";
       throw Error("GPU for rank " + t + " is not yet supported")
      }
 
      function ko(t, e) {
       var n = JSON.parse(JSON.stringify(t));
       return n.shapeInfo.logicalShape = e, n
      }
 
      function Io(t, e) {
       return e.map((function(e) {
        return t[e]
       })).join(", ")
      }
      var Oo = function(t, e, n, r) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, O(t.length > 2, (function() {
         return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2."
        }));
        var i = t[t.length - 1],
         o = Math.ceil(i / e);
        this.outputShape = t.slice(0, -1), o > 1 && this.outputShape.push(o), r || this.variableNames.push("bestIndicesA");
        var a, s, u = this.outputShape,
         c = u.length,
         l = Eo(c),
         h = co("coords", c);
        if (1 === o) {
         var p = Eo(s = c + 1);
         a = "\n        " + p + " sourceLocR = " + p + "(" + h.join() + ", 0);\n        ++" + h[c - 1] + ";\n        " + p + " sourceLocG = " + p + "(" + h.join() + ", 0);\n        ++" + h[c - 2] + ";\n        " + p + " sourceLocA = " + p + "(" + h.join() + ", 0);\n        --" + h[c - 1] + ";\n        " + p + " sourceLocB = " + p + "(" + h.join() + ", 0);\n        --" + h[c - 2] + ";"
        } else s = c, a = "\n        " + l + " sourceLocR = coords;\n        ++" + h[c - 1] + ";\n        " + l + " sourceLocG = coords;\n        ++" + h[c - 2] + ";\n        " + l + " sourceLocA = coords;\n        --" + h[c - 1] + ";\n        " + l + " sourceLocB = coords;\n        --" + h[c - 2] + ";";
        var f = ["x", "y", "z", "w", "u", "v"].slice(0, s),
         d = "." + f[s - 1],
         v = f.map((function(t) {
          return "int " + t
         })),
         m = co("sourceLocR", s - 1).concat("inIdx.r"),
         g = co("sourceLocG", s - 1).concat("inIdx.g"),
         y = co("sourceLocB", s - 1).concat("inIdx.b"),
         b = co("sourceLocA", s - 1).concat("inIdx.a"),
         x = "max" === n ? "greaterThan" : "lessThan",
         w = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m.join() + "),\n                             getBestIndicesAChannel(" + g.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + b.join() + ")));",
         C = "vec4(\n            getAChannel(" + m.join() + "),\n            hasNextCol ? getAChannel(" + g.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b.join() + ") : 0.)",
         S = r ? "" : "\n      float getBestIndicesAChannel(" + v.join() + ") {\n        return getChannel(getBestIndicesA(" + f.join() + "),\n                                          vec2(" + f.slice(-2).join() + "));\n      }";
        this.userCode = "\n      float getAChannel(" + v.join() + ") {\n        return getChannel(getA(" + f.join() + "),\n                               vec2(" + f.slice(-2).join() + "));\n      }\n      " + S + "\n      void main() {\n        " + l + " coords = getOutputCoords();\n        bool hasNextCol = " + h[c - 1] + " < " + (u[c - 1] - 1) + ";\n        bool hasNextRow = " + h[c - 2] + " < " + (u[c - 2] - 1) + ";\n        " + a + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d + ", sourceLocG" + d + ",\n          sourceLocB" + d + ", sourceLocA" + d + ") * " + e + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + C + ";\n\n        for (int i = 0; i < " + e + "; i++) {\n          inIdx = srcIdx;\n          " + w + "\n          vec4 candidate = " + C + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + x + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "
       },
       Ao = function(t) {
        this.variableNames = ["dy"], this.outputShape = t.inShape;
        var e = t.filterHeight,
         n = t.filterWidth,
         r = t.strideHeight,
         i = t.strideWidth,
         o = t.dilationHeight,
         a = t.dilationWidth,
         s = t.effectiveFilterHeight,
         u = t.effectiveFilterWidth,
         c = s - 1 - t.padInfo.top,
         l = u - 1 - t.padInfo.left,
         h = 1 / (e * n);
        this.userCode = "\n      const ivec2 pads = ivec2(" + c + ", " + l + ");\n      const float avgMultiplier = float(" + h + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s + ";\n            wR += " + o + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u + ";\n            wC+= " + a + ") {\n            float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       No = function(t) {
        this.variableNames = ["dy"], this.outputShape = t.inShape;
        var e = t.filterDepth,
         n = t.filterHeight,
         r = t.filterWidth,
         i = t.strideDepth,
         o = t.strideHeight,
         a = t.strideWidth,
         s = t.dilationDepth,
         u = t.dilationHeight,
         c = t.dilationWidth,
         l = t.effectiveFilterDepth,
         h = t.effectiveFilterHeight,
         p = t.effectiveFilterWidth,
         f = l - 1 - t.padInfo.front,
         d = h - 1 - t.padInfo.top,
         v = p - 1 - t.padInfo.left,
         m = 1 / (e * n * r);
        this.userCode = "\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + v + ");\n      const float avgMultiplier = float(" + m + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          float dyD = float(dyDCorner + wD) / " + i + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h + ";\n              wR += " + u + ") {\n            float dyR = float(dyRCorner + wR) / " + o + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + p + ";\n                wC += " + c + ") {\n              float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Ro = function(t, e, n, r, i, o) {
        this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Ii(t, e), Ii(t, n);
        var a = "0.0";
        null != r && (Ii(t, r), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
        var s = "1.0";
        null != i && (Ii(t, i), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + a + ";\n        float scale = " + s + ";\n        float inv = scale * inversesqrt(variance + float(" + o + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "
       },
       To = function(t, e, n, r, i, o) {
        this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], Ii(t, e), Ii(t, n);
        var a = "vec4(0.0)";
        null != r && (Ii(t, r), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
        var s = "vec4(1.0)";
        null != i && (Ii(t, i), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = " + a + ";\n        vec4 scale = " + s + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + o + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "
       },
       _o = "return areal * breal - aimag * bimag;",
       Do = "return areal * bimag + aimag * breal;",
       Fo = function(t, e, n) {
        this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Ii(e, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "
       },
       Mo = "return a + b;",
       Lo = "return a - b;",
       Bo = "return a * b;",
       Po = "return (a < 0.) ? b * a : a;",
       zo = function(t, e, n) {
        this.variableNames = ["A", "B"], this.outputShape = Ii(e, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "
       },
       jo = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
       Wo = function(t, e, n, r) {
        void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Ii(e, n);
        var i = this.outputShape.length,
         o = "";
        if (r)
         if (0 === i || 1 === T(this.outputShape)) o = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
         else if (o = "\n          " + Eo(i) + " coords = getOutputCoords();\n        ", 1 === i) o += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
        else {
         var a = co("coords", i);
         o += "\n            bool nextRowOutOfBounds =\n              (" + a[i - 2] + " + 1) >= " + this.outputShape[i - 2] + ";\n            bool nextColOutOfBounds =\n              (" + a[i - 1] + " + 1) >= " + this.outputShape[i - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "
        }
        this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + o + "\n\n        setOutput(result);\n      }\n    "
       },
       Vo = function() {
        function t(t) {
         this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
        }
        return t.prototype.getCustomSetupFunc = function(t, e) {
         var n = this;
         return function(r, i) {
          null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(i, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(i, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e)
         }
        }, t
       }(),
       Uo = function() {
        function t(t) {
         this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
        }
        return t.prototype.getCustomSetupFunc = function(t, e) {
         var n = this;
         return function(r, i) {
          null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(i, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(i, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e)
         }
        }, t
       }(),
       Ho = function(t) {
        this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
       },
       $o = function(t) {
        this.outputShape = [], this.outputShape = Rn(t, 1), this.variableNames = t.map((function(t, e) {
         return "T" + e
        }));
        var e = new Array(t.length - 1);
        e[0] = t[0][1];
        for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];
        var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];
        for (n = 1; n < e.length; n++) {
         var i = e[n - 1];
         r.push("else if (yC < " + e[n] + ") setOutput(getT" + n + "(yR, yC-" + i + "));")
        }
        var o = e.length,
         a = e[e.length - 1];
        r.push("else setOutput(getT" + o + "(yR, yC-" + a + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    "
       },
       Go = function(t, e) {
        this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Rn(t, e);
        var n = this.outputShape,
         r = n.length,
         i = Eo(r),
         o = co("coords", r),
         a = ["x", "y", "z", "w", "u", "v"].slice(0, r);
        this.variableNames = t.map((function(t, e) {
         return "T" + e
        }));
        var s = new Array(t.length - 1);
        s[0] = t[0][e];
        for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];
        var c = a[e],
         l = a.slice(-2),
         h = a.join(),
         p = "if (" + c + " < " + s[0] + ") {\n        return getChannel(\n            getT0(" + h + "), vec2(" + l.join() + "));\n        }";
        for (u = 1; u < s.length; u++) {
         var f = s[u - 1];
         p += "\n        if (" + c + " < " + s[u] + "  && " + c + " >= " + s[u - 1] + ") {\n          return getChannel(\n            getT" + u + "(" + qo(a, c, f) + "),\n            vec2(" + qo(l, c, f) + "));\n        }"
        }
        var d = s.length,
         v = s[s.length - 1];
        p += "\n        return getChannel(\n          getT" + d + "(" + qo(a, c, v) + "),\n          vec2(" + qo(l, c, v) + "));", this.userCode = "\n      float getValue(" + a.map((function(t) {
         return "int " + t
        })) + ") {\n        " + p + "\n      }\n\n      void main() {\n        " + i + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + o + "), 0., 0., 0.);\n\n        " + o[r - 1] + " = " + o[r - 1] + " + 1;\n        if (" + o[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + o + ");\n        }\n\n        " + o[r - 2] + " = " + o[r - 2] + " + 1;\n        if (" + o[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + o + ");\n        }\n\n        " + o[r - 1] + " = " + o[r - 1] + " - 1;\n        if (" + o[r - 2] + " < " + n[r - 2] + " &&\n            " + o[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + o + ");\n        }\n        setOutput(result);\n      }\n    "
       };
 
      function qo(t, e, n) {
       var r = t.indexOf(e);
       return t.map((function(t, e) {
        return e === r ? t + " - " + n : t
       })).join()
      }
      var Ko = function(t) {
        this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
        var e = t.strideHeight,
         n = t.strideWidth,
         r = t.padInfo.top,
         i = t.padInfo.left,
         o = "channelsLast" === t.dataFormat;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + i + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              if (" + o + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Xo = function(t) {
        this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
        var e = t.filterHeight,
         n = t.filterWidth,
         r = t.strideHeight,
         i = t.strideWidth,
         o = "channelsLast" === t.dataFormat,
         a = e - 1 - t.padInfo.top,
         s = n - 1 - t.padInfo.left,
         u = o ? 1 : 2,
         c = o ? 2 : 3,
         l = o ? 3 : 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u + "], coords[" + c + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n\n              if (" + o + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Yo = function(t) {
        this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
        var e = t.strideDepth,
         n = t.strideHeight,
         r = t.strideWidth,
         i = t.padInfo.front,
         o = t.padInfo.top,
         a = t.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t.outDepth + "; yF++) {\n            int xF = wF + yF * " + e + " - " + i + ";\n\n            if (xF < 0 || xF >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + o + ";\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + a + ";\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Zo = function(t) {
        this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
        var e = t.filterDepth,
         n = t.filterHeight,
         r = t.filterWidth,
         i = t.strideDepth,
         o = t.strideHeight,
         a = t.strideWidth,
         s = e - 1 - t.padInfo.front,
         u = n - 1 - t.padInfo.top,
         c = r - 1 - t.padInfo.left;
        this.userCode = "\n      const ivec3 pads = ivec3(" + s + ", " + u + ", " + c + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + i + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + o + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Jo = function(t) {
        this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
        var e = t.strideHeight,
         n = t.strideWidth,
         r = t.padInfo.top,
         i = t.padInfo.left,
         o = t.outChannels / t.inChannels;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + o + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + i + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Qo = function(t) {
        this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
        var e = t.filterHeight,
         n = t.filterWidth,
         r = t.strideHeight,
         i = t.strideWidth,
         o = e - 1 - t.padInfo.top,
         a = n - 1 - t.padInfo.left,
         s = t.outChannels / t.inChannels;
        this.userCode = "\n      const ivec2 pads = ivec2(" + o + ", " + a + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s + "; dm++) {\n              int d2 = d1 * " + s + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       ta = function(t, e, n, r) {
        void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
        var i = t.padInfo.top,
         o = t.padInfo.left,
         a = t.strideHeight,
         s = t.strideWidth,
         u = t.dilationHeight,
         c = t.dilationWidth,
         l = t.filterHeight,
         h = t.filterWidth,
         p = 4 * Math.floor(t.inChannels / 4),
         f = t.inChannels % 4,
         d = "channelsLast" === t.dataFormat,
         v = d ? 1 : 2,
         m = d ? 2 : 3,
         g = d ? 3 : 1,
         y = "",
         b = "";
        n && (y = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", b = "result = activation(result);");
        var x = e ? "result += getBiasAtOutCoords();" : "";
        e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y + "\n\n      const ivec2 strides = ivec2(" + a + ", " + s + ");\n      const ivec2 pads = ivec2(" + i + ", " + o + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + m + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l + "; wR++) {\n          int xR = xRCorner + wR * " + u + ";\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c + ";\n\n            if (xC < 0 || xC >= " + t.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + p + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === f) + ") {\n\n              if (" + d + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + p + ") *\n                    getW(wR, wC, " + p + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + p + ", xR, xC) *\n                    getW(wR, wC, " + p + ", d2);\n              }\n\n            } else if (" + (2 === f) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + p + ", d2),\n                getW(wR, wC, " + p + " + 1, d2)\n              );\n\n              if (" + d + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + p + "),\n                  getX(batch, xR, xC, " + p + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + p + ", xR, xC),\n                  getX(batch, " + p + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === f) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + p + ", d2),\n                getW(wR, wC, " + p + " + 1, d2),\n                getW(wR, wC, " + p + " + 2, d2)\n              );\n\n              if (" + d + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + p + "),\n                  getX(batch, xR, xC, " + p + " + 1),\n                  getX(batch, xR, xC, " + p + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + p + ", xR, xC),\n                  getX(batch, " + p + " + 1, xR, xC),\n                  getX(batch, " + p + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + x + "\n        " + b + "\n        setOutput(result);\n      }\n    "
       },
       ea = function(t) {
        this.variableNames = ["x", "W"], this.outputShape = t.outShape;
        var e = t.padInfo.front,
         n = t.padInfo.top,
         r = t.padInfo.left,
         i = t.strideDepth,
         o = t.strideHeight,
         a = t.strideWidth,
         s = t.dilationDepth,
         u = t.dilationHeight,
         c = t.dilationWidth,
         l = t.filterDepth,
         h = t.filterHeight,
         p = t.filterWidth,
         f = 4 * Math.floor(t.inChannels / 4),
         d = t.inChannels % 4;
        this.userCode = "\n      const ivec3 strides = ivec3(" + i + ", " + o + ", " + a + ");\n      const ivec3 pads = ivec3(" + e + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l + "; wF++) {\n          int xF = xFCorner + wF * " + s + ";\n\n          if (xF < 0 || xF >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + "; wR++) {\n            int xR = xRCorner + wR * " + u + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + p + "; wC++) {\n              int xC = xCCorner + wC * " + c + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + f + ") *\n                  getW(wF, wR, wC, " + f + ", d2);\n              } else if (" + (2 === d) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1),\n                  getX(batch, xF, xR, xC, " + f + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2),\n                  getW(wF, wR, wC, " + f + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       na = function(t, e, n, r) {
        void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
        var i = t.inHeight,
         o = t.inWidth,
         a = t.padInfo.top,
         s = t.padInfo.left,
         u = t.strideHeight,
         c = t.strideWidth,
         l = t.dilationHeight,
         h = t.dilationWidth,
         p = t.filterHeight,
         f = t.filterWidth,
         d = t.outChannels / t.inChannels,
         v = "",
         m = "";
        n && (v = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", m = "result = activation(result);");
        var g = e ? "result += getBiasAtOutCoords();" : "";
        e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d + ";\n        int q = d2 - d1 * " + d + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + p + "; wR++) {\n          int xR = xRCorner + wR * " + l + ";\n\n          if (xR < 0 || xR >= " + i + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + f + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + o + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g + "\n        " + m + "\n        setOutput(result);\n      }\n    "
       },
       ra = function(t, e, n, r) {
        void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;
        for (var i = t.inHeight, o = t.inWidth, a = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, p = t.filterHeight, f = t.filterWidth, d = f, v = "int xR; int xC; int xCOffset;", m = 0; m < p; m++)
         for (var g = 0; g < f; g++) v += "\n          vec4 xTexelR" + m + "C" + 2 * g + " = vec4(0.);\n          vec4 wR" + m + "C" + g + " = vec4(0.);\n          vec4 xR" + m + "C" + g + " = vec4(0.);";
        for (m = 0; m < p; m++)
         for (var y = 0; y < d; y++) {
          if (v += "\n          xR = xRCorner + " + m * l + ";\n          xC = xCCorner + " + (g = 2 * y) * h + ";\n        ", 1 === c) {
           if (g < f && (v += s % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + i + " && xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + i + " && xCOffset >= 0 && xCOffset < " + o + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + m + "C" + g + " = vec4(previous.zw, xTexelR" + m + "C" + g + ".xy);\n                } else {\n                  xR" + m + "C" + g + " = vec4(0, 0, xTexelR" + m + "C" + g + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + i + " && xC >= 0 && xC < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = xTexelR" + m + "C" + g + ";\n              ", g + 1 < f)) {
            var b = s % 2 == 0 ? k(h) : h;
            h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (v += "\n                  xCOffset = xC + " + s % 2 + " + " + b + ";\n\n                  if(xR >= 0 && xR < " + i + " &&\n                    xCOffset >= 0 && xCOffset < " + o + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (v += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + i + " &&\n                      xCOffset >= 0 && xCOffset < " + o + ") {\n                      xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + m + "C" + g + " = vec4(0.);\n                    }\n                  "), v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".xy);\n                ") : v += "\n                  xCOffset = xC + " + b + ";\n\n                  if(xR >= 0 && xR < " + i + " &&\n                    xCOffset >= 0 && xCOffset < " + o + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + m + "C" + (g + 1) + " = xTexelR" + m + "C" + (g + 2) + ";\n                "
           }
          } else g < f && (v += "\n              if(xR >= 0 && xR < " + i + ") {\n            ", s % 2 == 1 ? (v += "\n                xCOffset = xC + 1 - " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + o + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n              ", g + 1 < f && (v += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c + ";\n                  if(xCOffset >= 0 && xCOffset < " + o + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + m + "C" + (g + 1) + " = vec4(xTexelR" + m + "C" + (g + 2) + ".xy, final.xy);\n                ")) : (v += "\n                if(xC >= 0 && xC < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".xy, xTexelR" + m + "C" + (g + 2) + ".xy);\n              ", g + 1 < f && (v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n                ")), v += "}");
          g < f && (v += "\n            vec4 wTexelR" + m + "C" + g + " = getW(" + m + ", " + g + ", d1, q);\n            wR" + m + "C" + g + " = vec4(wTexelR" + m + "C" + g + ".xz, wTexelR" + m + "C" + g + ".xz);\n          ", g + 1 < f && (v += "\n              vec4 wTexelR" + m + "C" + (g + 1) + " = getW(" + m + ", " + (g + 1) + ", d1, q);\n              wR" + m + "C" + (g + 1) + " =\n                vec4(wTexelR" + m + "C" + (g + 1) + ".xz, wTexelR" + m + "C" + (g + 1) + ".xz);"))
         }
        for (m = 0; m < p; m++)
         for (g = 0; g < f; g++) v += "dotProd += xR" + m + "C" + g + " * wR" + m + "C" + g + ";";
        var x = "",
         w = "";
        n && (x = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", w = "result = activation(result);");
        var C = e ? "result += getBiasAtOutCoords();" : "";
        e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + x + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v + "\n\n        vec4 result = dotProd;\n        " + C + "\n        " + w + "\n        setOutput(result);\n      }\n    "
       },
       ia = function(t, e, n, r, i) {
        this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
        var o = t[0],
         a = t[1],
         s = t[2],
         u = t[3],
         c = e[0],
         l = n[0],
         h = n[1];
        this.outputShape = [c, l, h, u];
        var p = "bilinear" === r ? 1 : 0,
         f = [a - 1 + ".0", s - 1 + ".0"],
         d = f[0],
         v = f[1],
         m = l > 1 ? ["" + (a - 1) / (l - 1), "(y2-y1) * height_ratio", "y1*" + d + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d],
         g = m[0],
         y = m[1],
         b = m[2],
         x = h > 1 ? ["" + (s - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + v + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v],
         w = x[0],
         C = x[1],
         S = x[2];
        this.userCode = "\n      const float height_ratio = float(" + g + ");\n      const float width_ratio = float(" + w + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + o + ") {\n          return;\n        }\n\n        float height_scale = " + y + ";\n        float width_scale = " + C + ";\n\n        float in_y = " + b + ";\n        if( in_y < 0.0 || in_y > " + d + " ) {\n          setOutput(float(" + i + "));\n          return;\n        }\n        float in_x = " + S + ";\n        if( in_x < 0.0 || in_x > " + v + " ) {\n          setOutput(float(" + i + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + p + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "
       },
       oa = function(t, e, n) {
        this.variableNames = ["x"], this.outputShape = t;
        var r = t.length,
         i = t[t.length - 1],
         o = n ? "<" : ">";
        this.userCode = "\n      int getIndex(int i) {\n        " + (n ? "return " + i + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + Eo(r) + " coords = getOutputCoords();\n        int end = " + aa(r, "coords") + ";\n        float val = 0.0;\n        for (int i = " + i + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + o + " end) {\n            continue;\n          }\n          if (idx == end && " + e + ") {\n            continue;\n          }\n          " + aa(r, "coords") + " = idx;\n          val += getX(" + function(t, e) {
         if (1 === t) return "" + e;
         if (2 === t) return e + ".x, " + e + ".y";
         if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
         if (4 === t) return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
         throw Error("Cumulative sum for rank " + t + " is not yet supported")
        }(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    "
       };
 
      function aa(t, e) {
       if (1 === t) return "" + e;
       if (2 === t) return e + ".y";
       if (3 === t) return e + ".z";
       if (4 === t) return e + ".w";
       throw Error("Cumulative sum for rank " + t + " is not yet supported")
      }
      var sa = function(t) {
        this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Ht.DENSE;
        var e = Jt(t),
         n = lo();
        this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ho(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    "
       },
       ua = function(t) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Ht.DENSE;
        var e = Jt(t),
         n = lo();
        this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + ho(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    "
       },
       ca = function() {
        function t(t, e, n) {
         this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e + ";\n      int offset_h = imod(h, " + e + ");\n      int in_w = w / " + e + ";\n      int offset_w = imod(w, " + e + ");\n      int offset_d = (offset_h * " + e + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  "
        }
        return t.prototype.getHeightCoordString = function() {
         return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
        }, t.prototype.getWidthCoordString = function() {
         return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
        }, t.prototype.getDepthCoordString = function() {
         return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
        }, t.prototype.getOutputDepthSize = function() {
         return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
        }, t.prototype.getInputSamplingString = function() {
         return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
        }, t
       }(),
       la = function(t) {
        this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
       },
       ha = function(t) {
        this.variableNames = ["A"], this.outTexUsage = $t.DOWNLOAD;
        var e = lo();
        this.outputShape = t, this.userCode = "\n      " + fo + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e.output + " = encode_float(x);\n      }\n    "
       },
       pa = function(t) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = $t.DOWNLOAD;
        var e = lo();
        this.outputShape = t, this.userCode = "\n      " + fo + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e.output + " = encode_float(x);\n      }\n    "
       },
       fa = function(t, e, n) {
        void 0 === n && (n = !1), this.variableNames = ["A"];
        var r = lo(),
         i = e[0],
         o = e[1];
        this.outputShape = t;
        var a = "result";
        n && (a = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + po(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + o + ";\n        int c = imod(flatIndex, " + o + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + o + ".0, " + i + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + a + ", 0., 0., 0.);\n      }\n    "
       },
       da = function(t, e, n) {
        void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
        var r = lo(),
         i = e[0],
         o = e[1];
        this.outputShape = t;
        var a = "",
         s = "result";
        n && (s = "floor(result * 255. + 0.5)");
        for (var u = 0; u <= 1; u++)
         for (var c = 0; c <= 1; c++) {
          var l = 2 * u + c;
          a += "\n          localCoords = coords;\n          if(localCoords[2] + " + c + " < " + t[2] + ") {\n            localCoords[2] += " + c + ";\n            if(localCoords[1] + " + u + " < " + t[1] + ") {\n              localCoords[1] += " + u + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + o + ";\n              c = imod(flatIndex, " + o + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + o + ".0, " + i + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l + "] = values[2];\n              } else {\n                result[" + l + "] = values[3];\n              }\n            }\n          }\n        "
         }
        this.userCode = "\n      " + po(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + a + "\n\n        " + r.output + " = " + s + ";\n      }\n    "
       },
       va = "return real * expR - imag * expI;",
       ma = "return real * expI + imag * expR;",
       ga = function(t, e, n) {
        this.variableNames = ["real", "imag"];
        var r = e[1];
        this.outputShape = e;
        var i = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
         o = n ? r + ".0" : "1.0";
        this.userCode = "\n      const float exponentMultiplier = " + i + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + o + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "
       },
       ya = function() {
        function t(t, e) {
         this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
        }
        return t.prototype.getCustomSetupFunc = function(t) {
         var e = this;
         return function(n, r) {
          null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(e.valueLoc, t)
         }
        }, t
       }(),
       ba = function(t, e, n) {
        this.variableNames = ["A", "indices"];
        var r = t.slice();
        r[n] = e, this.outputShape = r, this.rank = r.length;
        var i = Eo(this.rank),
         o = function(t, e) {
          var n = t.length;
          if (n > 4) throw Error("Gather for rank " + n + " is not yet supported");
          if (1 === n) return "int(getIndices(resRC))";
          for (var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i = [], o = 0; o < t.length; o++) o === e ? i.push("int(getIndices(" + r[o] + "))") : i.push("" + r[o]);
          return i.join()
         }(t, n);
        this.userCode = "\n      void main() {\n        " + i + " resRC = getOutputCoords();\n        setOutput(getA(" + o + "));\n      }\n    "
       },
       xa = function(t, e, n) {
        this.sliceDim = t, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = n;
        var r = Eo(e.length),
         i = Eo(n.length),
         o = this.sliceDim > 1 ? "strides[j]" : "strides";
        this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + i + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + o + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "
       };
 
      function wa(t, e) {
       var n = lo();
       return se(t, e, n.version + "\n    precision highp float;\n    " + n.attribute + " vec3 clipSpacePos;\n    " + n.attribute + " vec2 uv;\n    " + n.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")
      }
 
      function Ca(t, e) {
       return ve(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
      }
 
      function Sa(t, e) {
       return me(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]))
      }
 
      function Ea(t, e, n, r, i, o, a) {
       ye(n, r);
       var s = ge(t, e),
        u = t.TEXTURE_2D;
       return ee(t, e, (function() {
        return t.bindTexture(u, s)
       })), ee(t, e, (function() {
        return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE)
       })), ee(t, e, (function() {
        return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)
       })), ee(t, e, (function() {
        return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST)
       })), ee(t, e, (function() {
        return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST)
       })), ee(t, e, (function() {
        return t.texImage2D(u, 0, i, n, r, 0, o, a, null)
       })), ee(t, e, (function() {
        return t.bindTexture(t.TEXTURE_2D, null)
       })), s
      }
 
      function ka(t, e, n, r, i) {
       var o = Zt(n, r);
       return Ea(t, e, o[0], o[1], i.internalFormatFloat, i.textureFormatFloat, t.FLOAT)
      }
 
      function Ia(t, e, n, r, i) {
       var o = Zt(n, r);
       return Ea(t, e, o[0], o[1], i.internalFormatHalfFloat, i.textureFormatFloat, i.textureTypeHalfFloat)
      }
 
      function Oa(t, e, n, r, i) {
       var o = Zt(n, r);
       return Ea(t, e, o[0], o[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE)
      }
 
      function Aa(t, e, n, r, i) {
       var o = Qt(n, r);
       return Ea(t, e, o[0], o[1], i.internalFormatPackedFloat, t.RGBA, t.FLOAT)
      }
 
      function Na(t, e, n, r, i) {
       var o = Qt(n, r);
       return Ea(t, e, o[0], o[1], i.internalFormatPackedHalfFloat, t.RGBA, i.textureTypeHalfFloat)
      }
 
      function Ra(t, e, n, r) {
       return ee(t, e, (function() {
        return t.bindBuffer(t.ARRAY_BUFFER, r)
       })), xe(t, e, n, "clipSpacePos", r, 3, 20, 0) && xe(t, e, n, "uv", r, 2, 20, 12)
      }
 
      function Ta(t, e, n, r, i, o, a) {
       var s, u, c;
       ee(t, e, (function() {
        return t.bindTexture(t.TEXTURE_2D, n)
       })), o instanceof Uint8Array ? (s = new Uint8Array(r * i * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * i * 4), u = t.FLOAT, c = a.internalFormatPackedFloat), s.set(o), ee(t, e, (function() {
        return t.texImage2D(t.TEXTURE_2D, 0, c, r, i, 0, t.RGBA, u, s)
       })), ee(t, e, (function() {
        return t.bindTexture(t.TEXTURE_2D, null)
       }))
      }
 
      function _a(t, e, n, r) {
       ee(t, e, (function() {
        return t.bindTexture(t.TEXTURE_2D, n)
       })), r.data instanceof Uint8Array ? ee(t, e, (function() {
        return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data)
       })) : ee(t, e, (function() {
        return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r)
       })), ee(t, e, (function() {
        return t.bindTexture(t.TEXTURE_2D, null)
       }))
      }
 
      function Da(t, e, n, r, i) {
       var o = t.createBuffer();
       ee(t, e, (function() {
        return t.bindBuffer(t.PIXEL_PACK_BUFFER, o)
       }));
       var a = 16 * n * r;
       return ee(t, e, (function() {
        return t.bufferData(t.PIXEL_PACK_BUFFER, a, t.STREAM_READ)
       })), ee(t, e, (function() {
        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0)
       })), ee(t, e, (function() {
        return t.bindBuffer(t.PIXEL_PACK_BUFFER, null)
       })), o
      }
 
      function Fa(t, e, n) {
       var r = t,
        i = new Float32Array(n);
       return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, i), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), i
      }
 
      function Ma(t, e, n, r, i) {
       var o = Zt(n, r),
        a = o[0],
        s = o[1],
        u = new Uint8Array(n * r * 4);
       return ee(t, e, (function() {
        return t.readPixels(0, 0, a, s, i.downloadTextureFormat, t.UNSIGNED_BYTE, u)
       })), new Float32Array(u.buffer)
      }
 
      function La(t, e, n, r, i, o, a, s) {
       var u = t,
        c = new Float32Array(function(t, e) {
         var n = Qt(t, e);
         return n[0] * n[1] * 4
        }(o, a));
       return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c
      }
 
      function Ba(t, e, n, r) {
       var i = new Float32Array(n * r * 4);
       return ee(t, e, (function() {
        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, i)
       })), i
      }
      var Pa = Object.freeze({
        createVertexShader: wa,
        createVertexBuffer: Ca,
        createIndexBuffer: Sa,
        createFloat32MatrixTexture: ka,
        createFloat16MatrixTexture: Ia,
        createUnsignedBytesMatrixTexture: Oa,
        createPackedMatrixTexture: Aa,
        createFloat16PackedMatrixTexture: Na,
        bindVertexProgramAttributeStreams: Ra,
        uploadDenseMatrixToTexture: Ta,
        uploadPixelDataToTexture: _a,
        createBufferFromOutputTexture: Da,
        downloadFloat32MatrixFromBuffer: Fa,
        downloadByteEncodedFloatMatrixFromOutputTexture: Ma,
        downloadPackedMatrixFromBuffer: La,
        downloadMatrixFromPackedOutputTexture: Ba
       }),
       za = function() {
        function t(t) {
         this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
         var e = h().getNumber("WEBGL_VERSION");
         null != t ? (this.gl = t, Xt(e, t)) : this.gl = Yt(e);
         var n = "WEBGL_color_buffer_float";
         if (1 === h().getNumber("WEBGL_VERSION")) {
          if (this.textureFloatExtension = ae(this.gl, this.debug, "OES_texture_float"), je(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = ae(this.gl, this.debug, "OES_texture_half_float");
          else if (h().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          if (this.colorBufferFloatExtension = this.gl.getExtension(n), je(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = ae(this.gl, this.debug, "EXT_color_buffer_half_float");
          else if (h().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
         } else if (n = "EXT_color_buffer_float", je(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);
         else {
          if (!je(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
          this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float")
         }
         this.vertexBuffer = Ca(this.gl, this.debug), this.indexBuffer = Sa(this.gl, this.debug), this.framebuffer = be(this.gl, this.debug), this.textureConfig = te(this.gl, this.textureHalfFloatExtension)
        }
        return Object.defineProperty(t.prototype, "debug", {
         get: function() {
          return h().getBool("DEBUG")
         },
         enumerable: !0,
         configurable: !0
        }), t.prototype.dispose = function() {
         var t = this;
         if (!this.disposed) {
          null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
          var e = this.gl;
          ee(e, this.debug, (function() {
           return e.finish()
          })), ee(e, this.debug, (function() {
           return e.bindFramebuffer(e.FRAMEBUFFER, null)
          })), ee(e, this.debug, (function() {
           return e.deleteFramebuffer(t.framebuffer)
          })), ee(e, this.debug, (function() {
           return e.bindBuffer(e.ARRAY_BUFFER, null)
          })), ee(e, this.debug, (function() {
           return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)
          })), ee(e, this.debug, (function() {
           return e.deleteBuffer(t.indexBuffer)
          })), this.disposed = !0
         }
        }, t.prototype.createFloat32MatrixTexture = function(t, e) {
         return this.throwIfDisposed(), ka(this.gl, this.debug, t, e, this.textureConfig)
        }, t.prototype.createFloat16MatrixTexture = function(t, e) {
         return this.throwIfDisposed(), Ia(this.gl, this.debug, t, e, this.textureConfig)
        }, t.prototype.createUnsignedBytesMatrixTexture = function(t, e) {
         return this.throwIfDisposed(), Oa(this.gl, this.debug, t, e, this.textureConfig)
        }, t.prototype.uploadPixelDataToTexture = function(t, e) {
         this.throwIfDisposed(), _a(this.gl, this.debug, t, e)
        }, t.prototype.uploadDenseMatrixToTexture = function(t, e, n, r) {
         this.throwIfDisposed(), Ta(this.gl, this.debug, t, e, n, r, this.textureConfig)
        }, t.prototype.createFloat16PackedMatrixTexture = function(t, e) {
         return this.throwIfDisposed(), Na(this.gl, this.debug, t, e, this.textureConfig)
        }, t.prototype.createPackedMatrixTexture = function(t, e) {
         return this.throwIfDisposed(), Aa(this.gl, this.debug, t, e, this.textureConfig)
        }, t.prototype.deleteMatrixTexture = function(t) {
         var e = this;
         this.throwIfDisposed(), this.outputTexture === t && (Ie(this.gl, this.debug, this.framebuffer), this.outputTexture = null), ee(this.gl, this.debug, (function() {
          return e.gl.deleteTexture(t)
         }))
        }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t, e, n) {
         var r = this;
         return this.downloadMatrixDriver(t, (function() {
          return Ma(r.gl, r.debug, e, n, r.textureConfig)
         }))
        }, t.prototype.downloadPackedMatrixFromBuffer = function(t, e, n, r, i, o) {
         return La(this.gl, t, 0, 0, 0, i, o, this.textureConfig)
        }, t.prototype.downloadFloat32MatrixFromBuffer = function(t, e) {
         return Fa(this.gl, t, e)
        }, t.prototype.createBufferFromTexture = function(t, e, n) {
         this.bindTextureToFrameBuffer(t);
         var r = Da(this.gl, this.debug, e, n, this.textureConfig);
         return this.unbindTextureToFrameBuffer(), r
        }, t.prototype.createAndWaitForFence = function() {
         var t = this.createFence(this.gl);
         return this.pollFence(t)
        }, t.prototype.createFence = function(t) {
         var e, n, r = this;
         if (h().getBool("WEBGL_FENCE_API_ENABLED")) {
          var i = t,
           o = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
          t.flush(), n = function() {
           var t = i.clientWaitSync(o, 0, 0);
           return t === i.ALREADY_SIGNALED || t === i.CONDITION_SATISFIED
          }, e = o
         } else h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function() {
          return r.isQueryAvailable(e, h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
         }) : n = function() {
          return !0
         };
         return {
          query: e,
          isFencePassed: n
         }
        }, t.prototype.downloadMatrixFromPackedTexture = function(t, e, n) {
         var r = this;
         return this.downloadMatrixDriver(t, (function() {
          return Ba(r.gl, r.debug, e, n)
         }))
        }, t.prototype.createProgram = function(t) {
         this.throwIfDisposed();
         var e = this.gl,
          n = ue(e, this.debug, t),
          r = wa(e, this.debug),
          i = pe(e, this.debug);
         return ee(e, this.debug, (function() {
          return e.attachShader(i, r)
         })), ee(e, this.debug, (function() {
          return e.attachShader(i, n)
         })), fe(e, this.debug, i), this.debug && de(e, this.debug, i), this.vertexAttrsAreBound || (this.setProgram(i), this.vertexAttrsAreBound = Ra(e, this.debug, this.program, this.vertexBuffer)), i
        }, t.prototype.deleteProgram = function(t) {
         var e = this;
         this.throwIfDisposed(), t === this.program && (this.program = null), null != t && ee(this.gl, this.debug, (function() {
          return e.gl.deleteProgram(t)
         }))
        }, t.prototype.setProgram = function(t) {
         var e = this;
         this.throwIfDisposed(), this.program = t, null != this.program && this.debug && de(this.gl, this.debug, this.program), ee(this.gl, this.debug, (function() {
          return e.gl.useProgram(t)
         }))
        }, t.prototype.getUniformLocation = function(t, e, n) {
         return void 0 === n && (n = !0), this.throwIfDisposed(), n ? Ce(this.gl, this.debug, t, e) : Se(this.gl, t, e)
        }, t.prototype.getAttributeLocation = function(t, e) {
         var n = this;
         return this.throwIfDisposed(), ee(this.gl, this.debug, (function() {
          return n.gl.getAttribLocation(t, e)
         }))
        }, t.prototype.getUniformLocationNoThrow = function(t, e) {
         return this.throwIfDisposed(), this.gl.getUniformLocation(t, e)
        }, t.prototype.setInputMatrixTexture = function(t, e, n) {
         this.throwIfDisposed(), this.throwIfNoProgram(), Ee(this.gl, this.debug, this.program, t, e, n)
        }, t.prototype.setOutputMatrixTexture = function(t, e, n) {
         this.setOutputMatrixTextureDriver(t, n, e)
        }, t.prototype.setOutputPackedMatrixTexture = function(t, e, n) {
         this.throwIfDisposed();
         var r = Qt(e, n),
          i = r[0],
          o = r[1];
         this.setOutputMatrixTextureDriver(t, i, o)
        }, t.prototype.setOutputMatrixWriteRegion = function(t, e, n, r) {
         this.setOutputMatrixWriteRegionDriver(n, t, r, e)
        }, t.prototype.setOutputPackedMatrixWriteRegion = function(t, e, n, r) {
         throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
        }, t.prototype.debugValidate = function() {
         null != this.program && de(this.gl, this.debug, this.program), Oe(this.gl)
        }, t.prototype.executeProgram = function() {
         this.throwIfDisposed(), this.throwIfNoProgram();
         var t = this.gl;
         this.debug && this.debugValidate(), ee(t, this.debug, (function() {
          return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0)
         }))
        }, t.prototype.blockUntilAllProgramsCompleted = function() {
         var t = this;
         this.throwIfDisposed(), ee(this.gl, this.debug, (function() {
          return t.gl.finish()
         }))
        }, t.prototype.getQueryTimerExtension = function() {
         return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = ae(this.gl, this.debug, 2 === h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
        }, t.prototype.getQueryTimerExtensionWebGL2 = function() {
         return this.getQueryTimerExtension()
        }, t.prototype.getQueryTimerExtensionWebGL1 = function() {
         return this.getQueryTimerExtension()
        }, t.prototype.beginQuery = function() {
         if (2 === h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
          var t = this.gl,
           e = this.getQueryTimerExtensionWebGL2(),
           n = t.createQuery();
          return t.beginQuery(e.TIME_ELAPSED_EXT, n), n
         }
         var r = this.getQueryTimerExtensionWebGL1(),
          i = r.createQueryEXT();
         return r.beginQueryEXT(r.TIME_ELAPSED_EXT, i), i
        }, t.prototype.endQuery = function() {
         if (2 !== h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
          var t = this.getQueryTimerExtensionWebGL1();
          t.endQueryEXT(t.TIME_ELAPSED_EXT)
         } else {
          var e = this.gl,
           n = this.getQueryTimerExtensionWebGL2();
          e.endQuery(n.TIME_ELAPSED_EXT)
         }
        }, t.prototype.waitForQueryAndGetTime = function(t) {
         return s(this, void 0, void 0, (function() {
          var e = this;
          return u(this, (function(n) {
           switch (n.label) {
            case 0:
             return [4, B((function() {
              return e.disposed || e.isQueryAvailable(t, h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
             }))];
            case 1:
             return n.sent(), [2, this.getQueryTime(t, h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]
           }
          }))
         }))
        }, t.prototype.getQueryTime = function(t, e) {
         if (0 === e) return null;
         if (2 === e) {
          var n = this.gl;
          return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6
         }
         var r = this.getQueryTimerExtensionWebGL1();
         return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6
        }, t.prototype.isQueryAvailable = function(t, e) {
         if (0 === e) return !0;
         if (2 === e) {
          var n = this.gl,
           r = this.getQueryTimerExtensionWebGL2(),
           i = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
          return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint
         }
         return i = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT), null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint
        }, t.prototype.pollFence = function(t) {
         var e = this;
         return new Promise((function(n) {
          e.addItemToPoll((function() {
           return t.isFencePassed()
          }), (function() {
           return n()
          }))
         }))
        }, t.prototype.pollItems = function() {
         for (var t = function(t) {
           for (var e = 0; e < t.length; ++e)
            if (!t[e]()) break;
           return e - 1
          }(this.itemsToPoll.map((function(t) {
           return t.isDoneFn
          }))), e = 0; e <= t; ++e)(0, this.itemsToPoll[e].resolveFn)();
         this.itemsToPoll = this.itemsToPoll.slice(t + 1)
        }, t.prototype.addItemToPoll = function(t, e) {
         var n = this;
         this.itemsToPoll.push({
          isDoneFn: t,
          resolveFn: e
         }), this.itemsToPoll.length > 1 || B((function() {
          return n.pollItems(), 0 === n.itemsToPoll.length
         }))
        }, t.prototype.bindTextureToFrameBuffer = function(t) {
         this.throwIfDisposed(), ke(this.gl, this.debug, t, this.framebuffer), this.debug && Oe(this.gl)
        }, t.prototype.unbindTextureToFrameBuffer = function() {
         null != this.outputTexture ? (ke(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Oe(this.gl)) : Ie(this.gl, this.debug, this.framebuffer)
        }, t.prototype.downloadMatrixDriver = function(t, e) {
         this.bindTextureToFrameBuffer(t);
         var n = e();
         return this.unbindTextureToFrameBuffer(), n
        }, t.prototype.setOutputMatrixTextureDriver = function(t, e, n) {
         this.throwIfDisposed();
         var r = this.gl;
         ke(r, this.debug, t, this.framebuffer), this.debug && Oe(r), this.outputTexture = t, ee(r, this.debug, (function() {
          return r.viewport(0, 0, e, n)
         })), ee(r, this.debug, (function() {
          return r.scissor(0, 0, e, n)
         }))
        }, t.prototype.setOutputMatrixWriteRegionDriver = function(t, e, n, r) {
         var i = this;
         this.throwIfDisposed(), ee(this.gl, this.debug, (function() {
          return i.gl.scissor(t, e, n, r)
         }))
        }, t.prototype.throwIfDisposed = function() {
         if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
        }, t.prototype.throwIfNoProgram = function() {
         if (null == this.program) throw new Error("No GPU program is currently set.")
        }, t
       }();
 
      function ja(t, e) {
       if (t.length !== e.length) throw Error("Binary was compiled with " + t.length + " inputs, but was executed with " + e.length + " inputs");
       t.forEach((function(t, n) {
        var r = t.logicalShape,
         i = e[n],
         o = i.shape;
        if (!_(r, o)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + o + " must match");
        if (!t.isUniform || !i.isUniform) {
         var a = t.texShape,
          s = i.isUniform ? null : i.texData.texShape;
         if (!_(a, s)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + a + " and " + s + " must match")
        }
       }))
      }
      var Wa = function(t, e, n) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;
        for (var r = n.filterWidth, i = n.inChannels, o = n.strideWidth, a = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, p = s.left, f = s.top, d = i * r, v = lo(), m = "channelsLast" === h, g = m ? 0 : 1, y = m ? 1 : 2, b = "", x = 0; x <= 1; x++)
         for (var w = 0; w <= 1; w++) b += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + x + ";\n\n          if(blockIndex < " + t[1] + " && pos < " + t[0] + ") {\n            offsetY = int(blockIndex / (" + u + ")) * " + a + " - " + f + ";\n            d0 = offsetY + " + l + " * (pos / " + d + ");\n\n            if(d0 < " + e[g] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u + ".) * " + o + ". - " + p + ".);\n              d1 = offsetX + " + c + " * (int(mod(float(pos), " + d + ".) / " + i + ".));\n\n              if(d1 < " + e[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + i + ".));\n\n                if (" + m + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
        this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + b + "\n\n        " + v.output + " = result;\n      }\n    "
       },
       Va = function(t, e, n, r, i) {
        this.variableNames = ["x"], this.outputShape = [];
        var o, a = e,
         s = t[3] - 1;
        this.outputShape = t;
        var u = "float(" + n + ") + float(" + r + ") * sum";
        o = .5 === i ? "inversesqrt(" + u + ")" : 1 === i ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + i + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + a + "; j <= " + a + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + o + ";\n        setOutput(val);\n      }\n    "
       },
       Ua = function(t, e, n, r, i) {
        this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = i, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + i + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + i + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "
       },
       Ha = function(t, e, n, r, i) {
        this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
        var o, a = e,
         s = t[3] - 1;
        this.outputShape = t;
        var u = "float(" + n + ") + float(" + r + ") * sum";
        o = .5 === i ? "inversesqrt(" + u + ")" : 1 === i ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + i + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + a + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + a + "; j <= " + a + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + o + ";\n        setOutput(result);\n      }\n    "
       },
       $a = function(t) {
        this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
        var e = t.strideHeight,
         n = t.strideWidth,
         r = t.dilationHeight,
         i = t.effectiveFilterHeight,
         o = t.effectiveFilterWidth,
         a = i - 1 - t.padInfo.top,
         s = o - 1 - t.padInfo.left,
         u = i * o - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + i + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + e + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + o + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + o + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       Ga = function(t) {
        this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
        var e = t.strideDepth,
         n = t.strideHeight,
         r = t.strideWidth,
         i = t.dilationDepth,
         o = t.dilationHeight,
         a = t.dilationWidth,
         s = t.effectiveFilterDepth,
         u = t.effectiveFilterHeight,
         c = t.effectiveFilterWidth,
         l = s - 1 - t.padInfo.front,
         h = u - 1 - t.padInfo.top,
         p = c - 1 - t.padInfo.left,
         f = s * u * c - 1;
        this.userCode = "\n      const ivec3 pads = ivec3(" + l + ", " + h + ", " + p + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s + ";\n           wD += " + i + ") {\n          float dyD = float(dyDCorner + wD) / " + e + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + o + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + a + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + f + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u + " * " + c + " +\n                  wR * " + c + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
       },
       qa = function(t, e, n, r, i, o, a) {
        void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === i && (i = !1), void 0 === o && (o = null), void 0 === a && (a = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
        var s = n ? t[1] : t[2],
         u = Math.ceil(s / 2),
         c = n ? "i * 2, rc.y" : "rc.y, i * 2",
         l = r ? "rc.z, i * 2" : "i * 2, rc.z",
         h = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
         p = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
         f = "",
         d = "";
        o && (f = a ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + o + "\n        }" : "vec4 activation(vec4 x) {\n          " + o + "\n        }", d = "result = activation(result);");
        var v = i ? "result += getBiasAtOutCoords();" : "";
        i && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + f + "\n\n      const float sharedDimension = " + u + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c + ");\n          vec4 b = getMatrixB(rc.x, " + l + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h[0] + " * " + p[0] + ");\n          result += (" + h[1] + " * " + p[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v + "\n\n        " + d + "\n\n        setOutput(result);\n      }\n    "
       },
       Ka = function() {
        function t(t, e, n) {
         this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e - 1) + "));\n      }\n    "
        }
        return t.prototype.getCustomSetupFunc = function(t) {
         var e = this;
         return function(n, r) {
          null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(e.seedLoc, t)
         }
        }, t
       }(),
       Xa = function(t, e, n, r) {
        this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    "
       },
       Ya = function(t) {
        this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;
        var e = t.length;
        if (0 === e) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
        else {
         var n = co("rc", e),
          r = Eo(e),
          i = function(t, e, n) {
           if (1 === t) return "rc > " + e[0];
           for (var r = "", i = t - 2; i < t; i++) r += n[i] + " >= " + e[i], i < t - 1 && (r += "||");
           return r
          }(e, t, n),
          o = function(t, e, n, r) {
           if (1 === t) return "";
           var i = r.slice(-2);
           return "\n    int r = " + i[0] + ";\n    int c = " + i[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e + ";\n    bool rEdge = rp1 >= " + n + ";\n  "
          }(e, t[t.length - 1], t[t.length - 2], n),
          a = function(t, e) {
           var n = t.length,
            r = function(t, e) {
             for (var n = [], r = 0; r <= 1; r++)
              for (var i = 0; i <= 1; i++) {
               for (var o = (0 === r ? "r" : "rp1") + ", " + (0 === i ? "c" : "cp1"), a = 2; a < t; a++) o = e[e.length - 1 - a] + "," + o;
               n.push(o)
              }
             return n
            }(n, e);
           return 1 === n ? "getA(rc),\n            rc + 1 >= " + t[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")"
          }(t, n);
         this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + i + ") {\n            setOutput(vec4(0));\n          } else {\n            " + o + "\n\n            setOutput(vec4(" + a + "));\n          }\n        }\n      "
        }
       },
       Za = function(t, e, n) {
        this.variableNames = ["x"], this.outputShape = e.map((function(e, n) {
         return e[0] + t[n] + e[1]
        }));
        var r = t.length,
         i = Eo(r),
         o = e.map((function(t) {
          return t[0]
         })).join(","),
         a = e.map((function(e, n) {
          return e[0] + t[n]
         })).join(","),
         s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
        this.userCode = 1 !== r ? "\n      " + i + " start = " + i + "(" + o + ");\n      " + i + " end = " + i + "(" + a + ");\n\n      void main() {\n        " + i + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n + "));\n        } else {\n          " + i + " coords = outC - start;\n          setOutput(getX(" + s + "));\n        }\n      }\n    " : "\n        int start = " + o + ";\n        int end = " + a + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "
       },
       Ja = function(t, e, n) {
        this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map((function(e, n) {
         return e[0] + t[n] + e[1]
        }));
        for (var r = t.length, i = Eo(r), o = e.map((function(t) {
          return t[0]
         })).join(","), a = e.map((function(e, n) {
          return e[0] + t[n]
         })).join(","), s = co("rc", r), u = co("source", r), c = s[r - 1] + " < " + this.outputShape[r - 1], l = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")", h = [i + " rc = outputLoc;", s[r - 1] + " += 1;\n       if(" + c + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + s[r - 2] + " += 1;\n       if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + c + ") {"], p = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", f = "", d = 0, v = 1 === r ? 2 : 4; d < v; d++) f += "\n        " + h[d] + "\n        if (" + p + ") {\n          result[" + d + "] = float(" + n + ");\n        } else {\n          " + i + " source = rc - start;\n          result[" + d + "] = getChannel(getX(" + u.join() + "), " + l + ");\n        }\n      ";
        f += 1 === r ? "} " : "}}", this.userCode = "\n      const " + i + " start = " + i + "(" + o + ");\n      const " + i + " end = " + i + "(" + a + ");\n\n      void main() {\n        " + i + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + f + "\n        setOutput(result);\n      }\n    "
       },
       Qa = function(t, e, n) {
        if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
        var r = t.filterWidth,
         i = t.strideHeight,
         o = t.strideWidth,
         a = t.dilationHeight,
         s = t.dilationWidth,
         u = t.effectiveFilterHeight,
         c = t.effectiveFilterWidth,
         l = t.padInfo.top,
         h = t.padInfo.left;
        this.outputShape = t.outShape;
        var p = "avg" === e,
         f = "0.0";
        if (p || (f = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + i + ", " + o + ");\n        const ivec2 pads = ivec2(" + l + ", " + h + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + a + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + s + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
        else {
         var d = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
         "avg" === e && (d = "avgValue / count");
         var v = 4 * Math.floor(r / 4),
          m = r % 4,
          g = "\n      if (" + p + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
         this.userCode = "\n      const ivec2 strides = ivec2(" + i + ", " + o + ");\n      const ivec2 pads = ivec2(" + l + ", " + h + ");\n      const float initializationValue = " + f + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + f + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u + ";\n            wR += " + a + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v + "; wC += 4) {\n            int xC = xCCorner + wC * " + s + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              getValue(batch, xR, xC + 3 * " + s + ", d)\n            );\n\n            " + g + "\n          }\n\n          int xC = xCCorner + " + v + ";\n          if (" + (1 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (2 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (3 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              initializationValue\n            );\n\n            " + g + "\n          }\n        }\n        setOutput(" + d + ");\n      }\n    "
        }
       },
       ts = function(t, e, n) {
        if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
        var r = t.filterWidth,
         i = t.strideDepth,
         o = t.strideHeight,
         a = t.strideWidth,
         s = t.dilationDepth,
         u = t.dilationHeight,
         c = t.dilationWidth,
         l = t.effectiveFilterDepth,
         h = t.effectiveFilterHeight,
         p = t.effectiveFilterWidth,
         f = t.padInfo.front,
         d = t.padInfo.top,
         v = t.padInfo.left;
        this.outputShape = t.outShape;
        var m = "avg" === e,
         g = "0.0";
        if (m || (g = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + i + ", " + o + ", " + a + ");\n        const ivec3 pads = ivec3(" + f + ", " + d + ", " + v + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l + ";\n              wD += " + s + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h + ";\n                wR += " + u + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + p + ";\n                  wC += " + c + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h + " * " + p + " +\n                      wR * " + p + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
        else {
         var y = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
         "avg" === e && (y = "avgValue / count");
         var b = 4 * Math.floor(r / 4),
          x = r % 4,
          w = "\n      if (" + m + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
         this.userCode = "\n      const ivec3 strides =\n        ivec3(" + i + ", " + o + ", " + a + ");\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + v + ");\n      const float initializationValue = " + g + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + ";\n            wR += " + u + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + b + "; wC += 4) {\n              int xC = xCCorner + wC * " + c + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c + ", ch)\n              );\n\n              " + w + "\n            }\n\n            int xC = xCCorner + " + b + ";\n            if (" + (1 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (2 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (3 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                initializationValue\n              );\n\n              " + w + "\n            }\n          }\n          setOutput(" + y + ");\n        }\n      }\n    "
        }
       },
       es = function(t, e) {
        this.variableNames = ["x"];
        var n = t.windowSize,
         r = t.batchSize,
         i = t.inSize,
         o = Math.ceil(i / n);
        this.outputShape = [r, o];
        var a = "0.0",
         s = "";
        "prod" === e ? a = "1.0" : "min" === e ? (a = "1.0 / 1e-20", s = "min") : "max" === e && (a = "-1.0 / 1e-20", s = "max");
        var u = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "sum" === e ? u = "sumValue" : "prod" === e ? u = "prodValue" : "all" === e ? u = "allValue" : "any" === e && (u = "anyValue");
        var c = 4 * Math.floor(n / 4),
         l = n % 4,
         h = "\n      if (" + ("sum" === e) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s + "(values, minMaxValue);\n      }\n    ",
         p = "vec4";
        "all" === e ? (a = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", p = "bvec4") : "any" === e && (a = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", p = "bvec4");
        var f = "";
        i % n > 0 && (f = "\n        if (inIdx < 0 || inIdx >= " + i + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + a + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + f + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + a + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h + "\n        }\n\n        int inIdx = inOffset + " + c + ";\n        if (" + (1 === l) + ") {\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (2 === l) + ") {\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (3 === l) + ") {\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h + "\n        }\n        setOutput(" + u + ");\n      }\n    "
       },
       ns = function(t, e) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;
        for (var n = "", r = 0; r < 4; r++) {
         var i = "thisRC = rc;";
         r % 2 == 1 && (i += "thisRC.z += 1;"), r > 1 && (i += "thisRC.y += 1;"), n += "\n        " + i + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      "
        }
        this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + ho(["r", "c", "d"], e) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + po(t) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t[1] + ";\n        int cols = " + t[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    "
       },
       rs = function(t, e, n) {
        this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
        var r = e.shape,
         i = r[1],
         o = r[2],
         a = t.shape,
         s = a[1],
         u = a[2],
         c = [n && s > 1 ? i - 1 : i, n && u > 1 ? o - 1 : o],
         l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
         h = c[0] / l[0],
         p = c[1] / l[1],
         f = 1 / h,
         d = 1 / p,
         v = 2 * Math.ceil(f) + 2,
         m = 2 * Math.ceil(d) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + p + ");\n\n        const float invHeightScale = float(" + f + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (i - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (o - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
       },
       is = function(t, e, n, r) {
        this.variableNames = ["A"], this.outputShape = [];
        var i = t[0],
         o = t[1],
         a = t[2],
         s = t[3];
        this.outputShape = [i, e, n, s];
        var u = [r && e > 1 ? o - 1 : o, r && n > 1 ? a - 1 : a],
         c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + o + ".0, " + a + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "
       },
       os = function(t, e, n, r) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
        var i = t[0],
         o = t[1],
         a = t[2],
         s = t[3];
        this.outputShape = [i, e, n, s];
        var u = [r && e > 1 ? o - 1 : o, r && n > 1 ? a - 1 : a],
         c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
        this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ",\n          " + u[1] / c[1] + ");\n      const vec3 inputShapeRC = vec3(" + o + ".0, " + a + ".0,\n                                     " + a + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "
       },
       as = function(t, e, n) {
        this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
        var r = e.shape,
         i = r[1],
         o = r[2],
         a = t.shape,
         s = a[1],
         u = a[2],
         c = [n && s > 1 ? i - 1 : i, n && u > 1 ? o - 1 : o],
         l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
         h = c[0] / l[0],
         p = c[1] / l[1],
         f = 1 / h,
         d = 1 / p,
         v = 2 * Math.ceil(f) + 2,
         m = 2 * Math.ceil(d) + 2;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + p + ");\n\n        const float invHeightScale = float(" + f + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c[0] + ") *\n                (float(dyR) / float(" + l[0] + "));\n\n            float sourceFracCol =\n                float(" + c[1] + ") *\n                  (float(dyC) / float(" + l[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + i + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + o + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
       },
       ss = function(t, e, n, r) {
        this.variableNames = ["A"], this.outputShape = [];
        var i = t[0],
         o = t[1],
         a = t[2],
         s = t[3];
        this.outputShape = [i, e, n, s];
        var u = [r && e > 1 ? o - 1 : o, r && n > 1 ? a - 1 : a],
         c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
         l = r ? "0.5" : "0.0";
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + o + ".0, " + a + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "
       },
       us = function(t, e) {
        this.variableNames = ["x"];
        var n = t.length;
        if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
        if (this.outputShape = t, 1 !== n) {
         var r = t.map((function(n, r) {
           return function(n) {
            return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]"
           }(r)
          })).join(","),
          i = Eo(n);
         this.userCode = "\n      void main() {\n        " + i + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    "
        } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t[0] + " - coord - 1));\n        }\n      "
       },
       cs = function(t, e) {
        this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
        var n = t.length;
        if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
        this.outputShape = t;
        var r = co("rc", n),
         i = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
         o = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
         a = Eo(n);
 
        function s(n) {
         var r = t.map((function(r, i) {
          return function(n, r) {
           return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - " + r[n] + " - 1" : "" + r[n]
          }(i, n)
         }));
         return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))"
        }
        this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t[0] + " - rc - 1),\n            " + t[0] + " - rc - 1);\n          if(" + i + "){\n              result.g = getChannel(getX(" + t[0] + " - (rc  + 1) - 1),\n                " + t[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + a + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function(t) {
         return s(t)
        }(r.slice()) + ";\n          if(" + i + "){\n            result.g = " + function(t) {
         return t[n - 1] = "(" + t[n - 1] + " + 1)", s(t)
        }(r.slice()) + ";\n          }\n          if(" + o + ") {\n            result.b = " + function(t) {
         return t[n - 2] = "(" + t[n - 2] + " + 1)", s(t)
        }(r.slice()) + ";\n            if(" + i + ") {\n              result.a = " + function(t) {
         return t[n - 1] = "(" + t[n - 1] + " + 1)", t[n - 2] = "(" + t[n - 2] + " + 1)", s(t)
        }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    "
       },
       ls = function(t, e, n, r, i, o, a) {
        void 0 === a && (a = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = o;
        var s = Eo(i.length),
         u = Eo(o.length),
         c = "";
        1 === n ? c = "i" : 2 === n && (c = "i, j");
        var l = "getIndices(" + c + ")",
         h = "";
        1 === r ? h = "i" : 2 === r && (h = "i, coords[1]");
        var p = "getUpdates(" + h + ")",
         f = e > 1 ? "strides[j]" : "strides";
        this.userCode = "\n        " + s + " strides = " + s + "(" + i + ");\n\n        void main() {\n          " + u + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e + "; j++) {\n              int index = round(" + l + ");\n              flattenedIndex += index * " + f + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + p + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "
       },
       hs = function(t, e) {
        this.variableNames = ["x", "segmentIds"];
        var n = t.windowSize,
         r = t.batchSize,
         i = t.inSize,
         o = t.numSegments,
         a = o * Math.ceil(i / n);
        this.outputShape = [r, a];
        var s = 4 * Math.floor(n / 4),
         u = n % 4,
         c = "\n        sumValue += dot(values, segFilter);\n    ",
         l = "";
        i % n > 0 && (l = "\n        if (inIdx < 0 || inIdx >= " + i + ") {\n          return initializationValue;\n        }\n      ");
        var h = "";
        i % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= " + i + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + o + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + o + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c + "\n        }\n\n        int inIdx = inOffset + " + s + ";\n        if (" + (1 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c + "\n        } else if (" + (2 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c + "\n        } else if (" + (3 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c + "\n        }\n        setOutput(sumValue);\n      }\n    "
       },
       ps = function(t, e, n) {
        var r, i;
        if (this.variableNames = ["c", "a", "b"], this.outputShape = e, n > 4) throw Error("Where for rank " + n + " is not yet supported");
        if (1 === n) i = "resRC", r = "resRC";
        else {
         for (var o = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], a = [], s = [], u = 0; u < e.length; u++) s.push("" + o[u]), u < t && a.push("" + o[u]);
         r = a.join(), i = s.join()
        }
        var c = Eo(n);
        this.userCode = "\n      void main() {\n        " + c + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + i + "));\n        } else {\n          setOutput(getB(" + i + "));\n        }\n      }\n    "
       },
       fs = function() {
        function t(t) {
         this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;
         var e, n = Eo(this.rank),
          r = "uniform int start[" + this.rank + "];",
          i = function(t) {
           if (1 === t) return "sourceLoc";
           if (t <= 6) return ds.slice(0, t).map((function(t) {
            return "sourceLoc." + t
           })).join(",");
           throw Error("Slicing for rank " + t + " is not yet supported")
          }(this.rank);
         e = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + t.map((function(t, e) {
          return "sourceLoc." + ds[e] + " = start[" + e + "] + coords." + ds[e] + ";"
         })).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + e + "\n        setOutput(getSource(" + i + "));\n      }\n    "
        }
        return t.prototype.getCustomSetupFunc = function(t) {
         var e = this;
         if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
         return function(n, r) {
          null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t)
         }
        }, t
       }(),
       ds = ["x", "y", "z", "w", "u", "v"],
       vs = function() {
        function t(t) {
         this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;
         var e = Eo(this.rank),
          n = co("coords", this.rank),
          r = co("sourceLoc", this.rank),
          i = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
          o = "getChannel(getSource(" + r.join() + "), " + i + ")",
          a = "\n      result.x = " + o + ";\n      if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + o + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
          s = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + t[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + o + ";\n        if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + o + ";\n        }\n      }\n    ",
          u = this.rank <= 4 ? "sourceLoc = coords +\n            " + e + "(" + t.map((function(t, e) {
           return "start[" + e + "]"
          })).join() + ");" : t.map((function(t, e) {
           return r[e] + " = " + n[e] + " + start[" + e + "];"
          })).join("\n");
         this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e + " coords = getOutputCoords();\n        " + e + " sourceLoc;\n        " + u + "\n        vec4 result = vec4(0.);\n        " + a + "\n        " + s + "\n        setOutput(result);\n      }\n    "
        }
        return t.prototype.getCustomSetupFunc = function(t) {
         var e = this;
         if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
         return function(n, r) {
          null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t)
         }
        }, t
       }(),
       ms = function(t, e, n) {
        this.variableNames = ["x"], this.outputShape = n;
        var r = n.length,
         i = Eo(n.length),
         o = Eo(n.length),
         a = "";
        if (1 === r) a = "coords * strides + begin";
        else {
         var s = 0;
         a = n.map((function(t, e) {
          return s++, 1 === n.length ? "coords * strides[" + e + "] + begin[" + e + "]" : "coords[" + (s - 1) + "] * strides[" + e + "] + begin[" + e + "]"
         })).join(",")
        }
        this.userCode = "\n      " + i + " begin = " + i + "(" + t + ");\n      " + i + " strides = " + i + "(" + e + ");\n\n      void main() {\n        " + o + " coords = getOutputCoords();\n        setOutput(getX(" + a + "));\n      }\n    "
       },
       gs = function() {
        function t(t) {
         this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}
        }
        return t.prototype.acquireTexture = function(t, e, n) {
         var r, i = ys(e, n),
          o = bs(t, i, n);
         if (o in this.freeTextures || (this.freeTextures[o] = []), o in this.usedTextures || (this.usedTextures[o] = []), this.freeTextures[o].length > 0) {
          this.numFreeTextures--, this.numUsedTextures++, this.log();
          var a = this.freeTextures[o].shift();
          return this.usedTextures[o].push(a), a
         }
         return this.numUsedTextures++, this.log(), i === Gt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : i === Gt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : i === Gt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : i === Gt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : i === Gt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[o].push(r), r
        }, t.prototype.releaseTexture = function(t, e, n, r) {
         if (null != this.freeTextures) {
          var i = bs(e, ys(n, r), r);
          i in this.freeTextures || (this.freeTextures[i] = []), this.freeTextures[i].push(t), this.numFreeTextures++, this.numUsedTextures--;
          var o = this.usedTextures[i],
           a = o.indexOf(t);
          if (a < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
          o.splice(a, 1), this.log()
         }
        }, t.prototype.log = function() {
         if (this.logEnabled) {
          var t = this.numFreeTextures + this.numUsedTextures;
          console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t + ")")
         }
        }, t.prototype.getNumUsedTextures = function() {
         return this.numUsedTextures
        }, t.prototype.getNumFreeTextures = function() {
         return this.numFreeTextures
        }, t.prototype.dispose = function() {
         var t = this;
         if (null != this.freeTextures) {
          for (var e in this.freeTextures) this.freeTextures[e].forEach((function(e) {
           t.gpgpu.deleteMatrixTexture(e)
          }));
          for (var e in this.usedTextures) this.usedTextures[e].forEach((function(e) {
           t.gpgpu.deleteMatrixTexture(e)
          }));
          this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0
         }
        }, t
       }();
 
      function ys(t, e) {
       if (t === $t.UPLOAD) return Gt.PACKED_2X2_FLOAT32;
       if (t === $t.RENDER || null == t) return function(t) {
        return h().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16
       }(e);
       if (t === $t.DOWNLOAD || t === $t.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;
       throw new Error("Unknown logical texture type " + t)
      }
 
      function bs(t, e, n) {
       return t[0] + "_" + t[1] + "_" + e + "_" + n
      }
      var xs = function(t, e) {
        this.variableNames = ["A"];
        for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];
        this.outputShape = n, this.rank = n.length;
        var i = Eo(this.rank),
         o = function(t) {
          var e = t.length;
          if (e > 5) throw Error("Tile for rank " + e + " is not yet supported");
          if (1 === e) return "imod(resRC, " + t[0] + ")";
          for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], i = 0; i < t.length; i++) r.push("imod(" + n[i] + ", " + t[i] + ")");
          return r.join()
         }(t);
        this.userCode = "\n      void main() {\n        " + i + " resRC = getOutputCoords();\n        setOutput(getA(" + o + "));\n      }\n    "
       },
       ws = function(t, e) {
        this.variableNames = ["A"];
        for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];
        this.outputShape = n, this.rank = n.length;
        var i = Eo(this.rank),
         o = function(t) {
          var e = t.length;
          if (e > 6) throw Error("Transpose for rank " + e + " is not yet supported");
          for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(e), i = 0; i < t.length; i++) r[t[i]] = n[i];
          return r.join()
         }(e);
        this.userCode = "\n    void main() {\n      " + i + " resRC = getOutputCoords();\n      setOutput(getA(" + o + "));\n    }\n    "
       },
       Cs = function(t, e) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
        for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];
        if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
        var i = Eo(this.rank),
         o = uo("rc", this.rank),
         a = new Array(this.rank);
        for (r = 0; r < e.length; r++) a[e[r]] = o[r];
        var s = "vec2(" + a.slice(-2).join() + ")",
         u = "++" + o[this.rank - 1] + " < " + n[this.rank - 1],
         c = "getChannel(getA(" + a.join() + "), " + s + ")";
        this.userCode = "\n    void main() {\n      " + i + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c + ";\n      if(" + u + ") {\n        result[1] = " + c + ";\n      }\n      --" + o[this.rank - 1] + ";\n      if(++" + o[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + c + ";\n        if(" + u + ") {\n          result[3] = " + c + ";\n        }\n      }\n      setOutput(result);\n    }\n    "
       },
       Ss = 1.7580993408473768,
       Es = 1.0507009873554805,
       ks = function(t, e) {
        this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      float unaryOperation(float x) {\n        " + e + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
       },
       Is = "if (isnan(x)) return x;",
       Os = "return x;",
       As = "return abs(x);",
       Ns = Is + "\n  return (x < 0.0) ? 0.0 : x;\n",
       Rs = Is + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
       Ts = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
       _s = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + Ss + ";\n  float scale = " + Es + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n",
       Ds = "return -x;",
       Fs = "return ceil(x);",
       Ms = "return floor(x);",
       Ls = "return exp(x);",
       Bs = "return exp(x) - 1.0;",
       Ps = Is + "\n  return sin(x);\n",
       zs = Is + "\n  return cos(x);\n",
       js = Is + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",
       Ws = Is + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",
       Vs = Is + "\n  return atan(x);\n",
       Us = Is + "return log(x + sqrt(x * x + 1.0));",
       Hs = Is + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",
       $s = Is + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",
       Gs = "return x;",
       qs = "return x;",
       Ks = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
       Xs = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
       Ys = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
       Zs = function(t, e) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
       },
       Js = function(t) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;
        var e = t.length,
         n = co("rc", e),
         r = Eo(e),
         i = function(t, e) {
          if (1 === t) return "rc";
          for (var n = "", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += ",");
          return n
         }(e, n),
         o = n.slice(-2),
         a = e <= 1 ? "rc" : "vec2(" + o.join(",") + ")";
        this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + i + ");\n\n        setOutput(getChannel(packedInput, " + a + "));\n      }\n    "
       },
       Qs = {};
 
      function tu(t, e) {
       if (void 0 === e && (e = !1), "linear" === t) return e ? qs : Os;
       if ("relu" === t) return e ? Ks : Ns;
       if ("elu" === t) return e ? Ys : Ts;
       if ("relu6" === t) return e ? Xs : Rs;
       if ("prelu" === t) return e ? jo : Po;
       throw new Error("Activation " + t + " has not been implemented for the WebGL backend.")
      }
      var eu = 600,
       nu = function(t) {
        function e(e) {
         var n, r = t.call(this) || this;
         if (r.pendingRead = new WeakMap, r.pendingDisposal = new WeakSet, r.dataRefCount = new WeakMap, r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !h().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
         if (null == e) {
          var i = Yt(h().getNumber("WEBGL_VERSION"));
          r.binaryCache = (n = h().getNumber("WEBGL_VERSION")) in Qs ? Qs[n] : (Qs[n] = {}, Qs[n]), r.gpgpu = new za(i), r.canvas = i.canvas, r.gpgpuCreatedLocally = !0
         } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;
         return r.textureManager = new gs(r.gpgpu), r.numMBBeforeWarning = null == h().global.screen ? 1024 : h().global.screen.height * h().global.screen.width * window.devicePixelRatio * eu / 1024 / 1024, r.texData = new wi(r, Wt), r
        }
        return a(e, t), e.prototype.numDataIds = function() {
         return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes
        }, e.prototype.write = function(t, e, n) {
         if (h().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === n && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
         var r = {};
         return this.texData.set(r, {
          shape: e,
          dtype: n,
          values: t,
          usage: $t.UPLOAD
         }), r
        }, e.prototype.move = function(t, e, n, r) {
         if (h().getBool("DEBUG") && this.checkNumericalProblems(e), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
         this.texData.set(t, {
          shape: n,
          dtype: r,
          values: e,
          usage: $t.UPLOAD
         })
        }, e.prototype.readSync = function(t) {
         var e = this.texData.get(t),
          n = e.values,
          r = e.dtype,
          i = e.complexTensors,
          o = e.slice,
          a = e.shape,
          s = e.isPacked;
         if (null != o) {
          var u = void 0;
          u = s ? new Zs(a, Gs) : new ks(a, Gs);
          var c = this.runWebGLProgram(u, [{
            dataId: t,
            shape: a,
            dtype: r
           }], r),
           l = this.readSync(c.dataId);
          return this.disposeData(c.dataId), l
         }
         if (null != n) return this.convertAndCacheOnCPU(t);
         if ("string" === r) return n;
         var h, p, f = null != this.activeTimers;
         return f && (h = at()), p = "complex64" === r ? Ui(i.real.dataSync(), i.imag.dataSync()) : this.getValuesFromTexture(t), f && (this.downloadWaitMs += at() - h), this.convertAndCacheOnCPU(t, p)
        }, e.prototype.read = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n, r, i, o, a, s, c, l, p, f, d, v, m, g, y, b, x, w, C, S, E;
          return u(this, (function(u) {
           switch (u.label) {
            case 0:
             if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise((function(t) {
              return e.push(t)
             }))];
             if (n = this.texData.get(t), r = n.values, i = n.shape, o = n.slice, a = n.dtype, s = n.complexTensors, c = n.isPacked, null != o) return l = void 0, l = c ? new Zs(i, Gs) : new ks(i, Gs), p = this.runWebGLProgram(l, [{
              dataId: t,
              shape: i,
              dtype: a
             }], a), f = this.read(p.dataId), this.disposeData(p.dataId), [2, f];
             if (null != r) return [2, this.convertAndCacheOnCPU(t)];
             if (!h().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === h().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
             return d = null, "complex64" !== a && h().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t), m = this.texData.get(v.dataId), d = (E = this.gpgpu).createBufferFromTexture.apply(E, [m.texture].concat(Jt(i)))), this.pendingRead.set(t, []), "complex64" === a ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
            case 1:
             u.sent(), u.label = 2;
            case 2:
             return "complex64" !== a ? [3, 4] : [4, Promise.all([s.real.data(), s.imag.data()])];
            case 3:
             return y = u.sent(), b = y[0], x = y[1], g = Ui(b, x), [3, 5];
            case 4:
             null == d ? g = this.getValuesFromTexture(t) : (w = T(i), g = this.gpgpu.downloadFloat32MatrixFromBuffer(d, w)), u.label = 5;
            case 5:
             return null != v && this.disposeData(v.dataId), C = this.convertAndCacheOnCPU(t, g), S = this.pendingRead.get(t), this.pendingRead.delete(t), S.forEach((function(t) {
              return t(C)
             })), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, C]
           }
          }))
         }))
        }, e.prototype.checkNumericalProblems = function(t) {
         if (null != t)
          for (var e = 0; e < t.length; e++) {
           var n = t[e];
           if (!ie(n)) {
            if (h().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
            throw Error("The value " + n + " cannot be represented on this device.")
           }
          }
        }, e.prototype.getValuesFromTexture = function(t) {
         var e, n = this.texData.get(t),
          r = n.shape,
          i = n.dtype,
          o = n.isPacked,
          a = T(r);
         if (h().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
          var s = this.decode(t),
           u = this.texData.get(s.dataId),
           c = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [u.texture].concat(Jt(r))).subarray(0, a);
          return this.disposeData(s.dataId), c
         }
         var l = h().getBool("WEBGL_PACK") && !0 === o,
          p = l ? De(r) : r,
          f = l ? new pa(p) : new ha(p),
          d = this.runWebGLProgram(f, [{
           shape: p,
           dtype: i,
           dataId: t
          }], "float32"),
          v = this.texData.get(d.dataId),
          m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, a);
         return this.disposeData(d.dataId), m
        }, e.prototype.time = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n, r, i, o, a, s;
          return u(this, (function(u) {
           switch (u.label) {
            case 0:
             return e = this.activeTimers, n = [], r = !1, null == this.programTimersStack ? (this.programTimersStack = n, r = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), i = R(this.activeTimers.map((function(t) {
              return t.query
             }))).filter((function(t) {
              return null != t
             })), o = R(this.activeTimers.map((function(t) {
              return t.name
             }))).filter((function(t) {
              return null != t
             })), this.activeTimers = e, r && (this.programTimersStack = null), [4, Promise.all(i)];
            case 1:
             return a = u.sent(), s = {
              uploadWaitMs: this.uploadWaitMs,
              downloadWaitMs: this.downloadWaitMs,
              kernelMs: I(a),
              getExtraProfileInfo: function() {
               return a.map((function(t, e) {
                return {
                 name: o[e],
                 ms: t
                }
               })).map((function(t) {
                return t.name + ": " + t.ms
               })).join(", ")
              },
              wallMs: null
             }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s]
           }
          }))
         }))
        }, e.prototype.memory = function() {
         return {
          unreliable: !1,
          numBytesInGPU: this.numBytesInGPU
         }
        }, e.prototype.startTimer = function() {
         return h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : {
          startMs: at(),
          endMs: null
         }
        }, e.prototype.endTimer = function(t) {
         return h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = at(), t)
        }, e.prototype.getQueryTime = function(t) {
         return s(this, void 0, void 0, (function() {
          var e;
          return u(this, (function(n) {
           return h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs]
          }))
         }))
        }, e.prototype.disposeData = function(t) {
         if (!this.pendingDisposal.has(t)) {
          if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;
          if (this.texData.has(t)) {
           this.releaseGPUData(t);
           var e = this.texData.get(t).complexTensors;
           null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t)
          }
         }
        }, e.prototype.releaseGPUData = function(t) {
         var e = this.texData.get(t),
          n = e.texture,
          r = e.dtype,
          i = e.texShape,
          o = e.usage,
          a = e.isPacked,
          s = e.slice,
          u = s && s.origDataId || t,
          c = this.dataRefCount.get(u);
         c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(i, r), this.textureManager.releaseTexture(n, i, o, a)));
         var l = this.texData.get(t);
         l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null
        }, e.prototype.getTexture = function(t) {
         return this.uploadToGPU(t), this.texData.get(t).texture
        }, e.prototype.getDataInfo = function(t) {
         return this.texData.get(t)
        }, e.prototype.getCPUBackend = function() {
         return h().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Wt.findBackend("cpu")), this.cpuBackend) : null
        }, e.prototype.shouldExecuteOnCPU = function(t, e) {
         var n = this;
         return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every((function(t) {
          return null == n.texData.get(t.dataId).texture && t.size < e
         }))
        }, e.prototype.getGPGPUContext = function() {
         return this.gpgpu
        }, e.prototype.complex = function(t, e) {
         var n = this.makeOutput(t.shape, "complex64");
         return this.texData.get(n.dataId).complexTensors = {
          real: Wt.keep(t.clone()),
          imag: Wt.keep(e.clone())
         }, n
        }, e.prototype.real = function(t) {
         return this.texData.get(t.dataId).complexTensors.real.clone()
        }, e.prototype.imag = function(t) {
         return this.texData.get(t.dataId).complexTensors.imag.clone()
        }, e.prototype.slice = function(t, e, n) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);
         if (0 === T(n)) return Mn([], n, t.dtype);
         var r = this.texData.get(t.dataId).isPacked,
          i = ci(t.shape, e, n);
         if (r || !i) {
          var o = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new vs(n) : new fs(n),
           a = o.getCustomSetupFunc(e);
          return this.compileAndRun(o, [t], null, a)
         }
         return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n)
        }, e.prototype.shallowSlice = function(t, e, n) {
         var r = this.texData.get(t.dataId),
          i = this.makeOutput(n, t.dtype),
          o = this.texData.get(i.dataId);
         Object.assign(o, r), o.shape = n, o.dtype = t.dtype;
         var a = li(e, t.strides);
         r.slice && (a += r.slice.flatOffset), o.slice = {
          flatOffset: a,
          origDataId: r.slice && r.slice.origDataId || t.dataId
         };
         var s = this.dataRefCount.get(o.slice.origDataId) || 1;
         return this.dataRefCount.set(o.slice.origDataId, s + 1), i
        }, e.prototype.stridedSlice = function(t, e, n, r) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);
         var i = ai(e, n, r);
         if (i.some((function(t) {
           return 0 === t
          }))) return Mn([], i);
         var o = new ms(e, r, i);
         return this.compileAndRun(o, [t])
        }, e.prototype.reverse = function(t, e) {
         var n = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new cs(t.shape, e) : new us(t.shape, e);
         return this.compileAndRun(n, [t])
        }, e.prototype.concat = function(t, e) {
         if ("complex64" === t[0].dtype) {
          var n = t.map((function(t) {
            return Dn(t)
           })),
           r = t.map((function(t) {
            return Fn(t)
           }));
          return _n(this.concat(n, e), this.concat(r, e))
         }
         if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
         if (1 === t.length) return t[0];
         if (t.length > h().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var i = Math.floor(t.length / 2),
           o = this.concat(t.slice(0, i), e),
           a = this.concat(t.slice(i), e);
          return this.concat([o, a], e)
         }
         if (h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
          var s = new Go(t.map((function(t) {
           return t.shape
          })), e);
          return this.compileAndRun(s, t)
         }
         var u = Rn(t.map((function(t) {
           return t.shape
          })), e),
          c = t.map((function(t) {
           return t.as2D(-1, T(t.shape.slice(e)))
          })),
          l = new $o(c.map((function(t) {
           return t.shape
          })));
         return this.compileAndRun(l, c).reshape(u)
        }, e.prototype.neg = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ds, t.dtype);
         var e = new ks(t.shape, Ds);
         return this.compileAndRun(e, [t])
        }, e.prototype.batchMatMul = function(t, e, n, r) {
         var i = n ? t.shape[2] : t.shape[1],
          o = r ? e.shape[1] : e.shape[2],
          a = n ? t.shape[1] : t.shape[2],
          s = t.shape[0];
         if ((1 === i || 1 === o) && a > 1e3) {
          n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));
          var u = 1 === o ? t : t.as3D(s, a, 1),
           c = 1 === o ? 2 : 1,
           l = 1 === o ? e.as3D(s, 1, a) : e;
          return this.multiply(u, l).sum(c, !0)
         }
         var h = _t(t.dtype, e.dtype),
          p = new qa(t.shape, [s, i, o], n, r);
         return this.compileAndRun(p, [t, e], h)
        }, e.prototype.fusedBatchMatMul = function(t) {
         var e = t.a,
          n = t.b,
          r = t.transposeA,
          i = t.transposeB,
          o = t.bias,
          a = t.activation,
          s = t.preluActivationWeights,
          u = r ? e.shape[2] : e.shape[1],
          c = i ? n.shape[1] : n.shape[2],
          l = e.shape[0],
          h = _t(e.dtype, n.dtype),
          p = null != o,
          f = null != s,
          d = a ? tu(a, !0) : null,
          v = new qa(e.shape, [l, u, c], r, i, p, d, f),
          m = [e, n];
         return o && m.push(o), s && m.push(s), this.compileAndRun(v, m, h)
        }, e.prototype.multiply = function(t, e) {
         if ("complex64" === t.dtype) {
          var n = this.texData.get(t.dataId),
           r = this.texData.get(e.dataId),
           i = new Fo(_o, t.shape, e.shape),
           o = new Fo(Do, t.shape, e.shape),
           a = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],
           s = this.compileAndRun(i, a),
           u = this.compileAndRun(o, a),
           c = this.complex(s, u);
          return s.dispose(), u.dispose(), c
         }
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, Bo, t.dtype);
         var l = new zo(Bo, t.shape, e.shape);
         return this.compileAndRun(l, [t, e], t.dtype)
        }, e.prototype.batchNormalization = function(t, e, n, r, i, o) {
         var a = [t, e, n],
          s = null;
         null != o && (s = o.shape, a.push(o));
         var u = null;
         if (null != i && (u = i.shape, a.push(i)), h().getBool("WEBGL_PACK_NORMALIZATION")) {
          var c = new To(t.shape, e.shape, n.shape, s, u, r);
          return this.compileAndRun(c, a)
         }
         var l = new Ro(t.shape, e.shape, n.shape, s, u, r);
         return this.compileAndRun(l, a)
        }, e.prototype.localResponseNormalization4D = function(t, e, n, r, i) {
         var o = h().getBool("WEBGL_PACK_NORMALIZATION") ? new Ha(t.shape, e, n, r, i) : new Va(t.shape, e, n, r, i);
         return this.compileAndRun(o, [t])
        }, e.prototype.LRNGrad = function(t, e, n, r, i, o, a) {
         var s = new Ua(e.shape, r, i, o, a);
         return this.compileAndRun(s, [e, n, t])
        }, e.prototype.tile = function(t, e) {
         if ("string" === t.dtype) {
          var n = this.readSync(t.dataId).map((function(t) {
           return ct(t)
          }));
          return no(mr(t.shape, t.dtype, n), e)
         }
         var r = new xs(t.shape, e);
         return this.compileAndRun(r, [t])
        }, e.prototype.pad = function(t, e, n) {
         var r = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ja(t.shape, e, n) : new Za(t.shape, e, n);
         return this.compileAndRun(r, [t])
        }, e.prototype.transpose = function(t, e) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);
         var n = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Cs(t.shape, e) : new ws(t.shape, e);
         return this.compileAndRun(n, [t])
        }, e.prototype.gather = function(t, e, n) {
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);
         var r = new ba(t.shape, e.size, n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.batchToSpaceND = function(t, e, n) {
         O(t.rank <= 4, (function() {
          return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"
         }));
         var r = e.reduce((function(t, e) {
           return t * e
          })),
          i = $r(t.shape, e, r),
          o = Gr(i.length, e.length),
          a = qr(t.shape, e, r),
          s = Kr(n, e.length),
          u = Xr(a, n, e.length);
         return t.reshape(i).transpose(o).reshape(a).slice(s, u)
        }, e.prototype.spaceToBatchND = function(t, e, n) {
         O(t.rank <= 4, (function() {
          return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"
         }));
         var r = e.reduce((function(t, e) {
           return t * e
          })),
          i = [
           [0, 0]
          ];
         i.push.apply(i, n);
         for (var o = 1 + e.length; o < t.shape.length; ++o) i.push([0, 0]);
         var a = t.pad(i),
          s = $r(a.shape, e, r, !1),
          u = Gr(s.length, e.length, !1),
          c = qr(a.shape, e, r, !1);
         return a.reshape(s).transpose(u).reshape(c)
        }, e.prototype.reduce = function(t, e, n) {
         var r = t.shape[0],
          i = t.shape[1],
          o = Qr(i),
          a = new es({
           windowSize: o,
           inSize: i,
           batchSize: r
          }, e),
          s = this.compileAndRun(a, [t], n);
         return 1 === s.shape[1] ? s : this.reduce(s, e, n)
        }, e.prototype.argReduce = function(t, e, n) {
         void 0 === n && (n = null);
         var r = t.shape[0],
          i = t.shape[1];
         null != n && (r = n.shape[0], i = n.shape[1]);
         var o = Qr(i),
          a = new so({
           windowSize: o,
           inSize: i,
           batchSize: r
          }, e, null == n),
          s = [t];
         null != n && s.push(n);
         var u = this.compileAndRun(a, s, "int32");
         return 1 === u.shape[1] ? u : this.argReduce(t, e, u)
        }, e.prototype.argReducePacked = function(t, e, n) {
         void 0 === n && (n = null);
         var r = null != n ? n.shape : t.shape,
          i = Qr(r[r.length - 1]),
          o = new Oo(r, i, e, null == n),
          a = null == n ? [t] : [t, n],
          s = this.compileAndRun(o, a, "int32");
         return s.rank === t.rank ? this.argReducePacked(t, e, s) : s
        }, e.prototype.sum = function(t, e) {
         kn("sum", e, t.rank);
         var n = Sn(t.shape, e),
          r = n[0],
          i = T(n[1]),
          o = t.as2D(-1, i),
          a = Dt(t.dtype);
         return this.reduce(o, "sum", a).reshape(r)
        }, e.prototype.prod = function(t, e) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
         var n = Sn(t.shape, e),
          r = n[0],
          i = T(n[1]),
          o = t.as2D(-1, i),
          a = Dt(t.dtype);
         return this.reduce(o, "prod", a).reshape(r)
        }, e.prototype.unsortedSegmentSum = function(t, e, n) {
         var r = 0,
          i = In([r], t.rank),
          o = t;
         null != i && (o = t.transpose(i), r = An(1, t.rank)[0]);
         var a = function(t, e, n) {
           for (var r = [], i = t.length, o = 0; o < i; o++) o !== e ? r.push(t[o]) : r.push(n);
           return r
          }(o.shape, r, n),
          s = T([o.shape[r]]),
          u = o.as2D(-1, s),
          c = Dt(t.dtype),
          l = this.segOpCompute(u, "unsortedSegmentSum", e, c, n).reshape(a);
         return null != i && (l = l.transpose(On(i))), l
        }, e.prototype.segOpCompute = function(t, e, n, r, i) {
         var o = t.shape[0],
          a = t.shape[1],
          s = function(t, e) {
           var n, r = !1;
           for (t <= Jr ? (n = t, r = !0) : n = tt(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = tt(t, n + 1);
           return n
          }(a, i),
          u = new hs({
           windowSize: s,
           inSize: a,
           batchSize: o,
           numSegments: i
          }, e),
          c = this.compileAndRun(u, [t, n], r);
         return c.shape[1] === i ? c : (n = Xn(0, i).tile([a / s]), this.segOpCompute(c, e, n, r, i))
        }, e.prototype.argMinMaxReduce = function(t, e, n) {
         var r = [e];
         if (kn("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !h().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
          var i = Sn(t.shape, r),
           o = i[0],
           a = T(i[1]),
           s = t.as2D(-1, a);
          return this.argReduce(s, n).reshape(o)
         }
         return this.argReducePacked(t, n)
        }, e.prototype.argMin = function(t, e) {
         return this.argMinMaxReduce(t, e, "min")
        }, e.prototype.argMax = function(t, e) {
         return this.argMinMaxReduce(t, e, "max")
        }, e.prototype.cumsum = function(t, e, n, r) {
         if (e !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
         var i = new oa(t.shape, n, r);
         return this.compileAndRun(i, [t])
        }, e.prototype.equal = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(equal(a, b));\n", "bool");
         var n = new zo("return float(a == b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.notEqual = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(notEqual(a, b));\n", "bool");
         var n = new zo("return float(a != b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.less = function(t, e) {
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThan(a, b));\n", "bool");
         var n = new zo("return float(a < b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.lessEqual = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
         var n = new zo("return float(a <= b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.greater = function(t, e) {
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThan(a, b));\n", "bool");
         var n = new zo("return float(a > b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.greaterEqual = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
         var n = new zo("return float(a >= b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.logicalNot = function(t) {
         var e = new ks(t.shape, "return float(!(x >= 1.0));");
         return this.compileAndRun(e, [t])
        }, e.prototype.logicalAnd = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
         var n = new zo("return float(a >= 1.0 && b >= 1.0);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.logicalOr = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
         var n = new zo("return float(a >= 1.0 || b >= 1.0);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "bool")
        }, e.prototype.select = function(t, e, n) {
         var r = new ps(t.rank, e.shape, e.rank);
         return this.compileAndRun(r, [t, e, n], _t(e.dtype, n.dtype))
        }, e.prototype.where = function(t) {
         mn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
         var e = t.dataSync();
         return io(t.shape, e)
        }, e.prototype.topk = function(t, e, n) {
         return ro(t.dataSync(), t.shape, t.dtype, e)
        }, e.prototype.min = function(t, e) {
         kn("min", e, t.rank);
         var n = Sn(t.shape, e),
          r = n[0],
          i = T(n[1]),
          o = t.as2D(-1, i);
         return this.reduce(o, "min", o.dtype).reshape(r)
        }, e.prototype.minimum = function(t, e) {
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new zo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.mod = function(t, e) {
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new zo("if (b == 0.0) return NAN;\n  return mod(a, b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.max = function(t, e) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
         kn("max", e, t.rank);
         var n = Sn(t.shape, e),
          r = n[0],
          i = T(n[1]),
          o = t.as2D(-1, i);
         return this.reduce(o, "max", o.dtype).reshape(r)
        }, e.prototype.maximum = function(t, e) {
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new zo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.all = function(t, e) {
         kn("all", e, t.rank);
         var n = Sn(t.shape, e),
          r = n[0],
          i = T(n[1]),
          o = t.as2D(-1, i);
         return this.reduce(o, "all", o.dtype).reshape(r)
        }, e.prototype.any = function(t, e) {
         kn("any", e, t.rank);
         var n = Sn(t.shape, e),
          r = n[0],
          i = T(n[1]),
          o = t.as2D(-1, i);
         return this.reduce(o, "any", o.dtype).reshape(r)
        }, e.prototype.squaredDifference = function(t, e) {
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("return (a - b) * (a - b);", t.shape, e.shape) : new zo("return (a - b) * (a - b);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.realDivide = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", !0);
         var n = new zo("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "float32")
        }, e.prototype.floorDiv = function(t, e) {
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
         var n = new zo("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t.shape, e.shape);
         return this.compileAndRun(n, [t, e], "int32")
        }, e.prototype.add = function(t, e) {
         if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, Mo);
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);
         var n = _t(t.dtype, e.dtype);
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, Mo, n);
         var r = new zo(Mo, t.shape, e.shape);
         return this.compileAndRun(r, [t, e], n)
        }, e.prototype.packedUnaryOp = function(t, e, n) {
         var r = new Zs(t.shape, e);
         return this.compileAndRun(r, [t], n)
        }, e.prototype.packedBinaryOp = function(t, e, n, r, i) {
         void 0 === i && (i = !1);
         var o = new Wo(n, t.shape, e.shape, i);
         return this.compileAndRun(o, [t, e], r)
        }, e.prototype.complexSeparableBinaryOp = function(t, e, n) {
         var r = this,
          i = this.texData.get(t.dataId),
          o = this.texData.get(e.dataId),
          a = [
           [i.complexTensors.real, o.complexTensors.real],
           [i.complexTensors.imag, o.complexTensors.imag]
          ].map((function(i) {
           var o = i[0],
            a = i[1],
            s = r.makeComplexComponentTensorInfo(t, o),
            u = r.makeComplexComponentTensorInfo(e, a),
            c = new zo(n, t.shape, e.shape);
           return r.compileAndRun(c, [s, u], _t(o.dtype, a.dtype))
          })),
          s = a[0],
          u = a[1],
          c = this.complex(s, u);
         return s.dispose(), u.dispose(), c
        }, e.prototype.makeComplexComponentTensorInfo = function(t, e) {
         return {
          dataId: e.dataId,
          dtype: e.dtype,
          shape: t.shape
         }
        }, e.prototype.addN = function(t) {
         if (1 === t.length) return t[0];
         if (t.length > h().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var e = Math.floor(t.length / 2),
           n = this.addN(t.slice(0, e)),
           r = this.addN(t.slice(e));
          return this.addN([n, r])
         }
         var i = t.map((function(t) {
           return t.dtype
          })).reduce((function(t, e) {
           return _t(t, e)
          })),
          o = t.map((function(t) {
           return t.shape
          })),
          a = h().getBool("WEBGL_PACK") ? new ao(t[0].shape, o) : new oo(t[0].shape, o);
         return this.compileAndRun(a, t, i)
        }, e.prototype.subtract = function(t, e) {
         if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, Lo);
         if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);
         var n = _t(t.dtype, e.dtype);
         if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, Lo, t.dtype);
         var r = new zo(Lo, t.shape, e.shape);
         return this.compileAndRun(r, [t, e], n)
        }, e.prototype.pow = function(t, e) {
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new zo("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t.shape, e.shape),
          r = _t(t.dtype, e.dtype);
         return this.compileAndRun(n, [t, e], r)
        }, e.prototype.ceil = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Fs, t.dtype);
         var e = new ks(t.shape, Fs);
         return this.compileAndRun(e, [t])
        }, e.prototype.floor = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ms, t.dtype);
         var e = new ks(t.shape, Ms);
         return this.compileAndRun(e, [t])
        }, e.prototype.sign = function(t) {
         var e = new ks(t.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
         return this.compileAndRun(e, [t])
        }, e.prototype.isNaN = function(t) {
         var e = new ks(t.shape, "return float(isnan(x));");
         return this.compileAndRun(e, [t], "bool")
        }, e.prototype.isInf = function(t) {
         var e = new ks(t.shape, "return float(isinf(x));");
         return this.compileAndRun(e, [t], "bool")
        }, e.prototype.isFinite = function(t) {
         var e = new ks(t.shape, "return float(!isnan(x) && !isinf(x));");
         return this.compileAndRun(e, [t], "bool")
        }, e.prototype.round = function(t) {
         var e = new ks(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
         return this.compileAndRun(e, [t])
        }, e.prototype.exp = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ls, t.dtype);
         var e = new ks(t.shape, Ls);
         return this.compileAndRun(e, [t])
        }, e.prototype.expm1 = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Bs, t.dtype);
         var e = new ks(t.shape, Bs);
         return this.compileAndRun(e, [t])
        }, e.prototype.log = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t.dtype);
         var e = new ks(t.shape, "if (x < 0.0) return NAN;\n  return log(x);");
         return this.compileAndRun(e, [t])
        }, e.prototype.log1p = function(t) {
         var e = new ks(t.shape, "return log(1.0 + x);");
         return this.compileAndRun(e, [t])
        }, e.prototype.sqrt = function(t) {
         var e = new ks(t.shape, "return sqrt(x);");
         return this.compileAndRun(e, [t])
        }, e.prototype.rsqrt = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
         var e = new ks(t.shape, "return inversesqrt(x);");
         return this.compileAndRun(e, [t])
        }, e.prototype.reciprocal = function(t) {
         var e = new ks(t.shape, "return 1.0 / x;");
         return this.compileAndRun(e, [t])
        }, e.prototype.relu = function(t) {
         var e;
         return e = h().getBool("WEBGL_PACK") ? new Zs(t.shape, Ks) : new ks(t.shape, Ns), this.compileAndRun(e, [t])
        }, e.prototype.relu6 = function(t) {
         var e;
         return e = h().getBool("WEBGL_PACK") ? new Zs(t.shape, Xs) : new ks(t.shape, Rs), this.compileAndRun(e, [t])
        }, e.prototype.prelu = function(t, e) {
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo(jo, t.shape, e.shape) : new zo(Po, t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.elu = function(t) {
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ys, t.dtype);
         var e = new ks(t.shape, Ts);
         return this.compileAndRun(e, [t])
        }, e.prototype.eluDer = function(t, e) {
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t.shape, e.shape) : new zo("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.selu = function(t) {
         var e = new ks(t.shape, _s);
         return this.compileAndRun(e, [t])
        }, e.prototype.int = function(t) {
         var e = new ks(t.shape, "return float(int(x));");
         return this.compileAndRun(e, [t], "int32")
        }, e.prototype.clip = function(t, e, n) {
         var r, i = (r = h().getBool("WEBGL_PACK_CLIP") ? new Uo(t.shape) : new Vo(t.shape)).getCustomSetupFunc(e, n);
         return this.compileAndRun(r, [t], null, i)
        }, e.prototype.abs = function(t) {
         if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
         if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, As, t.dtype);
         var e = new ks(t.shape, As);
         return this.compileAndRun(e, [t])
        }, e.prototype.complexAbs = function(t) {
         var e = this.texData.get(t.dataId),
          n = new Ho(t.shape),
          r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];
         return this.compileAndRun(n, r)
        }, e.prototype.sigmoid = function(t) {
         var e = new ks(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
         return this.compileAndRun(e, [t])
        }, e.prototype.softplus = function(t) {
         var e = new ks(t.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
         return this.compileAndRun(e, [t])
        }, e.prototype.sin = function(t) {
         var e = new ks(t.shape, Ps);
         return this.compileAndRun(e, [t])
        }, e.prototype.cos = function(t) {
         var e = new ks(t.shape, zs);
         return this.compileAndRun(e, [t])
        }, e.prototype.tan = function(t) {
         var e = new ks(t.shape, "return tan(x);");
         return this.compileAndRun(e, [t])
        }, e.prototype.asin = function(t) {
         var e = new ks(t.shape, js);
         return this.compileAndRun(e, [t])
        }, e.prototype.acos = function(t) {
         var e = new ks(t.shape, Ws);
         return this.compileAndRun(e, [t])
        }, e.prototype.atan = function(t) {
         var e = new ks(t.shape, Vs);
         return this.compileAndRun(e, [t])
        }, e.prototype.atan2 = function(t, e) {
         var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Wo("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new zo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t.shape, e.shape);
         return this.compileAndRun(n, [t, e])
        }, e.prototype.sinh = function(t) {
         var e = new ks(t.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
         return this.compileAndRun(e, [t])
        }, e.prototype.cosh = function(t) {
         var e = new ks(t.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
         return this.compileAndRun(e, [t])
        }, e.prototype.tanh = function(t) {
         var e = new ks(t.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
         return this.compileAndRun(e, [t])
        }, e.prototype.asinh = function(t) {
         var e = new ks(t.shape, Us);
         return this.compileAndRun(e, [t])
        }, e.prototype.acosh = function(t) {
         var e = new ks(t.shape, Hs);
         return this.compileAndRun(e, [t])
        }, e.prototype.atanh = function(t) {
         var e = new ks(t.shape, $s);
         return this.compileAndRun(e, [t])
        }, e.prototype.erf = function(t) {
         var e = new ks(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
         return this.compileAndRun(e, [t])
        }, e.prototype.step = function(t, e) {
         var n = new ks(t.shape, function(t) {
          return void 0 === t && (t = 0), Is + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  "
         }(e));
         return this.compileAndRun(n, [t])
        }, e.prototype.conv2dByMatMul = function(t, e, n, r, i, o) {
         var a = t.shape,
          s = this.texData.get(t.dataId),
          u = n.inChannels,
          c = a[0] * a[1] * a[2],
          l = n.outChannels,
          p = "channelsLast" === n.dataFormat,
          f = (1 === c || 1 === l) && u > 1e3,
          d = a[2] % 2 != 0 && !!s.isPacked;
         if (f || !h().getBool("WEBGL_LAZILY_UNPACK") || !h().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d) {
          var v = p ? a[0] * a[1] * a[2] : a[0] * a[2] * a[3],
           m = this.reshape(t, [1, v, n.inChannels]),
           g = this.reshape(e, [1, n.inChannels, n.outChannels]);
          return this.reshape(this.fusedBatchMatMul({
           a: m,
           b: g,
           transposeA: !1,
           transposeB: !1,
           bias: r,
           activation: i,
           preluActivationWeights: o
          }), n.outShape)
         }
         var y = p ? a[0] * a[1] * (a[2] + 1) : a[0] * a[2] * (a[3] + 1),
          b = {
           dataId: t.dataId,
           shape: [1, y, n.inChannels],
           dtype: t.dtype
          },
          x = s.shape;
         s.shape = s.shape.slice(), s.shape[s.shape.length - 2]++, O(Le(s.shape, b.shape), (function() {
          return "packed reshape " + s.shape + " to " + b.shape + " isn't free"
         }));
         var w = this.reshape(e, [1, n.inChannels, n.outChannels]),
          C = this.fusedBatchMatMul({
           a: b,
           b: w,
           transposeA: !1,
           transposeB: !1,
           bias: r,
           activation: i,
           preluActivationWeights: o
          }),
          S = this.texData.get(C.dataId);
         return O(S.isPacked, (function() {
          return "batchMatMul result is expected to be packed"
         })), s.shape = x, S.shape = n.outShape, Wt.makeTensorFromDataId(C.dataId, n.outShape, C.dtype)
        }, e.prototype.conv2dWithIm2Row = function(t, e, n, r, i, o) {
         var a = n.filterWidth,
          s = n.filterHeight,
          u = n.inChannels,
          c = n.outWidth,
          l = n.outHeight,
          h = "channelsLast" === n.dataFormat,
          p = a * s * u,
          f = l * c,
          d = [p, f],
          v = t.squeeze([0]),
          m = e.reshape([1, p, -1]),
          g = new Wa(d, v.shape, n),
          y = this.compileAndRun(g, [v]).reshape([1, d[0], d[1]]),
          b = null != r,
          x = null != o,
          w = i ? tu(i, !0) : null,
          C = new qa(y.shape, [1, f, n.outChannels], !0, !1, b, w, x),
          S = [y, m];
         r && S.push(r), x && S.push(o);
         var E = this.compileAndRun(C, S);
         return h ? E.reshape([1, l, c, n.outChannels]) : E.reshape([1, n.outChannels, l, c])
        }, e.prototype.fusedConv2d = function(t) {
         var e = t.input,
          n = t.filter,
          r = t.convInfo,
          i = t.bias,
          o = t.activation,
          a = t.preluActivationWeights;
         if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, i, o, a);
         if (h().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, i, o, a);
         var s = null != i,
          u = null != a,
          c = o ? tu(o, !1) : null,
          l = new ta(r, s, c, u),
          p = [e, n];
         return i && p.push(i), a && p.push(a), this.compileAndRun(l, p)
        }, e.prototype.conv2d = function(t, e, n) {
         if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);
         if (h().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);
         var r = new ta(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.conv2dDerInput = function(t, e, n) {
         var r = new Xo(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.conv2dDerFilter = function(t, e, n) {
         var r = new Ko(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.fusedDepthwiseConv2D = function(t) {
         var e, n = t.input,
          r = t.filter,
          i = t.convInfo,
          o = t.bias,
          a = t.activation,
          s = t.preluActivationWeights,
          u = h().getBool("WEBGL_PACK_DEPTHWISECONV") && i.strideWidth <= 2 && i.outChannels / i.inChannels == 1,
          c = a ? tu(a, u) : null,
          l = [n, r],
          p = null != o,
          f = null != s;
         return p && l.push(o), f && l.push(s), u ? (e = new ra(i, p, c, f), this.compileAndRun(e, l)) : (e = new na(i, p, c, f), this.compileAndRun(e, l))
        }, e.prototype.depthwiseConv2D = function(t, e, n) {
         var r;
         return h().getBool("WEBGL_PACK_DEPTHWISECONV") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new ra(n), this.compileAndRun(r, [t, e])) : (r = new na(n), this.compileAndRun(r, [t, e]))
        }, e.prototype.depthwiseConv2DDerInput = function(t, e, n) {
         var r = new Qo(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
         var r = new Jo(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.conv3d = function(t, e, n) {
         var r = new ea(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.conv3dDerInput = function(t, e, n) {
         var r = new Zo(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.conv3dDerFilter = function(t, e, n) {
         var r = new Yo(n);
         return this.compileAndRun(r, [t, e])
        }, e.prototype.maxPool = function(t, e) {
         var n = new Qa(e, "max", !1);
         return this.compileAndRun(n, [t])
        }, e.prototype.avgPool = function(t, e) {
         var n = new Qa(e, "avg", !1);
         return this.compileAndRun(n, [t], "float32")
        }, e.prototype.maxPoolBackprop = function(t, e, n, r) {
         var i = new Qa(r, "max", !0),
          o = this.compileAndRun(i, [e]),
          a = new $a(r),
          s = this.compileAndRun(a, [t, o], e.dtype);
         return o.dispose(), s
        }, e.prototype.avgPoolBackprop = function(t, e, n) {
         var r = new Ao(n);
         return this.compileAndRun(r, [t], e.dtype)
        }, e.prototype.cast = function(t, e) {
         return zi(t, e, this)
        }, e.prototype.unstack = function(t, e) {
         for (var n = t.shape[e], r = new Array(t.rank - 1), i = 0, o = 0; o < t.rank; o++) o !== e && (r[i++] = t.shape[o]);
         var a = new Array(t.rank).fill(0),
          s = t.shape.slice();
         s[e] = 1;
         var u = new Array(n);
         for (o = 0; o < u.length; o++) a[e] = o, u[o] = this.slice(t, a, s).reshape(r);
         return u
        }, e.prototype.avgPool3d = function(t, e) {
         var n = new ts(e, "avg", !1);
         return this.compileAndRun(n, [t], "float32")
        }, e.prototype.avgPool3dBackprop = function(t, e, n) {
         var r = new No(n);
         return this.compileAndRun(r, [t], e.dtype)
        }, e.prototype.maxPool3d = function(t, e) {
         var n = new ts(e, "max", !1);
         return this.compileAndRun(n, [t], "float32")
        }, e.prototype.maxPool3dBackprop = function(t, e, n, r) {
         var i = new ts(r, "max", !0),
          o = this.compileAndRun(i, [e]),
          a = new Ga(r),
          s = this.compileAndRun(a, [t, o], e.dtype);
         return o.dispose(), s
        }, e.prototype.reshape = function(t, e) {
         var n = this.texData.get(t.dataId);
         if (n.isPacked && !Le(t.shape, e) && (null === n.texture || !Le(n.shape, e))) {
          var r = this.packedReshape(t, e);
          return Wt.makeTensorFromDataId(r.dataId, r.shape, r.dtype)
         }
         return ji(t, e)
        }, e.prototype.resizeBilinear = function(t, e, n, r) {
         var i = h().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new os(t.shape, e, n, r) : new is(t.shape, e, n, r);
         return this.compileAndRun(i, [t], "float32")
        }, e.prototype.resizeBilinearBackprop = function(t, e, n) {
         var r = new rs(t, e, n);
         return this.compileAndRun(r, [t])
        }, e.prototype.resizeNearestNeighbor = function(t, e, n, r) {
         var i = new ss(t.shape, e, n, r);
         return this.compileAndRun(i, [t])
        }, e.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
         var r = new as(t, e, n);
         return this.compileAndRun(r, [t])
        }, e.prototype.multinomial = function(t, e, n, r) {
         var i = e ? t : bi(t),
          o = i.shape[0],
          a = i.shape[1],
          s = new Ka(o, a, n),
          u = s.getCustomSetupFunc(r);
         return this.compileAndRun(s, [i], "int32", u)
        }, e.prototype.oneHot = function(t, e, n, r) {
         var i = new Xa(t.size, e, n, r);
         return this.compileAndRun(i, [t])
        }, e.prototype.diag = function(t) {
         var e = new la(t.size);
         return this.compileAndRun(e, [t])
        }, e.prototype.nonMaxSuppression = function(t, e, n, r, i) {
         return mn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Xi(t.dataSync(), e.dataSync(), n, r, i)
        }, e.prototype.cropAndResize = function(t, e, n, r, i, o) {
         var a = new ia(t.shape, e.shape, r, i, o);
         return this.compileAndRun(a, [t, e, n], "float32")
        }, e.prototype.depthToSpace = function(t, e, n) {
         O(e > 1, (function() {
          return "blockSize should be > 1 for depthToSpace, but was: " + e
         }));
         var r = t.shape[0],
          i = "NHWC" === n ? t.shape[1] : t.shape[2],
          o = "NHWC" === n ? t.shape[2] : t.shape[3],
          a = "NHWC" === n ? t.shape[3] : t.shape[1],
          s = i * e,
          u = o * e,
          c = a / (e * e),
          l = new ca("NHWC" === n ? [r, s, u, c] : [r, c, s, u], e, n);
         return this.compileAndRun(l, [t])
        }, e.prototype.split = function(t, e, n) {
         return eo(t, e, n)
        }, e.prototype.scatterND = function(t, e, n) {
         var r = ni(0, t, n),
          i = r.sliceRank,
          o = r.numUpdates,
          a = r.sliceSize,
          s = r.strides,
          u = r.outputSize,
          c = [u / a, a],
          l = t.reshape([o, i]),
          h = e.reshape([o, a]);
         if (0 === u) return ji(Mn([]), n);
         var p = Bn(0),
          f = new ls(o, i, l.rank, h.rank, s, c);
         return this.compileAndRun(f, [h, l, p]).reshape(n)
        }, e.prototype.sparseToDense = function(t, e, n, r) {
         var i = ni(0, t, n),
          o = i.sliceRank,
          a = i.numUpdates,
          s = i.strides,
          u = i.outputSize,
          c = new ls(a, o, t.rank, e.rank, s, [u, 1], !1);
         return this.compileAndRun(c, [e, t, r]).reshape(n)
        }, e.prototype.fft = function(t) {
         return this.fftImpl(t, !1)
        }, e.prototype.ifft = function(t) {
         return this.fftImpl(t, !0)
        }, e.prototype.fftImpl = function(t, e) {
         var n = this.texData.get(t.dataId),
          r = new ga(va, t.shape, e),
          i = new ga(ma, t.shape, e),
          o = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],
          a = this.compileAndRun(r, o),
          s = this.compileAndRun(i, o),
          u = this.complex(a, s).as2D(t.shape[0], t.shape[1]);
         return a.dispose(), s.dispose(), u
        }, e.prototype.gatherND = function(t, e) {
         var n = e.shape,
          r = n[n.length - 1],
          i = Yr(t, e),
          o = i[0],
          a = i[1],
          s = i[2],
          u = i[3],
          c = e.reshape([a, r]),
          l = t.reshape([t.size / s, s]),
          h = new xa(r, u, [a, s]);
         return this.compileAndRun(h, [l, c]).reshape(o)
        }, e.prototype.fill = function(t, e, n) {
         if ("string" === (n = n || J(e))) {
          var r = V(n, T(t));
          return r.fill(e), Wt.makeTensor(r, t, n, this)
         }
         var i = new ya(t, e),
          o = i.getCustomSetupFunc(e);
         return this.compileAndRun(i, [], n, o)
        }, e.prototype.onesLike = function(t) {
         if ("string" === t.dtype) throw new Error("onesLike is not supported under string dtype");
         return this.fill(t.shape, 1, t.dtype)
        }, e.prototype.zerosLike = function(t) {
         return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype)
        }, e.prototype.linspace = function(t, e, n) {
         return Wi(t, e, n)
        }, e.prototype.makeTensorInfo = function(t, e) {
         var n = this.write(null, t, e);
         return this.texData.get(n).usage = null, {
          dataId: n,
          shape: t,
          dtype: e
         }
        }, e.prototype.makeOutput = function(t, e) {
         var n = this.makeTensorInfo(t, e).dataId;
         return Wt.makeTensorFromDataId(n, t, e, this)
        }, e.prototype.unpackTensor = function(t) {
         var e = new Js(t.shape);
         return this.runWebGLProgram(e, [t], t.dtype)
        }, e.prototype.packTensor = function(t) {
         var e = new Ya(t.shape);
         return this.runWebGLProgram(e, [t], t.dtype, null, !0)
        }, e.prototype.packedReshape = function(t, e) {
         var n = [Te(t.shape)].concat(_e(t.shape)),
          r = {
           dtype: t.dtype,
           shape: n,
           dataId: t.dataId
          },
          i = [Te(e)].concat(_e(e)),
          o = new ns(i, n),
          a = this.runWebGLProgram(o, [r], t.dtype, null, !0);
         return {
          dataId: a.dataId,
          shape: e,
          dtype: a.dtype
         }
        }, e.prototype.decode = function(t) {
         var e, n = this.texData.get(t),
          r = n.isPacked,
          i = n.shape,
          o = n.dtype,
          a = De(i);
         return e = r ? new ua(a) : new sa(a), {
          dtype: o,
          shape: i,
          dataId: this.runWebGLProgram(e, [{
           shape: a,
           dtype: o,
           dataId: t
          }], o, null, !0).dataId
         }
        }, e.prototype.runWebGLProgram = function(t, e, n, r, i) {
         var o = this;
         void 0 === i && (i = !1);
         var a = this.makeTensorInfo(t.outputShape, n),
          s = this.texData.get(a.dataId);
         if (t.packedOutput && (s.isPacked = !0), t.outPackingScheme === Ht.DENSE) {
          var u = Jt(t.outputShape);
          s.texShape = u.map((function(t) {
           return 2 * t
          }))
         }
         if (null != t.outTexUsage && (s.usage = t.outTexUsage), 0 === T(a.shape)) return s.values = W(a.dtype, 0), a;
         var c = [],
          l = e.map((function(e) {
           if ("complex64" === e.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
           var n = o.texData.get(e.dataId);
           if (null == n.texture) {
            if (!t.packedInputs && T(e.shape) <= h().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
             shape: e.shape,
             texData: null,
             isUniform: !0,
             uniformValues: n.values
            };
            t.packedInputs && (n.isPacked = !0, n.shape = e.shape)
           } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? o.unpackTensor(e) : o.packTensor(e), c.push(e), n = o.texData.get(e.dataId);
           else if (n.isPacked && !Le(n.shape, e.shape)) {
            var r = e,
             i = e.shape;
            e.shape = n.shape, e = o.packedReshape(e, i), c.push(e), n = o.texData.get(e.dataId), r.shape = i
           }
           return o.uploadToGPU(e.dataId), {
            shape: e.shape,
            texData: n,
            isUniform: !1
           }
          }));
         this.uploadToGPU(a.dataId);
         var p, f = {
           shape: a.shape,
           texData: s,
           isUniform: !1
          },
          d = function(t, e, n) {
           var r = "";
           e.concat(n).forEach((function(t) {
            var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,
             n = t.isUniform ? "uniform" : t.texData.texShape;
            r += t.shape + "_" + n + "_" + e
           }));
           var i = t.userCode,
            o = t.constructor.name;
           return o + "_" + r + "_" + i
          }(t, l, f),
          v = this.getAndSaveBinary(d, (function() {
           return function(t, e, n, r) {
            var i = e.userCode,
             o = n.map((function(t, n) {
              var r = {
               logicalShape: t.shape,
               texShape: t.isUniform ? null : t.texData.texShape,
               isUniform: t.isUniform,
               isPacked: !t.isUniform && t.texData.isPacked,
               flatOffset: null
              };
              return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {
               name: e.variableNames[n],
               shapeInfo: r
              }
             })),
             a = o.map((function(t) {
              return t.shapeInfo
             })),
             s = {
              logicalShape: r.shape,
              texShape: r.texData.texShape,
              isUniform: !1,
              isPacked: r.texData.isPacked,
              flatOffset: null
             },
             u = vo(o, s, i, e.packedInputs),
             c = t.createProgram(u),
             l = null,
             p = t.getUniformLocation(c, "NAN", !1);
            1 === h().getNumber("WEBGL_VERSION") && (l = t.getUniformLocation(c, "INFINITY", !1));
            for (var f = {}, d = 0; d < e.variableNames.length; d++) {
             var v = e.variableNames[d];
             f[v] = t.getUniformLocation(c, v, !1), f["offset" + v] = t.getUniformLocation(c, "offset" + v, !1)
            }
            return {
             program: e,
             source: u,
             webGLProgram: c,
             uniformLocations: f,
             inShapeInfos: a,
             outShapeInfo: s,
             infLoc: l,
             nanLoc: p
            }
           }(o.gpgpu, t, l, f)
          })),
          m = null != this.activeTimers;
         if (m && (p = this.startTimer()), function(t, e, n, r, i) {
           ja(e.inShapeInfos, n), ja([e.outShapeInfo], [r]);
           var o = r.texData.texture,
            a = r.texData.texShape;
           r.texData.isPacked ? t.setOutputPackedMatrixTexture(o, a[0], a[1]) : t.setOutputMatrixTexture(o, a[0], a[1]), t.setProgram(e.webGLProgram), 1 === h().getNumber("WEBGL_VERSION") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach((function(n, r) {
            var i = e.program.variableNames[r],
             o = e.uniformLocations[i],
             a = e.uniformLocations["offset" + i];
            if (null != o)
             if (n.isUniform)
              if (T(n.shape) < 2) t.gl.uniform1f(o, n.uniformValues[0]);
              else {
               var s = n.uniformValues;
               s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(o, s)
              }
            else null != n.texData.slice && null != a && t.gl.uniform1i(a, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, o, r)
           })), null != i && i(t, e.webGLProgram), t.executeProgram()
          }(this.gpgpu, v, l, f, r), c.forEach((function(t) {
           return o.disposeData(t.dataId)
          })), m && (p = this.endTimer(p), this.activeTimers.push({
           name: t.constructor.name,
           query: this.getQueryTime(p)
          })), !h().getBool("WEBGL_LAZILY_UNPACK") && s.isPacked && !1 === i) {
          var g = this.unpackTensor(a);
          return this.disposeData(a.dataId), g
         }
         return a
        }, e.prototype.compileAndRun = function(t, e, n, r, i) {
         void 0 === i && (i = !1), n = n || e[0].dtype;
         var o = this.runWebGLProgram(t, e, n, r, i);
         return Wt.makeTensorFromDataId(o.dataId, o.shape, o.dtype)
        }, e.prototype.getAndSaveBinary = function(t, e) {
         return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t]
        }, e.prototype.getTextureManager = function() {
         return this.textureManager
        }, e.prototype.dispose = function() {
         var t = this;
         this.disposed || (h().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((function(e) {
          t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e]
         })), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0)
        }, e.prototype.floatPrecision = function() {
         var t = this;
         return null == this.floatPrecisionValue && (this.floatPrecisionValue = nn((function() {
          if (!h().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
           var e = h().getBool("DEBUG");
           h().set("DEBUG", !1);
           var n = t.abs(Bn(1e-8)).dataSync()[0];
           if (h().set("DEBUG", e), n > 0) return 32
          }
          return 16
         }))), this.floatPrecisionValue
        }, e.prototype.epsilon = function() {
         return 32 === this.floatPrecision() ? 1e-7 : 1e-4
        }, e.prototype.uploadToGPU = function(t) {
         var e, n = this.texData.get(t),
          r = n.shape,
          i = n.dtype,
          o = n.values,
          a = n.texture,
          s = n.usage,
          u = n.isPacked;
         if (null == a) {
          var c, l = null != this.activeTimers;
          l && (c = at());
          var h = n.texShape;
          if (null == h && (h = Fe(r, u), n.texShape = h), null != o) {
           var p = De(r),
            f = void 0,
            d = h[1],
            v = h[0],
            m = o instanceof Uint8Array;
           u ? (d = (e = Qt(h[0], h[1]))[0], v = e[1], f = new da(p, [v, d], m)) : f = new fa(p, [v, d], m);
           var g = this.makeTensorInfo([v, d], i);
           this.texData.get(g.dataId).usage = m ? $t.PIXELS : $t.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), d, v, o);
           var y = this.runWebGLProgram(f, [g], i, null, !0),
            b = this.texData.get(y.dataId);
           n.texture = b.texture, n.texShape = b.texShape, n.isPacked = b.isPacked, n.usage = b.usage, this.disposeData(g.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += at() - c)
          } else {
           var x = this.acquireTexture(h, s, i, u);
           n.texture = x
          }
         }
        }, e.prototype.convertAndCacheOnCPU = function(t, e) {
         var n = this.texData.get(t),
          r = n.dtype;
         return this.releaseGPUData(t), null != e && (n.values = function(t, e) {
          if ("float32" === e || "complex64" === e) return t;
          if ("int32" === e || "bool" === e) {
           for (var n = "int32" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);
           return n
          }
          throw new Error("Unknown dtype " + e)
         }(e, r)), n.values
        }, e.prototype.acquireTexture = function(t, e, n, r) {
         if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
          var i = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
          this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + i + " MB, most likely due to a memory leak")
         }
         return this.textureManager.acquireTexture(t, e, r)
        }, e.prototype.computeBytes = function(t, e) {
         return t[0] * t[1] * q(e)
        }, e
       }(Ci);
      Vt() && Wt.registerBackend("webgl", (function() {
       return new nu
      }), 2), b({
       kernelName: "Square",
       gradFunc: function(t, e) {
        var n = e[0];
        return {
         x: function() {
          return t.mul(n.toFloat().mul(2))
         }
        }
       }
      });
      var ru = Tn({
        square_: function(t) {
         var e = bn(t, "x", "square"),
          n = [e];
         return Wt.runKernelFunc((function(t, n) {
          return n([e]), t.square(e)
         }), {
          x: e
         }, null, "Square", {}, n, [])
        }
       }),
       iu = Tn({
        abs_: function(t) {
         var e = bn(t, "x", "abs");
         return "complex64" === e.dtype ? Wt.runKernelFunc((function(t) {
          return t.complexAbs(e)
         }), {
          $x: e
         }) : Wt.runKernelFunc((function(t, n) {
          var r = t.abs(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return t.mul(n.toFloat().step(-1))
           }
          }
         }), "Abs")
        }
       }),
       ou = Tn({
        acos_: function(t) {
         var e = bn(t, "x", "acos");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.acos(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt()).neg()
           }
          }
         }))
        }
       }),
       au = Tn({
        acosh_: function(t) {
         var e = bn(t, "x", "acosh");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.acosh(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.divStrict(n.toFloat().square().sub(1).sqrt())
           }
          }
         }))
        }
       }),
       su = Tn({
        asin_: function(t) {
         var e = bn(t, "x", "asin");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.asin(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt())
           }
          }
         }))
        }
       }),
       uu = Tn({
        asinh_: function(t) {
         var e = bn(t, "x", "asinh");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.asinh(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.divStrict(Bn(1).add(n.toFloat().square()).sqrt())
           }
          }
         }))
        }
       }),
       cu = Tn({
        atan_: function(t) {
         var e = bn(t, "x", "atan");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.atan(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.div(n.toFloat().square().add(1))
           }
          }
         }))
        }
       }),
       lu = Tn({
        atanh_: function(t) {
         var e = bn(t, "x", "atanh");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.atanh(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.div(Bn(1).sub(n.toFloat().square()))
           }
          }
         }))
        }
       }),
       hu = Tn({
        ceil_: function(t) {
         var e = bn(t, "x", "ceil");
         return Wt.runKernelFunc((function(t) {
          return t.ceil(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       pu = Tn({
        clipByValue_: function(t, e, n) {
         var r = bn(t, "x", "clipByValue");
         O(e <= n, (function() {
          return "Error in clip: min (" + e + ") must be less than or equal to max (" + n + ")."
         }));
         var i = [r],
          o = {
           min: e,
           max: n
          };
         return Wt.runKernelFunc((function(t, i) {
          var o = t.clip(r, e, n);
          return i([r]), o
         }), {
          x: r
         }, (function(t, r) {
          var i = r[0];
          return {
           x: function() {
            return t.where(i.greaterEqual(e).logicalAnd(i.lessEqual(n)), Zn(t))
           }
          }
         }), "ClipByValue", o, i)
        }
       }),
       fu = Tn({
        cos_: function(t) {
         var e = bn(t, "x", "cos"),
          n = [e];
         return Wt.runKernelFunc((function(t, n) {
          var r = t.cos(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return n.toFloat().sin().neg().mul(t)
           }
          }
         }), "Cos", {}, n)
        }
       }),
       du = Tn({
        cosh_: function(t) {
         var e = bn(t, "x", "cosh");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.cosh(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return n.toFloat().sinh().mulStrict(t)
           }
          }
         }))
        }
       }),
       vu = Tn({
        erf_: function(t) {
         var e = bn(t, "x", "erf");
         return O("int32" === e.dtype || "float32" === e.dtype, (function() {
          return "Input dtype must be `int32` or `float32`."
         })), "int32" === e.dtype && (e = e.toFloat()), Wt.runKernelFunc((function(t, n) {
          var r = t.erf(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)))
           }
          }
         }))
        }
       }),
       mu = Tn({
        exp_: function(t) {
         var e = bn(t, "x", "exp");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.exp(e);
          return n([r]), r
         }), {
          x: e
         }, (function(t, e) {
          return {
           x: function() {
            return t.mulStrict(e[0])
           }
          }
         }), "Exp", {}, [], [!0])
        }
       }),
       gu = Tn({
        expm1_: function(t) {
         var e = bn(t, "x", "expm1");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.expm1(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.mul(n.exp())
           }
          }
         }))
        }
       }),
       yu = Tn({
        floor_: function(t) {
         var e = bn(t, "x", "floor");
         return Wt.runKernelFunc((function(t) {
          return t.floor(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       bu = Tn({
        log_: function(t) {
         var e = bn(t, "x", "log"),
          n = [e];
         return Wt.runKernelFunc((function(t, n) {
          var r = t.log(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return t.div(n.toFloat())
           }
          }
         }), "Log", {}, n)
        }
       }),
       xu = Tn({
        log1p_: function(t) {
         var e = bn(t, "x", "log1p");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.log1p(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.div(n.add(1))
           }
          }
         }))
        }
       }),
       wu = Tn({
        logSigmoid_: function(t) {
         var e = bn(t, "x", "logSigmoid");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.softplus(e.neg()).neg();
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.mul(n.neg().sigmoid())
           }
          }
         }))
        }
       }),
       Cu = Tn({
        neg_: function(t) {
         var e = bn(t, "x", "neg");
         return Wt.runKernelFunc((function(t) {
          return t.neg(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return t.neg()
           }
          }
         }))
        }
       }),
       Su = Tn({
        reciprocal_: function(t) {
         var e = bn(t, "x", "reciprocal");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.reciprocal(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.div(n.square().neg())
           }
          }
         }))
        }
       }),
       Eu = Tn({
        round_: function(t) {
         var e = bn(t, "x", "round");
         return Wt.runKernelFunc((function(t) {
          return t.round(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       ku = Tn({
        rsqrt_: function(t) {
         var e = bn(t, "x", "rsqrt"),
          n = [e];
         return Wt.runKernelFunc((function(t, n) {
          var r = t.rsqrt(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return t.div(n.pow(1.5).mul(2)).neg()
           }
          }
         }), "Rsqrt", {}, n)
        }
       }),
       Iu = Tn({
        sigmoid_: function(t) {
         var e = bn(t, "x", "sigmoid");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.sigmoid(e);
          return n([r]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return t.mul(n.mul(Bn(1).sub(n)))
           }
          }
         }), "Sigmoid")
        }
       }),
       Ou = Tn({
        sign_: function(t) {
         var e = bn(t, "x", "sign");
         return Wt.runKernelFunc((function(t) {
          return t.sign(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Au = Tn({
        isNaN_: function(t) {
         var e = bn(t, "x", "isNaN");
         return Wt.runKernelFunc((function(t) {
          return t.isNaN(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Nu = Tn({
        isInf_: function(t) {
         var e = bn(t, "x", "isInf");
         return Wt.runKernelFunc((function(t) {
          return t.isInf(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Ru = Tn({
        isFinite_: function(t) {
         var e = bn(t, "x", "isFinite");
         return Wt.runKernelFunc((function(t) {
          return t.isFinite(e)
         }), {
          $x: e
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Tu = Tn({
        sin_: function(t) {
         var e = bn(t, "x", "sin"),
          n = [e];
         return Wt.runKernelFunc((function(t, n) {
          var r = t.sin(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return n.toFloat().cos().mul(t)
           }
          }
         }), "Sin", {}, n)
        }
       }),
       _u = Tn({
        sinh_: function(t) {
         var e = bn(t, "x", "sinh");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.sinh(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return n.toFloat().cosh().mulStrict(t)
           }
          }
         }))
        }
       }),
       Du = Tn({
        softplus_: function(t) {
         var e = bn(t, "x", "softplus");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.softplus(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.mul(n.sigmoid())
           }
          }
         }))
        }
       }),
       Fu = Tn({
        sqrt_: function(t) {
         var e = bn(t, "x", "sqrt");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.sqrt(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.div(n.toFloat().sqrt().mul(2))
           }
          }
         }))
        }
       }),
       Mu = Tn({
        step_: function(t, e) {
         void 0 === e && (e = 0);
         var n = bn(t, "x", "step");
         return Wt.runKernelFunc((function(t) {
          return t.step(n, e)
         }), {
          $x: n
         }, (function(t) {
          return {
           $x: function() {
            return Zn(t)
           }
          }
         }))
        }
       }),
       Lu = Tn({
        tan_: function(t) {
         var e = bn(t, "x", "tan");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.tan(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return t.div(n.cos().square())
           }
          }
         }))
        }
       }),
       Bu = Tn({
        tanh_: function(t) {
         var e = bn(t, "x", "tanh");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.tanh(e);
          return n([r]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return Bn(1).sub(n.square()).mulStrict(t)
           }
          }
         }), "Tanh", {}, null, [!0])
        }
       });
 
      function Pu(t, e, n, r, i, o) {
       var a, s, u = bn(t, "x", "batchNorm"),
        c = bn(e, "mean", "batchNorm"),
        l = bn(n, "variance", "batchNorm");
       return null != i && (a = bn(i, "scale", "batchNorm")), null != r && (s = bn(r, "offset", "batchNorm")), O(2 === u.rank, (function() {
        return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
       })), O(2 === c.rank || 1 === c.rank, (function() {
        return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c.rank + "."
       })), O(2 === l.rank || 1 === l.rank, (function() {
        return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l.rank + "."
       })), null != a && O(2 === a.rank || 1 === a.rank, (function() {
        return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + a.rank + "."
       })), null != s && O(2 === s.rank || 1 === s.rank, (function() {
        return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + "."
       })), Wu(u, c, l, s, a, o)
      }
 
      function zu(t, e, n, r, i, o) {
       var a, s, u = bn(t, "x", "batchNorm"),
        c = bn(e, "mean", "batchNorm"),
        l = bn(n, "variance", "batchNorm");
       return null != i && (a = bn(i, "scale", "batchNorm")), null != r && (s = bn(r, "offset", "batchNorm")), O(3 === u.rank, (function() {
        return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
       })), O(3 === c.rank || 1 === c.rank, (function() {
        return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c.rank + "."
       })), O(3 === l.rank || 1 === l.rank, (function() {
        return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l.rank + "."
       })), null != a && O(3 === a.rank || 1 === a.rank, (function() {
        return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + a.rank + "."
       })), null != s && O(3 === s.rank || 1 === s.rank, (function() {
        return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + "."
       })), Wu(u, c, l, s, a, o)
      }
 
      function ju(t, e, n, r, i, o) {
       var a, s, u = bn(t, "x", "batchNorm"),
        c = bn(e, "mean", "batchNorm"),
        l = bn(n, "variance", "batchNorm");
       return null != i && (a = bn(i, "scale", "batchNorm")), null != r && (s = bn(r, "offset", "batchNorm")), O(4 === u.rank, (function() {
        return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + "."
       })), O(4 === c.rank || 1 === c.rank, (function() {
        return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c.rank + "."
       })), O(4 === l.rank || 1 === l.rank, (function() {
        return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l.rank + "."
       })), null != a && O(4 === a.rank || 1 === a.rank, (function() {
        return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + a.rank + "."
       })), null != s && O(4 === s.rank || 1 === s.rank, (function() {
        return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + "."
       })), Wu(u, c, l, s, a, o)
      }
 
      function Wu(t, e, n, r, i, o) {
       null == o && (o = .001);
       var a, s, u, c = bn(t, "x", "batchNorm"),
        l = bn(e, "mean", "batchNorm"),
        h = bn(n, "variance", "batchNorm");
       null != i && (a = bn(i, "scale", "batchNorm")), null != r && (s = bn(r, "offset", "batchNorm")), O(l.rank === h.rank, (function() {
        return "Batch normalization gradient requires mean and variance to have equal ranks."
       })), O(null == s || l.rank === s.rank, (function() {
        return "Batch normalization gradient requires mean and offset to have equal ranks."
       })), O(null == a || l.rank === a.rank, (function() {
        return "Batch normalization gradient requires mean and scale to have equal ranks."
       })), u = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;
       var p = [c, l, h, a];
       return Wt.runKernelFunc((function(t, e) {
        var n = t.batchNormalization(u, Vu(l), Vu(h), o, Vu(a), Vu(s));
        return e([c, l, h, a]), n
       }), {
        x: c,
        mean: l,
        variance: h,
        scale: a,
        offset: s
       }, (function(t, e) {
        var n = e,
         r = n[0],
         i = n[1],
         a = n[2],
         s = n[3],
         c = null == s ? Bn(1) : s,
         l = ki(i.shape, u.shape),
         h = [];
        if (1 === i.rank) {
         for (var p = 0; p < u.shape.length - 1; ++p) h.push(u.shape[p]);
         h.push(1)
        }
        var f = r.sub(i),
         d = t.mul(c),
         v = ku(a.add(Bn(o))),
         m = v.mul(v).mul(v).mul(Bn(-.5));
        return {
         x: function() {
          return 1 === i.rank ? t.mul(Wr(v.as4D(1, 1, 1, i.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(v).mul(c).reshape(r.shape)
         },
         mean: function() {
          var t = v.mul(Bn(-1)).mul(d);
          return 1 === i.rank && (t = t.sum(l)), t.reshape(i.shape)
         },
         variance: function() {
          var t = m.mul(f).mul(d);
          return 1 === i.rank && (t = t.sum(l)), t.reshape(i.shape)
         },
         scale: function() {
          var e = f.mul(v),
           n = t.mul(e);
          return 1 === i.rank && (n = n.sum(l)), n.reshape(i.shape)
         },
         offset: function() {
          var e = t;
          return 1 === i.rank && (e = e.sum(l)), e.reshape(i.shape)
         }
        }
       }), "BatchNormalization", {
        varianceEpsilon: o
       }, p).reshape(c.shape)
      }
 
      function Vu(t) {
       return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t
      }
 
      function Uu() {
       Ze("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")
      }
      var Hu = Tn({
        batchNormalization2d_: function(t, e, n, r, i, o) {
         return void 0 === r && (r = .001), Uu(), Pu(t, e, n, o, i, r)
        }
       }),
       $u = Tn({
        batchNormalization3d_: function(t, e, n, r, i, o) {
         return void 0 === r && (r = .001), Uu(), zu(t, e, n, o, i, r)
        }
       }),
       Gu = Tn({
        batchNormalization4d_: function(t, e, n, r, i, o) {
         return void 0 === r && (r = .001), Uu(), ju(t, e, n, o, i, r)
        }
       }),
       qu = Tn({
        batchNormalization_: function(t, e, n, r, i, o) {
         return void 0 === r && (r = .001), Uu(), Wu(t, e, n, o, i, r)
        }
       }),
       Ku = Tn({
        batchNorm_: Wu
       }),
       Xu = Tn({
        batchNorm2d_: Pu
       }),
       Yu = Tn({
        batchNorm3d_: zu
       }),
       Zu = Tn({
        batchNorm4d_: ju
       }),
       Ju = Tn({
        logicalAnd_: function(t, e) {
         var n = bn(t, "a", "logicalAnd", "bool"),
          r = bn(e, "b", "logicalAnd", "bool");
         return Ii(n.shape, r.shape), Wt.runKernelFunc((function(t) {
          return t.logicalAnd(n, r)
         }), {
          a: n,
          b: r
         }, null, "LogicalAnd")
        }
       }),
       Qu = Tn({
        logicalNot_: function(t) {
         var e = bn(t, "x", "logicalNot", "bool");
         return Wt.runKernelFunc((function(t) {
          return t.logicalNot(e)
         }), {
          $x: e
         })
        }
       }),
       tc = Tn({
        logicalOr_: function(t, e) {
         var n = bn(t, "a", "logicalOr", "bool"),
          r = bn(e, "b", "logicalOr", "bool");
         return Ii(n.shape, r.shape), Wt.runKernelFunc((function(t) {
          return t.logicalOr(n, r)
         }), {
          $a: n,
          $b: r
         })
        }
       }),
       ec = Tn({
        logicalXor_: function(t, e) {
         var n = bn(t, "a", "logicalXor", "bool"),
          r = bn(e, "b", "logicalXor", "bool");
         return Ii(n.shape, r.shape), tc(t, e).logicalAnd(Ju(t, e).logicalNot())
        }
       }),
       nc = Tn({
        where_: function(t, e, n) {
         var r = bn(e, "a", "where"),
          i = bn(n, "b", "where"),
          o = bn(t, "condition", "where", "bool");
         return A(r.shape, i.shape, "Error in where: "), 1 === o.rank ? O(o.shape[0] === r.shape[0], (function() {
          return "The first dimension of `a` must match the size of `condition`."
         })) : A(o.shape, i.shape, "Error in where: "), Wt.runKernelFunc((function(t, e) {
          var n = t.select(o, r, i);
          return e([o]), n
         }), {
          $condition: o,
          $a: r,
          $b: i
         }, (function(t, e) {
          var n = e[0];
          return {
           $condition: function() {
            return Zn(n).toFloat()
           },
           $a: function() {
            return t.mul(n.cast(t.dtype))
           },
           $b: function() {
            return t.mul(n.logicalNot().cast(t.dtype))
           }
          }
         }))
        }
       }),
       rc = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r;
         return u(this, (function(i) {
          switch (i.label) {
           case 0:
            return [4, (e = bn(t, "condition", "whereAsync", "bool")).data()];
           case 1:
            return n = i.sent(), r = io(e.shape, n), t !== e && e.dispose(), [2, r]
          }
         }))
        }))
       },
       ic = Tn({
        add_: function(t, e) {
         var n, r = bn(t, "a", "add"),
          i = bn(e, "b", "add");
         n = Ft(r, i), r = n[0], i = n[1];
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t) {
          return t.add(r, i)
         }), {
          a: r,
          b: i
         }, (function(t) {
          return {
           a: function() {
            var e = t,
             n = ki(r.shape, o);
            return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape)
           },
           b: function() {
            var e = t,
             n = ki(i.shape, o);
            return n.length > 0 && (e = e.sum(n)), e.reshape(i.shape)
           }
          }
         }), "Add")
        }
       }),
       oc = Tn({
        addN_: function(t) {
         O(Array.isArray(t), (function() {
          return "The argument passed to tf.addN() must be a list of tensors"
         })), O(t.length >= 1, (function() {
          return "Must pass at least one tensor to tf.addN(), but got " + t.length
         }));
         var e = t.map((function(t, e) {
           return bn(t, "tensors" + e, "addN")
          })),
          n = e[0];
         e.forEach((function(t) {
          if (t.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
         })), e.forEach((function(t) {
          if (!_(t.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
         }));
         var r = e;
         return Wt.runKernelFunc((function(t) {
          return t.addN(e)
         }), r, (function(t) {
          var n = {};
          return e.forEach((function(e, r) {
           n[r] = function() {
            return t.clone()
           }
          })), n
         }), "AddN")
        }
       }),
       ac = Tn({
        addStrict_: function(t, e) {
         var n = bn(t, "a", "addStrict"),
          r = bn(e, "b", "addStrict");
         return A(n.shape, r.shape, "Error in addStrict: "), n.add(r)
        }
       }),
       sc = Tn({
        atan2_: function(t, e) {
         var n, r = bn(t, "a", "atan2"),
          i = bn(e, "b", "atan2");
         n = Ft(r, i), r = n[0], i = n[1];
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t, e) {
          var n = t.atan2(r, i);
          return e([r, i]), n
         }), {
          $a: r,
          $b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           $a: function() {
            var e = ic(n.square(), r.square()),
             i = t.mul(r.div(e)),
             a = ki(n.shape, o);
            return a.length > 0 && (i = i.sum(a)), i.reshape(n.shape)
           },
           $b: function() {
            var e = ic(n.square(), r.square()),
             i = Cu(t.mul(n.div(e))),
             a = ki(r.shape, o);
            return a.length > 0 && (i = i.sum(a)), i.reshape(r.shape)
           }
          }
         }))
        }
       }),
       uc = Tn({
        div_: function(t, e) {
         var n, r = bn(t, "a", "div"),
          i = bn(e, "b", "div");
         if (n = Ft(r, i), r = n[0], i = n[1], "int32" === r.dtype && "int32" === i.dtype) return hc(r, i);
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t, e) {
          var n = t.realDivide(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           a: function() {
            var e = t.div(r.toFloat()),
             i = ki(n.shape, o);
            return i.length > 0 ? e.sum(i).reshape(n.shape) : e
           },
           b: function() {
            var e = t.mul(n.toFloat()),
             i = ki(r.shape, o);
            i.length > 0 && (e = e.sum(i).reshape(r.shape));
            var a = r.square();
            return e.div(a.toFloat()).neg()
           }
          }
         }), "Div")
        }
       }),
       cc = Tn({
        divNoNan_: function(t, e) {
         var n, r = bn(t, "a", "div"),
          i = bn(e, "b", "div");
         r = (n = Ft(r, i))[0], i = n[1];
         var o = uc(r, i),
          a = Zn(o),
          s = i.equal(a);
         return nc(s, a, o)
        }
       }),
       lc = Tn({
        divStrict_: function(t, e) {
         var n = bn(t, "a", "div"),
          r = bn(e, "b", "div");
         return A(n.shape, r.shape, "Error in divideStrict: "), n.div(r)
        }
       }),
       hc = Tn({
        floorDiv_: function(t, e) {
         var n, r = bn(t, "a", "floorDiv"),
          i = bn(e, "b", "floorDiv");
         n = Ft(r, i), r = n[0], i = n[1];
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t, e) {
          var n = t.floorDiv(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           a: function() {
            var e = t.div(r.toFloat()),
             i = ki(n.shape, o);
            return i.length > 0 ? e.sum(i).reshape(n.shape) : e
           },
           b: function() {
            var e = t.mul(n.toFloat()),
             i = ki(r.shape, o);
            i.length > 0 && (e = e.sum(i).reshape(r.shape));
            var a = r.square();
            return e.div(a.toFloat()).neg()
           }
          }
         }), "FloorDiv")
        }
       }),
       pc = Tn({
        maximum_: function(t, e) {
         var n, r = bn(t, "a", "maximum"),
          i = bn(e, "b", "maximum");
         return n = Ft(r, i), r = n[0], i = n[1], "bool" === r.dtype && (r = r.toInt(), i = i.toInt()), Ii(r.shape, i.shape), Wt.runKernelFunc((function(t, e) {
          var n = t.maximum(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           a: function() {
            return t.mul(n.greaterEqual(r).toFloat())
           },
           b: function() {
            return t.mul(n.less(r).toFloat())
           }
          }
         }), "Maximum")
        }
       }),
       fc = Tn({
        maximumStrict_: function(t, e) {
         var n = bn(t, "a", "maximumStrict"),
          r = bn(e, "b", "maximumStrict");
         return A(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r)
        }
       }),
       dc = Tn({
        minimum_: function(t, e) {
         var n, r = bn(t, "a", "minimum"),
          i = bn(e, "b", "minimum");
         return n = Ft(r, i), r = n[0], i = n[1], "bool" === r.dtype && (r = r.toInt(), i = i.toInt()), Ii(r.shape, i.shape), Wt.runKernelFunc((function(t, e) {
          var n = t.minimum(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           a: function() {
            return t.mul(n.lessEqual(r).toFloat())
           },
           b: function() {
            return t.mul(n.greater(r).toFloat())
           }
          }
         }), "Minimum")
        }
       }),
       vc = Tn({
        minimumStrict_: function(t, e) {
         var n = bn(t, "a", "minimumStrict"),
          r = bn(e, "b", "minimumStrict");
         return A(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r)
        }
       }),
       mc = Tn({
        mod_: function(t, e) {
         var n, r = bn(t, "a", "mod"),
          i = bn(e, "b", "mod");
         n = Ft(r, i), r = n[0], i = n[1];
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t, e) {
          var n = t.mod(r, i);
          return e([r, i]), n
         }), {
          $a: r,
          $b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           $a: function() {
            var e = ki(n.shape, o);
            return e.length > 0 ? t.sum(e).reshape(n.shape) : t
           },
           $b: function() {
            var e = t.mul(n.div(r).floor().neg()),
             i = ki(r.shape, o);
            return i.length > 0 ? e.sum(i).reshape(r.shape) : e
           }
          }
         }))
        }
       }),
       gc = Tn({
        modStrict_: function(t, e) {
         var n = bn(t, "a", "modStrict"),
          r = bn(e, "b", "modStrict");
         return A(n.shape, r.shape, "Error in modStrict: "), n.mod(r)
        }
       }),
       yc = Tn({
        mul_: function(t, e) {
         var n, r = bn(t, "a", "mul"),
          i = bn(e, "b", "mul");
         n = Ft(r, i), r = n[0], i = n[1];
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t, e) {
          var n = t.multiply(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           a: function() {
            var e = t.mul(r.toFloat()),
             i = ki(n.shape, o);
            return i.length > 0 ? e.sum(i).reshape(n.shape) : e
           },
           b: function() {
            var e = t.mul(n.toFloat()),
             i = ki(r.shape, o);
            return i.length > 0 ? e.sum(i).reshape(r.shape) : e
           }
          }
         }), "Mul")
        }
       }),
       bc = Tn({
        mulStrict_: function(t, e) {
         var n = bn(t, "a", "mul"),
          r = bn(e, "b", "mul");
         return A(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r)
        }
       }),
       xc = Tn({
        pow_: function(t, e) {
         var n = bn(t, "base", "pow"),
          r = bn(e, "exp", "pow"),
          i = Ii(n.shape, r.shape);
         return t = n.cast(_t(n.dtype, r.dtype)), e = r.cast(_t(n.dtype, r.dtype)), Wt.runKernelFunc((function(t, e) {
          var i = t.pow(n, r);
          return e([n, r, i]), i
         }), {
          $base: n,
          $exp: r
         }, (function(t, e) {
          var n = e[0],
           r = e[1],
           o = e[2];
          return {
           $base: function() {
            var e = r.toFloat(),
             o = t.mul(e.mul(n.pow(e.sub(Bn(1))))),
             a = ki(n.shape, i);
            return a.length > 0 && (o = o.sum(a)), o.reshape(n.shape)
           },
           $exp: function() {
            var e = n.greater(0),
             a = n.log().where(e, Zn(n)),
             s = t.mul(o.mul(a)),
             u = ki(r.shape, i);
            return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape)
           }
          }
         }))
        }
       }),
       wc = Tn({
        powStrict_: function(t, e) {
         return A(t.shape, e.shape, "Error in powStrict: "), t.pow(e)
        }
       }),
       Cc = Tn({
        squaredDifference_: function(t, e) {
         var n, r = bn(t, "a", "squaredDifference"),
          i = bn(e, "b", "squaredDifference");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t, e) {
          var n = t.squaredDifference(r, i);
          return e([r, i]), n
         }), {
          $a: r,
          $b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1],
           i = Bn(2);
          return {
           $a: function() {
            return t.mul(n.sub(r).mul(i))
           },
           $b: function() {
            return t.mul(r.sub(n).mul(i))
           }
          }
         }))
        }
       }),
       Sc = Tn({
        squaredDifferenceStrict_: function(t, e) {
         var n = bn(t, "a", "squaredDifferenceStrict"),
          r = bn(e, "b", "squaredDifferenceStrict");
         return A(n.shape, r.shape, "Error in squaredDifferenceStrict: "), n.squaredDifference(r)
        }
       }),
       Ec = Tn({
        sub_: function(t, e) {
         var n, r = bn(t, "a", "sub"),
          i = bn(e, "b", "sub");
         n = Ft(r, i), r = n[0], i = n[1];
         var o = Ii(r.shape, i.shape);
         return Wt.runKernelFunc((function(t) {
          return t.subtract(r, i)
         }), {
          a: r,
          b: i
         }, (function(t) {
          return {
           a: function() {
            var e = t,
             n = ki(r.shape, o);
            return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape)
           },
           b: function() {
            var e = t,
             n = ki(i.shape, o);
            return n.length > 0 && (e = e.sum(n)), e.neg().reshape(i.shape)
           }
          }
         }), "Sub")
        }
       }),
       kc = Tn({
        subStrict_: function(t, e) {
         var n = bn(t, "a", "subStrict"),
          r = bn(e, "b", "subStrict");
         return A(n.shape, r.shape, "Error in subStrict: "), n.sub(r)
        }
       }),
       Ic = Tn({
        equal_: function(t, e) {
         var n, r = bn(t, "a", "equal"),
          i = bn(e, "b", "equal");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t) {
          return t.equal(r, i)
         }), {
          $a: r,
          $b: i
         })
        }
       }),
       Oc = Tn({
        equalStrict_: function(t, e) {
         var n = bn(t, "a", "equalStrict"),
          r = bn(e, "b", "equalStrict");
         return A(n.shape, r.shape, "Error in equalStrict: "), n.equal(r)
        }
       }),
       Ac = Tn({
        greater_: function(t, e) {
         var n, r = bn(t, "a", "greater"),
          i = bn(e, "b", "greater");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t) {
          return t.greater(r, i)
         }), {
          a: r,
          b: i
         }, null, "Greater")
        }
       }),
       Nc = Tn({
        greaterEqual_: function(t, e) {
         var n, r = bn(t, "a", "greaterEqual"),
          i = bn(e, "b", "greaterEqual");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t, e) {
          var n = t.greaterEqual(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, (function(t, e) {
          var n = e[0],
           r = e[1];
          return {
           a: function() {
            return Zn(n)
           },
           b: function() {
            return Zn(r)
           }
          }
         }), "GreaterEqual")
        }
       }),
       Rc = Tn({
        greaterEqualStrict_: function(t, e) {
         var n = bn(t, "a", "greaterEqualStrict"),
          r = bn(e, "b", "greaterEqualStrict");
         return A(n.shape, r.shape, "Error in greaterEqualStrict: "), n.greaterEqual(r)
        }
       }),
       Tc = Tn({
        greaterStrict_: function(t, e) {
         var n = bn(t, "a", "greaterStrict"),
          r = bn(e, "b", "greaterStrict");
         return A(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r)
        }
       }),
       _c = Tn({
        less_: function(t, e) {
         var n, r = bn(t, "a", "less"),
          i = bn(e, "b", "less");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t) {
          return t.less(r, i)
         }), {
          a: r,
          b: i
         }, null, "Less")
        }
       }),
       Dc = Tn({
        lessEqual_: function(t, e) {
         var n, r = bn(t, "a", "lessEqual"),
          i = bn(e, "b", "lessEqual");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t, e) {
          var n = t.lessEqual(r, i);
          return e([r, i]), n
         }), {
          a: r,
          b: i
         }, null, "LessEqual")
        }
       }),
       Fc = Tn({
        lessEqualStrict_: function(t, e) {
         var n = bn(t, "a", "lessEqualStrict"),
          r = bn(e, "b", "lessEqualStrict");
         return A(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r)
        }
       }),
       Mc = Tn({
        lessStrict_: function(t, e) {
         var n = bn(t, "a", "lessStrict"),
          r = bn(e, "b", "lessStrict");
         return A(n.shape, r.shape, "Error in lessStrict: "), n.less(r)
        }
       }),
       Lc = Tn({
        notEqual_: function(t, e) {
         var n, r = bn(t, "a", "notEqual"),
          i = bn(e, "b", "notEqual");
         return n = Ft(r, i), r = n[0], i = n[1], Ii(r.shape, i.shape), Wt.runKernelFunc((function(t) {
          return t.notEqual(r, i)
         }), {
          $a: r,
          $b: i
         })
        }
       }),
       Bc = Tn({
        notEqualStrict_: function(t, e) {
         var n = bn(t, "a", "notEqualStrict"),
          r = bn(e, "b", "notEqualStrict");
         return A(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r)
        }
       });
 
      function Pc(t, e) {
       for (var n = [], r = t; r < e; ++r) n.push(r);
       return n
      }
 
      function zc(t) {
       for (var e = [], n = 0; n < t.length; ++n)
        for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);
       return e
      }
      var jc = Tn({
        gather_: function(t, e, n) {
         void 0 === n && (n = 0);
         var r = bn(t, "x", "gather"),
          i = bn(e, "indices", "gather", "int32");
         n = z(n, r.shape)[0];
         var o = function(t, e, n) {
          for (var r = t.shape[n], i = [], o = 1, a = 1, s = 0; s < n; s++) i.push(t.shape[s]), o *= t.shape[s];
          for (s = 0; s < e.rank; s++) i.push(e.shape[s]);
          for (s = n + 1; s < t.rank; s++) i.push(t.shape[s]), a *= t.shape[s];
          return {
           batchSize: o,
           sliceSize: a,
           dimSize: r,
           outputShape: i
          }
         }(r, i, n);
         return Wt.runKernelFunc((function(t, e) {
          var o = t.gather(r, i.flatten(), n);
          return e([i]), o
         }), {
          x: r,
          indices: i
         }, (function(t, e) {
          var i = e[0];
          return {
           x: function() {
            var e = r.shape,
             o = i.size,
             a = e.slice(0, n),
             s = a.length,
             u = e.slice(n, e.length).slice(1),
             c = u.length,
             l = Pc(0, s),
             h = Pc(s + 1, s + 1 + c),
             p = zc([a, [o], u]),
             f = t.reshape(p),
             d = i.reshape([o]),
             v = zc([
              [s], l, h
             ]),
             m = f.transpose(v),
             g = Wc(m, d, r.shape[n]),
             y = On(v);
            return g.transpose(y)
           },
           indices: function() {
            return i
           }
          }
         }), "Gather", {
          axis: n
         }).reshape(o.outputShape)
        }
       }),
       Wc = Tn({
        unsortedSegmentSum_: function(t, e, n) {
         var r = bn(t, "x", "unsortedSegmentSum"),
          i = bn(e, "segmentIds", "unsortedSegmentSum", "int32");
         return O(D(n), (function() {
          return "numSegments must be of dtype int"
         })), Wt.runKernelFunc((function(t, e) {
          var o = t.unsortedSegmentSum(r, i, n);
          return e([i]), o
         }), {
          $x: r
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return function(t, e) {
             for (var n = pc(e, Zn(e)), r = jc(t, n), i = Nc(e, Bn(0, "int32")), o = r.rank - i.rank, a = 0; a < o; ++a) i = Er(i, a + 1);
             i = Ju(i, $n(r.shape, "bool"));
             var s = Zn(r);
             return nc(i, r, s)
            }(t, n)
           }
          }
         }))
        }
       }),
       Vc = function(t, e, n) {
        return s(this, void 0, void 0, (function() {
         var r, i, o, a, s, c, l, h, p, f, d, v, m;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            for (r = bn(t, "tensor", "boolMask"), i = bn(e, "mask", "boolMask", "bool"), o = null == n ? 0 : n, a = i.rank, s = r.shape, O(a > 0, (function() {
              return "mask cannot be scalar"
             })), A(s.slice(o, o + a), i.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c = 1, l = o; l < o + a; l++) c *= s[l];
            return h = s.slice(0, o).concat([c], s.slice(o + a)), p = r.reshape(h), f = i.reshape([-1]), [4, rc(f)];
           case 1:
            return d = u.sent(), v = d.squeeze([1]), m = jc(p, v, o), t !== r && r.dispose(), e !== i && i.dispose(), v.dispose(), p.dispose(), f.dispose(), d.dispose(), [2, m]
          }
         }))
        }))
       };
 
      function Uc(t, e, n, r, i, o, a) {
       void 0 === o && (o = "NHWC"), O(t.length === e.rank, (function() {
        return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match"
       }));
       var s = t,
        u = e,
        c = !1;
       3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, t[0], t[1], t[2]]), O(4 === s.length, (function() {
        return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + "."
       })), O(4 === u.rank, (function() {
        return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank
       })), O(4 === n.rank, (function() {
        return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank
       }));
       var l = "NHWC" === o ? s[3] : s[1],
        h = "NHWC" === o ? u.shape[3] : u.shape[1];
       O(l === n.shape[2], (function() {
        return "Error in conv2dDerInput: depth of input (" + l + ") must match input depth for filter " + n.shape[2] + "."
       })), O(h === n.shape[3], (function() {
        return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + n.shape[3] + "."
       })), null != a && O(D(i), (function() {
        return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + i + "."
       }));
       var p = Pi(o),
        f = Ni(s, n.shape, r, 1, i, a, !1, p),
        d = Wt.runKernelFunc((function(t, e) {
         var r = t.conv2dDerInput(u, n, f);
         return e([n, u]), r
        }), {
         dy4D: u,
         filter: n
        }, (function(t, e) {
         var n = e[0],
          s = e[1];
         return {
          dy4D: function() {
           return qc(t, n, r, i, o, 1, a)
          },
          filter: function() {
           return Xc(t, s, n.shape, r, i, o, a)
          }
         }
        }));
       return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d
      }
 
      function Hc(t) {
       var e = function(t) {
         return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
        }(t),
        n = e[0],
        r = e[1],
        i = e[2];
       return 1 === n && 1 === r && 1 === i
      }
 
      function $c(t, e, n, r, i) {
       O(t.length === e.rank, (function() {
        return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match"
       }));
       var o = t,
        a = e,
        s = !1;
       4 === e.rank && (s = !0, a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), o = [1, t[0], t[1], t[2], t[3]]);
       var u = o[4],
        c = a.shape[4];
       O(5 === o.length, (function() {
        return "Error in conv3dDerInput: inShape must be length 5, but got length " + o.length + "."
       })), O(5 === a.rank, (function() {
        return "Error in conv3dDerInput: dy must be rank 5, but got rank " + a.rank
       })), O(5 === n.rank, (function() {
        return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank
       })), O(u === n.shape[3], (function() {
        return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + n.shape[3] + "."
       })), O(c === n.shape[4], (function() {
        return "Error in conv3dDerInput: depth of output (" + c + ") must match output depth for filter " + n.shape[4] + "."
       }));
       var l = Ri(o, n.shape, r, 1, i),
        h = Wt.runKernelFunc((function(t) {
         return t.conv3dDerInput(a, n, l)
        }), {
         dy5D: a
        });
       return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
      }
      var Gc = Tn({
        conv1d_: function(t, e, n, r, i, o, a) {
         void 0 === i && (i = "NWC"), void 0 === o && (o = 1);
         var s = bn(t, "x", "conv1d"),
          u = bn(e, "filter", "conv1d"),
          c = s,
          l = !1;
         2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), O(3 === c.rank, (function() {
          return "Error in conv1d: input must be rank 3, but got rank " + c.rank + "."
         })), O(3 === u.rank, (function() {
          return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + "."
         })), null != a && O(D(r), (function() {
          return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
         })), O(c.shape[2] === u.shape[1], (function() {
          return "Error in conv1d: depth of input (" + c.shape[2] + ") must match input depth for filter " + u.shape[1] + "."
         })), O(Bi(n, o), (function() {
          return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + o + "'"
         })), O("NWC" === i, (function() {
          return "Error in conv1d: got dataFormat of " + i + " but only NWC is currently supported."
         }));
         var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),
          p = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),
          f = qc(p, h, [1, n], r, "NHWC", [1, o], a);
         return l ? f.as2D(f.shape[2], f.shape[3]) : f.as3D(f.shape[0], f.shape[2], f.shape[3])
        }
       }),
       qc = Tn({
        conv2d_: function(t, e, n, r, i, o, a) {
         void 0 === i && (i = "NHWC"), void 0 === o && (o = [1, 1]);
         var s = bn(t, "x", "conv2d"),
          u = bn(e, "filter", "conv2d"),
          c = s,
          l = !1;
         3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), O(4 === c.rank, (function() {
          return "Error in conv2d: input must be rank 4, but got rank " + c.rank + "."
         })), O(4 === u.rank, (function() {
          return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + "."
         })), null != a && O(D(r), (function() {
          return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
         }));
         var h = "NHWC" === i ? c.shape[3] : c.shape[1];
         O(h === u.shape[2], (function() {
          return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + u.shape[2] + "."
         })), O(Bi(n, o), (function() {
          return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
         }));
         var p = Pi(i),
          f = Ni(c.shape, u.shape, n, o, r, a, !1, p),
          d = [u, c],
          v = Wt.runKernelFunc((function(t, e) {
           var n = t.conv2d(c, u, f);
           return e([u, c]), n
          }), {
           x: c,
           filter: u
          }, (function(t, e) {
           var a = e,
            s = a[0],
            u = a[1];
           return O(Li(o), (function() {
            return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + o + "'"
           })), {
            x: function() {
             return Yc(u.shape, t, s, n, r, i)
            },
            filter: function() {
             return Xc(u, t, s.shape, n, r, i)
            }
           }
          }), "Conv2D", f, d);
         return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v
        }
       }),
       Kc = Tn({
        conv3d_: function(t, e, n, r, i, o) {
         void 0 === i && (i = "NDHWC"), void 0 === o && (o = [1, 1, 1]);
         var a = bn(t, "x", "conv3d"),
          s = bn(e, "filter", "conv3d"),
          u = a,
          c = !1;
         4 === a.rank && (c = !0, u = a.as5D(1, a.shape[0], a.shape[1], a.shape[2], a.shape[3])), O(5 === u.rank, (function() {
          return "Error in conv3d: input must be rank 5, but got rank " + u.rank + "."
         })), O(5 === s.rank, (function() {
          return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + "."
         })), O(u.shape[4] === s.shape[3], (function() {
          return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + "."
         })), O(function(t, e) {
          return Hc(t) || Hc(e)
         }(n, o), (function() {
          return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
         })), O("NDHWC" === i, (function() {
          return "Error in conv3d: got dataFormat of " + i + " but only NDHWC is currently supported."
         }));
         var l = Ri(u.shape, s.shape, n, o, r),
          h = Wt.runKernelFunc((function(t, e) {
           var n = t.conv3d(u, s, l);
           return e([u, s]), n
          }), {
           x: u,
           $filter: s
          }, (function(t, e) {
           O(Hc(o), (function() {
            return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + o + "'"
           }));
           var i = e[0],
            a = e[1];
           return {
            x: function() {
             return $c(i.shape, t, a, n, r)
            },
            $filter: function() {
             return function(t, e, n, r, i) {
              var o = t;
              4 === t.rank && (o = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));
              var a = e;
              4 === a.rank && (a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])), O(5 === o.rank, (function() {
               return "Error in conv3dDerFilter: input must be rank 5, but got shape " + o.shape + "."
              })), O(5 === a.rank, (function() {
               return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + a.shape + "."
              })), O(5 === n.length, (function() {
               return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + "."
              })), O(o.shape[4] === n[3], (function() {
               return "Error in conv3dDerFilter: depth of input " + o.shape[4] + ") must match input depth in filter (" + n[3] + "."
              })), O(a.shape[4] === n[4], (function() {
               return "Error in conv3dDerFilter: depth of dy (" + a.shape[4] + ") must match output depth for filter (" + n[4] + ")."
              }));
              var s = Ri(o.shape, n, r, 1, i);
              return Wt.runKernelFunc((function(t) {
               return t.conv3dDerFilter(o, a, s)
              }), {
               x5D: o,
               dy5D: a
              })
             }(i, t, a.shape, n, r)
            }
           }
          }));
         return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
        }
       }),
       Xc = Tn({
        conv2dDerFilter_: function(t, e, n, r, i, o, a) {
         void 0 === o && (o = "NHWC");
         var s = t;
         3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
         var u = e;
         3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), O(4 === s.rank, (function() {
          return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + "."
         })), O(4 === u.rank, (function() {
          return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + "."
         })), O(4 === n.length, (function() {
          return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + "."
         }));
         var c = "NHWC" === o ? s.shape[3] : s.shape[1],
          l = "NHWC" === o ? u.shape[3] : u.shape[1];
         O(c === n[2], (function() {
          return "Error in conv2dDerFilter: depth of input " + c + ") must match input depth in filter (" + n[2] + "."
         })), O(l === n[3], (function() {
          return "Error in conv2dDerFilter: depth of dy (" + l + ") must match output depth for filter (" + n[3] + ")."
         })), null != a && O(D(i), (function() {
          return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + i + "."
         }));
         var h = Pi(o),
          p = Ni(s.shape, n, r, 1, i, a, !1, h);
         return Wt.runKernelFunc((function(t) {
          return t.conv2dDerFilter(s, u, p)
         }), {
          x4D: s,
          dy4D: u
         })
        }
       }),
       Yc = Tn({
        conv2dDerInput_: Uc
       }),
       Zc = Tn({
        depthwiseConv2d_: function(t, e, n, r, i, o, a) {
         void 0 === i && (i = "NHWC"), void 0 === o && (o = [1, 1]);
         var s = bn(t, "x", "depthwiseConv2d"),
          u = bn(e, "filter", "depthwiseConv2d"),
          c = s,
          l = !1;
         3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), O(4 === c.rank, (function() {
          return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c.rank + "."
         })), O(4 === u.rank, (function() {
          return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + "."
         })), O(c.shape[3] === u.shape[2], (function() {
          return "Error in depthwiseConv2d: number of input channels (" + c.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + "."
         })), null == o && (o = [1, 1]), O(Bi(n, o), (function() {
          return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
         })), null != a && O(D(r), (function() {
          return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
         }));
         var h = Ni(c.shape, u.shape, n, o, r, a, !0),
          p = [c, u],
          f = Wt.runKernelFunc((function(t, e) {
           var n = t.depthwiseConv2D(c, u, h);
           return e([c, u]), n
          }), {
           x: c,
           filter: u
          }, (function(t, e) {
           O(Li(o), (function() {
            return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + o + "'"
           }));
           var n = e[0],
            r = e[1];
           return {
            x: function() {
             return Jc(n.shape, t, r, h)
            },
            filter: function() {
             return Qc(n, t, r.shape, h)
            }
           }
          }), "DepthwiseConv2dNative", h, p);
         return l ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f
        }
       }),
       Jc = Tn({
        depthwiseConv2dDerInput_: function(t, e, n, r) {
         var i = e,
          o = !1;
         3 === e.rank && (o = !0, i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
         var a = Wt.runKernelFunc((function(t) {
          return t.depthwiseConv2DDerInput(i, n, r)
         }), {
          dy4D: i
         });
         return o ? a.as3D(a.shape[1], a.shape[2], a.shape[3]) : a
        }
       }),
       Qc = Tn({
        depthwiseConv2dDerFilter_: function(t, e, n, r) {
         var i = t;
         3 === t.rank && (i = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
         var o = e;
         return 3 === o.rank && (o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Wt.runKernelFunc((function(t) {
          return t.depthwiseConv2DDerFilter(i, o, r)
         }), {
          x4D: i,
          dy4D: o
         })
        }
       }),
       tl = Tn({
        separableConv2d_: function(t, e, n, r, i, o, a) {
         void 0 === o && (o = [1, 1]), void 0 === a && (a = "NHWC");
         var s = bn(t, "x", "separableConv2d"),
          u = bn(e, "depthwiseFilter", "separableConv2d"),
          c = bn(n, "pointwiseFilter", "separableConv2d"),
          l = s,
          h = !1;
         if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), "NCHW" === a) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
         O(4 === l.rank, (function() {
          return "Error in separableConv2d: input must be rank 4, but got rank " + l.rank + "."
         })), O(4 === u.rank, (function() {
          return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + "."
         })), O(4 === c.rank, (function() {
          return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + "."
         })), O(1 === c.shape[0], (function() {
          return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c.shape[0] + "."
         })), O(1 === c.shape[1], (function() {
          return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c.shape[1] + "."
         }));
         var p = u.shape[2],
          f = u.shape[3];
         O(c.shape[2] === p * f, (function() {
          return "Error in separableConv2d: the third dimension of pointwise filter must be " + p * f + ", but got " + c.shape[2] + "."
         }));
         var d = Zc(l, u, r, i, a, o),
          v = qc(d, c, 1, "valid", a);
         return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v
        }
       }),
       el = Tn({
        conv2dTranspose_: function(t, e, n, r, i, o) {
         return Uc(n, bn(t, "x", "conv2dTranspose"), bn(e, "filter", "conv2dTranspose"), r, i, "NHWC", o)
        }
       }),
       nl = Tn({
        conv3dTranspose_: function(t, e, n, r, i) {
         return $c(n, bn(t, "x", "conv3dTranspose"), bn(e, "filter", "conv3dTranspose"), r, i)
        }
       }),
       rl = Tn({
        matMul_: function(t, e, n, r) {
         var i;
         void 0 === n && (n = !1), void 0 === r && (r = !1);
         var o = bn(t, "a", "matMul"),
          a = bn(e, "b", "matMul");
         i = Ft(o, a), o = i[0], a = i[1];
         var s = n ? o.shape[o.rank - 2] : o.shape[o.rank - 1],
          u = r ? a.shape[a.rank - 1] : a.shape[a.rank - 2],
          c = n ? o.shape[o.rank - 1] : o.shape[o.rank - 2],
          l = r ? a.shape[a.rank - 2] : a.shape[a.rank - 1],
          h = o.shape.slice(0, -2),
          p = a.shape.slice(0, -2),
          f = T(h),
          d = T(p);
         O(o.rank >= 2 && a.rank >= 2 && o.rank === a.rank, (function() {
          return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + o.rank + " and " + a.rank + "."
         })), O(_(h, p), (function() {
          return "Error in matMul: outer dimensions (" + h + ") and (" + p + ") of Tensors with shapes " + o.shape + " and " + a.shape + " must match."
         })), O(s === u, (function() {
          return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + o.shape + " and " + a.shape + " and transposeA=" + n + " and transposeB=" + r + " must match."
         }));
         var v = o.shape.slice(0, -2).concat([c, l]),
          m = n ? o.as3D(f, s, c) : o.as3D(f, c, s),
          g = r ? a.as3D(d, l, u) : a.as3D(d, u, l),
          y = {
           transposeA: n,
           transposeB: r
          };
         return Wt.runKernelFunc((function(t, e) {
          var i = t.batchMatMul(m, g, n, r);
          return e([m, g]), i
         }), {
          a: m,
          b: g
         }, (function(t, e) {
          var i = e,
           o = i[0],
           a = i[1];
          return n || r ? !n && r ? {
           a: function() {
            return t.matMul(a, !1, !1)
           },
           b: function() {
            return t.matMul(o, !0, !1)
           }
          } : n && !r ? {
           a: function() {
            return a.matMul(t, !1, !0)
           },
           b: function() {
            return o.matMul(t, !1, !1)
           }
          } : {
           a: function() {
            return a.matMul(t, !0, !0)
           },
           b: function() {
            return t.matMul(o, !0, !0)
           }
          } : {
           a: function() {
            return t.matMul(a, !1, !0)
           },
           b: function() {
            return o.matMul(t, !0, !1)
           }
          }
         }), "BatchMatMul", y).reshape(v)
        }
       }),
       il = Tn({
        dot_: function(t, e) {
         var n = bn(t, "t1", "dot"),
          r = bn(e, "t2", "dot");
         O(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), (function() {
          return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + "."
         }));
         var i = 1 === n.rank ? n.size : n.shape[1],
          o = 1 === r.rank ? r.size : r.shape[0];
         return O(i === o, (function() {
          return "Error in dot: inner dimensions of inputs must match, but got " + i + " and " + o + "."
         })), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]))
        }
       }),
       ol = Tn({
        outerProduct_: function(t, e) {
         var n = bn(t, "v1", "outerProduct"),
          r = bn(e, "v2", "outerProduct");
         return O(1 === n.rank && 1 === r.rank, (function() {
          return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + "."
         })), n.as2D(-1, 1).matMul(r.as2D(1, -1))
        }
       }),
       al = Tn({
        reverse_: function(t, e) {
         var n = bn(t, "x", "reverse");
         if (0 === n.rank) return n.clone();
         var r = z(e, n.shape);
         return Wt.runKernelFunc((function(t) {
          return t.reverse(n, r)
         }), {
          $x: n
         }, (function(t) {
          return {
           $x: function() {
            return t.reverse(r)
           }
          }
         })).reshapeAs(n)
        }
       }),
       sl = Tn({
        reverse1d_: function(t) {
         var e = bn(t, "x", "reverse");
         return O(1 === e.rank, (function() {
          return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + "."
         })), al(e, 0)
        }
       }),
       ul = Tn({
        reverse2d_: function(t, e) {
         var n = bn(t, "x", "reverse");
         return O(2 === n.rank, (function() {
          return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + "."
         })), al(n, e)
        }
       }),
       cl = Tn({
        reverse3d_: function(t, e) {
         var n = bn(t, "x", "reverse");
         return O(3 === n.rank, (function() {
          return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + "."
         })), al(n, e)
        }
       }),
       ll = Tn({
        reverse4d_: function(t, e) {
         var n = bn(t, "x", "reverse");
         return O(4 === n.rank, (function() {
          return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + "."
         })), al(n, e)
        }
       });
 
      function hl(t, e, n, r, i, o) {
       var a = bn(t, "x", "maxPool"),
        s = a,
        u = !1;
       3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), null == r && (r = [1, 1]), O(4 === s.rank, (function() {
        return "Error in maxPool: input must be rank 4 but got rank " + s.rank + "."
       })), O(Bi(n, r), (function() {
        return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'"
       })), null != o && O(D(i), (function() {
        return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
       }));
       var c = Oi(s.shape, e, n, r, i, o);
       if (1 === c.filterWidth && 1 === c.filterHeight && _(c.inShape, c.outShape)) return a.clone();
       var l = [s],
        h = Wt.runKernelFunc((function(t, e) {
         var n = t.maxPool(s, c);
         return e([s, n]), n
        }), {
         x: s
        }, (function(t, o) {
         var a = o[0],
          s = o[1];
         return {
          x: function() {
           return function(t, e, n, r, i, o, a, s) {
            var u = bn(t, "dy", "maxPoolBackprop"),
             c = bn(e, "input", "maxPoolBackprop"),
             l = bn(n, "output", "maxPoolBackprop");
            O(c.rank === u.rank, (function() {
             return "Rank of input (" + c.rank + ") does not match rank of dy (" + u.rank + ")"
            })), null == o && (o = [1, 1]), O(Bi(i, o), (function() {
             return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + o + "'"
            })), O(4 === u.rank, (function() {
             return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u.rank + "."
            })), O(4 === c.rank, (function() {
             return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c.rank + "."
            })), null != s && O(D(a), (function() {
             return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + a + "."
            }));
            var h = Oi(c.shape, r, i, o, a, s);
            return Wt.runKernelFunc((function(t) {
             return t.maxPoolBackprop(u, c, l, h)
            }), {
             $dy: u,
             $input: c
            })
           }(t, a, s, e, n, r, i)
          }
         }
        }), "MaxPool", c, l);
       return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h
      }
 
      function pl(t, e, n, r, i, o) {
       var a = bn(t, "x", "avgPool", "float32");
       null == r && (r = [1, 1]), O(Bi(n, r), (function() {
        return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'"
       }));
       var s = a,
        u = !1;
       3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), O(4 === s.rank, (function() {
        return "Error in avgPool: x must be rank 4 but got rank " + s.rank + "."
       })), null != o && O(D(i), (function() {
        return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
       }));
       var c = Oi(s.shape, e, n, r, i, o);
       if (1 === c.filterWidth && 1 === c.filterHeight && _(c.inShape, c.outShape)) return a.clone();
       var l = Wt.runKernelFunc((function(t) {
        return t.avgPool(s, c)
       }), {
        x: s
       }, (function(t) {
        return {
         x: function() {
          return function(t, e, n, r, i, o) {
           var a = bn(t, "dy", "avgPoolBackprop"),
            s = bn(e, "input", "avgPoolBackprop");
           O(s.rank === a.rank, (function() {
            return "Rank of input (" + s.rank + ") does not match rank of dy (" + a.rank + ")"
           })), null == i && (i = [1, 1]), O(Bi(r, i), (function() {
            return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + i + "'"
           }));
           var u = s,
            c = a,
            l = !1;
           3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), O(4 === c.rank, (function() {
            return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c.rank + "."
           })), O(4 === u.rank, (function() {
            return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u.rank + "."
           }));
           var h = Oi(u.shape, n, r, i, o),
            p = Wt.runKernelFunc((function(t) {
             return t.avgPoolBackprop(c, u, h)
            }), {
             dy4D: c,
             input4D: u
            });
           return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p
          }(t, s, e, n, r, i)
         }
        }
       }), "AvgPool", c);
       return l = l.cast(a.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l
      }
      var fl = Tn({
        maxPool_: function(t, e, n, r, i) {
         return hl(t, e, n, 1, r, i)
        }
       }),
       dl = Tn({
        avgPool_: function(t, e, n, r, i) {
         return pl(t, e, n, 1, r, i)
        }
       }),
       vl = Tn({
        pool_: function(t, e, n, r, i, o) {
         null == i && (i = [1, 1]), null == o && (o = 1), 0 === r && (r = "valid");
         var a = bn(t, "x", "maxPool"),
          s = a,
          u = !1;
         3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), O(Bi(o, i), (function() {
          return "Error in pool: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + i + "'"
         }));
         var c, l = Oi(s.shape, e, o, i, r),
          h = [l.dilationHeight, l.dilationWidth];
         c = "same" === r ? function(t, e) {
          var n = t.map((function(t, n) {
            return t + (t - 1) * (e[n] - 1)
           })).map((function(t) {
            return t - 1
           })),
           r = n.map((function(t) {
            return Math.floor(t / 2)
           })),
           i = n.map((function(t, e) {
            return t - r[e]
           }));
          return n.map((function(t, e) {
           return [r[e], i[e]]
          }))
         }([l.filterHeight, l.filterWidth], h) : [
          [0, 0],
          [0, 0]
         ];
         var p = 1 === h[0] && 1 === h[1],
          f = function(t, e, n) {
           var r = n.map((function(t) {
             return t[0]
            })),
            i = n.map((function(t) {
             return t[1]
            })),
            o = t.concat(r, i),
            a = e.map((function(t, e) {
             return (t - o[e] % t) % t
            })),
            s = i.map((function(t, e) {
             return t + a[e]
            })),
            u = e.map((function(t, e) {
             return [r[e], s[e]]
            })),
            c = e.map((function(t, e) {
             return [0, a[e]]
            }));
           return [u, c]
          }([l.inHeight, l.inWidth], h, c),
          d = f[0],
          v = f[1],
          m = p ? r : "valid",
          g = p ? s : Pr(s, h, d),
          y = ("avg" === n ? function() {
           return pl(g, e, o, 1, m)
          } : function() {
           return hl(g, e, o, 1, m)
          })(),
          b = p ? y : yr(y, h, v);
         return u ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b
        }
       }),
       ml = Tn({
        maxPool3d_: function(t, e, n, r, i, o, a) {
         void 0 === o && (o = "NDHWC");
         var s = bn(t, "x", "maxPool3d"),
          u = s,
          c = !1;
         4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == a && (a = [1, 1, 1]), O(5 === u.rank, (function() {
          return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + "."
         })), O("NDHWC" === o, (function() {
          return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + o
         })), O(Bi(n, a), (function() {
          return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'"
         })), null != i && O(D(r), (function() {
          return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + "."
         }));
         var l = Ai(u.shape, e, n, a, r, i, o),
          h = Wt.runKernelFunc((function(t, e) {
           var n = t.maxPool3d(u, l);
           return e([u, n]), n
          }), {
           x: u
          }, (function(t, o) {
           var s = o[0],
            u = o[1];
           return {
            x: function() {
             return function(t, e, n, r, i, o, a, s) {
              var u = bn(t, "dy", "maxPool3dBackprop"),
               c = bn(e, "input", "maxPool3dBackprop"),
               l = bn(n, "output", "maxPool3dBackprop"),
               h = u,
               p = c,
               f = l,
               d = !1;
              4 === c.rank && (d = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), p = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), f = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3])), O(5 === h.rank, (function() {
               return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h.rank + "."
              })), O(5 === p.rank, (function() {
               return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + p.rank + "."
              })), O(5 === f.rank, (function() {
               return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + f.rank + "."
              })), null == o && (o = [1, 1, 1]), O(Bi(i, o), (function() {
               return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + o + "'"
              })), null != s && O(D(a), (function() {
               return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + a + "."
              }));
              var v = Ai(p.shape, r, i, o, a, s),
               m = Wt.runKernelFunc((function(t) {
                return t.maxPool3dBackprop(h, p, f, v)
               }), {
                dy5D: h,
                input5D: p
               });
              return d ? m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]) : m
             }(t, s, u, e, n, a, r, i)
            }
           }
          }));
         return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
        }
       }),
       gl = Tn({
        avgPool3d_: function(t, e, n, r, i, o, a) {
         void 0 === o && (o = "NDHWC");
         var s = bn(t, "x", "avgPool3d", "float32"),
          u = s,
          c = !1;
         4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == a && (a = [1, 1, 1]), O(5 === u.rank, (function() {
          return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + "."
         })), O("NDHWC" === o, (function() {
          return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + o
         })), O(Bi(n, a), (function() {
          return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'"
         })), null != i && O(D(r), (function() {
          return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + "."
         }));
         var l = Ai(u.shape, e, n, a, r, i, o),
          h = Wt.runKernelFunc((function(t) {
           return t.avgPool3d(u, l)
          }), {
           x: u
          }, (function(t) {
           return {
            x: function() {
             return function(t, e, n, r, i, o, a) {
              var s = bn(t, "dy", "avgPool3dBackprop"),
               u = bn(e, "input", "avgPool3dBackprop"),
               c = s,
               l = u,
               h = !1;
              4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])), O(5 === c.rank, (function() {
               return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c.rank + "."
              })), O(5 === l.rank, (function() {
               return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l.rank + "."
              })), null == i && (i = [1, 1, 1]), O(Bi(r, i), (function() {
               return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + i + "'"
              })), null != a && O(D(o), (function() {
               return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + "."
              }));
              var p = Ai(l.shape, n, r, i, o, a),
               f = Wt.runKernelFunc((function(t) {
                return t.avgPool3dBackprop(c, l, p)
               }), {
                dy5D: c,
                input5D: l
               });
              return h ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f
             }(t, u, e, n, a, r, i)
            }
           }
          }));
         return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
        }
       }),
       yl = Tn({
        slice_: function(t, e, n) {
         var r, i, o = bn(t, "x", "slice");
         if (0 === o.rank) throw new Error("Slicing scalar is not possible");
         (r = "number" == typeof e ? [e].concat(new Array(o.rank - 1).fill(0)) : e.length < o.rank ? e.concat(new Array(o.rank - e.length).fill(0)) : e.slice()).forEach((function(t) {
          O(-1 !== t, (function() {
           return "slice() does not support negative begin indexing."
          }))
         })), i = (i = null == n ? new Array(o.rank).fill(-1) : "number" == typeof n ? [n].concat(new Array(o.rank - 1).fill(-1)) : n.length < o.rank ? n.concat(new Array(o.rank - n.length).fill(-1)) : n).map((function(t, e) {
          return t >= 0 ? t : (O(-1 === t, (function() {
           return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + e + "."
          })), o.shape[e] - r[e])
         })), ii(o, r, i);
         var a = o.shape,
          s = {
           begin: r,
           size: i
          };
         return Wt.runKernelFunc((function(t) {
          return t.slice(o, r, i)
         }), {
          x: o
         }, (function(t) {
          for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], a[n] - r[n] - i[n]]);
          return {
           x: function() {
            return t.pad(e)
           }
          }
         }), "Slice", s)
        }
       }),
       bl = Tn({
        slice1d_: function(t, e, n) {
         var r = bn(t, "x", "slice1d");
         return O(1 === r.rank, (function() {
          return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor"
         })), yl(r, [e], [n])
        }
       }),
       xl = Tn({
        slice2d_: function(t, e, n) {
         var r = bn(t, "x", "slice2d");
         return O(2 === r.rank, (function() {
          return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor"
         })), yl(r, e, n)
        }
       }),
       wl = Tn({
        slice3d_: function(t, e, n) {
         var r = bn(t, "x", "slice3d");
         return O(3 === r.rank, (function() {
          return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor"
         })), yl(r, e, n)
        }
       }),
       Cl = Tn({
        slice4d_: function(t, e, n) {
         var r = bn(t, "x", "slice4d");
         return O(4 === r.rank, (function() {
          return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor"
         })), yl(r, e, n)
        }
       });
 
      function Sl(t, e, n, r, i) {
       return e.rank < n.rank && (e = e.reshape(En(e.shape, r))), t.rank < n.rank && (t = t.reshape(En(t.shape, r))), {
        x: function() {
         var r = t.mul(n.equal(e).cast(t.dtype));
         return null == i ? r : r.transpose(i)
        }
       }
      }
      var El = Tn({
        all_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "all", "bool"),
          i = z(e, r.shape),
          o = i,
          a = In(o, r.rank);
         null != a && (r = r.transpose(a), o = An(o.length, r.rank));
         var s = Wt.runKernelFunc((function(t) {
          return t.all(r, o)
         }), {
          $x: r
         });
         if (n) {
          var u = En(s.shape, i);
          return s.reshape(u)
         }
         return s
        }
       }),
       kl = Tn({
        any_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "any", "bool"),
          i = z(e, r.shape),
          o = i,
          a = In(o, r.rank);
         null != a && (r = r.transpose(a), o = An(o.length, r.rank));
         var s = Wt.runKernelFunc((function(t) {
          return t.any(r, o)
         }), {
          $x: r
         });
         if (n) {
          var u = En(s.shape, i);
          return s.reshape(u)
         }
         return s
        }
       }),
       Il = Tn({
        argMax_: function(t, e) {
         void 0 === e && (e = 0);
         var n = bn(t, "x", "argMax");
         null == e && (e = 0);
         var r = z(e, n.shape),
          i = In(r, n.rank);
         null != i && (n = n.transpose(i), r = An(r.length, n.rank));
         var o = {
           axis: r[0]
          },
          a = [n];
         return Wt.runKernelFunc((function(t, e) {
          var i = t.argMax(n, r[0]);
          return e([n]), i
         }), {
          x: n
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return Zn(n)
           }
          }
         }), "ArgMax", o, a)
        }
       }),
       Ol = Tn({
        argMin_: function(t, e) {
         void 0 === e && (e = 0);
         var n = bn(t, "x", "argMin");
         null == e && (e = 0);
         var r = z(e, n.shape),
          i = In(r, n.rank);
         return null != i && (n = n.transpose(i), r = An(r.length, n.rank)), Wt.runKernelFunc((function(t, e) {
          var i = t.argMin(n, r[0]);
          return e([n]), i
         }), {
          $x: n
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return Zn(n)
           }
          }
         }))
        }
       }),
       Al = Tn({
        logSumExp_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "logSumExp"),
          i = z(e, r.shape),
          o = r.max(i, !0),
          a = r.sub(o).exp().sum(i).log(),
          s = o.reshape(a.shape).add(a);
         if (n) {
          var u = En(s.shape, i);
          return s.reshape(u)
         }
         return s
        }
       }),
       Nl = Tn({
        max_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "max"),
          i = r,
          o = z(e, r.shape),
          a = o,
          s = In(a, r.rank);
         null != s && (r = r.transpose(s), a = An(a.length, r.rank));
         var u = [r],
          c = Wt.runKernelFunc((function(t, e) {
           var n = t.max(r, a);
           return e([i, n]), n
          }), {
           x: r
          }, (function(t, e) {
           return Sl(t, e[1], e[0], o, s)
          }), "Max", {
           axes: a
          }, u, [!0]);
         if (n) {
          var l = En(c.shape, o);
          c = c.reshape(l)
         }
         return c
        }
       }),
       Rl = Tn({
        mean_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "mean"),
          i = z(e, r.shape),
          o = T(Sn(r.shape, i)[1]);
         return gi((function(t) {
          var r = Bn(o);
          return {
           value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),
           gradFunc: function(e) {
            var n = t.shape.slice();
            return i.forEach((function(t) {
             n[t] = 1
            })), e.reshape(n).mul($n(t.shape, "float32")).div(o)
           }
          }
         }))(r)
        }
       }),
       Tl = Tn({
        min_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "min"),
          i = r,
          o = z(e, r.shape),
          a = o,
          s = In(a, r.rank);
         null != s && (r = r.transpose(s), a = An(a.length, r.rank));
         var u = [r],
          c = Wt.runKernelFunc((function(t, e) {
           var n = t.min(r, a);
           return e([i, n]), n
          }), {
           x: r
          }, (function(t, e) {
           return Sl(t, e[1], e[0], o, s)
          }), "Min", {
           axes: a
          }, u, [!0]);
         if (n) {
          var l = En(c.shape, o);
          c = c.reshape(l)
         }
         return c
        }
       }),
       _l = Tn({
        moments_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = z(e, (t = bn(t, "x", "moments")).shape),
          i = t.mean(r, n),
          o = i.shape;
         n || (o = En(i.shape, r));
         var a = t.toFloat().sub(i.reshape(o)).square();
         return {
          mean: i,
          variance: a.mean(r, n)
         }
        }
       }),
       Dl = Tn({
        sum_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "sum");
         "bool" === r.dtype && (r = r.toInt());
         var i = z(e, r.shape);
         return gi((function(t) {
          var e = In(i, t.rank),
           r = i,
           o = t;
          null != e && (o = t.transpose(e), r = An(r.length, t.rank));
          var a = function(e) {
            var n = t.shape.slice();
            return i.forEach((function(t) {
             n[t] = 1
            })), e.reshape(n).mul($n(t.shape, "float32"))
           },
           s = {
            axes: r
           },
           u = Wt.runKernelFunc((function(t) {
            return t.sum(o, r)
           }), {
            x: o
           }, (function(t) {
            return {
             x: function() {
              return a(t)
             }
            }
           }), "Sum", s);
          if (n) {
           var c = En(u.shape, i);
           u = u.reshape(c)
          }
          return {
           value: u,
           gradFunc: a
          }
         }))(r)
        }
       }),
       Fl = Tn({
        prod_: function(t, e, n) {
         void 0 === e && (e = null), void 0 === n && (n = !1);
         var r = bn(t, "x", "prod");
         "bool" === r.dtype && (r = r.toInt());
         var i = z(e, r.shape),
          o = In(i, r.rank),
          a = i,
          s = r;
         null != o && (s = r.transpose(o), a = An(a.length, r.rank));
         var u = Wt.runKernelFunc((function(t) {
          return t.prod(s, a)
         }), {
          permutedX: s
         });
         if (n) {
          var c = En(u.shape, i);
          u = u.reshape(c)
         }
         return u
        }
       }),
       Ml = Tn({
        elu_: function(t) {
         var e = bn(t, "x", "elu");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.elu(e);
          return n([r]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            return Wt.runKernelFunc((function(e) {
             return e.eluDer(t, n)
            }), {
             dy: t,
             y: n
            })
           }
          }
         }))
        }
       }),
       Ll = Tn({
        leakyRelu_: function(t, e) {
         void 0 === e && (e = .2);
         var n = bn(t, "x", "leakyRelu");
         return pc(Bn(e).mul(n), n)
        }
       }),
       Bl = Tn({
        prelu_: function(t, e) {
         var n = bn(t, "x", "prelu"),
          r = bn(e, "alpha", "prelu");
         return Wt.runKernelFunc((function(t, e) {
          var i = t.prelu(n, r);
          return e([n, r]), i
         }), {
          x: n,
          alpha: r
         }, (function(t, e) {
          var n = e[0],
           r = e[1],
           i = n.greater(0);
          return {
           x: function() {
            return nc(i, t, t.mul(r))
           },
           alpha: function() {
            var e = nc(i, Zn(t), t.mul(n)),
             o = ki(r.shape, t.shape);
            return o.length > 0 && (e = e.sum(o)), e.reshape(r.shape)
           }
          }
         }), "Prelu")
        }
       }),
       Pl = Tn({
        relu_: function(t) {
         var e = bn(t, "x", "relu");
         return "bool" === e.dtype ? e.toInt() : Wt.runKernelFunc((function(t, n) {
          var r = t.relu(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           x: function() {
            return t.mulStrict(n.step().toFloat())
           }
          }
         }), "Relu")
        }
       }),
       zl = Tn({
        relu6_: function(t) {
         var e = bn(t, "x", "relu6");
         return "bool" === e.dtype ? e.toInt() : Wt.runKernelFunc((function(t, n) {
          var r = t.relu6(e);
          return n([e]), r
         }), {
          x: e
         }, (function(t, e) {
          var n = e[0],
           r = n.lessEqual(6).mul(n.step());
          return {
           x: function() {
            return t.mulStrict(r.toFloat())
           }
          }
         }), "Relu6")
        }
       }),
       jl = Tn({
        selu_: function(t) {
         var e = bn(t, "x", "selu");
         return Wt.runKernelFunc((function(t, n) {
          var r = t.selu(e);
          return n([e]), r
         }), {
          $x: e
         }, (function(t, e) {
          var n = e[0];
          return {
           $x: function() {
            var e = n.greater(Bn(0)),
             r = Bn(Ss),
             i = Bn(Es),
             o = t.mul(i),
             a = t.mul(r).mul(n.toFloat().exp());
            return nc(e, o, a)
           }
          }
         }))
        }
       }),
       Wl = Tn({
        transpose_: function(t, e) {
         var n = bn(t, "x", "transpose");
         if (null == e && (e = n.shape.map((function(t, e) {
           return e
          })).reverse()), O(n.rank === e.length, (function() {
           return "Error in transpose: rank of input " + n.rank + " must match length of perm " + e + "."
          })), e.forEach((function(t) {
           O(t >= 0 && t < n.rank, (function() {
            return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + e
           }))
          })), n.rank <= 1) return n.clone();
         var r = {
          perm: e
         };
         return Wt.runKernelFunc((function(t) {
          return t.transpose(n, e)
         }), {
          x: n
         }, (function(t) {
          var n = On(e);
          return {
           x: function() {
            return t.transpose(n)
           }
          }
         }), "Transpose", r)
        }
       }),
       Vl = Tn({
        localResponseNormalization_: function(t, e, n, r, i) {
         void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === i && (i = .5);
         var o = bn(t, "x", "localResponseNormalization");
         O(4 === o.rank || 3 === o.rank, (function() {
          return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + o.rank + "."
         })), O(D(e), (function() {
          return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + "."
         }));
         var a = o,
          s = !1;
         3 === o.rank && (s = !0, a = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]));
         var u = Wt.runKernelFunc((function(t, o) {
          var s = t.localResponseNormalization4D(a, e, n, r, i);
          return o([a, s]), s
         }), {
          x4D: a
         }, (function(t, o) {
          var a = o[0],
           s = o[1];
          return {
           x4D: function() {
            return Wt.runKernelFunc((function(o) {
             return o.LRNGrad(t, a, s, e, n, r, i)
            }), {})
           }
          }
         }));
         return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
        }
       }),
       Ul = Tn({
        norm_: function(t, e, n, r) {
         void 0 === e && (e = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);
         var i = function t(e, n, r) {
           if (void 0 === r && (r = null), 0 === e.rank) return e.abs();
           if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);
           if (1 === e.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
            if (1 === n) return e.abs().sum(r);
            if (n === 1 / 0) return e.abs().max(r);
            if (n === -1 / 0) return e.abs().min(r);
            if ("euclidean" === n || 2 === n) return e.abs().pow(Bn(2, "int32")).sum(r).sqrt();
            throw new Error("Error in norm: invalid ord value: " + n)
           }
           if (Array.isArray(r) && 2 === r.length) {
            if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);
            if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
            if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
            if ("fro" === n || "euclidean" === n) return e.square().sum(r).sqrt();
            throw new Error("Error in norm: invalid ord value: " + n)
           }
           throw new Error("Error in norm: invalid axis: " + r)
          }(t = bn(t, "x", "norm"), e, n),
          o = i.shape;
         if (r) {
          var a = z(n, t.shape);
          o = En(i.shape, a)
         }
         return i.reshape(o)
        }
       }),
       Hl = Tn({
        basicLSTMCell_: function(t, e, n, r, i, o) {
         var a = bn(t, "forgetBias", "basicLSTMCell"),
          s = bn(e, "lstmKernel", "basicLSTMCell"),
          u = bn(n, "lstmBias", "basicLSTMCell"),
          c = bn(r, "data", "basicLSTMCell"),
          l = bn(i, "c", "basicLSTMCell"),
          h = bn(o, "h", "basicLSTMCell"),
          p = c.concat(h, 1).matMul(s).add(u),
          f = p.shape[0],
          d = p.shape[1] / 4,
          v = [f, d],
          m = p.slice([0, 0], v),
          g = p.slice([0, d], v),
          y = p.slice([0, 2 * d], v),
          b = p.slice([0, 3 * d], v),
          x = m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(a.add(y).sigmoid())),
          w = x.tanh().mulStrict(b.sigmoid());
         return [x, w]
        }
       }),
       $l = Tn({
        multiRNNCell_: function(t, e, n, r) {
         for (var i = bn(e, "data", "multiRNNCell"), o = xn(n, "c", "multiRNNCell"), a = xn(r, "h", "multiRNNCell"), s = i, u = [], c = 0; c < t.length; c++) {
          var l = t[c](s, o[c], a[c]);
          u.push(l[0]), u.push(l[1]), s = l[1]
         }
         var h = [],
          p = [];
         for (c = 0; c < u.length; c += 2) h.push(u[c]), p.push(u[c + 1]);
         return [h, p]
        }
       }),
       Gl = Tn({
        movingAverage_: function(t, e, n, r, i) {
         void 0 === i && (i = !0);
         var o = bn(t, "v", "movingAverage"),
          a = bn(e, "x", "movingAverage"),
          s = bn(n, "decay", "movingAverage");
         Mt(o, a), O(_(o.shape, a.shape), (function() {
          return "Shape mismatch in v and x"
         }));
         var u = Bn(1),
          c = u.sub(s),
          l = a.sub(o).mul(c);
         if (i) {
          O(null != r, (function() {
           return "When using zeroDebias: true, step is required."
          }));
          var h = bn(r, "step", "movingAverage");
          l = l.div(u.sub(xc(s, h)))
         }
         return o.add(l)
        }
       }),
       ql = Tn({
        stridedSlice_: function(t, e, n, r, i, o, a, s, u) {
         if (void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== a) throw new Error("ellipsis mask is not yet supported");
         var c = bn(t, "x", "stridedSlice"),
          l = oi(s),
          h = c.shape.slice();
         l.forEach((function(t) {
          e[t] = 0, n[t] = 1, h.splice(t, 0, 1)
         })), c = c.reshape(h);
         for (var p = 0; p < c.rank; p++) e[p] = si(i, e, r, c.shape, p), n[p] = ui(o, n, r, c.shape, p), r[p] = r[p] || 1;
         var f = oi(u);
         f.forEach((function(t) {
          n[t] = e[t] + 1, r[t] = 1
         }));
         var d = ai(e, n, r),
          v = d.filter((function(t, e) {
           return -1 === f.indexOf(e)
          }));
         return r.every((function(t) {
          return 1 === t
         })) ? yl(c, e, d).reshape(v) : Wt.runKernelFunc((function(t) {
          return t.stridedSlice(c, e, n, r)
         }), {
          $x: c
         }).reshape(v)
        }
       }),
       Kl = Tn({
        topk_: function(t, e, n) {
         void 0 === e && (e = 1), void 0 === n && (n = !0);
         var r = bn(t, "x", "topk");
         if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
         var i = r.shape[r.shape.length - 1];
         if (e > i) throw new Error("'k' passed to topk() must be <= the last dimension (" + i + ") but got " + e);
         var o = Wt.runKernelFunc((function(t) {
          return t.topk(r, e, n)
         }), {
          $x: r
         });
         return {
          values: o[0],
          indices: o[1]
         }
        }
       }),
       Xl = Tn({
        scatterND_: function(t, e, n) {
         var r = bn(t, "indices", "scatterND", "int32"),
          i = bn(e, "updates", "scatterND");
         return ei(i, r, n), Wt.runKernelFunc((function(t) {
          return t.scatterND(r, i, n)
         }), {
          indices: r,
          updates: i
         }, null, "ScatterNd", {
          shape: n
         })
        }
       }),
       Yl = Tn({
        fft_: function(t) {
         O("complex64" === t.dtype, (function() {
          return "The dtype for tf.spectral.fft() must be complex64 but got " + t.dtype + "."
         }));
         var e = t.shape[t.shape.length - 1],
          n = t.size / e,
          r = t.as2D(n, e);
         return Wt.runKernelFunc((function(t) {
          return t.fft(r)
         }), {
          input: t
         }).reshape(t.shape)
        }
       }),
       Zl = Tn({
        ifft_: function(t) {
         O("complex64" === t.dtype, (function() {
          return "The dtype for tf.spectral.ifft() must be complex64 but got " + t.dtype + "."
         }));
         var e = t.shape[t.shape.length - 1],
          n = t.size / e,
          r = t.as2D(n, e);
         return Wt.runKernelFunc((function(t) {
          return t.ifft(r)
         }), {
          input: t
         }).reshape(t.shape)
        }
       }),
       Jl = Tn({
        rfft_: function(t, e) {
         O("float32" === t.dtype, (function() {
          return "The dtype for rfft() must be real value but got " + t.dtype
         }));
         var n, r = t.shape[t.shape.length - 1],
          i = t.size / r;
         if (null != e && e < r) {
          var o = t.shape.map((function(t) {
            return 0
           })),
           a = t.shape.map((function(t) {
            return t
           }));
          a[t.shape.length - 1] = e, n = t.slice(o, a), r = e
         } else if (null != e && e > r) {
          var s = t.shape.map((function(t) {
           return t
          }));
          s[t.shape.length - 1] = e - r, n = t.concat(Gn(s), t.shape.length - 1), r = e
         } else n = t;
         var u = n.zerosLike(),
          c = _n(n, u).as2D(i, r),
          l = Yl(c),
          h = Math.floor(r / 2) + 1,
          p = Dn(l),
          f = Fn(l),
          d = p.split([h, r - h], p.shape.length - 1),
          v = f.split([h, r - h], f.shape.length - 1),
          m = n.shape.slice();
         return m[n.shape.length - 1] = h, _n(d[0], v[0]).reshape(m)
        }
       }),
       Ql = Tn({
        irfft_: function(t) {
         var e = t.shape[t.shape.length - 1],
          n = t.size / e;
         if (e <= 2) {
          var r = t.as2D(n, e),
           i = Zl(r);
          return Dn(i)
         }
         var o = [n, 2 * (e - 1)],
          a = Dn(t).as2D(n, e),
          s = Fn(t).as2D(n, e),
          u = a.slice([0, 1], [n, e - 2]).reverse(1),
          c = s.slice([0, 1], [n, e - 2]).reverse(1).mul(Bn(-1)),
          l = a.concat(u, 1),
          h = s.concat(c, 1);
         return r = _n(l, h).as2D(o[0], o[1]), i = Zl(r), Dn(i)
        }
       }),
       th = Object.freeze({
        fft: Yl,
        ifft: Zl,
        rfft: Jl,
        irfft: Ql
       }),
       eh = Tn({
        sparseToDense_: function(t, e, n, r) {
         void 0 === r && (r = 0);
         var i = bn(t, "sparseIndices", "sparseToDense", "int32"),
          o = bn(e, "sparseValues", "sparseToDense"),
          a = bn(r, "defaultValue", "sparseToDense", o.dtype);
         return function(t, e, n, r) {
          if ("int32" !== t.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
          if (t.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t.shape + ".");
          var i = t.rank > 0 ? t.shape[0] : 1,
           o = t.rank > 1 ? t.shape[1] : 1;
          if (n.length !== o) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + o + ".");
          var a = e.size;
          if (0 !== e.rank && (1 !== e.rank || a !== i)) throw new Error("sparseValues has incorrect shape " + e.shape + ", should be [] or [" + i + "]");
          if (e.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
         }(i, o, n, a), Wt.runKernelFunc((function(t) {
          return t.sparseToDense(i, o, n, a)
         }), {
          $sparseIndices: i,
          $sparseValues: o,
          $defaultValue: a
         })
        }
       }),
       nh = Tn({
        gatherND_: function(t, e) {
         var n = bn(e, "indices", "gatherND", "int32"),
          r = bn(t, "x", "gatherND");
         return Wt.runKernelFunc((function(t) {
          return t.gatherND(r, n)
         }), {
          x: r,
          indices: n
         }, null, "GatherNd")
        }
       }),
       rh = Tn({
        diag_: function(t) {
         var e = bn(t, "x", "diag").flatten(),
          n = t.shape.concat(t.shape);
         return Wt.runKernelFunc((function(t) {
          return t.diag(e)
         }), {
          $x: e
         }).reshape(n)
        }
       }),
       ih = Tn({
        dropout_: function(t, e, n, r) {
         var i = bn(t, "x", "dropout");
         if (O("float32" === i.dtype, (function() {
           return "x has to be a floating point tensor since it's going to be scaled, but got a " + i.dtype + " tensor instead."
          })), O(e >= 0 && e < 1, (function() {
           return "rate must be a float in the range [0, 1), but got " + e + "."
          })), 0 === e) return t instanceof Et ? i.clone() : i;
         var o = function(t, e) {
           if (null == e) return t.shape.slice();
           if (_(t.shape, e)) return e;
           if (t.shape.length === e.length) {
            for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);
            return n
           }
           return e
          }(i, n),
          a = 1 - e,
          s = Lr(o, 0, 1, "float32", r).add(a).floor().div(a);
         return i.mul(s)
        }
       });
 
      function oh(t, e, n) {
       for (var r = 1 - t % 2, i = new Float32Array(t), o = 0; o < t; ++o) {
        var a = 2 * Math.PI * o / (t + r - 1);
        i[o] = e - n * Math.cos(a)
       }
       return Pn(i, "float32")
      }
      var ah, sh = Tn({
        hannWindow_: function(t) {
         return oh(t, .5, .5)
        }
       }),
       uh = Tn({
        hammingWindow_: function(t) {
         return oh(t, .54, .46)
        }
       }),
       ch = Tn({
        frame_: function(t, e, n, r, i) {
         void 0 === r && (r = !1), void 0 === i && (i = 0);
         for (var o = 0, a = []; o + e <= t.size;) a.push(yl(t, o, e)), o += n;
         if (r)
          for (; o < t.size;) {
           var s = o + e - t.size,
            u = Jn([yl(t, o, e - s), qn([s], i)]);
           a.push(u), o += n
          }
         return 0 === a.length ? zn([], [0, e]) : Jn(a).as2D(a.length, e)
        }
       }),
       lh = Tn({
        stft_: function(t, e, n, r, i) {
         var o;
         void 0 === i && (i = sh), null == r && (o = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(o) / Math.log(2)))));
         for (var a = ch(t, e, n), s = yc(a, i(e)), u = [], c = 0; c < a.shape[0]; c++) u.push(Jl(s.slice([c, 0], [1, e]), r));
         return Jn(u)
        }
       }),
       hh = Object.freeze({
        hannWindow: sh,
        hammingWindow: uh,
        frame: ch,
        stft: lh
       }),
       ph = function(t, e, n) {
        return void 0 === n && (n = 1), s(this, void 0, void 0, (function() {
         var r, i, o, a, s, c, l, h, p, f, d, v, m, g;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return r = bn(t, "predictions", "inTopK"), i = bn(e, "targets", "inTopK"), O(r.rank > 1, (function() {
             return "inTopK() expects the predictions to be of rank 2 or higher, but got " + r.rank
            })), O(r.rank - 1 === i.rank, (function() {
             return "predictions rank should be 1 larger than targets rank, but got predictions rank " + r.rank + " and targets rank " + i.rank
            })), A(r.shape.slice(0, r.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), o = r.shape[r.shape.length - 1], O(n > 0 && n <= o, (function() {
             return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + o + "), but got " + n
            })), [4, r.data()];
           case 1:
            return a = u.sent(), [4, i.data()];
           case 2:
            for (s = u.sent(), c = [a.length / o, o], h = c[1], p = W("bool", l = c[0]), f = 0; f < l; f++) {
             for (d = f * h, v = a.subarray(d, d + h), m = [], g = 0; g < v.length; g++) m.push({
              value: v[g],
              index: g
             });
             for (m.sort((function(t, e) {
               return e.value - t.value
              })), p[f] = 0, g = 0; g < n; g++)
              if (m[g].index === s[f]) {
               p[f] = 1;
               break
              }
            }
            return t !== r && r.dispose(), e !== i && i.dispose(), [2, Mn(p, i.shape, "bool")]
          }
         }))
        }))
       };
      ! function(t) {
       t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS"
      }(ah || (ah = {}));
      var fh = Tn({
        absoluteDifference_: function(t, e, n, r) {
         void 0 === r && (r = ah.SUM_BY_NONZERO_WEIGHTS);
         var i = bn(t, "labels", "absoluteDifference"),
          o = bn(e, "predictions", "absoluteDifference"),
          a = null;
         null != n && (a = bn(n, "weights", "absoluteDifference")), A(i.shape, o.shape, "Error in absoluteDifference: ");
         var s = i.sub(o).abs();
         return dh(s, a, r)
        }
       }),
       dh = Tn({
        computeWeightedLoss_: function(t, e, n) {
         void 0 === n && (n = ah.SUM_BY_NONZERO_WEIGHTS);
         var r = bn(t, "losses", "computeWeightedLoss"),
          i = null;
         null != e && (i = bn(e, "weights", "computeWeightedLoss"));
         var o = null == i ? r : r.mul(i);
         if (n === ah.NONE) return o;
         if (n === ah.SUM) return o.sum();
         if (n === ah.MEAN) {
          if (null == i) return o.mean();
          var a = r.size / i.size,
           s = o.sum().div(i.sum());
          return a > 1 ? s.div(Bn(a)) : s
         }
         if (n === ah.SUM_BY_NONZERO_WEIGHTS) {
          if (null == i) return o.sum().div(Bn(r.size));
          var u = i.mul($n(r.shape)).notEqual(Bn(0)).sum().toFloat();
          return o.sum().div(u)
         }
         throw Error("Unknown reduction: " + n)
        }
       }),
       vh = Tn({
        cosineDistance_: function(t, e, n, r, i) {
         void 0 === i && (i = ah.SUM_BY_NONZERO_WEIGHTS);
         var o = bn(t, "labels", "cosineDistance"),
          a = bn(e, "predictions", "cosineDistance"),
          s = null;
         null != r && (s = bn(r, "weights", "cosineDistance")), A(o.shape, a.shape, "Error in cosineDistance: ");
         var u = Bn(1).sub(o.mul(a).sum(n, !0));
         return dh(u, s, i)
        }
       }),
       mh = Tn({
        hingeLoss_: function(t, e, n, r) {
         void 0 === r && (r = ah.SUM_BY_NONZERO_WEIGHTS);
         var i = bn(t, "labels", "hingeLoss"),
          o = bn(e, "predictions", "hingeLoss"),
          a = null;
         null != n && (a = bn(n, "weights", "hingeLoss")), A(i.shape, o.shape, "Error in hingeLoss: ");
         var s = Bn(1);
         i = Bn(2).mul(i).sub(s);
         var u = s.sub(i.mul(o)).relu();
         return dh(u, a, r)
        }
       }),
       gh = Tn({
        huberLoss_: function(t, e, n, r, i) {
         void 0 === r && (r = 1), void 0 === i && (i = ah.SUM_BY_NONZERO_WEIGHTS);
         var o = bn(t, "labels", "huberLoss"),
          a = bn(e, "predictions", "huberLoss"),
          s = null;
         null != n && (s = bn(n, "weights", "huberLoss")), A(o.shape, a.shape, "Error in huberLoss: ");
         var u = Bn(r),
          c = a.sub(o).abs(),
          l = dc(c, u),
          h = c.sub(l),
          p = Bn(.5).mul(l.square()).add(u.mul(h));
         return dh(p, s, i)
        }
       }),
       yh = Tn({
        logLoss_: function(t, e, n, r, i) {
         void 0 === r && (r = 1e-7), void 0 === i && (i = ah.SUM_BY_NONZERO_WEIGHTS);
         var o = bn(t, "labels", "logLoss"),
          a = bn(e, "predictions", "logLoss"),
          s = null;
         null != n && (s = bn(n, "weights", "logLoss")), A(o.shape, a.shape, "Error in logLoss: ");
         var u = Bn(1),
          c = Bn(r),
          l = o.mul(a.add(c).log()).neg().sub(u.sub(o).mul(u.sub(a).add(c).log()));
         return dh(l, s, i)
        }
       }),
       bh = Tn({
        meanSquaredError_: function(t, e, n, r) {
         void 0 === r && (r = ah.SUM_BY_NONZERO_WEIGHTS);
         var i = bn(t, "labels", "meanSquaredError"),
          o = bn(e, "predictions", "meanSquaredError"),
          a = null;
         null != n && (a = bn(n, "weights", "meanSquaredError")), A(i.shape, o.shape, "Error in meanSquaredError: ");
         var s = i.squaredDifference(o);
         return dh(s, a, r)
        }
       }),
       xh = Tn({
        sigmoidCrossEntropy_: function(t, e, n, r, i) {
         void 0 === r && (r = 0), void 0 === i && (i = ah.SUM_BY_NONZERO_WEIGHTS);
         var o = bn(t, "multiClassLabels", "sigmoidCrossEntropy"),
          a = bn(e, "logits", "sigmoidCrossEntropy"),
          s = null;
         if (null != n && (s = bn(n, "weights", "sigmoidCrossEntropy")), A(o.shape, a.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
          var u = Bn(r),
           c = Bn(1),
           l = Bn(.5);
          o = o.mul(c.sub(u)).add(l.mul(u))
         }
         var h = function(t, e) {
          var n = bn(t, "labels", "sigmoidCrossEntropyWithLogits"),
           r = bn(e, "logits", "sigmoidCrossEntropyWithLogits");
          A(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
          var i = r.relu(),
           o = r.mul(n),
           a = r.abs().neg().exp().log1p();
          return i.sub(o).add(a)
         }(o, a);
         return dh(h, s, i)
        }
       }),
       wh = Tn({
        softmaxCrossEntropy_: function(t, e, n, r, i) {
         void 0 === r && (r = 0), void 0 === i && (i = ah.SUM_BY_NONZERO_WEIGHTS);
         var o = bn(t, "onehotLabels", "softmaxCrossEntropy"),
          a = bn(e, "logits", "softmaxCrossEntropy"),
          s = null;
         if (null != n && (s = bn(n, "weights", "softmaxCrossEntropy")), A(o.shape, a.shape, "Error in softmaxCrossEntropy: "), r > 0) {
          var u = Bn(r),
           c = Bn(1),
           l = Bn(o.shape[1]);
          o = o.mul(c.sub(u)).add(u.div(l))
         }
         var h = function(t, e, n) {
          if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e.rank + " and dim was " + n);
          return gi((function(t, e, r) {
           var i = e.logSumExp([n], !0),
            o = e.toFloat().sub(i);
           return r([t, o]), {
            value: o.mul(t).neg().sum([n]),
            gradFunc: function(t, e) {
             var r = e[0],
              i = e[1],
              o = En(t.shape, [n]);
             return [t.reshape(o).mul(r.toFloat().sub(i.exp())), t.reshape(o).mul(i.exp().sub(r.toFloat()))]
            }
           }
          }))(t, e)
         }(o, a);
         return dh(h, s, i)
        }
       }),
       Ch = Object.freeze({
        get Reduction() {
         return ah
        },
        absoluteDifference: fh,
        computeWeightedLoss: dh,
        cosineDistance: vh,
        hingeLoss: mh,
        huberLoss: gh,
        logLoss: yh,
        meanSquaredError: bh,
        sigmoidCrossEntropy: xh,
        softmaxCrossEntropy: wh
       });
 
      function Sh(t, e) {
       return void 0 === e && (e = !1), Wt.tidy((function() {
        if (2 !== t.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t.shape.length + "D Tensor.");
        for (var n = t.shape[0], r = t.shape[1], i = kr(n), o = t.clone(), a = zn([
          [1]
         ], [1, 1]), s = a.clone(), u = n >= r ? r : n, c = function(t) {
          var e, u = o,
           c = s,
           l = i;
          e = Wt.tidy((function() {
           var e = o.slice([t, t], [n - t, 1]),
            u = e.norm(),
            c = o.slice([t, t], [1, 1]),
            l = zn([
             [-1]
            ]).where(c.greater(0), zn([
             [1]
            ])),
            h = c.sub(l.mul(u)),
            p = e.div(h);
           s = 1 === p.shape[0] ? a.clone() : a.concat(p.slice([1, 0], [p.shape[0] - 1, p.shape[1]]), 0);
           var f = l.matMul(h).div(u).neg(),
            d = o.slice([t, 0], [n - t, r]),
            v = f.mul(s);
           if (0 === t) o = d.sub(v.matMul(s.transpose().matMul(d)));
           else {
            var m = d.sub(v.matMul(s.transpose().matMul(d)));
            o = o.slice([0, 0], [t, r]).concat(m, 0)
           }
           var g = i.slice([0, t], [n, i.shape[1] - t]);
           if (0 === t) i = g.sub(g.matMul(s).matMul(v.transpose()));
           else {
            var y = g.sub(g.matMul(s).matMul(v.transpose()));
            i = i.slice([0, 0], [n, t]).concat(y, 1)
           }
           return [s, o, i]
          })), s = e[0], o = e[1], i = e[2], rn([u, c, l])
         }, l = 0; l < u; ++l) c(l);
        return !e && n > r && (i = i.slice([0, 0], [n, r]), o = o.slice([0, 0], [r, r])), [i, o]
       }))
      }
      var Eh = Tn({
        bandPart_: function(t, e, n) {
         if (e % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e + ".");
         if (n % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n + ".");
         var r = bn(t, "a", "bandPart");
         if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
         var i = r.shape,
          o = r.shape.slice(-2),
          a = o[0],
          s = o[1];
         if (!(e <= a)) throw new Error("bandPart(): numLower (" + e + ") must not be greater than the number of rows (" + a + ").");
         if (!(n <= s)) throw new Error("bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ").");
         e < 0 && (e = a), n < 0 && (n = s);
         var u = Xn(0, a, 1, "int32").reshape([-1, 1]),
          c = Xn(0, s, 1, "int32"),
          l = Ec(u, c),
          h = Ju(l.lessEqual(Bn(+e, "int32")), l.greaterEqual(Bn(-n, "int32"))),
          p = Gn([a, s], r.dtype);
         return jr(Ur(r.reshape([-1, a, s])).map((function(t) {
          return nc(h, t, p)
         }))).reshape(i)
        }
       }),
       kh = Tn({
        gramSchmidt_: function(t) {
         var e;
         if (Array.isArray(t)) {
          e = !1, O(null != t && t.length > 0, (function() {
           return "Gram-Schmidt process: input must not be null, undefined, or empty"
          }));
          for (var n = t[0].shape[0], r = function(e) {
            O(t[e].shape[0] === n, (function() {
             return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t[e].shape[0] + " vs. " + n + ")"
            }))
           }, i = 1; i < t.length; ++i) r(i)
         } else e = !0, t = rr(t, t.shape[0], 0).map((function(t) {
          return zr(t, [0])
         }));
         O(t.length <= t[0].shape[0], (function() {
          return "Gram-Schmidt: Number of vectors (" + t.length + ") exceeds number of dimensions (" + t[0].shape[0] + ")."
         }));
         var o = [],
          a = t,
          s = function(t) {
           o.push(Wt.tidy((function() {
            var e = a[t];
            if (t > 0)
             for (var n = 0; n < t; ++n) {
              var r = Dl(o[n].mulStrict(e)).mul(o[n]);
              e = e.sub(r)
             }
            return e.div(Ul(e, "euclidean"))
           })))
          };
         for (i = 0; i < t.length; ++i) s(i);
         return e ? jr(o, 0) : o
        }
       }),
       Ih = Tn({
        qr_: function(t, e) {
         if (void 0 === e && (e = !1), t.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t.rank);
         if (2 === t.rank) return Sh(t, e);
         var n = t.shape.slice(0, t.shape.length - 2).reduce((function(t, e) {
           return t * e
          })),
          r = Ur(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),
          i = [],
          o = [];
         return r.forEach((function(t) {
          var n = Sh(t, e),
           r = n[0],
           a = n[1];
          i.push(r), o.push(a)
         })), [jr(i, 0).reshape(t.shape), jr(o, 0).reshape(t.shape)]
        }
       }),
       Oh = Object.freeze({
        bandPart: Eh,
        gramSchmidt: kh,
        qr: Ih
       });
 
      function Ah(t, e, n, r, i, o) {
       null == r && (r = .5), null == i && (i = Number.NEGATIVE_INFINITY), null == o && (o = 0);
       var a = t.shape[0];
       return n = Math.min(n, a), O(0 <= r && r <= 1, (function() {
        return "iouThreshold must be in [0, 1], but was '" + r + "'"
       })), O(2 === t.rank, (function() {
        return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'"
       })), O(4 === t.shape[1], (function() {
        return "boxes must have 4 columns, but 2nd dimension was " + t.shape[1]
       })), O(1 === e.rank, (function() {
        return "scores must be a 1D tensor"
       })), O(e.shape[0] === a, (function() {
        return "scores has incompatible shape with boxes. Expected " + a + ", but was " + e.shape[0]
       })), O(0 <= o && o <= 1, (function() {
        return "softNmsSigma must be in [0, 1], but was '" + o + "'"
       })), {
        maxOutputSize: n,
        iouThreshold: r,
        scoreThreshold: i,
        softNmsSigma: o
       }
      }
      var Nh = Tn({
        resizeBilinear_: function(t, e, n) {
         void 0 === n && (n = !1);
         var r = bn(t, "images", "resizeBilinear");
         O(3 === r.rank || 4 === r.rank, (function() {
          return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + "."
         })), O(2 === e.length, (function() {
          return "Error in resizeBilinear: new shape must 2D, but got shape " + e + "."
         }));
         var i = r,
          o = !1;
         3 === r.rank && (o = !0, i = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
         var a = e[0],
          s = e[1],
          u = Wt.runKernelFunc((function(t, e) {
           return e([i]), t.resizeBilinear(i, a, s, n)
          }), {
           x: i
          }, (function(t, e) {
           return {
            x: function() {
             return Wt.runKernelFunc((function(r) {
              return r.resizeBilinearBackprop(t, e[0], n)
             }), {})
            }
           }
          }), "ResizeBilinear", {
           alignCorners: n,
           newHeight: a,
           newWidth: s
          });
         return o ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
        }
       }),
       Rh = Tn({
        resizeNearestNeighbor_: function(t, e, n) {
         void 0 === n && (n = !1);
         var r = bn(t, "images", "resizeNearestNeighbor");
         O(3 === r.rank || 4 === r.rank, (function() {
          return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + "."
         })), O(2 === e.length, (function() {
          return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + "."
         })), O("float32" === r.dtype || "int32" === r.dtype, (function() {
          return "`images` must have `int32` or `float32` as dtype"
         }));
         var i = r,
          o = !1;
         3 === r.rank && (o = !0, i = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
         var a = e[0],
          s = e[1],
          u = Wt.runKernelFunc((function(t, e) {
           return e([i]), t.resizeNearestNeighbor(i, a, s, n)
          }), {
           batchImages: i
          }, (function(t, e) {
           return {
            batchImages: function() {
             return Wt.runKernelFunc((function(r) {
              return r.resizeNearestNeighborBackprop(t, e[0], n)
             }), {})
            }
           }
          }));
         return o ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
        }
       }),
       Th = Tn({
        nonMaxSuppression_: function(t, e, n, r, i) {
         void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY);
         var o = bn(t, "boxes", "nonMaxSuppression"),
          a = bn(e, "scores", "nonMaxSuppression"),
          s = Ah(o, a, n, r, i);
         n = s.maxOutputSize, r = s.iouThreshold, i = s.scoreThreshold;
         var u = {
          maxOutputSize: n,
          iouThreshold: r,
          scoreThreshold: i
         };
         return Wt.runKernelFunc((function(t) {
          return t.nonMaxSuppression(o, a, n, r, i)
         }), {
          boxes: o,
          scores: a
         }, null, "NonMaxSuppressionV3", u)
        }
       }),
       _h = function(t, e, n, r, i) {
        return void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), s(this, void 0, void 0, (function() {
         var o, a, s, c, l, h, p;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return o = bn(t, "boxes", "nonMaxSuppressionAsync"), a = bn(e, "scores", "nonMaxSuppressionAsync"), s = Ah(o, a, n, r, i), n = s.maxOutputSize, r = s.iouThreshold, i = s.scoreThreshold, [4, Promise.all([o.data(), a.data()])];
           case 1:
            return c = u.sent(), l = c[0], h = c[1], p = Xi(l, h, n, r, i), o !== t && o.dispose(), a !== e && a.dispose(), [2, p]
          }
         }))
        }))
       },
       Dh = Tn({
        nonMaxSuppressionWithScore_: function(t, e, n, r, i, o) {
         void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === o && (o = 0);
         var a = bn(t, "boxes", "nonMaxSuppression"),
          s = bn(e, "scores", "nonMaxSuppression"),
          u = Ah(a, s, n, r, i, o),
          c = {
           maxOutputSize: n = u.maxOutputSize,
           iouThreshold: r = u.iouThreshold,
           scoreThreshold: i = u.scoreThreshold,
           softNmsSigma: o = u.softNmsSigma
          },
          l = Wt.runKernel("NonMaxSuppressionV5", {
           boxes: a,
           scores: s
          }, c);
         return {
          selectedIndices: l[0],
          selectedScores: l[1]
         }
        }
       }),
       Fh = function(t, e, n, r, i, o) {
        return void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === o && (o = 0), s(this, void 0, void 0, (function() {
         var a, s, c, l, h, p, f;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return a = bn(t, "boxes", "nonMaxSuppressionAsync"), s = bn(e, "scores", "nonMaxSuppressionAsync"), c = Ah(a, s, n, r, i, o), n = c.maxOutputSize, r = c.iouThreshold, i = c.scoreThreshold, o = c.softNmsSigma, [4, Promise.all([a.data(), s.data()])];
           case 1:
            return l = u.sent(), h = l[0], p = l[1], f = Yi(h, p, n, r, i, o), a !== t && a.dispose(), s !== e && s.dispose(), [2, f]
          }
         }))
        }))
       },
       Mh = Tn({
        cropAndResize_: function(t, e, n, r, i, o) {
         var a = bn(t, "image", "cropAndResize"),
          s = bn(e, "boxes", "cropAndResize", "float32"),
          u = bn(n, "boxInd", "cropAndResize", "int32");
         i = i || "bilinear", o = o || 0;
         var c = s.shape[0];
         return O(4 === a.rank, (function() {
          return "Error in cropAndResize: image must be rank 4,but got rank " + a.rank + "."
         })), O(2 === s.rank && 4 === s.shape[1], (function() {
          return "Error in cropAndResize: boxes must be have size [" + c + ",4] but had shape " + s.shape + "."
         })), O(1 === u.rank && u.shape[0] === c, (function() {
          return "Error in cropAndResize: boxInd must be have size [" + c + "] but had shape " + s.shape + "."
         })), O(2 === r.length, (function() {
          return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + "."
         })), O(r[0] >= 1 && r[1] >= 1, (function() {
          return "cropSize must be atleast [1,1], but was " + r
         })), O("bilinear" === i || "nearest" === i, (function() {
          return "method must be bilinear or nearest, but was " + i
         })), Wt.runKernelFunc((function(t, e) {
          return t.cropAndResize(a, s, u, r, i, o)
         }), {
          images: a,
          boxes: s,
          boxInd: u
         }, null, "CropAndResize", {
          method: i,
          extrapolationValue: o,
          cropSize: r
         })
        }
       }),
       Lh = Object.freeze({
        resizeBilinear: Nh,
        resizeNearestNeighbor: Rh,
        nonMaxSuppression: Th,
        nonMaxSuppressionAsync: _h,
        nonMaxSuppressionWithScore: Dh,
        nonMaxSuppressionWithScoreAsync: Fh,
        cropAndResize: Mh
       }),
       Bh = function(t, e) {
        return !(t > 0) || "linear" === e
       },
       Ph = function(t, e, n) {
        if (null == n || "linear" === n) return t;
        if ("relu" === n) return t.mul(e.step());
        throw new Error("Gradient for activation " + n + " has not been implemented yet.")
       },
       zh = function(t, e) {
        var n = e,
         r = ki(t.shape, e.shape);
        return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape)
       },
       jh = function(t, e, n) {
        if ("linear" === e) return t;
        if ("relu" === e) return Pl(t);
        if ("elu" === e) return Ml(t);
        if ("relu6" === e) return zl(t);
        if ("prelu" === e) return Bl(t, n);
        throw new Error("Unknown fused activation " + e + ".")
       },
       Wh = Tn({
        fusedMatMul_: function(t) {
         var e, n = t.a,
          r = t.b,
          i = t.transposeA,
          o = void 0 !== i && i,
          a = t.transposeB,
          s = void 0 !== a && a,
          u = t.bias,
          c = t.activation,
          l = void 0 === c ? "linear" : c,
          h = t.preluActivationWeights;
         if (!1 === Bh(Wt.state.gradientDepth, l)) {
          var p = rl(n, r, o, s);
          return null != u && (p = ic(p, u)), jh(p, l, h)
         }
         var f = bn(n, "a", "fused matMul"),
          d = bn(r, "b", "fused matMul");
         e = Ft(f, d), f = e[0], d = e[1];
         var v = o ? f.shape[f.rank - 2] : f.shape[f.rank - 1],
          m = s ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
          g = o ? f.shape[f.rank - 1] : f.shape[f.rank - 2],
          y = s ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
          b = f.shape.slice(0, -2),
          x = d.shape.slice(0, -2),
          w = T(b),
          C = T(x);
         O(f.rank >= 2 && d.rank >= 2 && f.rank === d.rank, (function() {
          return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + f.rank + " and " + d.rank + "."
         })), O(_(b, x), (function() {
          return "Error in fused matMul: outer dimensions (" + b + ") and (" + x + ") of Tensors with shapes " + f.shape + " and " + d.shape + " must match."
         })), O(v === m, (function() {
          return "Error in fused matMul: inner shapes (" + v + ") and (" + m + ") of Tensors with shapes " + f.shape + " and " + d.shape + " and transposeA=" + o + " and transposeB=" + s + " must match."
         }));
         var S, E, k = f.shape.slice(0, -2).concat([g, y]),
          I = o ? f.as3D(w, v, g) : f.as3D(w, g, v),
          A = s ? d.as3D(C, y, m) : d.as3D(C, m, y);
         null != u && Ii(k, (S = Ft(S = bn(u, "bias", "fused matMul"), f)[0]).shape), null != h && (E = bn(h, "prelu weights", "fused matMul"));
         var N = {
          $a: I,
          $b: A
         };
         return null != u && (N.$bias = S), null != h && (N.$preluActivationWeights = E), Wt.runKernelFunc((function(t, e) {
          var n = t.fusedBatchMatMul({
           a: I,
           b: A,
           transposeA: o,
           transposeB: s,
           bias: S,
           activation: l,
           preluActivationWeights: E
          });
          return e([I, A, n]), n
         }), N, (function(t, e) {
          var n = e[0],
           r = e[1],
           i = e[2],
           a = Ph(t, i, l),
           c = {};
          return null != u && (c = {
           $bias: function() {
            return zh(S, a)
           }
          }), o || s ? !o && s ? Object.assign({
           $a: function() {
            return a.matMul(r, !1, !1)
           },
           $b: function() {
            return a.matMul(n, !0, !1)
           }
          }, c) : o && !s ? Object.assign({
           $a: function() {
            return r.matMul(a, !1, !0)
           },
           $b: function() {
            return n.matMul(a, !1, !1)
           }
          }, c) : Object.assign({
           $a: function() {
            return r.matMul(a, !0, !0)
           },
           $b: function() {
            return a.matMul(n, !0, !0)
           }
          }, c) : Object.assign({
           $a: function() {
            return a.matMul(r, !1, !0)
           },
           $b: function() {
            return n.matMul(a, !0, !1)
           }
          }, c)
         })).reshape(k)
        }
       }),
       Vh = Tn({
        fusedConv2d_: function(t) {
         var e = t.x,
          n = t.filter,
          r = t.strides,
          i = t.pad,
          o = t.dataFormat,
          a = void 0 === o ? "NHWC" : o,
          s = t.dilations,
          u = void 0 === s ? [1, 1] : s,
          c = t.dimRoundingMode,
          l = t.bias,
          h = t.activation,
          p = void 0 === h ? "linear" : h,
          f = t.preluActivationWeights;
         if (p = p || "linear", !1 === Bh(Wt.state.gradientDepth, p)) {
          var d = qc(e, n, r, i, a, u, c);
          return null != l && (d = ic(d, l)), jh(d, p, f)
         }
         var v = bn(e, "x", "conv2d"),
          m = bn(n, "filter", "conv2d"),
          g = v,
          y = !1;
         3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), O(4 === g.rank, (function() {
          return "Error in fused conv2d: input must be rank 4, but got rank " + g.rank + "."
         })), O(4 === m.rank, (function() {
          return "Error in fused conv2d: filter must be rank 4, but got rank " + m.rank + "."
         })), null != c && O(D(i), (function() {
          return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c + " but got pad " + i + "."
         })), O(g.shape[3] === m.shape[2], (function() {
          return "Error in conv2d: depth of input (" + g.shape[3] + ") must match input depth for filter " + m.shape[2] + "."
         })), O(Bi(r, u), (function() {
          return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
         })), O("NHWC" === a, (function() {
          return "Error in conv2d: got dataFormat of " + a + " but only NHWC is currently supported."
         }));
         var b, x, w = Ni(g.shape, m.shape, r, u, i, c);
         null != l && (b = Ft(b = bn(l, "bias", "fused conv2d"), v)[0], Ii(w.outShape, b.shape)), null != f && (x = bn(f, "prelu weights", "fused conv2d"));
         var C = {
          x: g,
          filter: m
         };
         null != l && (C.bias = b), null != f && (C.preluActivationWeights = x);
         var S = [m, g],
          E = Wt.runKernelFunc((function(t, e) {
           var n = t.fusedConv2d({
            input: g,
            filter: m,
            convInfo: w,
            bias: b,
            activation: p,
            preluActivationWeights: x
           });
           return e([m, g, n]), n
          }), C, (function(t, e) {
           var n = e,
            o = n[0],
            a = n[1],
            s = n[2],
            c = Ph(t, s, p);
           O(Li(u), (function() {
            return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'"
           }));
           var h = {};
           return null != l && (h = {
            bias: function() {
             return zh(b, c)
            }
           }), Object.assign({
            x: function() {
             return Yc(a.shape, c, o, r, i)
            },
            filter: function() {
             return Xc(a, c, o.shape, r, i)
            }
           }, h)
          }), "FusedConv2D", {
           convInfo: w,
           activation: p
          }, S, [!0]);
         return y ? E.as3D(E.shape[1], E.shape[2], E.shape[3]) : E
        }
       }),
       Uh = Tn({
        fusedDepthwiseConv2d_: function(t) {
         var e = t.x,
          n = t.filter,
          r = t.strides,
          i = t.pad,
          o = t.dataFormat,
          a = void 0 === o ? "NHWC" : o,
          s = t.dilations,
          u = void 0 === s ? [1, 1] : s,
          c = t.dimRoundingMode,
          l = t.bias,
          h = t.activation,
          p = void 0 === h ? "linear" : h,
          f = t.preluActivationWeights;
         if (!1 === Bh(Wt.state.gradientDepth, p)) {
          var d = Zc(e, n, r, i, a, u, c);
          return null != l && (d = ic(d, l)), jh(d, p, f)
         }
         var v = bn(e, "x", "depthwiseConv2d"),
          m = bn(n, "filter", "depthwiseConv2d"),
          g = v,
          y = !1;
         3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), O(4 === g.rank, (function() {
          return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + g.rank + "."
         })), O(4 === m.rank, (function() {
          return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m.rank + "."
         })), O(g.shape[3] === m.shape[2], (function() {
          return "Error in fused depthwiseConv2d: number of input channels (" + g.shape[3] + ") must match the inChannels dimension in filter " + m.shape[2] + "."
         })), null == u && (u = [1, 1]), O(Bi(r, u), (function() {
          return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
         })), null != c && O(D(i), (function() {
          return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c + " but got pad " + i + "."
         }));
         var b, x, w = Ni(g.shape, m.shape, r, u, i, c, !0);
         null != l && (b = Ft(b = bn(l, "bias", "fused conv2d"), v)[0], Ii(w.outShape, b.shape)), null != f && (x = bn(f, "prelu weights", "fused depthwiseConv2d"));
         var C = {
          x: g,
          filter: m
         };
         null != l && (C.bias = b), null != f && (C.preluActivationWeights = x);
         var S = [m, g],
          E = Wt.runKernelFunc((function(t, e) {
           var n = t.fusedDepthwiseConv2D({
            input: g,
            filter: m,
            convInfo: w,
            bias: b,
            activation: p,
            preluActivationWeights: x
           });
           return e([m, g, n]), n
          }), C, (function(t, e) {
           O(Li(u), (function() {
            return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'"
           }));
           var n = e[0],
            r = e[1],
            i = e[2],
            o = Ph(t, i, p),
            a = {};
           return null != l && (a = {
            bias: function() {
             return zh(b, o)
            }
           }), Object.assign({
            x: function() {
             return Jc(r.shape, o, n, w)
            },
            filter: function() {
             return Qc(r, o, n.shape, w)
            }
           }, a)
          }), "FusedDepthwiseConv2D", {
           convInfo: w,
           activation: p
          }, S, [!0]);
         return y ? E.as3D(E.shape[1], E.shape[2], E.shape[3]) : E
        }
       }),
       Hh = Object.freeze({
        matMul: Wh,
        conv2d: Vh,
        depthwiseConv2d: Uh
       }),
       $h = Object.freeze({
        image: Lh,
        linalg: Oh,
        losses: Ch,
        spectral: th,
        fused: Hh,
        signal: hh,
        square: ru,
        conv1d: Gc,
        conv2d: qc,
        conv3d: Kc,
        depthwiseConv2d: Zc,
        separableConv2d: tl,
        conv2dTranspose: el,
        conv3dTranspose: nl,
        op: Tn,
        batchNormalization2d: Hu,
        batchNormalization3d: $u,
        batchNormalization4d: Gu,
        batchNormalization: qu,
        batchNorm: Ku,
        batchNorm2d: Xu,
        batchNorm3d: Yu,
        batchNorm4d: Zu,
        booleanMaskAsync: Vc,
        complex: _n,
        real: Dn,
        imag: Fn,
        concat: Jn,
        concat1d: Qn,
        concat2d: tr,
        concat3d: er,
        concat4d: nr,
        split: rr,
        matMul: rl,
        dot: il,
        outerProduct: ol,
        reverse: al,
        reverse1d: sl,
        reverse2d: ul,
        reverse3d: cl,
        reverse4d: ll,
        maxPool: fl,
        avgPool: dl,
        pool: vl,
        maxPool3d: ml,
        avgPool3d: gl,
        slice: yl,
        slice1d: bl,
        slice2d: xl,
        slice3d: wl,
        slice4d: Cl,
        abs: iu,
        acos: ou,
        acosh: au,
        asin: su,
        asinh: uu,
        atan: cu,
        atanh: lu,
        ceil: hu,
        clipByValue: pu,
        cos: fu,
        cosh: du,
        erf: vu,
        exp: mu,
        expm1: gu,
        floor: yu,
        log: bu,
        log1p: xu,
        logSigmoid: wu,
        neg: Cu,
        reciprocal: Su,
        round: Eu,
        rsqrt: ku,
        sigmoid: Iu,
        sign: Ou,
        isNaN: Au,
        isInf: Nu,
        isFinite: Ru,
        sin: Tu,
        sinh: _u,
        softplus: Du,
        sqrt: Fu,
        step: Mu,
        tan: Lu,
        tanh: Bu,
        all: El,
        any: kl,
        argMax: Il,
        argMin: Ol,
        logSumExp: Al,
        max: Nl,
        mean: Rl,
        min: Tl,
        moments: _l,
        sum: Dl,
        prod: Fl,
        equal: Ic,
        equalStrict: Oc,
        greater: Ac,
        greaterEqual: Nc,
        greaterEqualStrict: Rc,
        greaterStrict: Tc,
        less: _c,
        lessEqual: Dc,
        lessEqualStrict: Fc,
        lessStrict: Mc,
        notEqual: Lc,
        notEqualStrict: Bc,
        add: ic,
        addN: oc,
        addStrict: ac,
        atan2: sc,
        div: uc,
        divNoNan: cc,
        divStrict: lc,
        floorDiv: hc,
        maximum: pc,
        maximumStrict: fc,
        minimum: dc,
        minimumStrict: vc,
        mod: mc,
        modStrict: gc,
        mul: yc,
        mulStrict: bc,
        pow: xc,
        powStrict: wc,
        squaredDifference: Cc,
        squaredDifferenceStrict: Sc,
        sub: Ec,
        subStrict: kc,
        elu: Ml,
        leakyRelu: Ll,
        prelu: Bl,
        relu: Pl,
        relu6: zl,
        selu: jl,
        logicalAnd: Ju,
        logicalNot: Qu,
        logicalOr: tc,
        logicalXor: ec,
        where: nc,
        whereAsync: rc,
        buffer: mr,
        print: gr,
        batchToSpaceND: yr,
        broadcastTo: br,
        cast: xr,
        clone: wr,
        cumsum: Cr,
        depthToSpace: Sr,
        expandDims: Er,
        eye: kr,
        multinomial: Ir,
        oneHot: Or,
        pad: Ar,
        pad1d: Nr,
        pad2d: Rr,
        pad3d: Tr,
        pad4d: _r,
        rand: Dr,
        randomNormal: Fr,
        randomGamma: Mr,
        randomUniform: Lr,
        reshape: Br,
        spaceToBatchND: Pr,
        squeeze: zr,
        stack: jr,
        tile: Wr,
        truncatedNormal: Vr,
        unstack: Ur,
        setdiff1dAsync: Hr,
        fill: qn,
        linspace: Kn,
        ones: $n,
        range: Xn,
        scalar: Bn,
        tensor: Mn,
        tensor1d: Pn,
        tensor2d: zn,
        tensor3d: jn,
        tensor4d: Wn,
        tensor5d: Vn,
        tensor6d: Un,
        variable: Hn,
        zeros: Gn,
        onesLike: Yn,
        zerosLike: Zn,
        transpose: Wl,
        softmax: bi,
        logSoftmax: xi,
        localResponseNormalization: Vl,
        norm: Ul,
        gather: jc,
        unsortedSegmentSum: Wc,
        basicLSTMCell: Hl,
        multiRNNCell: $l,
        movingAverage: Gl,
        stridedSlice: ql,
        topk: Kl,
        scatterND: Xl,
        fft: Yl,
        ifft: Zl,
        rfft: Jl,
        irfft: Ql,
        sparseToDense: eh,
        gatherND: nh,
        diag: rh,
        dropout: ih,
        hannWindow: sh,
        hammingWindow: uh,
        frame: ch,
        stft: lh,
        inTopKAsync: ph
       });
 
      function Gh(t, e) {
       Array.isArray(t) || (t = [t]), t.forEach((function(t) {
        null != t && O("complex64" !== t.dtype, (function() {
         return e + " does not support complex64 tensors."
        }))
       }))
      }
 
      function qh(t, e, n, r) {
       if ("linear" === n) return t.linear(e);
       if ("relu" === n) return t.relu(e);
       if ("elu" === n) return t.elu(e);
       if ("relu6" === n) return t.relu6(e);
       if ("prelu" === n) return t.prelu(e, r);
       throw new Error("Activation " + n + " has not been implemented for the CPU backend.")
      }
      var Kh = function(t) {
       function e() {
        var e = t.call(this) || this;
        return e.blockSize = 48, e.firstUse = !0, e.data = new wi(e, Wt), e
       }
       return a(e, t), e.prototype.write = function(t, e, n) {
        this.firstUse && (this.firstUse = !1, h().get("IS_NODE") && mn("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
        var r = {};
        return this.data.set(r, {
         values: t,
         dtype: n
        }), r
       }, e.prototype.move = function(t, e, n, r) {
        this.data.set(t, {
         values: e,
         dtype: r
        })
       }, e.prototype.numDataIds = function() {
        return this.data.numDataIds()
       }, e.prototype.read = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          return [2, this.readSync(t)]
         }))
        }))
       }, e.prototype.readSync = function(t) {
        var e = this.data.get(t),
         n = e.dtype,
         r = e.complexTensors;
        return "complex64" === n ? Ui(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values
       }, e.prototype.bufferSync = function(t) {
        var e = this.readSync(t.dataId),
         n = e;
        if ("string" === t.dtype) try {
         n = e.map((function(t) {
          return ct(t)
         }))
        } catch (t) {
         throw new Error("Failed to decode encoded string bytes into utf-8")
        }
        return mr(t.shape, t.dtype, n)
       }, e.prototype.makeOutput = function(t, e, n) {
        var r = this.write(t, e, n);
        return Wt.makeTensorFromDataId(r, e, n, this)
       }, e.prototype.disposeData = function(t) {
        if (this.data.has(t)) {
         var e = this.data.get(t).complexTensors;
         null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t)
        }
       }, e.prototype.time = function(t) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          return e = at(), t(), [2, {
           kernelMs: at() - e
          }]
         }))
        }))
       }, e.prototype.memory = function() {
        return {
         unreliable: !0,
         reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
        }
       }, e.prototype.complex = function(t, e) {
        var n = this.makeOutput(null, t.shape, "complex64");
        return this.data.get(n.dataId).complexTensors = {
         real: Wt.keep(t.clone()),
         imag: Wt.keep(e.clone())
        }, n
       }, e.prototype.real = function(t) {
        return this.data.get(t.dataId).complexTensors.real.clone()
       }, e.prototype.imag = function(t) {
        return this.data.get(t.dataId).complexTensors.imag.clone()
       }, e.prototype.slice = function(t, e, n) {
        if (Gh(t, "slice"), ci(t.shape, e, n)) {
         var r = li(e, t.strides),
          i = T(n);
         return Mn(this.readSync(t.dataId).subarray(r, r + i), n, t.dtype)
        }
        for (var o = mr(n, t.dtype), a = this.bufferSync(t), s = 0; s < o.size; ++s) {
         var u = o.indexToLoc(s).map((function(t, n) {
          return t + e[n]
         }));
         o.values[s] = a.get.apply(a, u)
        }
        return o.toTensor()
       }, e.prototype.stridedSlice = function(t, e, n, r) {
        Gh(t, "stridedSlice");
        var i = ai(e, n, r);
        if (i.some((function(t) {
          return 0 === t
         }))) return Mn([], i);
        for (var o = mr(i, t.dtype), a = this.bufferSync(t), s = 0; s < o.size; s++) {
         for (var u = o.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++) c[l] = u[l] * r[l] + e[l];
         o.set.apply(o, [a.get.apply(a, c)].concat(u))
        }
        return o.toTensor()
       }, e.prototype.diag = function(t) {
        for (var e = this.readSync(t.dataId), n = mr([t.size, t.size], t.dtype), r = n.values, i = 0; i < e.length; i++) r[i * t.size + i] = e[i];
        return n.toTensor()
       }, e.prototype.unstack = function(t, e) {
        for (var n = t.shape[e], r = new Array(t.rank - 1), i = 0, o = 0; o < t.rank; o++) o !== e && (r[i++] = t.shape[o]);
        var a = new Array(t.rank).fill(0),
         s = t.shape.slice();
        s[e] = 1;
        var u = new Array(n);
        for (o = 0; o < u.length; o++) a[e] = o, u[o] = this.slice(t, a, s).reshape(r);
        return u
       }, e.prototype.reverse = function(t, e) {
        Gh(t, "reverse");
        for (var n = mr(t.shape, t.dtype), r = this.bufferSync(t), i = function(i) {
          var o = n.indexToLoc(i),
           a = o.slice();
          e.forEach((function(e) {
           return a[e] = t.shape[e] - 1 - a[e]
          })), n.set.apply(n, [r.get.apply(r, a)].concat(o))
         }, o = 0; o < n.size; o++) i(o);
        return n.toTensor()
       }, e.prototype.concat = function(t, e) {
        var n = this;
        if ("complex64" === t[0].dtype) {
         var r = t.map((function(t) {
           return Dn(t)
          })),
          i = t.map((function(t) {
           return Fn(t)
          }));
         return _n(this.concat(r, e), this.concat(i, e))
        }
        var o = t.map((function(t) {
          var n = T(t.shape.slice(e));
          return t.as2D(-1, n)
         })),
         a = Rn(o.map((function(t) {
          return t.shape
         })), 1),
         s = mr(a, t[0].dtype).values;
        if (1 === o[0].shape[0]) {
         var u = 0;
         o.forEach((function(t) {
          s.set(n.readSync(t.dataId), u), u += t.size
         }))
        } else {
         var c = 0;
         o.forEach((function(t) {
          for (var e = n.readSync(t.dataId), r = 0, i = 0; i < t.shape[0]; ++i)
           for (var o = i * a[1] + c, u = 0; u < t.shape[1]; ++u) s[o + u] = e[r++];
          c += t.shape[1]
         }))
        }
        var l = Rn(t.map((function(t) {
         return t.shape
        })), e);
        return Mn(s, l, t[0].dtype)
       }, e.prototype.neg = function(t) {
        return Gh(t, "neg"), this.multiply(Bn(-1), t)
       }, e.prototype.add = function(t, e) {
        return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), (function(t, e, n, r) {
         return {
          real: t + n,
          imag: e + r
         }
        })) : this.broadcastedBinaryOp(t, e, _t(t.dtype, e.dtype), (function(t, e) {
         return t + e
        }))
       }, e.prototype.addN = function(t) {
        var e = this;
        Gh(t, "addN");
        for (var n = t.map((function(t) {
          return e.readSync(t.dataId)
         })), r = mr(t[0].shape, t[0].dtype), i = r.values, o = 0; o < t.length; o++)
         for (var a = n[o], s = 0; s < i.length; s++) i[s] += a[s];
        return r.toTensor()
       }, e.prototype.subtract = function(t, e) {
        return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), (function(t, e, n, r) {
         return {
          real: t - n,
          imag: e - r
         }
        })) : this.broadcastedBinaryOp(t, e, _t(t.dtype, e.dtype), (function(t, e) {
         return t - e
        }))
       }, e.prototype.pow = function(t, e) {
        return Gh([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         return Math.pow(t, e)
        }))
       }, e.prototype.batchMatMul = function(t, e, n, r) {
        Gh([t, e], "matMul");
        for (var i = n ? t.shape[1] : t.shape[2], o = n ? t.shape[2] : t.shape[1], a = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], p = l[1], f = l[2], d = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], v = d[0], m = d[1], g = d[2], y = o * a, b = mr([s, o, a], t.dtype), x = b.values, w = this.blockSize, C = 0; C < s; C++)
         for (var S = 0; S < o; S += w)
          for (var E = 0; E < a; E += w)
           for (var k = 0; k < i; k += w)
            for (var I = Math.min(S + w, o), O = Math.min(E + w, a), A = Math.min(k + w, i), N = S; N < I; N++)
             for (var R = E; R < O; R++) {
              for (var T = 0, _ = k; _ < A; _++) T += u[C * h + N * p + _ * f] * c[_ * v + R * m + C * g];
              x[C * y + (N * a + R)] += T
             }
        return b.toTensor()
       }, e.prototype.fusedBatchMatMul = function(t) {
        var e = t.a,
         n = t.b,
         r = t.transposeA,
         i = t.transposeB,
         o = t.bias,
         a = t.activation,
         s = t.preluActivationWeights,
         u = this.batchMatMul(e, n, r, i);
        return o && (u = this.add(u, o)), a && (u = qh(this, u, a, s)), u
       }, e.prototype.multiply = function(t, e) {
        return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), (function(t, e, n, r) {
         return {
          real: t * n - e * r,
          imag: t * r + e * n
         }
        })) : this.broadcastedBinaryOp(t, e, _t(t.dtype, e.dtype), (function(t, e) {
         return t * e
        }))
       }, e.prototype.realDivide = function(t, e) {
        return Gh([t, e], "realDivide"), this.broadcastedBinaryOp(t, e, "float32", (function(t, e) {
         return t / e
        }))
       }, e.prototype.floorDiv = function(t, e) {
        return Gh([t, e], "floorDiv"), this.broadcastedBinaryOp(t, e, "int32", (function(t, e) {
         return Math.floor(t / e)
        }))
       }, e.prototype.sum = function(t, e) {
        Gh(t, "sum"), kn("sum", e, t.rank);
        for (var n = Sn(t.shape, e), r = n[0], i = n[1], o = Gn(r, _t(t.dtype, "int32")), a = T(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
         for (var l = c * a, h = 0, p = 0; p < a; ++p) h += u[l + p];
         s[c] = h
        }
        return o
       }, e.prototype.prod = function(t, e) {
        Gh(t, "sum");
        for (var n = Sn(t.shape, e), r = n[0], i = n[1], o = Gn(r, _t(t.dtype, "int32")), a = T(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
         for (var l = c * a, h = 1, p = 0; p < a; ++p) h *= u[l + p];
         s[c] = h
        }
        return o
       }, e.prototype.unsortedSegmentSum = function(t, e, n) {
        Gh(t, "unsortedSegmentSum");
        for (var r = [], i = t.rank - e.rank, o = 0; o < i; ++o) e = e.expandDims(o + 1);
        for (o = 0; o < n; ++o) {
         var a = Bn(o, "int32"),
          s = Ic(a, e).asType("float32").mul(t).sum(0);
         r.push(s)
        }
        return jr(r)
       }, e.prototype.argMin = function(t, e) {
        Gh(t, "argMin");
        var n = [e];
        kn("argMin", n, t.rank);
        for (var r = Sn(t.shape, n), i = r[0], o = r[1], a = Gn(i, "int32"), s = T(o), u = this.readSync(a.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
         for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {
          var v = c[h + d];
          v < p && (p = v, f = d)
         }
         u[l] = f
        }
        return a
       }, e.prototype.argMax = function(t, e) {
        Gh(t, "argMax");
        var n = [e];
        kn("argMax", n, t.rank);
        for (var r = Sn(t.shape, n), i = r[0], o = r[1], a = Gn(i, "int32"), s = T(o), u = this.readSync(a.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
         for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {
          var v = c[h + d];
          v > p && (p = v, f = d)
         }
         u[l] = f
        }
        return a
       }, e.prototype.cumsum = function(t, e, n, r) {
        if (Gh(t, "cumsum"), e !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
        for (var i = _t(t.dtype, "int32"), o = Gn(t.shape, i), a = this.readSync(o.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function(t, e) {
          return t + u - e - 1
         } : function(t, e) {
          return t + e
         }, l = 0; l < s.length; l += u)
         for (var h = 0; h < u; h++) {
          var p = c(l, h);
          if (0 === h) a[p] = n ? 0 : s[p];
          else {
           var f = c(l, h - 1);
           a[p] = n ? s[f] + a[f] : s[p] + a[f]
          }
         }
        return o
       }, e.prototype.equal = function(t, e) {
        return Gh([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t === e ? 1 : 0
        }))
       }, e.prototype.notEqual = function(t, e) {
        return Gh([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t !== e ? 1 : 0
        }))
       }, e.prototype.less = function(t, e) {
        return Gh([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t < e ? 1 : 0
        }))
       }, e.prototype.lessEqual = function(t, e) {
        return Gh([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t <= e ? 1 : 0
        }))
       }, e.prototype.greater = function(t, e) {
        return Gh([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t > e ? 1 : 0
        }))
       }, e.prototype.greaterEqual = function(t, e) {
        return Gh([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t >= e ? 1 : 0
        }))
       }, e.prototype.logicalNot = function(t) {
        Gh(t, "logicalNot");
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;
        return this.makeOutput(n, t.shape, "bool")
       }, e.prototype.logicalAnd = function(t, e) {
        return Gh([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t && e
        }))
       }, e.prototype.logicalOr = function(t, e) {
        return Gh([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
         return t || e
        }))
       }, e.prototype.select = function(t, e, n) {
        Gh([t, e, n], "select");
        for (var r = this.readSync(t.dataId), i = this.readSync(e.dataId), o = this.readSync(n.dataId), a = Gn(e.shape, _t(e.dtype, n.dtype)), s = this.readSync(a.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : T(e.shape.slice(1)), l = 0; l < r.length; l++)
         for (var h = 0; h < c; h++) 1 === r[l] ? s[u++] = i[l] : s[u++] = o[l];
        return a
       }, e.prototype.where = function(t) {
        Gh([t], "where");
        var e = this.readSync(t.dataId);
        return io(t.shape, e)
       }, e.prototype.topk = function(t, e, n) {
        return Gh(t, "topk"), ro(this.readSync(t.dataId), t.shape, t.dtype, e)
       }, e.prototype.min = function(t, e) {
        Gh(t, "min"), kn("min", e, t.rank);
        for (var n = Sn(t.shape, e), r = n[0], i = n[1], o = Gn(r, t.dtype), a = T(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
         for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          var f = u[l + p];
          f < h && (h = f)
         }
         s[c] = h
        }
        return o
       }, e.prototype.minimum = function(t, e) {
        return Gh([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         return Math.min(t, e)
        }))
       }, e.prototype.mod = function(t, e) {
        return Gh([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         var n = t % e;
         return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e
        }))
       }, e.prototype.max = function(t, e) {
        Gh(t, "max"), kn("max", e, t.rank);
        for (var n = Sn(t.shape, e), r = n[0], i = n[1], o = Gn(r, t.dtype), a = T(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
         for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          var f = u[l + p];
          f > h && (h = f)
         }
         s[c] = h
        }
        return o
       }, e.prototype.maximum = function(t, e) {
        return Gh([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         return Math.max(t, e)
        }))
       }, e.prototype.all = function(t, e) {
        Gh(t, "all"), kn("all", e, t.rank);
        for (var n = Sn(t.shape, e), r = n[0], i = n[1], o = Gn(r, t.dtype), a = T(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
         for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          var f = u[l + p];
          h = h && f
         }
         s[c] = h
        }
        return o
       }, e.prototype.any = function(t, e) {
        Gh(t, "any"), kn("any", e, t.rank);
        for (var n = Sn(t.shape, e), r = n[0], i = n[1], o = Gn(r, t.dtype), a = T(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
         for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
          var f = u[l + p];
          h = h || f
         }
         s[c] = h
        }
        return o
       }, e.prototype.squaredDifference = function(t, e) {
        return Gh([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         var n = t - e;
         return n * n
        }))
       }, e.prototype.ceil = function(t) {
        Gh(t, "ceil");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.floor = function(t) {
        Gh(t, "floor");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.sign = function(t) {
        Gh(t, "x");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.isNaN = function(t) {
        Gh(t, "x");
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);
        return this.makeOutput(n, t.shape, "bool")
       }, e.prototype.isInf = function(t) {
        Gh(t, "x");
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);
        return this.makeOutput(n, t.shape, "bool")
       }, e.prototype.isFinite = function(t) {
        Gh(t, "x");
        for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);
        return this.makeOutput(n, t.shape, "bool")
       }, e.prototype.round = function(t) {
        Gh(t, "round");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
         var i = Math.floor(e[r]);
         e[r] - i < .5 ? n[r] = Math.floor(e[r]) : e[r] - i > .5 ? n[r] = Math.ceil(e[r]) : n[r] = i % 2 == 0 ? i : i + 1
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.exp = function(t) {
        Gh(t, "exp");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.expm1 = function(t) {
        Gh(t, "expm1");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.log = function(t) {
        Gh(t, "log");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
         var i = e[r];
         n[r] = Math.log(i)
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.log1p = function(t) {
        Gh(t, "log1p");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
         var i = e[r];
         n[r] = Math.log1p(i)
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.sqrt = function(t) {
        Gh(t, "sqrt");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
         var i = e[r];
         n[r] = Math.sqrt(i)
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.rsqrt = function(t) {
        Gh(t, "rsqrt");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
         var i = e[r];
         n[r] = 1 / Math.sqrt(i)
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.reciprocal = function(t) {
        Gh(t, "reciprocal");
        for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.linear = function(t) {
        return t
       }, e.prototype.relu = function(t) {
        Gh(t, "relu");
        for (var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) n[i] = Math.max(0, r[i]);
        return e
       }, e.prototype.relu6 = function(t) {
        Gh(t, "relu");
        for (var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) n[i] = Math.min(Math.max(0, r[i]), 6);
        return e
       }, e.prototype.prelu = function(t, e) {
        return Gh([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         return t < 0 ? e * t : t
        }))
       }, e.prototype.elu = function(t) {
        Gh(t, "elu");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
         var i = n[r];
         e[r] = i >= 0 ? i : Math.exp(i) - 1
        }
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.eluDer = function(t, e) {
        Gh([t, e], "eluDer");
        for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), i = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
         var a = r[o];
         n[o] = a >= 1 ? i[o] : i[o] * (a + 1)
        }
        return this.makeOutput(n, e.shape, "float32")
       }, e.prototype.selu = function(t) {
        Gh(t, "selu");
        for (var e = Ss, n = Es, r = new Float32Array(t.size), i = this.readSync(t.dataId), o = 0; o < i.length; ++o) {
         var a = i[o];
         r[o] = a >= 0 ? n * a : e * (Math.exp(a) - 1)
        }
        return this.makeOutput(r, t.shape, "float32")
       }, e.prototype.clip = function(t, e, n) {
        Gh(t, "clip");
        for (var r = new Float32Array(t.size), i = this.readSync(t.dataId), o = 0; o < i.length; ++o) {
         var a = i[o];
         r[o] = a > n ? n : a < e ? e : a
        }
        return this.makeOutput(r, t.shape, "float32")
       }, e.prototype.abs = function(t) {
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.complexAbs = function(t) {
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
         var i = n[2 * r],
          o = n[2 * r + 1];
         e[r] = Math.hypot(i, o)
        }
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.int = function(t) {
        Gh(t, "int");
        for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];
        return this.makeOutput(e, t.shape, "int32")
       }, e.prototype.sigmoid = function(t) {
        Gh(t, "sigmoid");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.softplus = function(t) {
        Gh(t, "softplus");
        for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) {
         var o = r[i] > -e,
          a = r[i] < e,
          s = Math.exp(r[i]),
          u = void 0;
         u = a ? s : o ? r[i] : Math.log(1 + s), n[i] = u
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.sin = function(t) {
        Gh(t, "sin");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.cos = function(t) {
        Gh(t, "cos");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.tan = function(t) {
        Gh(t, "tan");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.asin = function(t) {
        Gh(t, "asin");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.acos = function(t) {
        Gh(t, "acos");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.atan = function(t) {
        Gh(t, "atan");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.atan2 = function(t, e) {
        return Gh([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
         return Math.atan2(t, e)
        }))
       }, e.prototype.sinh = function(t) {
        Gh(t, "sinh");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.cosh = function(t) {
        Gh(t, "cosh");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.tanh = function(t) {
        Gh(t, "tanh");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = F(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.asinh = function(t) {
        Gh(t, "asinh");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.acosh = function(t) {
        Gh(t, "acosh");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.atanh = function(t) {
        Gh(t, "atanh");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.erf = function(t) {
        Gh(t, "erf");
        for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
         var i = Math.sign(n[r]),
          o = Math.abs(n[r]),
          a = 1 / (1 + .3275911 * o);
         e[r] = i * (1 - ((((1.061405429 * a - 1.453152027) * a + 1.421413741) * a - .284496736) * a + .254829592) * a * Math.exp(-o * o))
        }
        return this.makeOutput(e, t.shape, "float32")
       }, e.prototype.step = function(t, e) {
        void 0 === e && (e = 0), Gh(t, "step");
        for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) {
         var o = r[i];
         isNaN(o) ? n[i] = NaN : n[i] = o > 0 ? 1 : e
        }
        return this.makeOutput(n, t.shape, "float32")
       }, e.prototype.fusedConv2d = function(t) {
        var e = t.input,
         n = t.filter,
         r = t.convInfo,
         i = t.bias,
         o = t.activation,
         a = t.preluActivationWeights,
         s = this.conv2d(e, n, r);
        return i && (s = this.add(s, i)), o && (s = qh(this, s, o, a)), s
       }, e.prototype.conv2d = function(t, e, n) {
        Gh([t, e], "conv2d");
        for (var r = n.filterHeight, i = n.filterWidth, o = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = "channelsLast" === n.dataFormat, l = mr(n.outShape, t.dtype), h = t.strides[0], p = c ? t.strides[1] : t.strides[2], f = c ? t.strides[2] : 1, d = c ? 1 : t.strides[1], v = l.strides[0], m = c ? l.strides[1] : l.strides[2], g = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], b = this.readSync(t.dataId), x = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C)
         for (var S = C * h, E = C * v, k = 0; k < n.outHeight; ++k)
          for (var I = E + k * m, O = k * n.strideHeight - u, A = 0; A < r; A++) {
           var N = O + A * o;
           if (!(N < 0 || N >= n.inHeight))
            for (var R = A * e.strides[0], T = S + N * p, _ = 0; _ < n.outWidth; ++_)
             for (var D = I + _ * g, F = _ * n.strideWidth - s, M = 0; M < i; M++) {
              var L = F + M * a;
              if (!(L < 0 || L >= n.inWidth))
               for (var B = T + L * f, P = R + M * e.strides[1], z = 0; z < n.inChannels; ++z) {
                for (var j = b[B + z * d], W = 0; W < n.outChannels; ++W) w[D + W * y] += j * x[P + W];
                P += n.outChannels
               }
             }
          }
        return l.toTensor()
       }, e.prototype.conv3d = function(t, e, n) {
        for (var r = n.filterDepth, i = n.filterHeight, o = n.filterWidth, a = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, p = mr(n.outShape, t.dtype), f = this.readSync(t.dataId), d = this.readSync(e.dataId), v = p.values, m = 0; m < n.batchSize; ++m)
         for (var g = m * t.strides[0], y = m * p.strides[0], b = 0; b < n.outDepth; ++b)
          for (var x = y + b * p.strides[1], w = b * n.strideDepth - c, C = 0; C < r; C++) {
           var S = w + C * a;
           if (!(S < 0 || S >= n.inDepth))
            for (var E = C * e.strides[0], k = g + S * t.strides[1], I = 0; I < n.outHeight; ++I)
             for (var O = x + I * p.strides[2], A = I * n.strideHeight - h, N = 0; N < i; N++) {
              var R = A + N * s;
              if (!(R < 0 || R >= n.inHeight))
               for (var T = E + N * e.strides[1], _ = k + R * t.strides[2], D = 0; D < n.outWidth; ++D)
                for (var F = O + D * n.outChannels, M = D * n.strideWidth - l, L = 0; L < o; L++) {
                 var B = M + L * u;
                 if (!(B < 0 || B >= n.inWidth))
                  for (var P = T + L * e.strides[2], z = _ + B * n.inChannels, j = P, W = 0; W < n.inChannels; ++W) {
                   for (var V = f[z + W], U = 0; U < n.outChannels; ++U) v[F + U] += V * d[j + U];
                   j += n.outChannels
                  }
                }
             }
          }
        return p.toTensor()
       }, e.prototype.conv2dDerInput = function(t, e, n) {
        Gh([t, e], "conv2dDerInput");
        for (var r = mr(n.inShape, "float32"), i = r.values, o = this.readSync(t.dataId), a = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, p = n.filterHeight, f = n.filterWidth, d = n.inChannels, v = n.inHeight, m = n.inWidth, g = n.outChannels, y = n.outHeight, b = n.outWidth, x = n.strideHeight, w = n.strideWidth, C = n.dataFormat, S = p - 1 - n.padInfo.top, E = f - 1 - n.padInfo.left, k = "channelsLast" === C, I = r.strides[0], O = k ? r.strides[1] : r.strides[2], A = k ? r.strides[2] : 1, N = k ? 1 : r.strides[1], R = t.strides[0], T = k ? t.strides[1] : t.strides[2], _ = k ? t.strides[2] : 1, D = k ? 1 : t.strides[1], F = 0; F < h; ++F)
         for (var M = 0; M < d; ++M)
          for (var L = 0; L < v; ++L)
           for (var B = L - S, P = Math.max(0, Math.ceil(B / x)), z = Math.min(y, (p + B) / x), j = 0; j < m; ++j) {
            for (var W = j - E, V = Math.max(0, Math.ceil(W / w)), U = Math.min(b, (f + W) / w), H = 0, $ = P; $ < z; ++$)
             for (var G = $ * x - B, q = V; q < U; ++q)
              for (var K = R * F + T * $ + _ * q, X = u * (p - 1 - G) + c * (f - 1 - (q * w - W)) + l * M, Y = 0; Y < g; ++Y) H += o[K + D * Y] * a[X + Y];
            i[I * F + O * L + A * j + N * M] = H
           }
        return r.toTensor()
       }, e.prototype.conv3dDerInput = function(t, e, n) {
        for (var r = mr(n.inShape, "float32"), i = r.values, o = r.strides, a = o[0], s = o[1], u = o[2], c = o[3], l = this.readSync(t.dataId), h = t.strides, p = h[0], f = h[1], d = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], b = g[1], x = g[2], w = g[3], C = n.batchSize, S = n.filterDepth, E = n.filterHeight, k = n.filterWidth, I = n.inChannels, O = n.inDepth, A = n.inHeight, N = n.inWidth, R = n.outChannels, T = n.outDepth, _ = n.outHeight, D = n.outWidth, F = n.strideDepth, M = n.strideHeight, L = n.strideWidth, B = S - 1 - n.padInfo.front, P = E - 1 - n.padInfo.top, z = k - 1 - n.padInfo.left, j = 0; j < C; ++j)
         for (var W = 0; W < I; ++W)
          for (var V = 0; V < O; ++V)
           for (var U = V - B, H = Math.max(0, Math.ceil(U / F)), $ = Math.min(T, (S + U) / F), G = 0; G < A; ++G)
            for (var q = G - P, K = Math.max(0, Math.ceil(q / M)), X = Math.min(_, (E + q) / M), Y = 0; Y < N; ++Y) {
             for (var Z = Y - z, J = Math.max(0, Math.ceil(Z / L)), Q = Math.min(D, (k + Z) / L), tt = 0, et = H; et < $; ++et)
              for (var nt = et * F - U, rt = K; rt < X; ++rt)
               for (var it = rt * M - q, ot = J; ot < Q; ++ot)
                for (var at = p * j + f * et + d * rt + v * ot, st = y * (S - 1 - nt) + b * (E - 1 - it) + x * (k - 1 - (ot * L - Z)) + w * W, ut = 0; ut < R; ++ut) tt += l[at + ut] * m[st + ut];
             i[a * j + s * V + u * G + c * Y + W] = tt
            }
        return r.toTensor()
       }, e.prototype.conv2dDerFilter = function(t, e, n) {
        Gh([t, e], "conv2dDerFilter");
        for (var r = n.strideHeight, i = n.strideWidth, o = n.filterHeight, a = n.filterWidth, s = "channelsLast" === n.dataFormat, u = mr(n.filterShape, "float32"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), p = this.bufferSync(e), f = 0; f < o; ++f)
         for (var d = Math.max(0, Math.ceil((l - f) / r)), v = Math.min(n.outHeight, (n.inHeight + l - f) / r), m = 0; m < a; ++m)
          for (var g = Math.max(0, Math.ceil((c - m) / i)), y = Math.min(n.outWidth, (n.inWidth + c - m) / i), b = 0; b < n.inChannels; ++b)
           for (var x = 0; x < n.outChannels; ++x) {
            for (var w = 0, C = 0; C < n.batchSize; ++C)
             for (var S = d; S < v; ++S)
              for (var E = f + S * r - l, k = g; k < y; ++k) {
               var I = m + k * i - c;
               w += s ? h.get(C, E, I, b) * p.get(C, S, k, x) : h.get(C, b, E, I) * p.get(C, x, S, k)
              }
            u.set(w, f, m, b, x)
           }
        return u.toTensor()
       }, e.prototype.conv3dDerFilter = function(t, e, n) {
        for (var r = n.strideDepth, i = n.strideHeight, o = n.strideWidth, a = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = mr(n.filterShape, "float32"), l = c.values, h = c.strides, p = h[0], f = h[1], d = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], b = g[1], x = g[2], w = g[3], C = this.readSync(t.dataId), S = t.strides, E = S[0], k = S[1], I = S[2], O = S[3], A = n.padInfo.front, N = n.padInfo.left, R = n.padInfo.top, T = 0; T < a; ++T)
         for (var _ = Math.max(0, Math.ceil((A - T) / r)), D = Math.min(n.outDepth, (n.inDepth + A - T) / r), F = T * p, M = 0; M < s; ++M)
          for (var L = Math.max(0, Math.ceil((R - M) / i)), B = Math.min(n.outHeight, (n.inHeight + R - M) / i), P = M * f + F, z = 0; z < u; ++z)
           for (var j = Math.max(0, Math.ceil((N - z) / o)), W = Math.min(n.outWidth, (n.inWidth + N - z) / o), V = z * d + P, U = 0; U < n.inChannels; ++U)
            for (var H = U * v + V, $ = 0; $ < n.outChannels; ++$) {
             for (var G = 0, q = 0; q < n.batchSize; ++q)
              for (var K = q * E, X = q * y, Y = _; Y < D; ++Y)
               for (var Z = (T + Y * r - A) * k + K, J = Y * b + X, Q = L; Q < B; ++Q)
                for (var tt = (M + Q * i - R) * I + Z, et = Q * x + J, nt = j; nt < W; ++nt) {
                 var rt = nt * w + et;
                 G += C[(z + nt * o - N) * O + tt + U] * m[rt + $]
                }
             l[H + $] = G
            }
        return c.toTensor()
       }, e.prototype.fusedDepthwiseConv2D = function(t) {
        var e = t.input,
         n = t.filter,
         r = t.convInfo,
         i = t.bias,
         o = t.activation,
         a = t.preluActivationWeights,
         s = this.depthwiseConv2D(e, n, r);
        return i && (s = this.add(s, i)), o && (s = qh(this, s, o, a)), s
       }, e.prototype.depthwiseConv2D = function(t, e, n) {
        Gh([t, e], "depthwiseConv2D");
        for (var r = n.filterHeight, i = n.filterWidth, o = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = mr(n.outShape, t.dtype), h = this.readSync(t.dataId), p = this.readSync(e.dataId), f = l.values, d = 0; d < n.batchSize; ++d)
         for (var v = d * t.strides[0], m = d * l.strides[0], g = 0; g < n.outHeight; ++g)
          for (var y = m + g * l.strides[1], b = g * n.strideHeight - s, x = 0; x < r; ++x) {
           var w = b + x * o;
           if (!(w < 0 || w >= n.inHeight))
            for (var C = x * e.strides[0], S = v + w * t.strides[1], E = 0; E < n.outWidth; ++E)
             for (var k = y + E * l.strides[2], I = E * n.strideWidth - u, O = 0; O < i; ++O) {
              var A = I + O * a;
              if (!(A < 0 || A >= n.inWidth))
               for (var N = C + O * e.strides[1], R = S + A * n.inChannels, T = k, _ = N, D = 0; D < n.inChannels; ++D) {
                for (var F = h[R + D], M = 0; M < c; ++M) f[T + M] += F * p[_ + M];
                T += c, _ += c
               }
             }
          }
        return l.toTensor()
       }, e.prototype.depthwiseConv2DDerInput = function(t, e, n) {
        Gh([t, e], "depthwiseConv2DDerInput");
        for (var r = mr(n.inShape, "float32"), i = r.values, o = r.strides, a = o[0], s = o[1], u = o[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], p = l[1], f = l[2], d = this.readSync(e.dataId), v = e.strides, m = v[0], g = v[1], y = v[2], b = n.batchSize, x = n.filterHeight, w = n.filterWidth, C = n.inChannels, S = n.inHeight, E = n.inWidth, k = n.outChannels, I = n.outHeight, O = n.outWidth, A = n.strideHeight, N = n.strideWidth, R = x - 1 - n.padInfo.top, T = w - 1 - n.padInfo.left, _ = k / C, D = 0; D < b; ++D)
         for (var F = 0; F < C; ++F)
          for (var M = 0; M < S; ++M)
           for (var L = M - R, B = Math.max(0, Math.ceil(L / A)), P = Math.min(I, (x + L) / A), z = 0; z < E; ++z) {
            for (var j = z - T, W = Math.max(0, Math.ceil(j / N)), V = Math.min(O, (w + j) / N), U = 0, H = B; H < P; ++H)
             for (var $ = H * A - L, G = W; G < V; ++G)
              for (var q = h * D + p * H + f * G, K = m * (x - 1 - $) + g * (w - 1 - (G * N - j)) + y * F, X = 0; X < _; ++X) U += c[q + (F * _ + X)] * d[K + X];
            i[a * D + s * M + u * z + F] = U
           }
        return r.toTensor()
       }, e.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
        Gh([t, e], "depthwiseConv2DDerFilter");
        for (var r = n.strideHeight, i = n.strideWidth, o = n.filterHeight, a = n.filterWidth, s = mr(n.filterShape, "float32"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), p = this.bufferSync(e), f = 0; f < o; ++f)
         for (var d = Math.max(0, Math.ceil((c - f) / r)), v = Math.min(n.outHeight, (n.inHeight + c - f) / r), m = 0; m < a; ++m)
          for (var g = Math.max(0, Math.ceil((u - m) / i)), y = Math.min(n.outWidth, (n.inWidth + u - m) / i), b = 0; b < n.outChannels; ++b) {
           for (var x = Math.trunc(b / l), w = b % l, C = 0, S = 0; S < n.batchSize; ++S)
            for (var E = d; E < v; ++E)
             for (var k = f + E * r - c, I = g; I < y; ++I) {
              var O = m + I * i - u;
              C += h.get(S, k, O, x) * p.get(S, E, I, b)
             }
           s.set(C, f, m, x, w)
          }
        return s.toTensor()
       }, e.prototype.tile = function(t, e) {
        return Gh(t, "tile"), no(this.bufferSync(t), e)
       }, e.prototype.pad = function(t, e, n) {
        Gh(t, "pad");
        var r = e.map((function(e, n) {
          return e[0] + t.shape[n] + e[1]
         })),
         i = e.map((function(t) {
          return t[0]
         })),
         o = this.bufferSync(t),
         a = mr(r, t.dtype);
        0 !== n && a.values.fill(n);
        for (var s = 0; s < t.size; s++) {
         var u = o.indexToLoc(s),
          c = u.map((function(t, e) {
           return t + i[e]
          }));
         a.set.apply(a, [o.get.apply(o, u)].concat(c))
        }
        return a.toTensor()
       }, e.prototype.transpose = function(t, e) {
        Gh(t, "transpose");
        for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];
        var i = this.readSync(t.dataId),
         o = mr(n, t.dtype),
         a = this.bufferSync(t);
        for (r = 0; r < t.size; ++r) {
         for (var s = a.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[e[c]];
         var l = o.locToIndex(u);
         o.values[l] = i[r]
        }
        return o.toTensor()
       }, e.prototype.gather = function(t, e, n) {
        Gh([t, e], "gather");
        var r = t.shape.slice(),
         i = this.readSync(e.dataId);
        r[n] = i.length;
        for (var o = mr(r, t.dtype), a = this.bufferSync(t), s = 0; s < o.size; ++s) {
         var u = o.indexToLoc(s),
          c = u.slice();
         c[n] = i[u[n]];
         var l = a.locToIndex(c);
         o.values[s] = a.values[l]
        }
        return o.toTensor()
       }, e.prototype.batchToSpaceND = function(t, e, n) {
        Gh([t], "batchToSpaceND");
        var r = e.reduce((function(t, e) {
          return t * e
         })),
         i = $r(t.shape, e, r),
         o = Gr(i.length, e.length),
         a = qr(t.shape, e, r),
         s = Kr(n, e.length),
         u = Xr(a, n, e.length);
        return t.reshape(i).transpose(o).reshape(a).slice(s, u)
       }, e.prototype.spaceToBatchND = function(t, e, n) {
        Gh([t], "spaceToBatchND");
        var r = e.reduce((function(t, e) {
          return t * e
         })),
         i = [
          [0, 0]
         ];
        i.push.apply(i, n);
        for (var o = 1 + e.length; o < t.shape.length; ++o) i.push([0, 0]);
        var a = t.pad(i),
         s = $r(a.shape, e, r, !1),
         u = Gr(s.length, e.length, !1),
         c = qr(a.shape, e, r, !1);
        return a.reshape(s).transpose(u).reshape(c)
       }, e.prototype.pool = function(t, e, n) {
        Gh(t, "pool");
        for (var r = e.strideHeight, i = e.strideWidth, o = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, p = this.readSync(t.dataId), f = mr(e.outShape, t.dtype), d = f.values, v = e.outShape[1] * e.outShape[2] * e.outShape[3], m = e.outShape[2] * e.outShape[3], g = e.outShape[3], y = 0; y < e.batchSize; ++y)
         for (var b = y * v, x = y * t.strides[0], w = 0; w < e.inChannels; ++w)
          for (var C = 0; C < e.outHeight; ++C)
           for (var S = C * r - c, E = Math.max(0, S), k = Math.min(e.inHeight, s + S), I = b + C * m, O = 0; O < e.outWidth; ++O) {
            for (var A = O * i - l, N = Math.max(0, A), R = Math.min(e.inWidth, u + A), T = h, _ = 0, D = 0, F = E; F < k; F += o) {
             for (var M = x + F * t.strides[1], L = N; L < R; L += a) {
              var B = p[M + L * t.strides[2] + w];
              "max" === n && B > T ? T = B : "avg" === n && (_ += B, D++)
             }
             if (isNaN(T)) break
            }
            d[I + O * g + w] = "avg" === n ? _ / D : T
           }
        return f.toTensor()
       }, e.prototype.maxPool = function(t, e) {
        return this.pool(t, e, "max")
       }, e.prototype.maxPoolPositions = function(t, e) {
        for (var n = mr(e.outShape, "int32"), r = e.strideHeight, i = e.strideWidth, o = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), p = 0; p < e.batchSize; ++p)
         for (var f = 0; f < e.inChannels; ++f)
          for (var d = 0; d < e.outHeight; ++d) {
           for (var v = d * r - c, m = v; m < 0;) m += o;
           for (var g = Math.min(e.inHeight, s + v), y = 0; y < e.outWidth; ++y) {
            for (var b = y * i - l, x = b; x < 0;) x += a;
            for (var w = Math.min(e.inWidth, u + b), C = Number.NEGATIVE_INFINITY, S = -1, E = m; E < g; E += o)
             for (var k = E - v, I = x; I < w; I += a) {
              var O = I - b,
               A = h.get(p, E, I, f);
              A > C && (C = A, S = k * u + O)
             }
            n.set(S, p, d, y, f)
           }
          }
        return n.toTensor()
       }, e.prototype.maxPoolBackprop = function(t, e, n, r) {
        Gh([e, n], "maxPoolBackprop");
        for (var i = this.maxPoolPositions(e, r), o = r.strideHeight, a = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, p = c - 1 - r.padInfo.top, f = mr(e.shape, "float32"), d = this.bufferSync(i), v = this.bufferSync(t), m = 0; m < r.batchSize; ++m)
         for (var g = 0; g < r.inChannels; ++g)
          for (var y = 0; y < r.inHeight; ++y)
           for (var b = 0; b < r.inWidth; ++b) {
            for (var x = y - p, w = b - h, C = 0, S = 0; S < c; S += s) {
             var E = (x + S) / o;
             if (!(E < 0 || E >= r.outHeight || Math.floor(E) !== E))
              for (var k = 0; k < l; k += u) {
               var I = (w + k) / a;
               if (!(I < 0 || I >= r.outWidth || Math.floor(I) !== I)) {
                var O = c * l - 1 - d.get(m, E, I, g) === S * l + k ? 1 : 0;
                0 !== O && (C += v.get(m, E, I, g) * O)
               }
              }
            }
            f.set(C, m, y, b, g)
           }
        return f.toTensor()
       }, e.prototype.avgPoolBackprop = function(t, e, n) {
        Gh([t, e], "avgPoolBackprop");
        for (var r = n.strideHeight, i = n.strideWidth, o = n.filterHeight, a = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, p = c - 1 - n.padInfo.top, f = mr(e.shape, "float32"), d = 1 / (o * a), v = this.bufferSync(t), m = 0; m < n.batchSize; ++m)
         for (var g = 0; g < n.inChannels; ++g)
          for (var y = 0; y < n.inHeight; ++y)
           for (var b = 0; b < n.inWidth; ++b) {
            for (var x = y - p, w = b - h, C = 0, S = 0; S < c; S += s) {
             var E = (x + S) / r;
             if (!(E < 0 || E >= n.outHeight || Math.floor(E) !== E))
              for (var k = 0; k < l; k += u) {
               var I = (w + k) / i;
               I < 0 || I >= n.outWidth || Math.floor(I) !== I || (C += v.get(m, E, I, g))
              }
            }
            f.set(C * d, m, y, b, g)
           }
        return f.toTensor()
       }, e.prototype.pool3d = function(t, e, n) {
        Gh(t, "pool3d");
        for (var r = e.strideDepth, i = e.strideHeight, o = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, p = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, v = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t.dataId), g = mr(e.outShape, t.dtype), y = g.values, b = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], x = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], S = 0; S < e.batchSize; ++S)
         for (var E = S * b, k = S * t.strides[0], I = 0; I < e.inChannels; ++I)
          for (var O = 0; O < e.outDepth; ++O) {
           for (var A = O * r - p, N = A; N < 0;) N += a;
           for (var R = Math.min(e.inDepth, c + A), T = E + O * x, _ = 0; _ < e.outHeight; ++_) {
            for (var D = _ * i - f, F = D; F < 0;) F += s;
            for (var M = Math.min(e.inHeight, l + D), L = T + _ * w, B = 0; B < e.outWidth; ++B) {
             for (var P = B * o - d, z = P; z < 0;) z += u;
             for (var j = Math.min(e.inWidth, h + P), W = L + B * C, V = v, U = 0, H = 0, $ = N; $ < R; $ += a) {
              for (var G = k + $ * t.strides[1], q = F; q < M; q += s) {
               for (var K = G + q * t.strides[2], X = z; X < j; X += u) {
                var Y = m[K + X * t.strides[3] + I];
                if ("max" === n && Y > V ? V = Y : "avg" === n && (U += Y, H++), isNaN(V)) break
               }
               if (isNaN(V)) break
              }
              if (isNaN(V)) break
             }
             y[W + I] = "avg" === n ? U / H : V
            }
           }
          }
        return g.toTensor()
       }, e.prototype.avgPool3d = function(t, e) {
        return Gh(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat()
       }, e.prototype.avgPool3dBackprop = function(t, e, n) {
        Gh([t, e], "avgPool3dBackprop");
        for (var r = n.strideDepth, i = n.strideHeight, o = n.strideWidth, a = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, p = n.effectiveFilterDepth, f = n.effectiveFilterHeight, d = n.effectiveFilterWidth, v = p - 1 - n.padInfo.front, m = d - 1 - n.padInfo.left, g = f - 1 - n.padInfo.top, y = mr(e.shape, "float32"), b = 1 / (a * s * u), x = this.bufferSync(t), w = 0; w < n.batchSize; ++w)
         for (var C = 0; C < n.inChannels; ++C)
          for (var S = 0; S < n.inDepth; ++S)
           for (var E = 0; E < n.inHeight; ++E)
            for (var k = 0; k < n.inWidth; ++k) {
             for (var I = S - v, O = E - g, A = k - m, N = 0, R = 0; R < p; R += c) {
              var T = (I + R) / r;
              if (!(T < 0 || T >= n.outDepth || Math.floor(T) !== T))
               for (var _ = 0; _ < f; _ += l) {
                var D = (O + _) / i;
                if (!(D < 0 || D >= n.outHeight || Math.floor(D) !== D))
                 for (var F = 0; F < d; F += h) {
                  var M = (A + F) / o;
                  M < 0 || M >= n.outWidth || Math.floor(M) !== M || (N += x.get(w, T, D, M, C))
                 }
               }
             }
             y.set(N * b, w, S, E, k, C)
            }
        return y.toTensor()
       }, e.prototype.maxPool3d = function(t, e) {
        return Gh(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat()
       }, e.prototype.maxPool3dPositions = function(t, e) {
        for (var n = mr(e.outShape, "int32"), r = e.strideDepth, i = e.strideHeight, o = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, p = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, v = this.bufferSync(t), m = 0; m < e.batchSize; ++m)
         for (var g = 0; g < e.inChannels; ++g)
          for (var y = 0; y < e.outDepth; ++y) {
           for (var b = y * r - p, x = b; x < 0;) x += a;
           for (var w = Math.min(e.inDepth, c + b), C = 0; C < e.outHeight; ++C) {
            for (var S = C * i - f, E = S; E < 0;) E += s;
            for (var k = Math.min(e.inHeight, l + S), I = 0; I < e.outWidth; ++I) {
             for (var O = I * o - d, A = O; A < 0;) A += u;
             for (var N = Math.min(e.inWidth, h + O), R = Number.NEGATIVE_INFINITY, T = -1, _ = x; _ < w; _ += a)
              for (var D = _ - b, F = E; F < k; F += s)
               for (var M = F - S, L = A; L < N; L += u) {
                var B = L - O,
                 P = v.get(m, _, F, L, g);
                P >= R && (R = P, T = D * l * h + M * l + B)
               }
             n.set(T, m, y, C, I, g)
            }
           }
          }
        return n.toTensor()
       }, e.prototype.maxPool3dBackprop = function(t, e, n, r) {
        Gh([e, n], "maxPool3dBackprop");
        for (var i = this.maxPool3dPositions(e, r), o = r.strideDepth, a = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, p = r.effectiveFilterHeight, f = r.effectiveFilterWidth, d = h - 1 - r.padInfo.front, v = f - 1 - r.padInfo.left, m = p - 1 - r.padInfo.top, g = mr(e.shape, "float32"), y = this.bufferSync(i), b = this.bufferSync(t), x = 0; x < r.batchSize; ++x)
         for (var w = 0; w < r.inChannels; ++w)
          for (var C = 0; C < r.inDepth; ++C)
           for (var S = 0; S < r.inHeight; ++S)
            for (var E = 0; E < r.inWidth; ++E) {
             for (var k = C - d, I = S - m, O = E - v, A = 0, N = 0; N < h; N += u) {
              var R = (k + N) / o;
              if (!(R < 0 || R >= r.outDepth || Math.floor(R) !== R))
               for (var T = 0; T < p; T += c) {
                var _ = (I + T) / a;
                if (!(_ < 0 || _ >= r.outHeight || Math.floor(_) !== _))
                 for (var D = 0; D < f; D += l) {
                  var F = (O + D) / s;
                  if (!(F < 0 || F >= r.outWidth || Math.floor(F) !== F)) {
                   var M = h * p * f - 1 - y.get(x, R, _, F, w) === N * p * f + T * f + D ? 1 : 0;
                   0 !== M && (A += b.get(x, R, _, F, w) * M)
                  }
                 }
               }
             }
             g.set(A, x, C, S, E, w)
            }
        return g.toTensor()
       }, e.prototype.cast = function(t, e) {
        return zi(t, e, this)
       }, e.prototype.reshape = function(t, e) {
        return ji(t, e)
       }, e.prototype.avgPool = function(t, e) {
        return Gh(t, "avgPool"), this.pool(t, e, "avg").toFloat()
       }, e.prototype.resizeBilinear = function(t, e, n, r) {
        Gh(t, "resizeBilinear");
        for (var i = t.shape, o = i[0], a = i[1], s = i[2], u = i[3], c = this.readSync(t.dataId), l = new Float32Array(T([o, e, n, u])), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = 0, d = h[0] / p[0], v = h[1] / p[1], m = 0; m < o; m++)
         for (var g = 0; g < e; g++)
          for (var y = d * g, b = Math.floor(y), x = y - b, w = Math.min(a - 1, Math.ceil(y)), C = m * t.strides[0] + b * t.strides[1], S = m * t.strides[0] + w * t.strides[1], E = 0; E < n; E++)
           for (var k = v * E, I = Math.floor(k), O = k - I, A = Math.min(s - 1, Math.ceil(k)), N = C + I * t.strides[2], R = S + I * t.strides[2], _ = C + A * t.strides[2], D = S + A * t.strides[2], F = 0; F < u; F++) {
            var M = c[N + F],
             L = c[R + F],
             B = M + (c[_ + F] - M) * O,
             P = B + (L + (c[D + F] - L) * O - B) * x;
            l[f++] = P
           }
        return Mn(l, [o, e, n, u])
       }, e.prototype.resizeBilinearBackprop = function(t, e, n) {
        Gh([t, e], "resizeBilinearBackprop");
        for (var r = e.shape, i = r[0], o = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(i * o * a * s), p = [n && c > 1 ? o - 1 : o, n && l > 1 ? a - 1 : a], f = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], d = p[0] / f[0], v = p[1] / f[1], m = this.readSync(t.dataId), g = 0, y = 0; y < i; y++)
         for (var b = y * e.strides[0], x = 0; x < c; x++)
          for (var w = x * d, C = Math.floor(w), S = Math.min(Math.ceil(w), o - 1), E = b + C * e.strides[1], k = b + S * e.strides[1], I = w - C, O = 1 - I, A = 0; A < l; A++)
           for (var N = A * v, R = Math.floor(N), T = Math.min(Math.ceil(N), a - 1), _ = N - R, D = 1 - _, F = E + R * e.strides[2], M = E + T * e.strides[2], L = k + R * e.strides[2], B = k + T * e.strides[2], P = O * D, z = O * _, j = I * D, W = I * _, V = 0; V < s; V++) {
            var U = m[g++];
            h[F + V] += U * P, h[M + V] += U * z, h[L + V] += U * j, h[B + V] += U * W
           }
        return Wn(h, [i, a, o, s], e.dtype)
       }, e.prototype.resizeNearestNeighbor = function(t, e, n, r) {
        Gh(t, "resizeNearestNeighbor");
        for (var i = t.shape, o = i[0], a = i[1], s = i[2], u = i[3], c = this.readSync(t.dataId), l = new Float32Array(o * e * n * u), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = h[0] / p[0], d = h[1] / p[1], v = 0, m = 0; m < o; m++)
         for (var g = m * t.strides[0], y = 0; y < e; y++)
          for (var b = f * y, x = g + Math.min(a - 1, r ? Math.round(b) : Math.floor(b)) * t.strides[1], w = 0; w < n; w++)
           for (var C = d * w, S = x + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], E = 0; E < u; E++) {
            var k = c[S + E];
            l[v++] = k
           }
        return Mn(l, [o, e, n, u], t.dtype)
       }, e.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
        Gh([t, e], "resizeNearestNeighborBackprop");
        for (var r = e.shape, i = r[0], o = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(i * o * a * s), p = this.readSync(t.dataId), f = [n && c > 1 ? o - 1 : o, n && l > 1 ? a - 1 : a], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], v = f[0] / d[0], m = f[1] / d[1], g = 1 / v, y = 1 / m, b = 2 * Math.ceil(g) + 2, x = 2 * Math.ceil(y) + 2, w = 0; w < i; w++)
         for (var C = w * e.strides[0], S = 0; S < o; S++)
          for (var E = C + S * e.strides[1], k = Math.floor(S * g), I = Math.floor(k - b / 2), O = 0; O < a; O++)
           for (var A = E + O * e.strides[2], N = Math.floor(O * y), R = Math.floor(N - x / 2), T = 0; T < s; T++) {
            for (var _ = 0, D = 0; D < b; D++) {
             var F = D + I;
             if (!(F < 0 || F >= c)) {
              var M = C + F * t.strides[1],
               L = F * v;
              if (S === Math.min(o - 1, n ? Math.round(L) : Math.floor(L)))
               for (var B = 0; B < x; B++) {
                var P = B + R;
                if (!(P < 0 || P >= l)) {
                 var z = M + P * t.strides[2],
                  j = P * m;
                 O === Math.min(a - 1, n ? Math.round(j) : Math.floor(j)) && (_ += p[z + T])
                }
               }
             }
            }
            h[A + T] = _
           }
        return Wn(h, e.shape, e.dtype)
       }, e.prototype.batchNormalization = function(t, e, n, r, i, o) {
        Gh([t, e, n, i, o], "batchNorm");
        for (var a = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = i ? this.readSync(i.dataId) : new Float32Array([1]), l = o ? this.readSync(o.dataId) : new Float32Array([0]), h = new Float32Array(a.length), p = l.length, f = c.length, d = u.length, v = s.length, m = 0, g = 0, y = 0, b = 0, x = 0; x < a.length; ++x) h[x] = l[m++] + (a[x] - s[g++]) * c[y++] / Math.sqrt(u[b++] + r), m >= p && (m = 0), g >= v && (g = 0), y >= f && (y = 0), b >= d && (b = 0);
        return Wn(h, t.shape)
       }, e.prototype.localResponseNormalization4D = function(t, e, n, r, i) {
        Gh(t, "localResponseNormalization4D");
        var o = t.shape[3],
         a = o - 1,
         s = this.readSync(t.dataId),
         u = t.size,
         c = new Float32Array(u);
 
        function l(t) {
         for (var n = t % o, r = t - n + Math.max(0, n - e), i = t - n + Math.min(n + e, a), u = 0; r <= i; r++) {
          var c = s[r];
          u += c * c
         }
         return u
        }
        for (var h = 0; h < u; h++) {
         var p = l(h),
          f = s[h] * Math.pow(n + r * p, -i);
         c[h] = f
        }
        return Wn(c, t.shape)
       }, e.prototype.LRNGrad = function(t, e, n, r, i, o, a) {
        Gh(t, "LRNGrad");
        for (var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), p = t.size, f = 0; f < p; f++) {
         for (var d = f % s, v = f - d + Math.max(0, d - r), m = f - d + Math.min(s, d + r + 1), g = 0, y = v; y < m; y++) g += Math.pow(c[y], 2);
         for (g = o * g + i, y = v; y < m; y++) {
          var b = -2 * o * a * c[y] * l[f] / g;
          f === y && (b += Math.pow(g, -a)), b *= u[f], h[y] += b
         }
        }
        return Wn(h, t.shape)
       }, e.prototype.multinomial = function(t, e, n, r) {
        Gh(t, "multinomial");
        for (var i = e ? t : bi(t), o = i.shape[0], a = i.shape[1], s = Gn([o, n], "int32"), u = this.readSync(s.dataId), c = this.readSync(i.dataId), l = 0; l < o; ++l) {
         var h = l * a,
          p = new Float32Array(a - 1);
         p[0] = c[h];
         for (var f = 1; f < p.length; ++f) p[f] = p[f - 1] + c[h + f];
         for (var d = pr(r.toString()), v = l * n, m = 0; m < n; ++m) {
          var g = d();
          u[v + m] = p.length;
          for (var y = 0; y < p.length; y++)
           if (g < p[y]) {
            u[v + m] = y;
            break
           }
         }
        }
        return s
       }, e.prototype.oneHot = function(t, e, n, r) {
        Gh(t, "oneHot");
        var i = new Float32Array(t.size * e);
        i.fill(r);
        for (var o = this.readSync(t.dataId), a = 0; a < t.size; ++a) o[a] >= 0 && o[a] < e && (i[a * e + o[a]] = n);
        return zn(i, [t.size, e], "int32")
       }, e.prototype.nonMaxSuppression = function(t, e, n, r, i) {
        return Gh(t, "nonMaxSuppression"), Xi(this.readSync(t.dataId), this.readSync(e.dataId), n, r, i)
       }, e.prototype.fft = function(t) {
        return this.fftBatch(t, !1)
       }, e.prototype.ifft = function(t) {
        return this.fftBatch(t, !0)
       }, e.prototype.fftBatch = function(t, e) {
        for (var n = t.shape[0], r = t.shape[1], i = mr(t.shape, "float32"), o = mr(t.shape, "float32"), a = Dn(t).as2D(n, r), s = Fn(t).as2D(n, r), u = 0; u < n; u++)
         for (var c = a.slice([u, 0], [1, r]), l = s.slice([u, 0], [1, r]), h = _n(c, l), p = this.readSync(this.fftImpl(h, e).dataId), f = 0; f < r; f++) {
          var d = Hi(p, f);
          i.values[u * r + f] = d.real, o.values[u * r + f] = d.imag
         }
        return _n(i.toTensor(), o.toTensor()).as2D(n, r)
       }, e.prototype.fftImpl = function(t, e) {
        var n = t.as1D(),
         r = n.size;
        if (this.isExponentOf2(r)) {
         var i = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
         return e && (i = _n(Dn(i).div(Bn(r)), Fn(i).div(Bn(r)))), i
        }
        var o = this.readSync(t.dataId),
         a = function(t) {
          for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];
          return {
           real: e,
           imag: n
          }
         }(this.fourierTransformByMatmul(o, r, e));
        return _n(a.real, a.imag).as2D(t.shape[0], t.shape[1])
       }, e.prototype.isExponentOf2 = function(t) {
        return 0 == (t & t - 1)
       }, e.prototype.fftRadix2 = function(t, e, n) {
        if (1 === e) return t;
        var r = this.readSync(t.dataId),
         i = e / 2,
         o = function(t) {
          for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), i = 0; i < t.length; i += 4) n[Math.floor(i / 4)] = t[i], r[Math.floor(i / 4)] = t[i + 1];
          return {
           real: n,
           imag: r
          }
         }(r),
         a = _n(o.real, o.imag).as1D(),
         s = function(t) {
          for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), i = 2; i < t.length; i += 4) n[Math.floor(i / 4)] = t[i], r[Math.floor(i / 4)] = t[i + 1];
          return {
           real: n,
           imag: r
          }
         }(r),
         u = _n(s.real, s.imag).as1D();
        a = this.fftRadix2(a, i, n), u = this.fftRadix2(u, i, n);
        var c = function(t, e) {
          for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), i = 0; i < Math.ceil(t / 2); i++) {
           var o = (e ? 2 : -2) * Math.PI * (i / t);
           n[i] = Math.cos(o), r[i] = Math.sin(o)
          }
          return {
           real: n,
           imag: r
          }
         }(e, n),
         l = _n(c.real, c.imag).mul(u),
         h = a.add(l),
         p = a.sub(l),
         f = Dn(h).concat(Dn(p)),
         d = Fn(h).concat(Fn(p));
        return _n(f, d).as1D()
       }, e.prototype.fourierTransformByMatmul = function(t, e, n) {
        for (var r = new Float32Array(2 * e), i = 0; i < e; i++) {
         for (var o = 0, a = 0, s = 0; s < e; s++) {
          var u = Gi(i * s, e, n),
           c = Hi(t, s);
          o += c.real * u.real - c.imag * u.imag, a += c.real * u.imag + c.imag * u.real
         }
         n && (o /= e, a /= e), $i(r, o, a, i)
        }
        return r
       }, e.prototype.depthToSpace = function(t, e, n) {
        O("NHWC" === n, (function() {
         return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n
        })), O(e > 1, (function() {
         return "blockSize should be > 1 for depthToSpace, but was: " + e
        }));
        for (var r = t.shape[0], i = t.shape[1], o = t.shape[2], a = t.shape[3], s = i * e, u = o * e, c = a / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), p = 0, f = 0; f < r; ++f)
         for (var d = 0; d < s; ++d)
          for (var v = Math.floor(d / e), m = d % e, g = 0; g < u; ++g)
           for (var y = Math.floor(g / e), b = (m * e + g % e) * c, x = 0; x < c; ++x) {
            var w = x + b + a * (y + o * (v + i * f));
            h[p++] = l[w]
           }
        return Wn(h, [r, s, u, c])
       }, e.prototype.broadcastedBinaryOp = function(t, e, n, r) {
        var i = Ii(t.shape, e.shape),
         o = mr(i, n),
         a = this.readSync(t.dataId),
         s = this.readSync(e.dataId),
         u = Ei(t.shape, i),
         c = Ei(e.shape, i),
         l = o.values;
        if (u.length + c.length === 0)
         for (var h = 0; h < l.length; ++h) l[h] = r(a[h % a.length], s[h % s.length]);
        else {
         var p = this.bufferSync(t),
          f = this.bufferSync(e),
          d = function(n) {
           var i = o.indexToLoc(n),
            h = i.slice(-t.rank);
           u.forEach((function(t) {
            return h[t] = 0
           }));
           var d = p.locToIndex(h),
            v = i.slice(-e.rank);
           c.forEach((function(t) {
            return v[t] = 0
           }));
           var m = f.locToIndex(v);
           l[n] = r(a[d], s[m])
          };
         for (h = 0; h < l.length; ++h) d(h)
        }
        return o.toTensor()
       }, e.prototype.broadcastedBinaryComplexOp = function(t, e, n) {
        var r = Ii(t.shape, e.shape),
         i = mr(r, "float32"),
         o = mr(r, "float32"),
         a = this.readSync(t.dataId),
         s = this.readSync(e.dataId),
         u = Ei(t.shape, r),
         c = Ei(e.shape, r),
         l = i.values,
         h = o.values;
        if (u.length + c.length === 0)
         for (var p = 0; p < l.length; p++) {
          var f = p % a.length,
           d = p % s.length,
           v = n(a[2 * f], a[2 * f + 1], s[2 * d], s[2 * d + 1]);
          l[p] = v.real, h[p] = v.imag
         } else {
          var m = this.bufferSync(this.data.get(t.dataId).complexTensors.real),
           g = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
           y = function(r) {
            var o = i.indexToLoc(r),
             p = o.slice(-t.rank);
            u.forEach((function(t) {
             return p[t] = 0
            }));
            var f = m.locToIndex(p),
             d = o.slice(-e.rank);
            c.forEach((function(t) {
             return d[t] = 0
            }));
            var v = g.locToIndex(d),
             y = n(a[2 * f], a[2 * f + 1], s[2 * v], s[2 * v + 1]);
            l[r] = y.real, h[r] = y.imag
           };
          for (p = 0; p < l.length; p++) y(p)
         }
        return this.complex(i.toTensor(), o.toTensor())
       }, e.prototype.split = function(t, e, n) {
        return eo(t, e, n)
       }, e.prototype.dispose = function() {}, e.prototype.floatPrecision = function() {
        return 32
       }, e.prototype.epsilon = function() {
        return 1e-7
       }, e.prototype.cropAndResize = function(t, e, n, r, i, o) {
        for (var a = t.shape, s = a[0], u = a[1], c = a[2], l = a[3], h = e.shape[0], p = r[0], f = r[1], d = mr([h, p, f, l], "float32"), v = this.readSync(e.dataId), m = this.readSync(n.dataId), g = this.readSync(t.dataId), y = t.strides, b = d.strides, x = 0; x < h; x++) {
         var w = 4 * x,
          C = v[w],
          S = v[w + 1],
          E = v[w + 2],
          k = v[w + 3],
          I = m[x];
         if (!(I >= s))
          for (var O = p > 1 ? (E - C) * (u - 1) / (p - 1) : 0, A = f > 1 ? (k - S) * (c - 1) / (f - 1) : 0, N = 0; N < p; N++) {
           var R = p > 1 ? C * (u - 1) + N * O : .5 * (C + E) * (u - 1);
           if (R < 0 || R > u - 1)
            for (var T = 0; T < f; T++)
             for (var _ = 0; _ < l; _++) {
              var D = _ + T * b[2] + N * b[1] + x * b[0];
              d.values[D] = o
             } else if ("bilinear" === i) {
              var F = Math.floor(R),
               M = Math.ceil(R),
               L = R - F;
              for (T = 0; T < f; T++)
               if (($ = f > 1 ? S * (c - 1) + T * A : .5 * (S + k) * (c - 1)) < 0 || $ > c - 1)
                for (_ = 0; _ < l; _++) D = _ + T * b[2] + N * b[1] + x * b[0], d.values[D] = o;
               else {
                var B = Math.floor($),
                 P = Math.ceil($),
                 z = $ - B;
                for (_ = 0; _ < l; _++) {
                 var j = g[D = _ + B * y[2] + F * y[1] + I * y[0]],
                  W = g[D = _ + P * y[2] + F * y[1] + I * y[0]],
                  V = g[D = _ + B * y[2] + M * y[1] + I * y[0]],
                  U = j + (W - j) * z,
                  H = V + (g[D = _ + P * y[2] + M * y[1] + I * y[0]] - V) * z;
                 D = _ + T * b[2] + N * b[1] + x * b[0], d.values[D] = U + (H - U) * L
                }
               }
             } else
              for (T = 0; T < f; ++T) {
               var $;
               if (($ = f > 1 ? S * (c - 1) + T * A : .5 * (S + k) * (c - 1)) < 0 || $ > c - 1)
                for (_ = 0; _ < l; _++) D = _ + T * b[2] + N * b[1] + x * b[0], d.values[D] = o;
               else {
                var G = Math.round($),
                 q = Math.round(R);
                for (_ = 0; _ < l; _++) {
                 var K = _ + G * y[2] + q * y[1] + I * y[0],
                  X = _ + T * b[2] + N * b[1] + x * b[0];
                 d.values[X] = g[K]
                }
               }
              }
          }
        }
        return d.toTensor()
       }, e.prototype.sparseToDense = function(t, e, n, r) {
        var i = ni(0, t, n),
         o = i.sliceRank,
         a = i.numUpdates,
         s = i.sliceSize,
         u = i.strides,
         c = i.outputSize;
        return this.scatter(t, e, n, c, s, a, o, u, r, !1)
       }, e.prototype.gatherND = function(t, e) {
        var n = e.shape,
         r = n[n.length - 1],
         i = Yr(t, e),
         o = i[0],
         a = i[1],
         s = i[2],
         u = i[3];
        if (0 === a) return Mn([], o, t.dtype);
        for (var c = new xt([a, s], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), p = 0; p < a; p++) {
         for (var f = [], d = 0, v = 0; v < r; v++) {
          var m = l[p * r + v];
          d += m * u[v], f.push(m)
         }
         if (d < 0 || d >= t.size / s) throw new Error("Invalid indices: " + f + " does not index into " + t.shape);
         for (var g = 0; g < s; g++) c.values[p * s + g] = h[d * s + g]
        }
        return c.toTensor().reshape(o)
       }, e.prototype.scatterND = function(t, e, n) {
        var r = ni(0, t, n),
         i = r.sliceRank,
         o = r.numUpdates,
         a = r.sliceSize,
         s = r.strides,
         u = r.outputSize,
         c = Bn(0);
        return this.scatter(t, e, n, u, a, o, i, s, c, !0)
       }, e.prototype.fill = function(t, e, n) {
        var r = V(n = n || J(e), T(t));
        return r.fill(e), Wt.makeTensor(r, t, n, this)
       }, e.prototype.onesLike = function(t) {
        if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
        return this.fill(t.shape, 1, t.dtype)
       }, e.prototype.zerosLike = function(t) {
        var e = V(t.dtype, T(t.shape));
        return this.makeOutput(e, t.shape, t.dtype)
       }, e.prototype.linspace = function(t, e, n) {
        return Wi(t, e, n)
       }, e.prototype.scatter = function(t, e, n, r, i, o, a, s, u, c) {
        var l = [r / i, i],
         h = this.readSync(t.dataId),
         p = this.readSync(e.dataId);
        if (0 === r) return Mn([], n, e.dtype);
        var f = new xt(l, e.dtype);
        f.values.fill(this.readSync(u.dataId)[0]);
        for (var d = 0; d < o; d++) {
         for (var v = [], m = 0, g = 0; g < a; g++) {
          var y = h[d * a + g];
          v.push(y), m += y * s[g]
         }
         if (m < 0 || m >= r / i) throw new Error("Invalid indices: " + v + " does not index into " + n);
         for (var b = 0; b < i; b++) c ? f.values[m * i + b] += p[d * i + b] : f.values[m * i + b] = 0 === e.rank ? p[0] : p[d * i + b]
        }
        return f.toTensor().reshape(n)
       }, e
      }(Ci);
      Wt.registerBackend("cpu", (function() {
       return new Kh
      }), 1), y({
       kernelName: "Square",
       backendName: "cpu",
       kernelFunc: function(t) {
        var e = t.inputs,
         n = t.backend,
         r = e.x,
         i = n;
        Gh(r, "square");
        for (var o = i.data.get(r.dataId).values, a = new Float32Array(o.length), s = 0; s < o.length; ++s) {
         var u = o[s];
         a[s] = u * u
        }
        return {
         dataId: i.write(a, r.shape, r.dtype),
         shape: r.shape,
         dtype: r.dtype
        }
       }
      }), y({
       kernelName: "NonMaxSuppressionV5",
       backendName: "cpu",
       kernelFunc: function(t) {
        var e = t.inputs,
         n = t.backend,
         r = t.attrs,
         i = e,
         o = i.boxes,
         a = i.scores,
         s = r,
         u = s.maxOutputSize,
         c = s.iouThreshold,
         l = s.scoreThreshold,
         h = s.softNmsSigma,
         p = n;
        Gh(o, "NonMaxSuppressionWithScore");
        var f = Yi(p.data.get(o.dataId).values, p.data.get(a.dataId).values, u, c, l, h);
        return [f.selectedIndices, f.selectedScores]
       }
      }), y({
       kernelName: "Square",
       backendName: "webgl",
       kernelFunc: function(t) {
        var e = t.inputs,
         n = t.backend,
         r = e.x,
         i = n,
         o = new ks(r.shape, "return x * x;");
        return i.runWebGLProgram(o, [r], r.dtype)
       }
      });
      var Xh, Yh = function(t) {
        this.variableNames = ["A"];
        var e = lo(),
         n = t[0],
         r = t[1];
        this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + e.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "
       },
       Zh = function(t) {
        this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
        var e = lo(),
         n = t[0],
         r = t[1];
        this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + e.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e.output + " = result;\n      }\n    "
       };
      y({
       kernelName: "FromPixels",
       backendName: "webgl",
       kernelFunc: function(t) {
        var e = t.inputs,
         n = t.backend,
         r = t.attrs,
         i = e.pixels,
         o = r.numChannels,
         a = "undefined" != typeof HTMLVideoElement && i instanceof HTMLVideoElement,
         s = "undefined" != typeof HTMLImageElement && i instanceof HTMLImageElement,
         u = a ? [i.videoWidth, i.videoHeight] : [i.width, i.height],
         c = u[0],
         l = u[1],
         p = [l, c],
         f = [l, c, o];
        (s || a) && (null == Xh && (Xh = document.createElement("canvas").getContext("2d")), Xh.canvas.width = c, Xh.canvas.height = l, Xh.drawImage(i, 0, 0, c, l), i = Xh.canvas);
        var d = n.makeTensorInfo(p, "int32");
        n.texData.get(d.dataId).usage = $t.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), i);
        var v = h().getBool("WEBGL_PACK") ? new Zh(f) : new Yh(f),
         m = n.runWebGLProgram(v, [d], "int32");
        return n.disposeData(d.dataId), m
       }
      }), y({
       kernelName: "NonMaxSuppressionV5",
       backendName: "webgl",
       kernelFunc: function(t) {
        var e = t.inputs,
         n = t.backend,
         r = t.attrs;
        mn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        var i = e,
         o = i.boxes,
         a = i.scores,
         s = r,
         u = s.maxOutputSize,
         c = s.iouThreshold,
         l = s.scoreThreshold,
         h = s.softNmsSigma,
         p = n,
         f = Yi(p.readSync(o.dataId), p.readSync(a.dataId), u, c, l, h);
        return [f.selectedIndices, f.selectedScores]
       }
      });
      var Jh = function() {
       function t() {}
       return t.prototype.fetch = function(t, e) {
        return fetch(t, e)
       }, t.prototype.now = function() {
        return performance.now()
       }, t.prototype.encode = function(t, e) {
        if ("utf-8" !== e && "utf8" !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e);
        return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t)
       }, t.prototype.decode = function(t, e) {
        return new TextDecoder(e).decode(t)
       }, t
      }();
      h().get("IS_BROWSER") && h().setPlatform("browser", new Jh);
      var Qh, tp = function() {
        return n(2)
       },
       ep = function() {
        function t() {
         this.util = n(3), this.textEncoder = new this.util.TextEncoder
        }
        return t.prototype.fetch = function(t, e) {
         return null != h().global.fetch ? h().global.fetch(t, e) : (null == Qh && (Qh = tp()), Qh(t, e))
        }, t.prototype.now = function() {
         var t = r.hrtime();
         return 1e3 * t[0] + t[1] / 1e6
        }, t.prototype.encode = function(t, e) {
         if ("utf-8" !== e && "utf8" !== e) throw new Error("Node built-in encoder only supports utf-8, but got " + e);
         return this.textEncoder.encode(t)
        }, t.prototype.decode = function(t, e) {
         return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t)
        }, t
       }();
      h().get("IS_NODE") && h().setPlatform("node", new ep);
      var np = {
        float32: 4,
        int32: 4,
        uint16: 2,
        uint8: 1,
        bool: 1
       },
       rp = 4;
 
      function ip(t, e) {
       for (var n = {}, r = 0, i = function(e) {
         var i = e.name,
          o = e.dtype,
          a = e.shape,
          s = T(a),
          u = void 0;
         if ("quantization" in e) {
          var c = e.quantization;
          if ("uint8" !== c.dtype && "uint16" !== c.dtype) throw new Error("Weight " + e.name + " has unknown quantization dtype " + c.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
          var l = np[c.dtype],
           h = t.slice(r, r + s * l),
           p = "uint8" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);
          if ("float32" === o) u = Float32Array.from(p, (function(t) {
           return t * c.scale + c.min
          }));
          else {
           if ("int32" !== o) throw new Error("Unsupported dtype in weight '" + i + "': " + o);
           u = Int32Array.from(p, (function(t) {
            return Math.round(t * c.scale + c.min)
           }))
          }
          r += s * l
         } else if ("string" === o) {
          var f = T(e.shape);
          u = [];
          for (var d = 0; d < f; d++) {
           var v = new Uint32Array(t.slice(r, r + rp))[0];
           r += rp;
           var m = new Uint8Array(t.slice(r, r + v));
           u.push(m), r += v
          }
         } else {
          var g = np[o];
          if (h = t.slice(r, r + s * g), "float32" === o) u = new Float32Array(h);
          else if ("int32" === o) u = new Int32Array(h);
          else {
           if ("bool" !== o) throw new Error("Unsupported dtype in weight '" + i + "': " + o);
           u = new Uint8Array(h)
          }
          r += s * g
         }
         n[i] = Mn(u, a, o)
        }, o = 0, a = e; o < a.length; o++) i(a[o]);
       return n
      }
 
      function op(t) {
       if (null === t) throw new Error("Invalid input value: " + JSON.stringify(t));
       var e = 0,
        n = [];
       t.forEach((function(t) {
        if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t.constructor.name)
       }));
       var r = new Uint8Array(e),
        i = 0;
       return n.forEach((function(t) {
        r.set(new Uint8Array(t.buffer), i), i += t.byteLength
       })), r.buffer
      }
      var ap = "undefined" != typeof i && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
 
      function sp(t) {
       return ap ? i.byteLength(t) : new Blob([t]).size
      }
 
      function up(t) {
       var e = 0;
       t.forEach((function(t) {
        e += t.byteLength
       }));
       var n = new Uint8Array(e),
        r = 0;
       return t.forEach((function(t) {
        n.set(new Uint8Array(t), r), r += t.byteLength
       })), n.buffer
      }
 
      function cp(t) {
       for (t = t.trim(); t.endsWith("/");) t = t.slice(0, t.length - 1);
       var e = t.split("/");
       return e[e.length - 1]
      }
 
      function lp(t) {
       if (t.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
       return {
        dateSaved: new Date,
        modelTopologyType: "JSON",
        modelTopologyBytes: null == t.modelTopology ? 0 : sp(JSON.stringify(t.modelTopology)),
        weightSpecsBytes: null == t.weightSpecs ? 0 : sp(JSON.stringify(t.weightSpecs)),
        weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength
       }
      }
      var hp = function() {
        function t() {
         this.saveRouters = [], this.loadRouters = []
        }
        return t.getInstance = function() {
         return null == t.instance && (t.instance = new t), t.instance
        }, t.registerSaveRouter = function(e) {
         t.getInstance().saveRouters.push(e)
        }, t.registerLoadRouter = function(e) {
         t.getInstance().loadRouters.push(e)
        }, t.getSaveHandlers = function(e) {
         return t.getHandlers(e, "save")
        }, t.getLoadHandlers = function(e, n) {
         return t.getHandlers(e, "load", n)
        }, t.getHandlers = function(e, n, r) {
         var i = [];
         return ("load" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach((function(t) {
          var n = t(e, r);
          null !== n && i.push(n)
         })), i
        }, t
       }(),
       pp = "://",
       fp = function() {
        function t() {
         this.managers = {}
        }
        return t.getInstance = function() {
         return null == t.instance && (t.instance = new t), t.instance
        }, t.registerManager = function(e, n) {
         O(null != e, (function() {
          return "scheme must not be undefined or null."
         })), e.endsWith(pp) && (e = e.slice(0, e.indexOf(pp))), O(e.length > 0, (function() {
          return "scheme must not be an empty string."
         }));
         var r = t.getInstance();
         O(null == r.managers[e], (function() {
          return "A model store manager is already registered for scheme '" + e + "'."
         })), r.managers[e] = n
        }, t.getManager = function(t) {
         var e = this.getInstance().managers[t];
         if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'");
         return e
        }, t.getSchemes = function() {
         return Object.keys(this.getInstance().managers)
        }, t
       }();
 
      function dp(t) {
       if (-1 === t.indexOf(pp)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + fp.getSchemes().join(","));
       return {
        scheme: t.split(pp)[0],
        path: t.split(pp)[1]
       }
      }
 
      function vp(t, e, n) {
       return void 0 === n && (n = !1), s(this, void 0, void 0, (function() {
        var r, i, o, a, s, c, l, h, p;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return O(t !== e, (function() {
            return "Old path and new path are the same: '" + t + "'"
           })), O((r = hp.getLoadHandlers(t)).length > 0, (function() {
            return "Copying failed because no load handler is found for source URL " + t + "."
           })), O(r.length < 2, (function() {
            return "Copying failed because more than one (" + r.length + ") load handlers for source URL " + t + "."
           })), i = r[0], O((o = hp.getSaveHandlers(e)).length > 0, (function() {
            return "Copying failed because no save handler is found for destination URL " + e + "."
           })), O(o.length < 2, (function() {
            return "Copying failed because more than one (" + r.length + ") save handlers for destination URL " + e + "."
           })), a = o[0], s = dp(t).scheme, c = dp(t).path, l = s === dp(t).scheme, [4, i.load()];
          case 1:
           return h = u.sent(), n && l ? [4, fp.getManager(s).removeModel(c)] : [3, 3];
          case 2:
           u.sent(), u.label = 3;
          case 3:
           return [4, a.save(h)];
          case 4:
           return p = u.sent(), !n || l ? [3, 6] : [4, fp.getManager(s).removeModel(c)];
          case 5:
           u.sent(), u.label = 6;
          case 6:
           return [2, p.modelArtifactsInfo]
         }
        }))
       }))
      }
      var mp = "models_store",
       gp = "model_info_store";
 
      function yp() {
       if (!h().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
       var t = window,
        e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
       if (null == e) throw new Error("The current browser does not appear to support IndexedDB.");
       return e
      }
 
      function bp(t) {
       var e = t.result;
       e.createObjectStore(mp, {
        keyPath: "modelPath"
       }), e.createObjectStore(gp, {
        keyPath: "modelPath"
       })
      }
      var xp = function() {
        function t(t) {
         if (this.indexedDB = yp(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
         this.modelPath = t
        }
        return t.prototype.save = function(t) {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(e) {
           if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
           return [2, this.databaseAction(this.modelPath, t)]
          }))
         }))
        }, t.prototype.load = function() {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(t) {
           return [2, this.databaseAction(this.modelPath)]
          }))
         }))
        }, t.prototype.databaseAction = function(t, e) {
         var n = this;
         return new Promise((function(t, r) {
          var i = n.indexedDB.open("tensorflowjs", 1);
          i.onupgradeneeded = function() {
           return bp(i)
          }, i.onsuccess = function() {
           var o = i.result;
           if (null == e) {
            var a = o.transaction(mp, "readonly"),
             s = a.objectStore(mp).get(n.modelPath);
            s.onsuccess = function() {
             if (null == s.result) return o.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
             t(s.result.modelArtifacts)
            }, s.onerror = function(t) {
             return o.close(), r(s.error)
            }, a.oncomplete = function() {
             return o.close()
            }
           } else {
            var u, c = lp(e),
             l = o.transaction(gp, "readwrite"),
             h = l.objectStore(gp),
             p = h.put({
              modelPath: n.modelPath,
              modelArtifactsInfo: c
             });
            p.onsuccess = function() {
             var i = (u = o.transaction(mp, "readwrite")).objectStore(mp).put({
              modelPath: n.modelPath,
              modelArtifacts: e,
              modelArtifactsInfo: c
             });
             i.onsuccess = function() {
              return t({
               modelArtifactsInfo: c
              })
             }, i.onerror = function(t) {
              var e = (h = l.objectStore(gp)).delete(n.modelPath);
              e.onsuccess = function() {
               return o.close(), r(i.error)
              }, e.onerror = function(t) {
               return o.close(), r(i.error)
              }
             }
            }, p.onerror = function(t) {
             return o.close(), r(p.error)
            }, l.oncomplete = function() {
             null == u ? o.close() : u.oncomplete = function() {
              return o.close()
             }
            }
           }
          }, i.onerror = function(t) {
           return r(i.error)
          }
         }))
        }, t.URL_SCHEME = "indexeddb://", t
       }(),
       wp = function(t) {
        return h().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(xp.URL_SCHEME) ? (e = t.slice(xp.URL_SCHEME.length), new xp(e)) : null;
        var e
       };
      hp.registerSaveRouter(wp), hp.registerLoadRouter(wp);
      var Cp = function() {
       function t() {
        this.indexedDB = yp()
       }
       return t.prototype.listModels = function() {
        return s(this, void 0, void 0, (function() {
         var t = this;
         return u(this, (function(e) {
          return [2, new Promise((function(e, n) {
           var r = t.indexedDB.open("tensorflowjs", 1);
           r.onupgradeneeded = function() {
            return bp(r)
           }, r.onsuccess = function() {
            var t = r.result,
             i = t.transaction(gp, "readonly"),
             o = i.objectStore(gp).getAll();
            o.onsuccess = function() {
             for (var t = {}, n = 0, r = o.result; n < r.length; n++) {
              var i = r[n];
              t[i.modelPath] = i.modelArtifactsInfo
             }
             e(t)
            }, o.onerror = function(e) {
             return t.close(), n(o.error)
            }, i.oncomplete = function() {
             return t.close()
            }
           }, r.onerror = function(t) {
            return n(r.error)
           }
          }))]
         }))
        }))
       }, t.prototype.removeModel = function(t) {
        return s(this, void 0, void 0, (function() {
         var e = this;
         return u(this, (function(n) {
          var r;
          return t = (r = t).startsWith(xp.URL_SCHEME) ? r.slice(xp.URL_SCHEME.length) : r, [2, new Promise((function(n, r) {
           var i = e.indexedDB.open("tensorflowjs", 1);
           i.onupgradeneeded = function() {
            return bp(i)
           }, i.onsuccess = function() {
            var e, o = i.result,
             a = o.transaction(gp, "readwrite"),
             s = a.objectStore(gp),
             u = s.get(t);
            u.onsuccess = function() {
             if (null == u.result) return o.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));
             var i = s.delete(t),
              a = function() {
               var i = (e = o.transaction(mp, "readwrite")).objectStore(mp).delete(t);
               i.onsuccess = function() {
                return n(u.result.modelArtifactsInfo)
               }, i.onerror = function(t) {
                return r(u.error)
               }
              };
             i.onsuccess = a, i.onerror = function(t) {
              return a(), o.close(), r(u.error)
             }
            }, u.onerror = function(t) {
             return o.close(), r(u.error)
            }, a.oncomplete = function() {
             null == e ? o.close() : e.oncomplete = function() {
              return o.close()
             }
            }
           }, i.onerror = function(t) {
            return r(i.error)
           }
          }))]
         }))
        }))
       }, t
      }();
      if (h().getBool("IS_BROWSER")) try {
       fp.registerManager(xp.URL_SCHEME, new Cp)
      } catch (o) {}
      var Sp = "/",
       Ep = "tensorflowjs_models",
       kp = "info",
       Ip = "model_topology",
       Op = "weight_specs",
       Ap = "weight_data",
       Np = "model_metadata";
 
      function Rp(t) {
       return {
        info: [Ep, t, kp].join(Sp),
        topology: [Ep, t, Ip].join(Sp),
        weightSpecs: [Ep, t, Op].join(Sp),
        weightData: [Ep, t, Ap].join(Sp),
        modelMetadata: [Ep, t, Np].join(Sp)
       }
      }
 
      function Tp(t) {
       var e = t.split(Sp);
       if (e.length < 3) throw new Error("Invalid key format: " + t);
       return e.slice(1, e.length - 1).join(Sp)
      }
      var _p = function() {
        function t(t) {
         if (!h().getBool("IS_BROWSER") || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
         if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
         this.modelPath = t, this.keys = Rp(this.modelPath)
        }
        return t.prototype.save = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n, r;
          return u(this, (function(o) {
           if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
           e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), r = lp(t);
           try {
            return this.LS.setItem(this.keys.info, JSON.stringify(r)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function(t) {
             if (ap) return i.from(t).toString("base64");
             for (var e = new Uint8Array(t), n = "", r = 0, o = e.length; r < o; r++) n += String.fromCharCode(e[r]);
             return btoa(n)
            }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
             format: t.format,
             generatedBy: t.generatedBy,
             convertedBy: t.convertedBy,
             userDefinedMetadata: t.userDefinedMetadata
            })), [2, {
             modelArtifactsInfo: r
            }]
           } catch (t) {
            throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + r.modelTopologyBytes + ", weightSpecsBytes=" + r.weightSpecsBytes + ", weightDataBytes=" + r.weightDataBytes + ".")
           }
           return [2]
          }))
         }))
        }, t.prototype.load = function() {
         return s(this, void 0, void 0, (function() {
          var t, e, n, r, o, a, s;
          return u(this, (function(u) {
           if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
           if ("JSON" !== t.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
           if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
           if (e.modelTopology = n, null == (r = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
           if (e.weightSpecs = r, null != (o = this.LS.getItem(this.keys.modelMetadata)) && (a = JSON.parse(o), e.format = a.format, e.generatedBy = a.generatedBy, e.convertedBy = a.convertedBy, e.userDefinedMetadata = a.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
           return e.weightData = function(t) {
            if (ap) {
             var e = i.from(t, "base64");
             return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
            }
            for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o);
            return r.buffer
           }(s), [2, e]
          }))
         }))
        }, t.URL_SCHEME = "localstorage://", t
       }(),
       Dp = function(t) {
        return h().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(_p.URL_SCHEME) ? (e = t.slice(_p.URL_SCHEME.length), new _p(e)) : null;
        var e
       };
      hp.registerSaveRouter(Dp), hp.registerLoadRouter(Dp);
      var Fp = function() {
       function t() {
        O(h().getBool("IS_BROWSER"), (function() {
         return "Current environment is not a web browser"
        })), O(void 0 !== window.localStorage, (function() {
         return "Current browser does not appear to support localStorage"
        })), this.LS = window.localStorage
       }
       return t.prototype.listModels = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, i, o;
         return u(this, (function(a) {
          for (t = {}, e = Ep + Sp, n = Sp + kp, r = 0; r < this.LS.length; ++r)(i = this.LS.key(r)).startsWith(e) && i.endsWith(n) && (o = Tp(i), t[o] = JSON.parse(this.LS.getItem(i)));
          return [2, t]
         }))
        }))
       }, t.prototype.removeModel = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n;
         return u(this, (function(r) {
          var i;
          if (t = (i = t).startsWith(_p.URL_SCHEME) ? i.slice(_p.URL_SCHEME.length) : i, e = Rp(t), null == this.LS.getItem(e.info)) throw new Error("Cannot find model at path '" + t + "'");
          return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n]
         }))
        }))
       }, t
      }();
      if (h().getBool("IS_BROWSER")) try {
       fp.registerManager(_p.URL_SCHEME, new Fp)
      } catch (o) {}
      var Mp = "model",
       Lp = ".json",
       Bp = ".weights.bin";
 
      function Pp(t) {
       return new Promise((function(t) {
        return setTimeout(t)
       })).then(t)
      }
      var zp = function() {
        function t(e) {
         if (!h().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
         e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = Mp), this.modelTopologyFileName = e + Lp, this.weightDataFileName = e + Bp
        }
        return t.prototype.save = function(t) {
         return s(this, void 0, void 0, (function() {
          var e, n, r, i, o, a;
          return u(this, (function(s) {
           switch (s.label) {
            case 0:
             if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
             if (e = window.URL.createObjectURL(new Blob([t.weightData], {
               type: "application/octet-stream"
              })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];
             throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
            case 1:
             return n = [{
              paths: ["./" + this.weightDataFileName],
              weights: t.weightSpecs
             }], r = {
              modelTopology: t.modelTopology,
              format: t.format,
              generatedBy: t.generatedBy,
              convertedBy: t.convertedBy,
              weightsManifest: n
             }, i = window.URL.createObjectURL(new Blob([JSON.stringify(r)], {
              type: "application/json"
             })), (o = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, o.href = i, [4, Pp((function() {
              return o.dispatchEvent(new MouseEvent("click"))
             }))];
            case 2:
             return s.sent(), null == t.weightData ? [3, 4] : ((a = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, a.href = e, [4, Pp((function() {
              return a.dispatchEvent(new MouseEvent("click"))
             }))]);
            case 3:
             s.sent(), s.label = 4;
            case 4:
             return [2, {
              modelArtifactsInfo: lp(t)
             }]
           }
          }))
         }))
        }, t.URL_SCHEME = "downloads://", t
       }(),
       jp = function() {
        function t(t) {
         if (null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t);
         this.files = t
        }
        return t.prototype.load = function() {
         return s(this, void 0, void 0, (function() {
          var t, e, n = this;
          return u(this, (function(r) {
           return t = this.files[0], e = this.files.slice(1), [2, new Promise((function(r, i) {
            var o = new FileReader;
            o.onload = function(o) {
             var a = JSON.parse(o.target.result),
              s = a.modelTopology;
             if (null != s) {
              0 === e.length && r({
               modelTopology: s
              });
              var u = a.weightsManifest;
              if (null != u) {
               var c;
               try {
                c = n.checkManifestAndWeightFiles(u, e)
               } catch (t) {
                return void i(t)
               }
               var l = [],
                h = [],
                p = [];
               u.forEach((function(t) {
                t.paths.forEach((function(t) {
                 h.push(t), p.push(null)
                })), l.push.apply(l, t.weights)
               })), u.forEach((function(t) {
                t.paths.forEach((function(t) {
                 var e = new FileReader;
                 e.onload = function(e) {
                  var n = e.target.result,
                   i = h.indexOf(t);
                  p[i] = n, -1 === p.indexOf(null) && r({
                   modelTopology: s,
                   weightSpecs: l,
                   weightData: up(p),
                   format: a.format,
                   generatedBy: a.generatedBy,
                   convertedBy: a.convertedBy,
                   userDefinedMetadata: a.userDefinedMetadata
                  })
                 }, e.onerror = function(e) {
                  return i("Failed to weights data from file of path '" + t + "'.")
                 }, e.readAsArrayBuffer(c[t])
                }))
               }))
              } else i(new Error("weightManifest field is missing from file " + t.name))
             } else i(new Error("modelTopology field is missing from file " + t.name))
            }, o.onerror = function(e) {
             return i("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")
            }, o.readAsText(t)
           }))]
          }))
         }))
        }, t.prototype.checkManifestAndWeightFiles = function(t, e) {
         for (var n = [], r = e.map((function(t) {
           return cp(t.name)
          })), i = {}, o = 0, a = t; o < a.length; o++) a[o].paths.forEach((function(t) {
          var o = cp(t);
          if (-1 !== n.indexOf(o)) throw new Error("Duplicate file basename found in weights manifest: '" + o + "'");
          if (n.push(o), -1 === r.indexOf(o)) throw new Error("Weight file with basename '" + o + "' is not provided.");
          i[t] = e[r.indexOf(o)]
         }));
         if (n.length !== e.length) throw new Error("Mismatch in the number of files in weights manifest (" + n.length + ") and the number of weight files provided (" + e.length + ").");
         return i
        }, t
       }();
 
      function Wp(t, e, n, r) {
       ! function(t) {
        O(null != t && Array.isArray(t) && t.length > 0, (function() {
         return "promises must be a none empty array"
        }))
       }(t),
       function(t, e) {
        O(t >= 0 && t <= 1, (function() {
         return "Progress fraction must be in range [0, 1], but got startFraction " + t
        })), O(e >= 0 && e <= 1, (function() {
         return "Progress fraction must be in range [0, 1], but got endFraction " + e
        })), O(e >= t, (function() {
         return "startFraction must be no more than endFraction, but got startFraction " + t + " and endFraction " + e
        }))
       }(n = null == n ? 0 : n, r = null == r ? 1 : r);
       var i = 0;
       return Promise.all(t.map((function(o) {
        return o.then((function(o) {
         var a = n + ++i / t.length * (r - n);
         return e(a), o
        })), o
       })))
      }
 
      function Vp(t, e) {
       return s(this, void 0, void 0, (function() {
        var n, r, i, o, a, s, c, l, p;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return null == e && (e = {}), n = null == e.fetchFunc ? h().platform.fetch : e.fetchFunc, r = t.map((function(t) {
            return n(t, e.requestInit, {
             isBinary: !0
            })
           })), i = 0, o = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(r)];
          case 1:
           return a = u.sent(), [3, 4];
          case 2:
           return [4, Wp(r, e.onProgress, i, o)];
          case 3:
           a = u.sent(), u.label = 4;
          case 4:
           return s = a.map((function(t) {
            return t.arrayBuffer()
           })), c = .5, l = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(s)];
          case 5:
           return p = u.sent(), [3, 8];
          case 6:
           return [4, Wp(s, e.onProgress, c, l)];
          case 7:
           p = u.sent(), u.label = 8;
          case 8:
           return [2, p]
         }
        }))
       }))
      }
 
      function Up(t) {
       var e = this;
       return function(n, r, i) {
        return void 0 === r && (r = ""), s(e, void 0, void 0, (function() {
         var e, o, a, s, c, l, h, p, f, d;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            if (e = n.map((function() {
              return !1
             })), o = {}, a = null != i ? i.map((function() {
              return !1
             })) : [], s = [], n.forEach((function(t, n) {
              var r = 0;
              t.weights.forEach((function(t) {
               var u = "quantization" in t ? t.quantization.dtype : t.dtype,
                c = np[u] * T(t.shape),
                l = function() {
                 e[n] = !0, null == o[n] && (o[n] = []), o[n].push({
                  manifestEntry: t,
                  groupOffset: r,
                  sizeBytes: c
                 })
                };
               null != i ? i.forEach((function(e, n) {
                e === t.name && (l(), a[n] = !0)
               })) : l(), s.push(t.name), r += c
              }))
             })), !a.every((function(t) {
              return t
             }))) throw c = i.filter((function(t, e) {
             return !a[e]
            })), new Error("Could not find weights in manifest with names: " + c.join(", ") + ". \nManifest JSON has weights with names: " + s.join(", ") + ".");
            return l = e.reduce((function(t, e, n) {
             return e && t.push(n), t
            }), []), h = [], l.forEach((function(t) {
             n[t].paths.forEach((function(t) {
              var e = r + (r.endsWith("/") ? "" : "/") + t;
              h.push(e)
             }))
            })), [4, t(h)];
           case 1:
            return p = u.sent(), f = {}, d = 0, l.forEach((function(t) {
             for (var e = n[t].paths.length, r = 0, i = 0; i < e; i++) r += p[d + i].byteLength;
             for (var a = new ArrayBuffer(r), s = new Uint8Array(a), u = 0, c = 0; c < e; c++) {
              var l = new Uint8Array(p[d + c]);
              s.set(l, u), u += l.byteLength
             }
             o[t].forEach((function(t) {
              var e = ip(a.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);
              for (var n in e) f[n] = e[n]
             })), d += e
            })), [2, f]
          }
         }))
        }))
       }
      }
      hp.registerSaveRouter((function(t) {
       return h().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(zp.URL_SCHEME) ? function(t) {
        return void 0 === t && (t = "model"), new zp(t)
       }(t.slice(zp.URL_SCHEME.length)) : null
      }));
      var Hp = function() {
       function t(t, e) {
        if (this.DEFAULT_METHOD = "POST", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (O("function" == typeof e.fetchFunc, (function() {
          return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"
         })), this.fetch = e.fetchFunc) : this.fetch = h().platform.fetch, O(null != t && t.length > 0, (function() {
          return "URL path for http must not be null, undefined or empty."
         })), Array.isArray(t) && O(2 === t.length, (function() {
          return "URL paths for http must have a length of 2, (actual length is " + t.length + ")."
         })), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        this.requestInit = e.requestInit || {}
       }
       return t.prototype.save = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r, i;
         return u(this, (function(o) {
          switch (o.label) {
           case 0:
            if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (e = Object.assign({
             method: this.DEFAULT_METHOD
            }, this.requestInit)).body = new FormData, n = [{
             paths: ["./model.weights.bin"],
             weights: t.weightSpecs
            }], r = {
             modelTopology: t.modelTopology,
             format: t.format,
             generatedBy: t.generatedBy,
             convertedBy: t.convertedBy,
             userDefinedMetadata: t.userDefinedMetadata,
             weightsManifest: n
            }, e.body.append("model.json", new Blob([JSON.stringify(r)], {
             type: "application/json"
            }), "model.json"), null != t.weightData && e.body.append("model.weights.bin", new Blob([t.weightData], {
             type: "application/octet-stream"
            }), "model.weights.bin"), [4, this.fetch(this.path, e)];
           case 1:
            if ((i = o.sent()).ok) return [2, {
             modelArtifactsInfo: lp(t),
             responses: [i]
            }];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + i.status + ".")
          }
         }))
        }))
       }, t.prototype.load = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, i, o, a, s, c, l, h, p;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return [4, this.fetch(this.path, this.requestInit)];
           case 1:
            if (!(t = u.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
            u.label = 2;
           case 2:
            return u.trys.push([2, 4, , 5]), [4, t.json()];
           case 3:
            return e = u.sent(), [3, 5];
           case 4:
            throw u.sent(), n = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n += " Please make sure the server is serving valid JSON for this request.", new Error(n);
           case 5:
            if (r = e.modelTopology, i = e.weightsManifest, o = e.generatedBy, a = e.convertedBy, s = e.format, c = e.userDefinedMetadata, null == r && null == i) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return null == i ? [3, 7] : [4, this.loadWeights(i)];
           case 6:
            p = u.sent(), l = p[0], h = p[1], u.label = 7;
           case 7:
            return [2, {
             modelTopology: r,
             weightSpecs: l,
             weightData: h,
             userDefinedMetadata: c,
             generatedBy: o,
             convertedBy: a,
             format: s
            }]
          }
         }))
        }))
       }, t.prototype.loadWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r, i, o, a, s, c, l, h, p;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function(t) {
              var e = t.lastIndexOf("/"),
               n = t.lastIndexOf("?"),
               r = t.substring(0, e),
               i = n > e ? t.substring(n) : "";
              return [r + "/", i]
             }(e), r = n[0], i = n[1], o = this.weightPathPrefix || r, a = [], s = 0, c = t; s < c.length; s++) l = c[s], a.push.apply(a, l.weights);
            return h = [], t.forEach((function(t) {
             t.paths.forEach((function(t) {
              h.push(o + t + i)
             }))
            })), [4, Vp(h, {
             requestInit: this.requestInit,
             fetchFunc: this.fetch,
             onProgress: this.onProgress
            })];
           case 1:
            return p = u.sent(), [2, [a, up(p)]]
          }
         }))
        }))
       }, t.URL_SCHEME_REGEX = /^https?:\/\//, t
      }();
 
      function $p(t) {
       return null != t.match(Hp.URL_SCHEME_REGEX)
      }
      var Gp = function(t, e) {
       return "undefined" == typeof fetch ? null : (Array.isArray(t) ? t.every((function(t) {
        return $p(t)
       })) : $p(t)) ? qp(t, {
        onProgress: e
       }) : null
      };
 
      function qp(t, e) {
       return new Hp(t, e)
      }
      hp.registerSaveRouter(Gp), hp.registerLoadRouter(Gp);
      var Kp, Xp = function() {
        function t(t) {
         this.modelArtifacts = t
        }
        return t.prototype.load = function() {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(t) {
           return [2, this.modelArtifacts]
          }))
         }))
        }, t
       }(),
       Yp = function() {
        function t(t) {
         this.saveHandler = t
        }
        return t.prototype.save = function(t) {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(e) {
           return [2, this.saveHandler(t)]
          }))
         }))
        }, t
       }(),
       Zp = Object.freeze({
        browserFiles: function(t) {
         return new jp(t)
        },
        browserHTTPRequest: function(t, e) {
         return qp(t, e)
        },
        concatenateArrayBuffers: up,
        decodeWeights: ip,
        encodeWeights: function(t, e) {
         return s(this, void 0, void 0, (function() {
          var n, r, i, o, a, c = this;
          return u(this, (function(l) {
           switch (l.label) {
            case 0:
             for (n = [], r = [], i = Array.isArray(t) ? t.map((function(t) {
               return t.name
              })) : Object.keys(t), o = function(o) {
               var a = i[o],
                l = Array.isArray(t) ? t[o].tensor : t[a];
               if ("float32" !== l.dtype && "int32" !== l.dtype && "bool" !== l.dtype && "string" !== l.dtype) throw new Error("Unsupported dtype in weight '" + a + "': " + l.dtype);
               var h = {
                name: a,
                shape: l.shape,
                dtype: l.dtype
               };
               if ("string" === l.dtype) {
                var p = new Promise((function(t) {
                 return s(c, void 0, void 0, (function() {
                  var e, n, r, i, o, a, s;
                  return u(this, (function(u) {
                   switch (u.label) {
                    case 0:
                     return [4, l.bytes()];
                    case 1:
                     for (e = u.sent(), n = e.reduce((function(t, e) {
                       return t + e.length
                      }), 0) + rp * e.length, r = new Uint8Array(n), i = 0, o = 0; o < e.length; o++) a = e[o], s = new Uint8Array(new Uint32Array([a.length]).buffer), r.set(s, i), i += rp, r.set(a, i), i += a.length;
                     return t(r), [2]
                   }
                  }))
                 }))
                }));
                r.push(p)
               } else r.push(l.data());
               null != e && (h.group = e), n.push(h)
              }, a = 0; a < i.length; ++a) o(a);
             return [4, Promise.all(r)];
            case 1:
             return [2, {
              data: op(l.sent()),
              specs: n
             }]
           }
          }))
         }))
        },
        fromMemory: function(t, e, n, r) {
         return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new Xp(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Xp({
          modelTopology: t
         })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Xp({
          modelTopology: t,
          weightSpecs: e,
          weightData: n,
          trainingConfig: r
         }))
        },
        getLoadHandlers: function(t, e) {
         return hp.getLoadHandlers(t, e)
        },
        getModelArtifactsInfoForJSON: lp,
        getSaveHandlers: function(t) {
         return hp.getSaveHandlers(t)
        },
        http: qp,
        isHTTPScheme: $p,
        loadWeights: function(t, e, n, r) {
         return void 0 === e && (e = ""), s(this, void 0, void 0, (function() {
          return u(this, (function(i) {
           return [2, Up((function(t) {
            return Vp(t, {
             requestInit: r
            })
           }))(t, e, n)]
          }))
         }))
        },
        registerLoadRouter: function(t) {
         return hp.registerLoadRouter(t)
        },
        registerSaveRouter: function(t) {
         return hp.registerSaveRouter(t)
        },
        weightsLoaderFactory: Up,
        withSaveHandler: function(t) {
         return new Yp(t)
        },
        copyModel: function(t, e) {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(n) {
           return [2, vp(t, e, !1)]
          }))
         }))
        },
        listModels: function() {
         return s(this, void 0, void 0, (function() {
          var t, e, n, r, i, o, a;
          return u(this, (function(s) {
           switch (s.label) {
            case 0:
             t = fp.getSchemes(), e = {}, n = 0, r = t, s.label = 1;
            case 1:
             return n < r.length ? (i = r[n], [4, fp.getManager(i).listModels()]) : [3, 4];
            case 2:
             for (a in o = s.sent()) e[i + pp + a] = o[a];
             s.label = 3;
            case 3:
             return n++, [3, 1];
            case 4:
             return [2, e]
           }
          }))
         }))
        },
        moveModel: function(t, e) {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(n) {
           return [2, vp(t, e, !0)]
          }))
         }))
        },
        removeModel: function(t) {
         return s(this, void 0, void 0, (function() {
          var e;
          return u(this, (function(n) {
           return e = dp(t), [2, fp.getManager(e.scheme).removeModel(e.path)]
          }))
         }))
        }
       }),
       Jp = Tn({
        confusionMatrix_: function(t, e, n) {
         var r = bn(t, "labels", "confusionMatrix"),
          i = bn(e, "predictions", "confusionMatrix");
         O(null == n || n > 0 && Number.isInteger(n), (function() {
          return "If provided, numClasses must be a positive integer, but got " + n
         })), O(1 === r.rank, (function() {
          return "Expected the rank of labels to be 1, but got " + r.rank
         })), O(1 === i.rank, (function() {
          return "Expected the rank of predictions to be 1, but got " + i.rank
         })), O(r.shape[0] === i.shape[0], (function() {
          return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + i.shape[0] + ". Labels and predictions should have the same number of elements."
         })), O(n > 0 && Number.isInteger(n), (function() {
          return "numClasses is required to be a positive integer, but got " + n
         }));
         var o = Or(r.asType("int32"), n),
          a = Or(i.asType("int32"), n);
         return o.transpose().matMul(a).asType("int32")
        }
       }),
       Qp = Object.freeze({
        confusionMatrix: Jp
       }),
       tf = Tn({
        fromPixels_: function(t, e) {
         if (void 0 === e && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
         if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
         var n = !1,
          r = !1,
          i = !1,
          o = !1,
          a = !1;
         if (t.data instanceof Uint8Array) n = !0;
         else if ("undefined" != typeof ImageData && t instanceof ImageData) r = !0;
         else if ("undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) i = !0;
         else if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) o = !0;
         else {
          if (null == t.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
          a = !0
         }
         if (i && i && t.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
         if (null != v("FromPixels", Wt.backendName)) return Wt.runKernel("FromPixels", {
          pixels: t
         }, {
          numChannels: e
         });
         var s, u, c = i ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
          l = c[0],
          h = c[1];
         if (a ? s = t.getContext("2d").getImageData(0, 0, l, h).data : r || n ? s = t.data : (o || i) && (null == Kp && (Kp = document.createElement("canvas").getContext("2d")), Kp.canvas.width = l, Kp.canvas.height = h, Kp.drawImage(t, 0, 0, l, h), s = Kp.getImageData(0, 0, l, h).data), 4 === e) u = new Int32Array(s);
         else {
          var p = l * h;
          u = new Int32Array(p * e);
          for (var f = 0; f < p; f++)
           for (var d = 0; d < e; ++d) u[f * e + d] = s[4 * f + d]
         }
         return jn(u, [h, l, e], "int32")
        }
       }),
       ef = Object.freeze({
        toPixels: function(t, e) {
         return s(this, void 0, void 0, (function() {
          var n, r, i, o, a, s, c, l, h, p, f, d, v, m, g, y, b, x, w, C, S, E, k;
          return u(this, (function(u) {
           switch (u.label) {
            case 0:
             if (n = bn(t, "img", "toPixels"), t instanceof Et || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n.rank + ".");
             if (r = n.shape.slice(0, 2), i = r[0], o = r[1], (a = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === a) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + a);
             return [4, n.data()];
            case 1:
             return s = u.sent(), c = n.min(), l = n.max(), [4, Promise.all([c.data(), l.data()])];
            case 2:
             if (h = u.sent(), p = h[0], f = h[1], d = p[0], v = f[0], c.dispose(), l.dispose(), "float32" === n.dtype) {
              if (d < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d + " - " + v + "].")
             } else {
              if ("int32" !== n.dtype) throw new Error("Unsupported type for toPixels: " + n.dtype + ". Please use float32 or int32 tensors.");
              if (d < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d + " - " + v + "].")
             }
             for (m = "float32" === n.dtype ? 255 : 1, g = new Uint8ClampedArray(o * i * 4), y = 0; y < i * o; ++y) b = void 0, x = void 0, w = void 0, C = void 0, 1 === a ? (b = s[y] * m, x = s[y] * m, w = s[y] * m, C = 255) : 3 === a ? (b = s[3 * y] * m, x = s[3 * y + 1] * m, w = s[3 * y + 2] * m, C = 255) : 4 === a && (b = s[4 * y] * m, x = s[4 * y + 1] * m, w = s[4 * y + 2] * m, C = s[4 * y + 3] * m), g[0 + (S = 4 * y)] = Math.round(b), g[S + 1] = Math.round(x), g[S + 2] = Math.round(w), g[S + 3] = Math.round(C);
             return null != e && (e.width = o, e.height = i, E = e.getContext("2d"), k = new ImageData(g, o, i), E.putImageData(k, 0, 0)), n !== t && n.dispose(), [2, g]
           }
          }))
         }))
        },
        fromPixels: tf
       }),
       nf = function() {
        function t() {}
        return t.prototype.getClassName = function() {
         return this.constructor.className
        }, t.fromConfig = function(t, e) {
         return new t(e)
        }, t
       }(),
       rf = function() {
        function t() {
         this.classNameMap = {}
        }
        return t.getMap = function() {
         return null == t.instance && (t.instance = new t), t.instance
        }, t.register = function(e) {
         t.getMap().classNameMap[e.className] = [e, e.fromConfig]
        }, t
       }();
 
      function of (t) {
       O(null != t.className, (function() {
        return "Class being registered does not have the static className property defined."
       })), O("string" == typeof t.className, (function() {
        return "className is required to be a string, but got type " + typeof t.className
       })), O(t.className.length > 0, (function() {
        return "Class being registered has an empty-string as its className, which is disallowed."
       })), rf.register(t)
      }
      var af = Object.freeze({
        Serializable: nf,
        SerializationMap: rf,
        registerClass: of
       }),
       sf = .001,
       uf = .1;
 
      function cf() {
       return 32 === Wt.backend.floatPrecision() ? sf : uf
      }
 
      function lf(t, e, n) {
       var r = !0;
       if ((G(t) || G(e)) && (r = !1), G(t) && G(e) && (r = !0), r) {
        var i = t.constructor.name,
         o = e.constructor.name;
        if (i !== o) throw new Error("Arrays are of different type. Actual: " + i + ". Expected: " + o)
       }
       if (Array.isArray(t) && Array.isArray(e)) {
        var a = gn(t),
         s = gn(e);
        if (!_(a, s)) throw new Error("Arrays have different shapes. Actual: [" + a + "]. Expected: [" + s + "]")
       }
       var u = G(t) ? t : R(t),
        c = G(e) ? e : R(e);
       if (u.length !== c.length) throw new Error("Arrays have different lengths actual: " + u.length + " vs expected: " + c.length + ".\nActual:   " + u + ".\nExpected: " + c + ".");
       for (var l = 0; l < c.length; ++l) {
        var h = u[l],
         p = c[l];
        if (!n(h, p)) throw new Error("Arrays differ: actual[" + l + "] = " + h + ", expected[" + l + "] = " + p + ".\nActual:   " + u + ".\nExpected: " + c + ".")
       }
      }
 
      function hf(t, e, n) {
       return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n)
      }
      var pf = Object.freeze({
        TEST_EPSILON_FLOAT16: uf,
        expectArraysClose: function(t, e, n) {
         return null == n && (n = cf()), lf(t, e, (function(t, e) {
          return hf(t, e, n)
         }))
        },
        testEpsilon: cf,
        expectPromiseToFail: function(t, e) {
         t().then((function() {
          return e.fail()
         }), (function() {
          return e()
         }))
        },
        expectArraysEqual: function(t, e) {
         var n = "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? [e] : e;
         return X(t) || X(t[0]) || X(e) || X(e[0]) ? lf(t, n, (function(t, e) {
          return t == e
         })) : lf(t, e, (function(t, e) {
          return hf(t, e, 0)
         }))
        },
        expectNumbersClose: function(t, e, n) {
         if (null == n && (n = cf()), !hf(t, e, n)) throw new Error("Numbers differ: actual === " + t + ", expected === " + e)
        },
        expectValuesInRange: function(t, e, n) {
         for (var r = 0; r < t.length; r++)
          if (t[r] < e || t[r] > n) throw new Error("Value out of range:" + t[r] + " low: " + e + ", high: " + n)
        },
        expectArrayBuffersEqual: function(t, e) {
         expect(new Float32Array(t)).toEqual(new Float32Array(e))
        }
       }),
       ff = "1.5.2",
       df = Object.freeze({
        gpgpu_util: Pa,
        webgl_util: Ge,
        forceHalfFloat: function() {
         h().set("WEBGL_FORCE_F16_TEXTURES", !0)
        },
        MathBackendWebGL: nu,
        setWebGLContext: Xt,
        GPGPUContext: za
       }),
       vf = function(t) {
        function e() {
         return null !== t && t.apply(this, arguments) || this
        }
        return a(e, t), e.prototype.minimize = function(t, e, n) {
         void 0 === e && (e = !1);
         var r = this.computeGradients(t, n),
          i = r.value,
          o = r.grads;
         if (null != n) {
          var a = n.map((function(t) {
           return {
            name: t.name,
            tensor: o[t.name]
           }
          }));
          this.applyGradients(a)
         } else this.applyGradients(o);
         return rn(o), e ? i : (i.dispose(), null)
        }, Object.defineProperty(e.prototype, "iterations", {
         get: function() {
          return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
         },
         enumerable: !0,
         configurable: !0
        }), e.prototype.incrementIterations = function() {
         this.iterations_ = this.iterations + 1
        }, e.prototype.computeGradients = function(t, e) {
         return mi(t, e)
        }, e.prototype.dispose = function() {
         null != this.iterations_ && rn(this.iterations_)
        }, e.prototype.saveIterations = function() {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(t) {
           return null == this.iterations_ && (this.iterations_ = 0), [2, {
            name: "iter",
            tensor: Bn(this.iterations_, "int32")
           }]
          }))
         }))
        }, e.prototype.getWeights = function() {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(t) {
           throw new Error("getWeights() is not implemented for this optimizer yet.")
          }))
         }))
        }, e.prototype.setWeights = function(t) {
         return s(this, void 0, void 0, (function() {
          return u(this, (function(t) {
           throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName())
          }))
         }))
        }, e.prototype.extractIterations = function(t) {
         return s(this, void 0, void 0, (function() {
          var e;
          return u(this, (function(n) {
           switch (n.label) {
            case 0:
             return e = this, [4, t[0].tensor.data()];
            case 1:
             return e.iterations_ = n.sent()[0], [2, t.slice(1)]
           }
          }))
         }))
        }, e
       }(nf);
      Object.defineProperty(vf, Symbol.hasInstance, {
       value: function(t) {
        return null != t.minimize && null != t.computeGradients && null != t.applyGradients
       }
      });
      var mf = function(t) {
       function e(e, n, r) {
        void 0 === r && (r = null);
        var i = t.call(this) || this;
        return i.learningRate = e, i.rho = n, i.epsilon = r, i.accumulatedGrads = [], i.accumulatedUpdates = [], null == r && (i.epsilon = Wt.backend.epsilon()), i
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this;
        (Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t)).forEach((function(n, r) {
         var i = Wt.registeredVariables[n];
         null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
          originalName: n + "/accum_grad",
          variable: nn((function() {
           return Zn(i).variable(!1)
          }))
         }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {
          originalName: n + "/accum_var",
          variable: nn((function() {
           return Zn(i).variable(!1)
          }))
         });
         var o = Array.isArray(t) ? t[r].tensor : t[n];
         if (null != o) {
          var a = e.accumulatedGrads[r].variable,
           s = e.accumulatedUpdates[r].variable;
          nn((function() {
           var t = a.mul(e.rho).add(o.square().mul(1 - e.rho)),
            n = s.add(e.epsilon).sqrt().div(a.add(e.epsilon).sqrt()).mul(o),
            r = s.mul(e.rho).add(n.square().mul(1 - e.rho));
           a.assign(t), s.assign(r);
           var u = n.mul(-e.learningRate).add(i);
           i.assign(u)
          }))
         }
        })), this.incrementIterations()
       }, e.prototype.dispose = function() {
        null != this.accumulatedUpdates && (rn(this.accumulatedGrads.map((function(t) {
         return t.variable
        }))), rn(this.accumulatedUpdates.map((function(t) {
         return t.variable
        }))))
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
           case 1:
            return [2, [e.sent()].concat(t.map((function(t) {
             return {
              name: t.originalName,
              tensor: t.variable
             }
            })))]
          }
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return [4, this.extractIterations(t)];
           case 1:
            return t = n.sent(), e = t.length / 2, this.accumulatedGrads = t.slice(0, e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), this.accumulatedUpdates = t.slice(e, 2 * e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), [2]
          }
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate,
         rho: this.rho,
         epsilon: this.epsilon
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate, e.rho, e.epsilon)
       }, e.className = "Adadelta", e
      }(vf); of (mf);
      var gf = function(t) {
       function e(e, n) {
        void 0 === n && (n = .1);
        var r = t.call(this) || this;
        return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this;
        (Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t)).forEach((function(n, r) {
         var i = Wt.registeredVariables[n];
         null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
          originalName: n + "/accumulator",
          variable: nn((function() {
           return qn(i.shape, e.initialAccumulatorValue).variable(!1)
          }))
         });
         var o = Array.isArray(t) ? t[r].tensor : t[n];
         if (null != o) {
          var a = e.accumulatedGrads[r].variable;
          nn((function() {
           var t = a.add(o.square());
           a.assign(t);
           var n = o.div(t.add(Wt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(i);
           i.assign(n)
          }))
         }
        })), this.incrementIterations()
       }, e.prototype.dispose = function() {
        null != this.accumulatedGrads && rn(this.accumulatedGrads.map((function(t) {
         return t.variable
        })))
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return [4, this.saveIterations()];
           case 1:
            return [2, [t.sent()].concat(this.accumulatedGrads.map((function(t) {
             return {
              name: t.originalName,
              tensor: t.variable
             }
            })))]
          }
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.extractIterations(t)];
           case 1:
            return t = e.sent(), this.accumulatedGrads = t.map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), [2]
          }
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate,
         initialAccumulatorValue: this.initialAccumulatorValue
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate, e.initialAccumulatorValue)
       }, e.className = "Adagrad", e
      }(vf); of (gf);
      var yf = function(t) {
       function e(e, n, r, i) {
        void 0 === i && (i = null);
        var o = t.call(this) || this;
        return o.learningRate = e, o.beta1 = n, o.beta2 = r, o.epsilon = i, o.accumulatedFirstMoment = [], o.accumulatedSecondMoment = [], nn((function() {
         o.accBeta1 = Bn(n).variable(), o.accBeta2 = Bn(r).variable()
        })), null == i && (o.epsilon = Wt.backend.epsilon()), o
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this,
         n = Array.isArray(t) ? t.map((function(t) {
          return t.name
         })) : Object.keys(t);
        nn((function() {
         var r = Ec(1, e.accBeta1),
          i = Ec(1, e.accBeta2);
         n.forEach((function(n, o) {
          var a = Wt.registeredVariables[n];
          null == e.accumulatedFirstMoment[o] && (e.accumulatedFirstMoment[o] = {
           originalName: n + "/m",
           variable: nn((function() {
            return Zn(a).variable(!1)
           }))
          }), null == e.accumulatedSecondMoment[o] && (e.accumulatedSecondMoment[o] = {
           originalName: n + "/v",
           variable: nn((function() {
            return Zn(a).variable(!1)
           }))
          });
          var s = Array.isArray(t) ? t[o].tensor : t[n];
          if (null != s) {
           var u = e.accumulatedFirstMoment[o].variable,
            c = e.accumulatedSecondMoment[o].variable,
            l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
            h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)),
            p = l.div(r),
            f = h.div(i);
           u.assign(l), c.assign(h);
           var d = p.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(a);
           a.assign(d)
          }
         })), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2))
        })), this.incrementIterations()
       }, e.prototype.dispose = function() {
        this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && rn(this.accumulatedFirstMoment.map((function(t) {
         return t.variable
        }))), null != this.accumulatedSecondMoment && rn(this.accumulatedSecondMoment.map((function(t) {
         return t.variable
        })))
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
           case 1:
            return [2, [e.sent()].concat(t.map((function(t) {
             return {
              name: t.originalName,
              tensor: t.variable
             }
            })))]
          }
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n = this;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return [4, this.extractIterations(t)];
           case 1:
            return t = r.sent(), nn((function() {
             n.accBeta1.assign(xc(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(xc(n.beta2, n.iterations_ + 1))
            })), e = t.length / 2, this.accumulatedFirstMoment = t.slice(0, e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), this.accumulatedSecondMoment = t.slice(e, 2 * e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), [2]
          }
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate,
         beta1: this.beta1,
         beta2: this.beta2,
         epsilon: this.epsilon
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon)
       }, e.className = "Adam", e
      }(vf); of (yf);
      var bf = function(t) {
       function e(e, n, r, i, o) {
        void 0 === i && (i = null), void 0 === o && (o = 0);
        var a = t.call(this) || this;
        return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = i, a.decay = o, a.accumulatedFirstMoment = [], a.accumulatedWeightedInfNorm = [], nn((function() {
         a.iteration = Bn(0).variable(), a.accBeta1 = Bn(n).variable()
        })), null == i && (a.epsilon = Wt.backend.epsilon()), a
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this,
         n = Array.isArray(t) ? t.map((function(t) {
          return t.name
         })) : Object.keys(t);
        nn((function() {
         var r = Ec(1, e.accBeta1),
          i = uc(-e.learningRate, e.iteration.mul(e.decay).add(1));
         n.forEach((function(n, o) {
          var a = Wt.registeredVariables[n];
          null == e.accumulatedFirstMoment[o] && (e.accumulatedFirstMoment[o] = {
           originalName: n + "/m",
           variable: Zn(a).variable(!1)
          }), null == e.accumulatedWeightedInfNorm[o] && (e.accumulatedWeightedInfNorm[o] = {
           originalName: n + "/v",
           variable: Zn(a).variable(!1)
          });
          var s = Array.isArray(t) ? t[o].tensor : t[n];
          if (null != s) {
           var u = e.accumulatedFirstMoment[o].variable,
            c = e.accumulatedWeightedInfNorm[o].variable,
            l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
            h = c.mul(e.beta2),
            p = s.abs(),
            f = h.maximum(p);
           u.assign(l), c.assign(f);
           var d = i.div(r).mul(l.div(f.add(e.epsilon))).add(a);
           a.assign(d)
          }
         })), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1))
        })), this.incrementIterations()
       }, e.prototype.dispose = function() {
        this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && rn(this.accumulatedFirstMoment.map((function(t) {
         return t.variable
        }))), null != this.accumulatedWeightedInfNorm && rn(this.accumulatedWeightedInfNorm.map((function(t) {
         return t.variable
        })))
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          throw new Error("getWeights() is not implemented for Adamax yet.")
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          throw new Error("setWeights() is not implemented for Adamax yet.")
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate,
         beta1: this.beta1,
         beta2: this.beta2,
         epsilon: this.epsilon,
         decay: this.decay
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay)
       }, e.className = "Adamax", e
      }(vf); of (bf);
      var xf = function(t) {
       function e(e) {
        var n = t.call(this) || this;
        return n.learningRate = e, n.setLearningRate(e), n
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this;
        (Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t)).forEach((function(n, r) {
         var i = Array.isArray(t) ? t[r].tensor : t[n];
         if (null != i) {
          var o = Wt.registeredVariables[n];
          nn((function() {
           var t = e.c.mul(i).add(o);
           o.assign(t)
          }))
         }
        })), this.incrementIterations()
       }, e.prototype.setLearningRate = function(t) {
        this.learningRate = t, null != this.c && this.c.dispose(), this.c = on(Bn(-t))
       }, e.prototype.dispose = function() {
        this.c.dispose()
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return [4, this.saveIterations()];
           case 1:
            return [2, [t.sent()]]
          }
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.extractIterations(t)];
           case 1:
            if (0 !== (t = e.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
            return [2]
          }
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate)
       }, e.className = "SGD", e
      }(vf); of (xf);
      var wf = function(t) {
       function e(e, n, r) {
        void 0 === r && (r = !1);
        var i = t.call(this, e) || this;
        return i.learningRate = e, i.momentum = n, i.useNesterov = r, i.accumulations = [], i.m = Bn(i.momentum), i
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this;
        (Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t)).forEach((function(n, r) {
         var i = Wt.registeredVariables[n];
         null == e.accumulations[r] && (e.accumulations[r] = {
          originalName: n + "/momentum",
          variable: nn((function() {
           return Zn(i).variable(!1)
          }))
         });
         var o = e.accumulations[r].variable,
          a = Array.isArray(t) ? t[r].tensor : t[n];
         null != a && nn((function() {
          var t, n = e.m.mul(o).add(a);
          t = e.useNesterov ? e.c.mul(a.add(n.mul(e.m))).add(i) : e.c.mul(n).add(i), o.assign(n), i.assign(t)
         }))
        })), this.incrementIterations()
       }, e.prototype.dispose = function() {
        this.m.dispose(), null != this.accumulations && rn(this.accumulations.map((function(t) {
         return t.variable
        })))
       }, e.prototype.setMomentum = function(t) {
        this.momentum = t
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          switch (t.label) {
           case 0:
            return [4, this.saveIterations()];
           case 1:
            return [2, [t.sent()].concat(this.accumulations.map((function(t) {
             return {
              name: t.originalName,
              tensor: t.variable
             }
            })))]
          }
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.extractIterations(t)];
           case 1:
            return t = e.sent(), this.accumulations = t.map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), [2]
          }
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate,
         momentum: this.momentum,
         useNesterov: this.useNesterov
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate, e.momentum, e.useNesterov)
       }, e.className = "Momentum", e
      }(xf); of (wf);
      var Cf = function(t) {
       function e(e, n, r, i, o) {
        void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === i && (i = null), void 0 === o && (o = !1);
        var a = t.call(this) || this;
        if (a.learningRate = e, a.decay = n, a.momentum = r, a.epsilon = i, a.accumulatedMeanSquares = [], a.accumulatedMoments = [], a.accumulatedMeanGrads = [], a.centered = o, null == i && (a.epsilon = Wt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
        return a
       }
       return a(e, t), e.prototype.applyGradients = function(t) {
        var e = this;
        (Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t)).forEach((function(n, r) {
         var i = Wt.registeredVariables[n];
         null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {
          originalName: n + "/rms",
          variable: nn((function() {
           return Zn(i).variable(!1)
          }))
         }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {
          originalName: n + "/momentum",
          variable: nn((function() {
           return Zn(i).variable(!1)
          }))
         }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {
          originalName: n + "/mg",
          variable: nn((function() {
           return Zn(i).variable(!1)
          }))
         });
         var o = Array.isArray(t) ? t[r].tensor : t[n];
         if (null != o) {
          var a = e.accumulatedMeanSquares[r].variable,
           s = e.accumulatedMoments[r].variable;
          nn((function() {
           var t = a.mul(e.decay).add(o.square().mul(1 - e.decay));
           if (e.centered) {
            var n = e.accumulatedMeanGrads[r].variable,
             u = n.mul(e.decay).add(o.mul(1 - e.decay)),
             c = s.mul(e.momentum).add(o.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));
            a.assign(t), n.assign(u), s.assign(c);
            var l = i.sub(c);
            i.assign(l)
           } else {
            var h = a.mul(e.decay).add(o.square().mul(1 - e.decay));
            c = s.mul(e.momentum).add(o.mul(e.learningRate).div(h.add(e.epsilon).sqrt())), a.assign(h), s.assign(c), l = i.sub(c), i.assign(l)
           }
          }))
         }
        })), this.incrementIterations()
       }, e.prototype.dispose = function() {
        null != this.accumulatedMeanSquares && rn(this.accumulatedMeanSquares.map((function(t) {
         return t.variable
        }))), null != this.accumulatedMeanGrads && this.centered && rn(this.accumulatedMeanGrads.map((function(t) {
         return t.variable
        }))), null != this.accumulatedMoments && rn(this.accumulatedMoments.map((function(t) {
         return t.variable
        })))
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];
           case 1:
            return [2, [e.sent()].concat(t.map((function(t) {
             return {
              name: t.originalName,
              tensor: t.variable
             }
            })))]
          }
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return [4, this.extractIterations(t)];
           case 1:
            return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), this.accumulatedMoments = t.slice(e, 2 * e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            })), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map((function(t) {
             return {
              originalName: t.name,
              variable: t.tensor.variable(!1)
             }
            }))), [2]
          }
         }))
        }))
       }, e.prototype.getConfig = function() {
        return {
         learningRate: this.learningRate,
         decay: this.decay,
         momentum: this.momentum,
         epsilon: this.epsilon,
         centered: this.centered
        }
       }, e.fromConfig = function(t, e) {
        return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered)
       }, e.className = "RMSProp", e
      }(vf); of (Cf);
      var Sf = function() {
        function t() {}
        return t.sgd = function(t) {
         return new xf(t)
        }, t.momentum = function(t, e, n) {
         return void 0 === n && (n = !1), new wf(t, e, n)
        }, t.rmsprop = function(t, e, n, r, i) {
         return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === i && (i = !1), new Cf(t, e, n, r, i)
        }, t.adam = function(t, e, n, r) {
         return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new yf(t, e, n, r)
        }, t.adadelta = function(t, e, n) {
         return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new mf(t, e, n)
        }, t.adamax = function(t, e, n, r, i) {
         return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === i && (i = 0), new bf(t, e, n, r, i)
        }, t.adagrad = function(t, e) {
         return void 0 === e && (e = .1), new gf(t, e)
        }, t
       }(),
       Ef = {
        sgd: Sf.sgd,
        momentum: Sf.momentum,
        adadelta: Sf.adadelta,
        adagrad: Sf.adagrad,
        rmsprop: Sf.rmsprop,
        adamax: Sf.adamax,
        adam: Sf.adam
       },
       kf = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(t) {
        return t()
       };
 
      function If() {
       return new Promise((function(t) {
        return kf((function() {
         return t()
        }))
       }))
      }
      Ct = $h
     }.call(this, n("c8ba"), n("4362"), n("b639").Buffer)
   },
   "45fc": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("b727").some,
     o = n("a640"),
     a = n("ae40"),
     s = o("some"),
     u = a("some");
    r({
     target: "Array",
     proto: !0,
     forced: !s || !u
    }, {
     some: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   "466d": function(t, e, n) {
    "use strict";
    var r = n("d784"),
     i = n("825a"),
     o = n("50c4"),
     a = n("1d80"),
     s = n("8aa5"),
     u = n("14c3");
    r("match", 1, (function(t, e, n) {
     return [function(e) {
      var n = a(this),
       r = void 0 == e ? void 0 : e[t];
      return void 0 !== r ? r.call(e, n) : new RegExp(e)[t](String(n))
     }, function(t) {
      var r = n(e, t, this);
      if (r.done) return r.value;
      var a = i(t),
       c = String(this);
      if (!a.global) return u(a, c);
      var l = a.unicode;
      a.lastIndex = 0;
      var h, p = [],
       f = 0;
      while (null !== (h = u(a, c))) {
       var d = String(h[0]);
       p[f] = d, "" === d && (a.lastIndex = s(c, o(a.lastIndex), l)), f++
      }
      return 0 === f ? null : p
     }]
    }))
   },
   "467f": function(t, e, n) {
    "use strict";
    var r = n("2d83");
    t.exports = function(t, e, n) {
     var i = n.config.validateStatus;
     !i || i(n.status) ? t(n) : e(r("Request failed with status code " + n.status, n.config, null, n.request, n))
    }
   },
   4804: function(t, e, n) {},
   "480e": function(t, e, n) {
    "use strict";
    n("7db0");
    var r = n("7560");
    e["a"] = r["a"].extend({
     name: "v-theme-provider",
     props: {
      root: Boolean
     },
     computed: {
      isDark: function() {
       return this.root ? this.rootIsDark : r["a"].options.computed.isDark.call(this)
      }
     },
     render: function() {
      return this.$slots.default && this.$slots.default.find((function(t) {
       return !t.isComment && " " !== t.text
      }))
     }
    })
   },
   4840: function(t, e, n) {
    var r = n("825a"),
     i = n("1c0b"),
     o = n("b622"),
     a = o("species");
    t.exports = function(t, e) {
     var n, o = r(t).constructor;
     return void 0 === o || void 0 == (n = r(o)[a]) ? e : i(n)
    }
   },
   "490a": function(t, e, n) {
    "use strict";
    n("99af"), n("a9e3"), n("8d4f");
    var r = n("a9ad"),
     i = n("80d2");
    e["a"] = r["a"].extend({
     name: "v-progress-circular",
     props: {
      button: Boolean,
      indeterminate: Boolean,
      rotate: {
       type: [Number, String],
       default: 0
      },
      size: {
       type: [Number, String],
       default: 32
      },
      width: {
       type: [Number, String],
       default: 4
      },
      value: {
       type: [Number, String],
       default: 0
      }
     },
     data: function() {
      return {
       radius: 20
      }
     },
     computed: {
      calculatedSize: function() {
       return Number(this.size) + (this.button ? 8 : 0)
      },
      circumference: function() {
       return 2 * Math.PI * this.radius
      },
      classes: function() {
       return {
        "v-progress-circular--indeterminate": this.indeterminate,
        "v-progress-circular--button": this.button
       }
      },
      normalizedValue: function() {
       return this.value < 0 ? 0 : this.value > 100 ? 100 : parseFloat(this.value)
      },
      strokeDashArray: function() {
       return Math.round(1e3 * this.circumference) / 1e3
      },
      strokeDashOffset: function() {
       return (100 - this.normalizedValue) / 100 * this.circumference + "px"
      },
      strokeWidth: function() {
       return Number(this.width) / +this.size * this.viewBoxSize * 2
      },
      styles: function() {
       return {
        height: Object(i["f"])(this.calculatedSize),
        width: Object(i["f"])(this.calculatedSize)
       }
      },
      svgStyles: function() {
       return {
        transform: "rotate(".concat(Number(this.rotate), "deg)")
       }
      },
      viewBoxSize: function() {
       return this.radius / (1 - Number(this.width) / +this.size)
      }
     },
     methods: {
      genCircle: function(t, e) {
       return this.$createElement("circle", {
        class: "v-progress-circular__".concat(t),
        attrs: {
         fill: "transparent",
         cx: 2 * this.viewBoxSize,
         cy: 2 * this.viewBoxSize,
         r: this.radius,
         "stroke-width": this.strokeWidth,
         "stroke-dasharray": this.strokeDashArray,
         "stroke-dashoffset": e
        }
       })
      },
      genSvg: function() {
       var t = [this.indeterminate || this.genCircle("underlay", 0), this.genCircle("overlay", this.strokeDashOffset)];
       return this.$createElement("svg", {
        style: this.svgStyles,
        attrs: {
         xmlns: "http://www.w3.org/2000/svg",
         viewBox: "".concat(this.viewBoxSize, " ").concat(this.viewBoxSize, " ").concat(2 * this.viewBoxSize, " ").concat(2 * this.viewBoxSize)
        }
       }, t)
      },
      genInfo: function() {
       return this.$createElement("div", {
        staticClass: "v-progress-circular__info"
       }, this.$slots.default)
      }
     },
     render: function(t) {
      return t("div", this.setTextColor(this.color, {
       staticClass: "v-progress-circular",
       attrs: {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
       },
       class: this.classes,
       style: this.styles,
       on: this.$listeners
      }), [this.genSvg(), this.genInfo()])
     }
    })
   },
   4930: function(t, e, n) {
    var r = n("d039");
    t.exports = !!Object.getOwnPropertySymbols && !r((function() {
     return !String(Symbol())
    }))
   },
   "498a": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("58a8").trim,
     o = n("c8d2");
    r({
     target: "String",
     proto: !0,
     forced: o("trim")
    }, {
     trim: function() {
      return i(this)
     }
    })
   },
   "4a7b": function(t, e, n) {
    "use strict";
    var r = n("c532");
    t.exports = function(t, e) {
     e = e || {};
     var n = {},
      i = ["url", "method", "params", "data"],
      o = ["headers", "auth", "proxy"],
      a = ["baseURL", "url", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "maxContentLength", "validateStatus", "maxRedirects", "httpAgent", "httpsAgent", "cancelToken", "socketPath"];
     r.forEach(i, (function(t) {
      "undefined" !== typeof e[t] && (n[t] = e[t])
     })), r.forEach(o, (function(i) {
      r.isObject(e[i]) ? n[i] = r.deepMerge(t[i], e[i]) : "undefined" !== typeof e[i] ? n[i] = e[i] : r.isObject(t[i]) ? n[i] = r.deepMerge(t[i]) : "undefined" !== typeof t[i] && (n[i] = t[i])
     })), r.forEach(a, (function(r) {
      "undefined" !== typeof e[r] ? n[r] = e[r] : "undefined" !== typeof t[r] && (n[r] = t[r])
     }));
     var s = i.concat(o).concat(a),
      u = Object.keys(e).filter((function(t) {
       return -1 === s.indexOf(t)
      }));
     return r.forEach(u, (function(r) {
      "undefined" !== typeof e[r] ? n[r] = e[r] : "undefined" !== typeof t[r] && (n[r] = t[r])
     })), n
    }
   },
   "4ad4": function(t, e, n) {
    "use strict";
    n("caad"), n("45fc"), n("b0c0"), n("b64b");
    var r = n("53ca"),
     i = n("16b7"),
     o = n("f2e7"),
     a = n("58df"),
     s = n("80d2"),
     u = n("d9bd"),
     c = Object(a["a"])(i["a"], o["a"]);
    e["a"] = c.extend({
     name: "activatable",
     props: {
      activator: {
       default: null,
       validator: function(t) {
        return ["string", "object"].includes(Object(r["a"])(t))
       }
      },
      disabled: Boolean,
      internalActivator: Boolean,
      openOnHover: Boolean
     },
     data: function() {
      return {
       activatorElement: null,
       activatorNode: [],
       events: ["click", "mouseenter", "mouseleave"],
       listeners: {}
      }
     },
     watch: {
      activator: "resetActivator",
      openOnHover: "resetActivator"
     },
     mounted: function() {
      var t = Object(s["n"])(this, "activator", !0);
      t && ["v-slot", "normal"].includes(t) && Object(u["b"])('The activator slot must be bound, try \'<template v-slot:activator="{ on }"><v-btn v-on="on">\'', this), this.addActivatorEvents()
     },
     beforeDestroy: function() {
      this.removeActivatorEvents()
     },
     methods: {
      addActivatorEvents: function() {
       if (this.activator && !this.disabled && this.getActivator()) {
        this.listeners = this.genActivatorListeners();
        for (var t = Object.keys(this.listeners), e = 0, n = t; e < n.length; e++) {
         var r = n[e];
         this.getActivator().addEventListener(r, this.listeners[r])
        }
       }
      },
      genActivator: function() {
       var t = Object(s["m"])(this, "activator", Object.assign(this.getValueProxy(), {
        on: this.genActivatorListeners(),
        attrs: this.genActivatorAttributes()
       })) || [];
       return this.activatorNode = t, t
      },
      genActivatorAttributes: function() {
       return {
        role: "button",
        "aria-haspopup": !0,
        "aria-expanded": String(this.isActive)
       }
      },
      genActivatorListeners: function() {
       var t = this;
       if (this.disabled) return {};
       var e = {};
       return this.openOnHover ? (e.mouseenter = function(e) {
        t.getActivator(e), t.runDelay("open")
       }, e.mouseleave = function(e) {
        t.getActivator(e), t.runDelay("close")
       }) : e.click = function(e) {
        var n = t.getActivator(e);
        n && n.focus(), e.stopPropagation(), t.isActive = !t.isActive
       }, e
      },
      getActivator: function(t) {
       if (this.activatorElement) return this.activatorElement;
       var e = null;
       if (this.activator) {
        var n = this.internalActivator ? this.$el : document;
        e = "string" === typeof this.activator ? n.querySelector(this.activator) : this.activator.$el ? this.activator.$el : this.activator
       } else if (1 === this.activatorNode.length || this.activatorNode.length && !t) {
        var r = this.activatorNode[0].componentInstance;
        e = r && r.$options.mixins && r.$options.mixins.some((function(t) {
         return t.options && ["activatable", "menuable"].includes(t.options.name)
        })) ? r.getActivator() : this.activatorNode[0].elm
       } else t && (e = t.currentTarget || t.target);
       return this.activatorElement = e, this.activatorElement
      },
      getContentSlot: function() {
       return Object(s["m"])(this, "default", this.getValueProxy(), !0)
      },
      getValueProxy: function() {
       var t = this;
       return {
        get value() {
         return t.isActive
        },
        set value(e) {
         t.isActive = e
        }
       }
      },
      removeActivatorEvents: function() {
       if (this.activator && this.activatorElement) {
        for (var t = Object.keys(this.listeners), e = 0, n = t; e < n.length; e++) {
         var r = n[e];
         this.activatorElement.removeEventListener(r, this.listeners[r])
        }
        this.listeners = {}
       }
      },
      resetActivator: function() {
       this.removeActivatorEvents(), this.activatorElement = null, this.getActivator(), this.addActivatorEvents()
      }
     }
    })
   },
   "4b85": function(t, e, n) {},
   "4d64": function(t, e, n) {
    var r = n("fc6a"),
     i = n("50c4"),
     o = n("23cb"),
     a = function(t) {
      return function(e, n, a) {
       var s, u = r(e),
        c = i(u.length),
        l = o(a, c);
       if (t && n != n) {
        while (c > l)
         if (s = u[l++], s != s) return !0
       } else
        for (; c > l; l++)
         if ((t || l in u) && u[l] === n) return t || l || 0;
       return !t && -1
      }
     };
    t.exports = {
     includes: a(!0),
     indexOf: a(!1)
    }
   },
   "4de4": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("b727").filter,
     o = n("1dde"),
     a = n("ae40"),
     s = o("filter"),
     u = a("filter");
    r({
     target: "Array",
     proto: !0,
     forced: !s || !u
    }, {
     filter: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   "4df4": function(t, e, n) {
    "use strict";
    var r = n("0366"),
     i = n("7b0b"),
     o = n("9bdd"),
     a = n("e95a"),
     s = n("50c4"),
     u = n("8418"),
     c = n("35a1");
    t.exports = function(t) {
     var e, n, l, h, p, f, d = i(t),
      v = "function" == typeof this ? this : Array,
      m = arguments.length,
      g = m > 1 ? arguments[1] : void 0,
      y = void 0 !== g,
      b = c(d),
      x = 0;
     if (y && (g = r(g, m > 2 ? arguments[2] : void 0, 2)), void 0 == b || v == Array && a(b))
      for (e = s(d.length), n = new v(e); e > x; x++) f = y ? g(d[x], x) : d[x], u(n, x, f);
     else
      for (h = b.call(d), p = h.next, n = new v; !(l = p.call(h)).done; x++) f = y ? o(h, g, [l.value, x], !0) : l.value, u(n, x, f);
     return n.length = x, n
    }
   },
   "4e82": function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return o
    }));
    var r = n("ade3"),
     i = n("3206");
 
    function o(t, e, n) {
     var o = Object(i["a"])(t, e, n).extend({
      name: "groupable",
      props: {
       activeClass: {
        type: String,
        default: function() {
         if (this[t]) return this[t].activeClass
        }
       },
       disabled: Boolean
      },
      data: function() {
       return {
        isActive: !1
       }
      },
      computed: {
       groupClasses: function() {
        return this.activeClass ? Object(r["a"])({}, this.activeClass, this.isActive) : {}
       }
      },
      created: function() {
       this[t] && this[t].register(this)
      },
      beforeDestroy: function() {
       this[t] && this[t].unregister(this)
      },
      methods: {
       toggle: function() {
        this.$emit("change")
       }
      }
     });
     return o
    }
    o("itemGroup")
   },
   "4ec9": function(t, e, n) {
    "use strict";
    var r = n("6d61"),
     i = n("6566");
    t.exports = r("Map", (function(t) {
     return function() {
      return t(this, arguments.length ? arguments[0] : void 0)
     }
    }), i)
   },
   "4f96": function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return a
    }));
    var r = n("0d21"),
     i = n("db90"),
     o = n("3d8c");
 
    function a(t) {
     return Object(r["a"])(t) || Object(i["a"])(t) || Object(o["a"])()
    }
   },
   "4ff9": function(t, e, n) {},
   "50c4": function(t, e, n) {
    var r = n("a691"),
     i = Math.min;
    t.exports = function(t) {
     return t > 0 ? i(r(t), 9007199254740991) : 0
    }
   },
   5135: function(t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function(t, e) {
     return n.call(t, e)
    }
   },
   5270: function(t, e, n) {
    "use strict";
    var r = n("c532"),
     i = n("c401"),
     o = n("2e67"),
     a = n("2444");
 
    function s(t) {
     t.cancelToken && t.cancelToken.throwIfRequested()
    }
    t.exports = function(t) {
     s(t), t.headers = t.headers || {}, t.data = i(t.data, t.headers, t.transformRequest), t.headers = r.merge(t.headers.common || {}, t.headers[t.method] || {}, t.headers), r.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function(e) {
      delete t.headers[e]
     }));
     var e = t.adapter || a.adapter;
     return e(t).then((function(e) {
      return s(t), e.data = i(e.data, e.headers, t.transformResponse), e
     }), (function(e) {
      return o(e) || (s(t), e && e.response && (e.response.data = i(e.response.data, e.response.headers, t.transformResponse))), Promise.reject(e)
     }))
    }
   },
   5319: function(t, e, n) {
    "use strict";
    var r = n("d784"),
     i = n("825a"),
     o = n("7b0b"),
     a = n("50c4"),
     s = n("a691"),
     u = n("1d80"),
     c = n("8aa5"),
     l = n("14c3"),
     h = Math.max,
     p = Math.min,
     f = Math.floor,
     d = /\$([$&'`]|\d\d?|<[^>]*>)/g,
     v = /\$([$&'`]|\d\d?)/g,
     m = function(t) {
      return void 0 === t ? t : String(t)
     };
    r("replace", 2, (function(t, e, n, r) {
     var g = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,
      y = r.REPLACE_KEEPS_$0,
      b = g ? "$" : "$0";
     return [function(n, r) {
      var i = u(this),
       o = void 0 == n ? void 0 : n[t];
      return void 0 !== o ? o.call(n, i, r) : e.call(String(i), n, r)
     }, function(t, r) {
      if (!g && y || "string" === typeof r && -1 === r.indexOf(b)) {
       var o = n(e, t, this, r);
       if (o.done) return o.value
      }
      var u = i(t),
       f = String(this),
       d = "function" === typeof r;
      d || (r = String(r));
      var v = u.global;
      if (v) {
       var w = u.unicode;
       u.lastIndex = 0
      }
      var C = [];
      while (1) {
       var S = l(u, f);
       if (null === S) break;
       if (C.push(S), !v) break;
       var E = String(S[0]);
       "" === E && (u.lastIndex = c(f, a(u.lastIndex), w))
      }
      for (var k = "", I = 0, O = 0; O < C.length; O++) {
       S = C[O];
       for (var A = String(S[0]), N = h(p(s(S.index), f.length), 0), R = [], T = 1; T < S.length; T++) R.push(m(S[T]));
       var _ = S.groups;
       if (d) {
        var D = [A].concat(R, N, f);
        void 0 !== _ && D.push(_);
        var F = String(r.apply(void 0, D))
       } else F = x(A, f, N, R, _, r);
       N >= I && (k += f.slice(I, N) + F, I = N + A.length)
      }
      return k + f.slice(I)
     }];
 
     function x(t, n, r, i, a, s) {
      var u = r + t.length,
       c = i.length,
       l = v;
      return void 0 !== a && (a = o(a), l = d), e.call(s, l, (function(e, o) {
       var s;
       switch (o.charAt(0)) {
        case "$":
         return "$";
        case "&":
         return t;
        case "`":
         return n.slice(0, r);
        case "'":
         return n.slice(u);
        case "<":
         s = a[o.slice(1, -1)];
         break;
        default:
         var l = +o;
         if (0 === l) return e;
         if (l > c) {
          var h = f(l / 10);
          return 0 === h ? e : h <= c ? void 0 === i[h - 1] ? o.charAt(1) : i[h - 1] + o.charAt(1) : e
         }
         s = i[l - 1]
       }
       return void 0 === s ? "" : s
      }))
     }
    }))
   },
   5363: function(t, e, n) {},
   "53ca": function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return r
    }));
    n("a4d3"), n("e01a"), n("d28b"), n("e260"), n("d3b7"), n("3ca3"), n("ddb0");
 
    function r(t) {
     return r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(t) {
      return typeof t
     } : function(t) {
      return t && "function" === typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
     }, r(t)
    }
   },
   5530: function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return o
    }));
    n("a4d3"), n("4de4"), n("4160"), n("e439"), n("dbb4"), n("b64b"), n("159b");
    var r = n("ade3");
 
    function i(t, e) {
     var n = Object.keys(t);
     if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(t);
      e && (r = r.filter((function(e) {
       return Object.getOwnPropertyDescriptor(t, e).enumerable
      }))), n.push.apply(n, r)
     }
     return n
    }
 
    function o(t) {
     for (var e = 1; e < arguments.length; e++) {
      var n = null != arguments[e] ? arguments[e] : {};
      e % 2 ? i(Object(n), !0).forEach((function(e) {
       Object(r["a"])(t, e, n[e])
      })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i(Object(n)).forEach((function(e) {
       Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
      }))
     }
     return t
    }
   },
   5607: function(t, e, n) {
    "use strict";
    n("99af"), n("b0c0"), n("a9e3"), n("d3b7"), n("25f0"), n("7435");
 
    function r(t, e) {
     t.style["transform"] = e, t.style["webkitTransform"] = e
    }
 
    function i(t, e) {
     t.style["opacity"] = e.toString()
    }
 
    function o(t) {
     return "TouchEvent" === t.constructor.name
    }
    var a = function(t, e) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
       r = e.getBoundingClientRect(),
       i = o(t) ? t.touches[t.touches.length - 1] : t,
       a = i.clientX - r.left,
       s = i.clientY - r.top,
       u = 0,
       c = .3;
      e._ripple && e._ripple.circle ? (c = .15, u = e.clientWidth / 2, u = n.center ? u : u + Math.sqrt(Math.pow(a - u, 2) + Math.pow(s - u, 2)) / 4) : u = Math.sqrt(Math.pow(e.clientWidth, 2) + Math.pow(e.clientHeight, 2)) / 2;
      var l = "".concat((e.clientWidth - 2 * u) / 2, "px"),
       h = "".concat((e.clientHeight - 2 * u) / 2, "px"),
       p = n.center ? l : "".concat(a - u, "px"),
       f = n.center ? h : "".concat(s - u, "px");
      return {
       radius: u,
       scale: c,
       x: p,
       y: f,
       centerX: l,
       centerY: h
      }
     },
     s = {
      show: function(t, e) {
       var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
       if (e._ripple && e._ripple.enabled) {
        var o = document.createElement("span"),
         s = document.createElement("span");
        o.appendChild(s), o.className = "v-ripple__container", n.class && (o.className += " ".concat(n.class));
        var u = a(t, e, n),
         c = u.radius,
         l = u.scale,
         h = u.x,
         p = u.y,
         f = u.centerX,
         d = u.centerY,
         v = "".concat(2 * c, "px");
        s.className = "v-ripple__animation", s.style.width = v, s.style.height = v, e.appendChild(o);
        var m = window.getComputedStyle(e);
        m && "static" === m.position && (e.style.position = "relative", e.dataset.previousPosition = "static"), s.classList.add("v-ripple__animation--enter"), s.classList.add("v-ripple__animation--visible"), r(s, "translate(".concat(h, ", ").concat(p, ") scale3d(").concat(l, ",").concat(l, ",").concat(l, ")")), i(s, 0), s.dataset.activated = String(performance.now()), setTimeout((function() {
         s.classList.remove("v-ripple__animation--enter"), s.classList.add("v-ripple__animation--in"), r(s, "translate(".concat(f, ", ").concat(d, ") scale3d(1,1,1)")), i(s, .25)
        }), 0)
       }
      },
      hide: function(t) {
       if (t && t._ripple && t._ripple.enabled) {
        var e = t.getElementsByClassName("v-ripple__animation");
        if (0 !== e.length) {
         var n = e[e.length - 1];
         if (!n.dataset.isHiding) {
          n.dataset.isHiding = "true";
          var r = performance.now() - Number(n.dataset.activated),
           o = Math.max(250 - r, 0);
          setTimeout((function() {
           n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), i(n, 0), setTimeout((function() {
            var e = t.getElementsByClassName("v-ripple__animation");
            1 === e.length && t.dataset.previousPosition && (t.style.position = t.dataset.previousPosition, delete t.dataset.previousPosition), n.parentNode && t.removeChild(n.parentNode)
           }), 300)
          }), o)
         }
        }
       }
      }
     };
 
    function u(t) {
     return "undefined" === typeof t || !!t
    }
 
    function c(t) {
     var e = {},
      n = t.currentTarget;
     if (n && n._ripple && !n._ripple.touched) {
      if (o(t)) n._ripple.touched = !0, n._ripple.isTouch = !0;
      else if (n._ripple.isTouch) return;
      e.center = n._ripple.centered, n._ripple.class && (e.class = n._ripple.class), s.show(t, n, e)
     }
    }
 
    function l(t) {
     var e = t.currentTarget;
     e && (window.setTimeout((function() {
      e._ripple && (e._ripple.touched = !1)
     })), s.hide(e))
    }
 
    function h(t, e, n) {
     var r = u(e.value);
     r || s.hide(t), t._ripple = t._ripple || {}, t._ripple.enabled = r;
     var i = e.value || {};
     i.center && (t._ripple.centered = !0), i.class && (t._ripple.class = e.value.class), i.circle && (t._ripple.circle = i.circle), r && !n ? (t.addEventListener("touchstart", c, {
      passive: !0
     }), t.addEventListener("touchend", l, {
      passive: !0
     }), t.addEventListener("touchcancel", l), t.addEventListener("mousedown", c), t.addEventListener("mouseup", l), t.addEventListener("mouseleave", l), t.addEventListener("dragstart", l, {
      passive: !0
     })) : !r && n && p(t)
    }
 
    function p(t) {
     t.removeEventListener("mousedown", c), t.removeEventListener("touchstart", c), t.removeEventListener("touchend", l), t.removeEventListener("touchcancel", l), t.removeEventListener("mouseup", l), t.removeEventListener("mouseleave", l), t.removeEventListener("dragstart", l)
    }
 
    function f(t, e, n) {
     h(t, e, !1)
    }
 
    function d(t) {
     delete t._ripple, p(t)
    }
 
    function v(t, e) {
     if (e.value !== e.oldValue) {
      var n = u(e.oldValue);
      h(t, e, n)
     }
    }
    var m = {
     bind: f,
     unbind: d,
     update: v
    };
    e["a"] = m
   },
   5692: function(t, e, n) {
    var r = n("c430"),
     i = n("c6cd");
    (t.exports = function(t, e) {
     return i[t] || (i[t] = void 0 !== e ? e : {})
    })("versions", []).push({
     version: "3.6.4",
     mode: r ? "pure" : "global",
     copyright: " 2020 Denis Pushkarev (zloirock.ru)"
    })
   },
   "56ef": function(t, e, n) {
    var r = n("d066"),
     i = n("241c"),
     o = n("7418"),
     a = n("825a");
    t.exports = r("Reflect", "ownKeys") || function(t) {
     var e = i.f(a(t)),
      n = o.f;
     return n ? e.concat(n(t)) : e
    }
   },
   5899: function(t, e) {
    t.exports = "\t\n\v\f\r  \u2028\u2029\ufeff"
   },
   "58a8": function(t, e, n) {
    var r = n("1d80"),
     i = n("5899"),
     o = "[" + i + "]",
     a = RegExp("^" + o + o + "*"),
     s = RegExp(o + o + "*$"),
     u = function(t) {
      return function(e) {
       var n = String(r(e));
       return 1 & t && (n = n.replace(a, "")), 2 & t && (n = n.replace(s, "")), n
      }
     };
    t.exports = {
     start: u(1),
     end: u(2),
     trim: u(3)
    }
   },
   "58df": function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return i
    }));
    var r = n("2b0e");
 
    function i() {
     for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
     return r["a"].extend({
      mixins: e
     })
    }
   },
   "5a34": function(t, e, n) {
    var r = n("44e7");
    t.exports = function(t) {
     if (r(t)) throw TypeError("The method doesn't accept regular expressions");
     return t
    }
   },
   "5c6c": function(t, e) {
    t.exports = function(t, e) {
     return {
      enumerable: !(1 & t),
      configurable: !(2 & t),
      writable: !(4 & t),
      value: e
     }
    }
   },
   "5d23": function(t, e, n) {
    "use strict";
    var r = n("80d2"),
     i = n("8860"),
     o = (n("ac1f"), n("466d"), n("5530")),
     a = n("ade3"),
     s = (n("db42"), n("9d26")),
     u = n("da13"),
     c = (n("498a"), n("2b0e")),
     l = c["a"].extend({
      name: "v-list-item-icon",
      functional: !0,
      render: function(t, e) {
       var n = e.data,
        r = e.children;
       return n.staticClass = "v-list-item__icon ".concat(n.staticClass || "").trim(), t("div", n, r)
      }
     }),
     h = n("7e2b"),
     p = n("9d65"),
     f = n("a9ad"),
     d = n("f2e7"),
     v = n("3206"),
     m = n("5607"),
     g = n("0789"),
     y = n("58df"),
     b = Object(y["a"])(h["a"], p["a"], f["a"], Object(v["a"])("list"), d["a"]),
     x = b.extend().extend({
      name: "v-list-group",
      directives: {
       ripple: m["a"]
      },
      props: {
       activeClass: {
        type: String,
        default: ""
       },
       appendIcon: {
        type: String,
        default: "$expand"
       },
       color: {
        type: String,
        default: "primary"
       },
       disabled: Boolean,
       group: String,
       noAction: Boolean,
       prependIcon: String,
       ripple: {
        type: [Boolean, Object],
        default: !0
       },
       subGroup: Boolean
      },
      computed: {
       classes: function() {
        return {
         "v-list-group--active": this.isActive,
         "v-list-group--disabled": this.disabled,
         "v-list-group--no-action": this.noAction,
         "v-list-group--sub-group": this.subGroup
        }
       }
      },
      watch: {
       isActive: function(t) {
        !this.subGroup && t && this.list && this.list.listClick(this._uid)
       },
       $route: "onRouteChange"
      },
      created: function() {
       this.list && this.list.register(this), this.group && this.$route && null == this.value && (this.isActive = this.matchRoute(this.$route.path))
      },
      beforeDestroy: function() {
       this.list && this.list.unregister(this)
      },
      methods: {
       click: function(t) {
        var e = this;
        this.disabled || (this.isBooted = !0, this.$emit("click", t), this.$nextTick((function() {
         return e.isActive = !e.isActive
        })))
       },
       genIcon: function(t) {
        return this.$createElement(s["a"], t)
       },
       genAppendIcon: function() {
        var t = !this.subGroup && this.appendIcon;
        return t || this.$slots.appendIcon ? this.$createElement(l, {
         staticClass: "v-list-group__header__append-icon"
        }, [this.$slots.appendIcon || this.genIcon(t)]) : null
       },
       genHeader: function() {
        return this.$createElement(u["a"], {
         staticClass: "v-list-group__header",
         attrs: {
          "aria-expanded": String(this.isActive),
          role: "button"
         },
         class: Object(a["a"])({}, this.activeClass, this.isActive),
         props: {
          inputValue: this.isActive
         },
         directives: [{
          name: "ripple",
          value: this.ripple
         }],
         on: Object(o["a"])({}, this.listeners$, {
          click: this.click
         })
        }, [this.genPrependIcon(), this.$slots.activator, this.genAppendIcon()])
       },
       genItems: function() {
        var t = this;
        return this.showLazyContent((function() {
         return [t.$createElement("div", {
          staticClass: "v-list-group__items",
          directives: [{
           name: "show",
           value: t.isActive
          }]
         }, Object(r["m"])(t))]
        }))
       },
       genPrependIcon: function() {
        var t = this.subGroup && null == this.prependIcon ? "$subgroup" : this.prependIcon;
        return t || this.$slots.prependIcon ? this.$createElement(l, {
         staticClass: "v-list-group__header__prepend-icon"
        }, [this.$slots.prependIcon || this.genIcon(t)]) : null
       },
       onRouteChange: function(t) {
        if (this.group) {
         var e = this.matchRoute(t.path);
         e && this.isActive !== e && this.list && this.list.listClick(this._uid), this.isActive = e
        }
       },
       toggle: function(t) {
        var e = this,
         n = this._uid === t;
        n && (this.isBooted = !0), this.$nextTick((function() {
         return e.isActive = n
        }))
       },
       matchRoute: function(t) {
        return null !== t.match(this.group)
       }
      },
      render: function(t) {
       return t("div", this.setTextColor(this.isActive && this.color, {
        staticClass: "v-list-group",
        class: this.classes
       }), [this.genHeader(), t(g["a"], this.genItems())])
      }
     }),
     w = (n("899c"), n("4de4"), n("7db0"), n("c740"), n("4160"), n("caad"), n("c975"), n("fb6a"), n("a434"), n("a9e3"), n("2532"), n("159b"), n("166a"), n("a452")),
     C = n("7560"),
     S = n("d9bd"),
     E = Object(y["a"])(w["a"], C["a"]).extend({
      name: "base-item-group",
      props: {
       activeClass: {
        type: String,
        default: "v-item--active"
       },
       mandatory: Boolean,
       max: {
        type: [Number, String],
        default: null
       },
       multiple: Boolean
      },
      data: function() {
       return {
        internalLazyValue: void 0 !== this.value ? this.value : this.multiple ? [] : void 0,
        items: []
       }
      },
      computed: {
       classes: function() {
        return Object(o["a"])({
         "v-item-group": !0
        }, this.themeClasses)
       },
       selectedIndex: function() {
        return this.selectedItem && this.items.indexOf(this.selectedItem) || -1
       },
       selectedItem: function() {
        if (!this.multiple) return this.selectedItems[0]
       },
       selectedItems: function() {
        var t = this;
        return this.items.filter((function(e, n) {
         return t.toggleMethod(t.getValue(e, n))
        }))
       },
       selectedValues: function() {
        return null == this.internalValue ? [] : Array.isArray(this.internalValue) ? this.internalValue : [this.internalValue]
       },
       toggleMethod: function() {
        var t = this;
        if (!this.multiple) return function(e) {
         return t.internalValue === e
        };
        var e = this.internalValue;
        return Array.isArray(e) ? function(t) {
         return e.includes(t)
        } : function() {
         return !1
        }
       }
      },
      watch: {
       internalValue: "updateItemsState",
       items: "updateItemsState"
      },
      created: function() {
       this.multiple && !Array.isArray(this.internalValue) && Object(S["c"])("Model must be bound to an array if the multiple property is true.", this)
      },
      methods: {
       genData: function() {
        return {
         class: this.classes
        }
       },
       getValue: function(t, e) {
        return null == t.value || "" === t.value ? e : t.value
       },
       onClick: function(t) {
        this.updateInternalValue(this.getValue(t, this.items.indexOf(t)))
       },
       register: function(t) {
        var e = this,
         n = this.items.push(t) - 1;
        t.$on("change", (function() {
         return e.onClick(t)
        })), this.mandatory && !this.selectedValues.length && this.updateMandatory(), this.updateItem(t, n)
       },
       unregister: function(t) {
        if (!this._isDestroyed) {
         var e = this.items.indexOf(t),
          n = this.getValue(t, e);
         this.items.splice(e, 1);
         var r = this.selectedValues.indexOf(n);
         if (!(r < 0)) {
          if (!this.mandatory) return this.updateInternalValue(n);
          this.multiple && Array.isArray(this.internalValue) ? this.internalValue = this.internalValue.filter((function(t) {
           return t !== n
          })) : this.internalValue = void 0, this.selectedItems.length || this.updateMandatory(!0)
         }
        }
       },
       updateItem: function(t, e) {
        var n = this.getValue(t, e);
        t.isActive = this.toggleMethod(n)
       },
       updateItemsState: function() {
        var t = this;
        this.$nextTick((function() {
         if (t.mandatory && !t.selectedItems.length) return t.updateMandatory();
         t.items.forEach(t.updateItem)
        }))
       },
       updateInternalValue: function(t) {
        this.multiple ? this.updateMultiple(t) : this.updateSingle(t)
       },
       updateMandatory: function(t) {
        if (this.items.length) {
         var e = this.items.slice();
         t && e.reverse();
         var n = e.find((function(t) {
          return !t.disabled
         }));
         if (n) {
          var r = this.items.indexOf(n);
          this.updateInternalValue(this.getValue(n, r))
         }
        }
       },
       updateMultiple: function(t) {
        var e = Array.isArray(this.internalValue) ? this.internalValue : [],
         n = e.slice(),
         r = n.findIndex((function(e) {
          return e === t
         }));
        this.mandatory && r > -1 && n.length - 1 < 1 || null != this.max && r < 0 && n.length + 1 > this.max || (r > -1 ? n.splice(r, 1) : n.push(t), this.internalValue = n)
       },
       updateSingle: function(t) {
        var e = t === this.internalValue;
        this.mandatory && e || (this.internalValue = e ? void 0 : t)
       }
      },
      render: function(t) {
       return t("div", this.genData(), this.$slots.default)
      }
     }),
     k = (E.extend({
      name: "v-item-group",
      provide: function() {
       return {
        itemGroup: this
       }
      }
     }), Object(y["a"])(E, f["a"]).extend({
      name: "v-list-item-group",
      provide: function() {
       return {
        isInGroup: !0,
        listItemGroup: this
       }
      },
      computed: {
       classes: function() {
        return Object(o["a"])({}, E.options.computed.classes.call(this), {
         "v-list-item-group": !0
        })
       }
      },
      methods: {
       genData: function() {
        return this.setTextColor(this.color, Object(o["a"])({}, E.options.methods.genData.call(this), {
         attrs: {
          role: "listbox"
         }
        }))
       }
      }
     })),
     I = n("1800"),
     O = (n("3408"), n("24b2")),
     A = Object(y["a"])(f["a"], O["a"]).extend({
      name: "v-avatar",
      props: {
       left: Boolean,
       right: Boolean,
       size: {
        type: [Number, String],
        default: 48
       },
       tile: Boolean
      },
      computed: {
       classes: function() {
        return {
         "v-avatar--left": this.left,
         "v-avatar--right": this.right,
         "v-avatar--tile": this.tile
        }
       },
       styles: function() {
        return Object(o["a"])({
         height: Object(r["f"])(this.size),
         minWidth: Object(r["f"])(this.size),
         width: Object(r["f"])(this.size)
        }, this.measurableStyles)
       }
      },
      render: function(t) {
       var e = {
        staticClass: "v-avatar",
        class: this.classes,
        style: this.styles,
        on: this.$listeners
       };
       return t("div", this.setBackgroundColor(this.color, e), this.$slots.default)
      }
     }),
     N = A,
     R = N.extend({
      name: "v-list-item-avatar",
      props: {
       horizontal: Boolean,
       size: {
        type: [Number, String],
        default: 40
       }
      },
      computed: {
       classes: function() {
        return Object(o["a"])({
         "v-list-item__avatar--horizontal": this.horizontal
        }, N.options.computed.classes.call(this), {
         "v-avatar--tile": this.tile || this.horizontal
        })
       }
      },
      render: function(t) {
       var e = N.options.render.call(this, t);
       return e.data = e.data || {}, e.data.staticClass += " v-list-item__avatar", e
      }
     });
    n.d(e, "a", (function() {
     return _
    })), n.d(e, "b", (function() {
     return D
    }));
    var T = Object(r["g"])("v-list-item__action-text", "span"),
     _ = Object(r["g"])("v-list-item__content", "div"),
     D = Object(r["g"])("v-list-item__title", "div"),
     F = Object(r["g"])("v-list-item__subtitle", "div");
    i["a"], u["a"], I["a"]
   },
   "5e23": function(t, e, n) {},
   "60da": function(t, e, n) {
    "use strict";
    var r = n("83ab"),
     i = n("d039"),
     o = n("df75"),
     a = n("7418"),
     s = n("d1e7"),
     u = n("7b0b"),
     c = n("44ad"),
     l = Object.assign,
     h = Object.defineProperty;
    t.exports = !l || i((function() {
     if (r && 1 !== l({
       b: 1
      }, l(h({}, "a", {
       enumerable: !0,
       get: function() {
        h(this, "b", {
         value: 3,
         enumerable: !1
        })
       }
      }), {
       b: 2
      })).b) return !0;
     var t = {},
      e = {},
      n = Symbol(),
      i = "abcdefghijklmnopqrst";
     return t[n] = 7, i.split("").forEach((function(t) {
      e[t] = t
     })), 7 != l({}, t)[n] || o(l({}, e)).join("") != i
    })) ? function(t, e) {
     var n = u(t),
      i = arguments.length,
      l = 1,
      h = a.f,
      p = s.f;
     while (i > l) {
      var f, d = c(arguments[l++]),
       v = h ? o(d).concat(h(d)) : o(d),
       m = v.length,
       g = 0;
      while (m > g) f = v[g++], r && !p.call(d, f) || (n[f] = d[f])
     }
     return n
    } : l
   },
   "615b": function(t, e, n) {},
   "61d2": function(t, e, n) {},
   "62ad": function(t, e, n) {
    "use strict";
    n("4160"), n("caad"), n("13d5"), n("45fc"), n("4ec9"), n("a9e3"), n("b64b"), n("d3b7"), n("ac1f"), n("3ca3"), n("5319"), n("2ca0"), n("159b"), n("ddb0");
    var r = n("ade3"),
     i = n("5530"),
     o = (n("4b85"), n("2b0e")),
     a = n("d9f7"),
     s = n("80d2"),
     u = ["sm", "md", "lg", "xl"],
     c = function() {
      return u.reduce((function(t, e) {
       return t[e] = {
        type: [Boolean, String, Number],
        default: !1
       }, t
      }), {})
     }(),
     l = function() {
      return u.reduce((function(t, e) {
       return t["offset" + Object(s["v"])(e)] = {
        type: [String, Number],
        default: null
       }, t
      }), {})
     }(),
     h = function() {
      return u.reduce((function(t, e) {
       return t["order" + Object(s["v"])(e)] = {
        type: [String, Number],
        default: null
       }, t
      }), {})
     }(),
     p = {
      col: Object.keys(c),
      offset: Object.keys(l),
      order: Object.keys(h)
     };
 
    function f(t, e, n) {
     var r = t;
     if (null != n && !1 !== n) {
      if (e) {
       var i = e.replace(t, "");
       r += "-".concat(i)
      }
      return "col" !== t || "" !== n && !0 !== n ? (r += "-".concat(n), r.toLowerCase()) : r.toLowerCase()
     }
    }
    var d = new Map;
    e["a"] = o["a"].extend({
     name: "v-col",
     functional: !0,
     props: Object(i["a"])({
      cols: {
       type: [Boolean, String, Number],
       default: !1
      }
     }, c, {
      offset: {
       type: [String, Number],
       default: null
      }
     }, l, {
      order: {
       type: [String, Number],
       default: null
      }
     }, h, {
      alignSelf: {
       type: String,
       default: null,
       validator: function(t) {
        return ["auto", "start", "end", "center", "baseline", "stretch"].includes(t)
       }
      },
      tag: {
       type: String,
       default: "div"
      }
     }),
     render: function(t, e) {
      var n = e.props,
       i = e.data,
       o = e.children,
       s = (e.parent, "");
      for (var u in n) s += String(n[u]);
      var c = d.get(s);
      return c || function() {
       var t, e;
       for (e in c = [], p) p[e].forEach((function(t) {
        var r = n[t],
         i = f(e, t, r);
        i && c.push(i)
       }));
       var i = c.some((function(t) {
        return t.startsWith("col-")
       }));
       c.push((t = {
        col: !i || !n.cols
       }, Object(r["a"])(t, "col-".concat(n.cols), n.cols), Object(r["a"])(t, "offset-".concat(n.offset), n.offset), Object(r["a"])(t, "order-".concat(n.order), n.order), Object(r["a"])(t, "align-self-".concat(n.alignSelf), n.alignSelf), t)), d.set(s, c)
      }(), t(n.tag, Object(a["a"])(i, {
       class: c
      }), o)
     }
    })
   },
   6544: function(t, e) {
    t.exports = function(t, e) {
     var n = "function" === typeof t.exports ? t.exports.extendOptions : t.options;
     for (var r in "function" === typeof t.exports && (n.components = t.exports.options.components), n.components = n.components || {}, e) n.components[r] = n.components[r] || e[r]
    }
   },
   6547: function(t, e, n) {
    var r = n("a691"),
     i = n("1d80"),
     o = function(t) {
      return function(e, n) {
       var o, a, s = String(i(e)),
        u = r(n),
        c = s.length;
       return u < 0 || u >= c ? t ? "" : void 0 : (o = s.charCodeAt(u), o < 55296 || o > 56319 || u + 1 === c || (a = s.charCodeAt(u + 1)) < 56320 || a > 57343 ? t ? s.charAt(u) : o : t ? s.slice(u, u + 2) : a - 56320 + (o - 55296 << 10) + 65536)
      }
     };
    t.exports = {
     codeAt: o(!1),
     charAt: o(!0)
    }
   },
   6566: function(t, e, n) {
    "use strict";
    var r = n("9bf2").f,
     i = n("7c73"),
     o = n("e2cc"),
     a = n("0366"),
     s = n("19aa"),
     u = n("2266"),
     c = n("7dd0"),
     l = n("2626"),
     h = n("83ab"),
     p = n("f183").fastKey,
     f = n("69f3"),
     d = f.set,
     v = f.getterFor;
    t.exports = {
     getConstructor: function(t, e, n, c) {
      var l = t((function(t, r) {
        s(t, l, e), d(t, {
         type: e,
         index: i(null),
         first: void 0,
         last: void 0,
         size: 0
        }), h || (t.size = 0), void 0 != r && u(r, t[c], t, n)
       })),
       f = v(e),
       m = function(t, e, n) {
        var r, i, o = f(t),
         a = g(t, e);
        return a ? a.value = n : (o.last = a = {
         index: i = p(e, !0),
         key: e,
         value: n,
         previous: r = o.last,
         next: void 0,
         removed: !1
        }, o.first || (o.first = a), r && (r.next = a), h ? o.size++ : t.size++, "F" !== i && (o.index[i] = a)), t
       },
       g = function(t, e) {
        var n, r = f(t),
         i = p(e);
        if ("F" !== i) return r.index[i];
        for (n = r.first; n; n = n.next)
         if (n.key == e) return n
       };
      return o(l.prototype, {
       clear: function() {
        var t = this,
         e = f(t),
         n = e.index,
         r = e.first;
        while (r) r.removed = !0, r.previous && (r.previous = r.previous.next = void 0), delete n[r.index], r = r.next;
        e.first = e.last = void 0, h ? e.size = 0 : t.size = 0
       },
       delete: function(t) {
        var e = this,
         n = f(e),
         r = g(e, t);
        if (r) {
         var i = r.next,
          o = r.previous;
         delete n.index[r.index], r.removed = !0, o && (o.next = i), i && (i.previous = o), n.first == r && (n.first = i), n.last == r && (n.last = o), h ? n.size-- : e.size--
        }
        return !!r
       },
       forEach: function(t) {
        var e, n = f(this),
         r = a(t, arguments.length > 1 ? arguments[1] : void 0, 3);
        while (e = e ? e.next : n.first) {
         r(e.value, e.key, this);
         while (e && e.removed) e = e.previous
        }
       },
       has: function(t) {
        return !!g(this, t)
       }
      }), o(l.prototype, n ? {
       get: function(t) {
        var e = g(this, t);
        return e && e.value
       },
       set: function(t, e) {
        return m(this, 0 === t ? 0 : t, e)
       }
      } : {
       add: function(t) {
        return m(this, t = 0 === t ? 0 : t, t)
       }
      }), h && r(l.prototype, "size", {
       get: function() {
        return f(this).size
       }
      }), l
     },
     setStrong: function(t, e, n) {
      var r = e + " Iterator",
       i = v(e),
       o = v(r);
      c(t, e, (function(t, e) {
       d(this, {
        type: r,
        target: t,
        state: i(t),
        kind: e,
        last: void 0
       })
      }), (function() {
       var t = o(this),
        e = t.kind,
        n = t.last;
       while (n && n.removed) n = n.previous;
       return t.target && (t.last = n = n ? n.next : t.state.first) ? "keys" == e ? {
        value: n.key,
        done: !1
       } : "values" == e ? {
        value: n.value,
        done: !1
       } : {
        value: [n.key, n.value],
        done: !1
       } : (t.target = void 0, {
        value: void 0,
        done: !0
       })
      }), n ? "entries" : "values", !n, !0), l(e)
     }
    }
   },
   "65f0": function(t, e, n) {
    var r = n("861d"),
     i = n("e8b5"),
     o = n("b622"),
     a = o("species");
    t.exports = function(t, e) {
     var n;
     return i(t) && (n = t.constructor, "function" != typeof n || n !== Array && !i(n.prototype) ? r(n) && (n = n[a], null === n && (n = void 0)) : n = void 0), new(void 0 === n ? Array : n)(0 === e ? 0 : e)
    }
   },
   "68dd": function(t, e, n) {},
   "69f3": function(t, e, n) {
    var r, i, o, a = n("7f9a"),
     s = n("da84"),
     u = n("861d"),
     c = n("9112"),
     l = n("5135"),
     h = n("f772"),
     p = n("d012"),
     f = s.WeakMap,
     d = function(t) {
      return o(t) ? i(t) : r(t, {})
     },
     v = function(t) {
      return function(e) {
       var n;
       if (!u(e) || (n = i(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
       return n
      }
     };
    if (a) {
     var m = new f,
      g = m.get,
      y = m.has,
      b = m.set;
     r = function(t, e) {
      return b.call(m, t, e), e
     }, i = function(t) {
      return g.call(m, t) || {}
     }, o = function(t) {
      return y.call(m, t)
     }
    } else {
     var x = h("state");
     p[x] = !0, r = function(t, e) {
      return c(t, x, e), e
     }, i = function(t) {
      return l(t, x) ? t[x] : {}
     }, o = function(t) {
      return l(t, x)
     }
    }
    t.exports = {
     set: r,
     get: i,
     has: o,
     enforce: d,
     getterFor: v
    }
   },
   "6d61": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("da84"),
     o = n("94ca"),
     a = n("6eeb"),
     s = n("f183"),
     u = n("2266"),
     c = n("19aa"),
     l = n("861d"),
     h = n("d039"),
     p = n("1c7e"),
     f = n("d44e"),
     d = n("7156");
    t.exports = function(t, e, n) {
     var v = -1 !== t.indexOf("Map"),
      m = -1 !== t.indexOf("Weak"),
      g = v ? "set" : "add",
      y = i[t],
      b = y && y.prototype,
      x = y,
      w = {},
      C = function(t) {
       var e = b[t];
       a(b, t, "add" == t ? function(t) {
        return e.call(this, 0 === t ? 0 : t), this
       } : "delete" == t ? function(t) {
        return !(m && !l(t)) && e.call(this, 0 === t ? 0 : t)
       } : "get" == t ? function(t) {
        return m && !l(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
       } : "has" == t ? function(t) {
        return !(m && !l(t)) && e.call(this, 0 === t ? 0 : t)
       } : function(t, n) {
        return e.call(this, 0 === t ? 0 : t, n), this
       })
      };
     if (o(t, "function" != typeof y || !(m || b.forEach && !h((function() {
       (new y).entries().next()
      }))))) x = n.getConstructor(e, t, v, g), s.REQUIRED = !0;
     else if (o(t, !0)) {
      var S = new x,
       E = S[g](m ? {} : -0, 1) != S,
       k = h((function() {
        S.has(1)
       })),
       I = p((function(t) {
        new y(t)
       })),
       O = !m && h((function() {
        var t = new y,
         e = 5;
        while (e--) t[g](e, e);
        return !t.has(-0)
       }));
      I || (x = e((function(e, n) {
       c(e, x, t);
       var r = d(new y, e, x);
       return void 0 != n && u(n, r[g], r, v), r
      })), x.prototype = b, b.constructor = x), (k || O) && (C("delete"), C("has"), v && C("get")), (O || E) && C(g), m && b.clear && delete b.clear
     }
     return w[t] = x, r({
      global: !0,
      forced: x != y
     }, w), f(x, t), m || n.setStrong(x, t, v), x
    }
   },
   "6ece": function(t, e, n) {},
   "6eeb": function(t, e, n) {
    var r = n("da84"),
     i = n("9112"),
     o = n("5135"),
     a = n("ce4e"),
     s = n("8925"),
     u = n("69f3"),
     c = u.get,
     l = u.enforce,
     h = String(String).split("String");
    (t.exports = function(t, e, n, s) {
     var u = !!s && !!s.unsafe,
      c = !!s && !!s.enumerable,
      p = !!s && !!s.noTargetGet;
     "function" == typeof n && ("string" != typeof e || o(n, "name") || i(n, "name", e), l(n).source = h.join("string" == typeof e ? e : "")), t !== r ? (u ? !p && t[e] && (c = !0) : delete t[e], c ? t[e] = n : i(t, e, n)) : c ? t[e] = n : a(e, n)
    })(Function.prototype, "toString", (function() {
     return "function" == typeof this && c(this).source || s(this)
    }))
   },
   "6f53": function(t, e, n) {
    var r = n("83ab"),
     i = n("df75"),
     o = n("fc6a"),
     a = n("d1e7").f,
     s = function(t) {
      return function(e) {
       var n, s = o(e),
        u = i(s),
        c = u.length,
        l = 0,
        h = [];
       while (c > l) n = u[l++], r && !a.call(s, n) || h.push(t ? [n, s[n]] : s[n]);
       return h
      }
     };
    t.exports = {
     entries: s(!0),
     values: s(!1)
    }
   },
   7156: function(t, e, n) {
    var r = n("861d"),
     i = n("d2bb");
    t.exports = function(t, e, n) {
     var o, a;
     return i && "function" == typeof(o = e.constructor) && o !== n && r(a = o.prototype) && a !== n.prototype && i(t, a), t
    }
   },
   "71d9": function(t, e, n) {
    "use strict";
    n("0481"), n("4160"), n("4069"), n("a9e3");
    var r = n("3835"),
     i = n("5530"),
     o = (n("5e23"), n("8dd9")),
     a = (n("a15b"), n("8efc"), n("90a2")),
     s = (n("36a7"), n("24b2")),
     u = n("58df"),
     c = Object(u["a"])(s["a"]).extend({
      name: "v-responsive",
      props: {
       aspectRatio: [String, Number]
      },
      computed: {
       computedAspectRatio: function() {
        return Number(this.aspectRatio)
       },
       aspectStyle: function() {
        return this.computedAspectRatio ? {
         paddingBottom: 1 / this.computedAspectRatio * 100 + "%"
        } : void 0
       },
       __cachedSizer: function() {
        return this.aspectStyle ? this.$createElement("div", {
         style: this.aspectStyle,
         staticClass: "v-responsive__sizer"
        }) : []
       }
      },
      methods: {
       genContent: function() {
        return this.$createElement("div", {
         staticClass: "v-responsive__content"
        }, this.$slots.default)
       }
      },
      render: function(t) {
       return t("div", {
        staticClass: "v-responsive",
        style: this.measurableStyles,
        on: this.$listeners
       }, [this.__cachedSizer, this.genContent()])
      }
     }),
     l = c,
     h = n("d9bd"),
     p = l.extend({
      name: "v-img",
      directives: {
       intersect: a["a"]
      },
      props: {
       alt: String,
       contain: Boolean,
       eager: Boolean,
       gradient: String,
       lazySrc: String,
       options: {
        type: Object,
        default: function() {
         return {
          root: void 0,
          rootMargin: void 0,
          threshold: void 0
         }
        }
       },
       position: {
        type: String,
        default: "center center"
       },
       sizes: String,
       src: {
        type: [String, Object],
        default: ""
       },
       srcset: String,
       transition: {
        type: [Boolean, String],
        default: "fade-transition"
       }
      },
      data: function() {
       return {
        currentSrc: "",
        image: null,
        isLoading: !0,
        calculatedAspectRatio: void 0,
        naturalWidth: void 0
       }
      },
      computed: {
       computedAspectRatio: function() {
        return Number(this.normalisedSrc.aspect || this.calculatedAspectRatio)
       },
       hasIntersect: function() {
        return "undefined" !== typeof window && "IntersectionObserver" in window
       },
       normalisedSrc: function() {
        return "string" === typeof this.src ? {
         src: this.src,
         srcset: this.srcset,
         lazySrc: this.lazySrc,
         aspect: Number(this.aspectRatio || 0)
        } : {
         src: this.src.src,
         srcset: this.srcset || this.src.srcset,
         lazySrc: this.lazySrc || this.src.lazySrc,
         aspect: Number(this.aspectRatio || this.src.aspect)
        }
       },
       __cachedImage: function() {
        if (!this.normalisedSrc.src && !this.normalisedSrc.lazySrc) return [];
        var t = [],
         e = this.isLoading ? this.normalisedSrc.lazySrc : this.currentSrc;
        this.gradient && t.push("linear-gradient(".concat(this.gradient, ")")), e && t.push('url("'.concat(e, '")'));
        var n = this.$createElement("div", {
         staticClass: "v-image__image",
         class: {
          "v-image__image--preload": this.isLoading, "v-image__image--contain": this.contain, "v-image__image--cover": !this.contain
         },
         style: {
          backgroundImage: t.join(", "),
          backgroundPosition: this.position
         },
         key: +this.isLoading
        });
        return this.transition ? this.$createElement("transition", {
         attrs: {
          name: this.transition,
          mode: "in-out"
         }
        }, [n]) : n
       }
      },
      watch: {
       src: function() {
        this.isLoading ? this.loadImage() : this.init(void 0, void 0, !0)
       },
       "$vuetify.breakpoint.width": "getSrc"
      },
      mounted: function() {
       this.init()
      },
      methods: {
       init: function(t, e, n) {
        if (!this.hasIntersect || n || this.eager) {
         if (this.normalisedSrc.lazySrc) {
          var r = new Image;
          r.src = this.normalisedSrc.lazySrc, this.pollForSize(r, null)
         }
         this.normalisedSrc.src && this.loadImage()
        }
       },
       onLoad: function() {
        this.getSrc(), this.isLoading = !1, this.$emit("load", this.src)
       },
       onError: function() {
        Object(h["b"])("Image load failed\n\n" + "src: ".concat(this.normalisedSrc.src), this), this.$emit("error", this.src)
       },
       getSrc: function() {
        this.image && (this.currentSrc = this.image.currentSrc || this.image.src)
       },
       loadImage: function() {
        var t = this,
         e = new Image;
        this.image = e, e.onload = function() {
         e.decode ? e.decode().catch((function(e) {
          Object(h["c"])("Failed to decode image, trying to render anyway\n\n" + "src: ".concat(t.normalisedSrc.src) + (e.message ? "\nOriginal error: ".concat(e.message) : ""), t)
         })).then(t.onLoad) : t.onLoad()
        }, e.onerror = this.onError, e.src = this.normalisedSrc.src, this.sizes && (e.sizes = this.sizes), this.normalisedSrc.srcset && (e.srcset = this.normalisedSrc.srcset), this.aspectRatio || this.pollForSize(e), this.getSrc()
       },
       pollForSize: function(t) {
        var e = this,
         n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100,
         r = function r() {
          var i = t.naturalHeight,
           o = t.naturalWidth;
          i || o ? (e.naturalWidth = o, e.calculatedAspectRatio = o / i) : null != n && setTimeout(r, n)
         };
        r()
       },
       genContent: function() {
        var t = l.options.methods.genContent.call(this);
        return this.naturalWidth && this._b(t.data, "div", {
         style: {
          width: "".concat(this.naturalWidth, "px")
         }
        }), t
       },
       __genPlaceholder: function() {
        if (this.$slots.placeholder) {
         var t = this.isLoading ? [this.$createElement("div", {
          staticClass: "v-image__placeholder"
         }, this.$slots.placeholder)] : [];
         return this.transition ? this.$createElement("transition", {
          props: {
           appear: !0,
           name: this.transition
          }
         }, t) : t[0]
        }
       }
      },
      render: function(t) {
       var e = l.options.render.call(this, t);
       return e.data.staticClass += " v-image", e.data.directives = this.hasIntersect ? [{
        name: "intersect",
        options: this.options,
        modifiers: {
         once: !0
        },
        value: this.init
       }] : [], e.data.attrs = {
        role: this.alt ? "img" : void 0,
        "aria-label": this.alt
       }, e.children = [this.__cachedSizer, this.__cachedImage, this.__genPlaceholder(), this.genContent()], t(e.tag, e.data, e.children)
      }
     }),
     f = n("80d2");
    e["a"] = o["a"].extend({
     name: "v-toolbar",
     props: {
      absolute: Boolean,
      bottom: Boolean,
      collapse: Boolean,
      dense: Boolean,
      extended: Boolean,
      extensionHeight: {
       default: 48,
       type: [Number, String]
      },
      flat: Boolean,
      floating: Boolean,
      prominent: Boolean,
      short: Boolean,
      src: {
       type: [String, Object],
       default: ""
      },
      tag: {
       type: String,
       default: "header"
      },
      tile: {
       type: Boolean,
       default: !0
      }
     },
     data: function() {
      return {
       isExtended: !1
      }
     },
     computed: {
      computedHeight: function() {
       var t = this.computedContentHeight;
       if (!this.isExtended) return t;
       var e = parseInt(this.extensionHeight);
       return this.isCollapsed ? t : t + (isNaN(e) ? 0 : e)
      },
      computedContentHeight: function() {
       return this.height ? parseInt(this.height) : this.isProminent && this.dense ? 96 : this.isProminent && this.short ? 112 : this.isProminent ? 128 : this.dense ? 48 : this.short || this.$vuetify.breakpoint.smAndDown ? 56 : 64
      },
      classes: function() {
       return Object(i["a"])({}, o["a"].options.computed.classes.call(this), {
        "v-toolbar": !0,
        "v-toolbar--absolute": this.absolute,
        "v-toolbar--bottom": this.bottom,
        "v-toolbar--collapse": this.collapse,
        "v-toolbar--collapsed": this.isCollapsed,
        "v-toolbar--dense": this.dense,
        "v-toolbar--extended": this.isExtended,
        "v-toolbar--flat": this.flat,
        "v-toolbar--floating": this.floating,
        "v-toolbar--prominent": this.isProminent
       })
      },
      isCollapsed: function() {
       return this.collapse
      },
      isProminent: function() {
       return this.prominent
      },
      styles: function() {
       return Object(i["a"])({}, this.measurableStyles, {
        height: Object(f["f"])(this.computedHeight)
       })
      }
     },
     created: function() {
      var t = this,
       e = [
        ["app", "<v-app-bar app>"],
        ["manual-scroll", '<v-app-bar :value="false">'],
        ["clipped-left", "<v-app-bar clipped-left>"],
        ["clipped-right", "<v-app-bar clipped-right>"],
        ["inverted-scroll", "<v-app-bar inverted-scroll>"],
        ["scroll-off-screen", "<v-app-bar scroll-off-screen>"],
        ["scroll-target", "<v-app-bar scroll-target>"],
        ["scroll-threshold", "<v-app-bar scroll-threshold>"],
        ["card", "<v-app-bar flat>"]
       ];
      e.forEach((function(e) {
       var n = Object(r["a"])(e, 2),
        i = n[0],
        o = n[1];
       t.$attrs.hasOwnProperty(i) && Object(h["a"])(i, o, t)
      }))
     },
     methods: {
      genBackground: function() {
       var t = {
         height: Object(f["f"])(this.computedHeight),
         src: this.src
        },
        e = this.$scopedSlots.img ? this.$scopedSlots.img({
         props: t
        }) : this.$createElement(p, {
         props: t
        });
       return this.$createElement("div", {
        staticClass: "v-toolbar__image"
       }, [e])
      },
      genContent: function() {
       return this.$createElement("div", {
        staticClass: "v-toolbar__content",
        style: {
         height: Object(f["f"])(this.computedContentHeight)
        }
       }, Object(f["m"])(this))
      },
      genExtension: function() {
       return this.$createElement("div", {
        staticClass: "v-toolbar__extension",
        style: {
         height: Object(f["f"])(this.extensionHeight)
        }
       }, Object(f["m"])(this, "extension"))
      }
     },
     render: function(t) {
      this.isExtended = this.extended || !!this.$scopedSlots.extension;
      var e = [this.genContent()],
       n = this.setBackgroundColor(this.color, {
        class: this.classes,
        style: this.styles,
        on: this.$listeners
       });
      return this.isExtended && e.push(this.genExtension()), (this.src || this.$scopedSlots.img) && e.unshift(this.genBackground()), t(this.tag, n, e)
     }
    })
   },
   7418: function(t, e) {
    e.f = Object.getOwnPropertySymbols
   },
   7435: function(t, e, n) {},
   "746f": function(t, e, n) {
    var r = n("428f"),
     i = n("5135"),
     o = n("e538"),
     a = n("9bf2").f;
    t.exports = function(t) {
     var e = r.Symbol || (r.Symbol = {});
     i(e, t) || a(e, t, {
      value: o.f(t)
     })
    }
   },
   7496: function(t, e, n) {
    "use strict";
    var r = n("5530"),
     i = (n("df86"), n("7560")),
     o = n("58df");
    e["a"] = Object(o["a"])(i["a"]).extend({
     name: "v-app",
     props: {
      dark: {
       type: Boolean,
       default: void 0
      },
      id: {
       type: String,
       default: "app"
      },
      light: {
       type: Boolean,
       default: void 0
      }
     },
     computed: {
      isDark: function() {
       return this.$vuetify.theme.dark
      }
     },
     beforeCreate: function() {
      if (!this.$vuetify || this.$vuetify === this.$root) throw new Error("Vuetify is not properly initialized, see https://vuetifyjs.com/getting-started/quick-start#bootstrapping-the-vuetify-object")
     },
     render: function(t) {
      var e = t("div", {
       staticClass: "v-application--wrap"
      }, this.$slots.default);
      return t("div", {
       staticClass: "v-application",
       class: Object(r["a"])({
        "v-application--is-rtl": this.$vuetify.rtl,
        "v-application--is-ltr": !this.$vuetify.rtl
       }, this.themeClasses),
       attrs: {
        "data-app": !0
       },
       domProps: {
        id: this.id
       }
      }, [e])
     }
    })
   },
   7560: function(t, e, n) {
    "use strict";
    n.d(e, "b", (function() {
     return o
    }));
    var r = n("5530"),
     i = n("2b0e");
 
    function o(t) {
     var e = Object(r["a"])({}, t.props, {}, t.injections),
      n = a.options.computed.isDark.call(e);
     return a.options.computed.themeClasses.call({
      isDark: n
     })
    }
    var a = i["a"].extend().extend({
     name: "themeable",
     provide: function() {
      return {
       theme: this.themeableProvide
      }
     },
     inject: {
      theme: {
       default: {
        isDark: !1
       }
      }
     },
     props: {
      dark: {
       type: Boolean,
       default: null
      },
      light: {
       type: Boolean,
       default: null
      }
     },
     data: function() {
      return {
       themeableProvide: {
        isDark: !1
       }
      }
     },
     computed: {
      appIsDark: function() {
       return this.$vuetify.theme.dark || !1
      },
      isDark: function() {
       return !0 === this.dark || !0 !== this.light && this.theme.isDark
      },
      themeClasses: function() {
       return {
        "theme--dark": this.isDark,
        "theme--light": !this.isDark
       }
      },
      rootIsDark: function() {
       return !0 === this.dark || !0 !== this.light && this.appIsDark
      },
      rootThemeClasses: function() {
       return {
        "theme--dark": this.rootIsDark,
        "theme--light": !this.rootIsDark
       }
      }
     },
     watch: {
      isDark: {
       handler: function(t, e) {
        t !== e && (this.themeableProvide.isDark = this.isDark)
       },
       immediate: !0
      }
     }
    });
    e["a"] = a
   },
   "75eb": function(t, e, n) {
    "use strict";
    n("4160"), n("159b");
    var r = n("ade3"),
     i = n("53ca"),
     o = n("9d65"),
     a = n("80d2"),
     s = n("58df"),
     u = n("d9bd");
 
    function c(t) {
     var e = Object(i["a"])(t);
     return "boolean" === e || "string" === e || t.nodeType === Node.ELEMENT_NODE
    }
    e["a"] = Object(s["a"])(o["a"]).extend({
     name: "detachable",
     props: {
      attach: {
       default: !1,
       validator: c
      },
      contentClass: {
       type: String,
       default: ""
      }
     },
     data: function() {
      return {
       activatorNode: null,
       hasDetached: !1
      }
     },
     watch: {
      attach: function() {
       this.hasDetached = !1, this.initDetach()
      },
      hasContent: function() {
       this.$nextTick(this.initDetach)
      }
     },
     beforeMount: function() {
      var t = this;
      this.$nextTick((function() {
       if (t.activatorNode) {
        var e = Array.isArray(t.activatorNode) ? t.activatorNode : [t.activatorNode];
        e.forEach((function(e) {
         if (e.elm && t.$el.parentNode) {
          var n = t.$el === t.$el.parentNode.firstChild ? t.$el : t.$el.nextSibling;
          t.$el.parentNode.insertBefore(e.elm, n)
         }
        }))
       }
      }))
     },
     mounted: function() {
      this.hasContent && this.initDetach()
     },
     deactivated: function() {
      this.isActive = !1
     },
     beforeDestroy: function() {
      try {
       if (this.$refs.content && this.$refs.content.parentNode && this.$refs.content.parentNode.removeChild(this.$refs.content), this.activatorNode) {
        var t = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode];
        t.forEach((function(t) {
         t.elm && t.elm.parentNode && t.elm.parentNode.removeChild(t.elm)
        }))
       }
      } catch (e) {
       console.log(e)
      }
     },
     methods: {
      getScopeIdAttrs: function() {
       var t = Object(a["k"])(this.$vnode, "context.$options._scopeId");
       return t && Object(r["a"])({}, t, "")
      },
      initDetach: function() {
       var t;
       this._isDestroyed || !this.$refs.content || this.hasDetached || "" === this.attach || !0 === this.attach || "attach" === this.attach || (t = !1 === this.attach ? document.querySelector("[data-app]") : "string" === typeof this.attach ? document.querySelector(this.attach) : this.attach, t ? (t.appendChild(this.$refs.content), this.hasDetached = !0) : Object(u["c"])("Unable to locate target ".concat(this.attach || "[data-app]"), this))
      }
     }
    })
   },
   7839: function(t, e) {
    t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
   },
   "7a77": function(t, e, n) {
    "use strict";
 
    function r(t) {
     this.message = t
    }
    r.prototype.toString = function() {
     return "Cancel" + (this.message ? ": " + this.message : "")
    }, r.prototype.__CANCEL__ = !0, t.exports = r
   },
   "7aac": function(t, e, n) {
    "use strict";
    var r = n("c532");
    t.exports = r.isStandardBrowserEnv() ? function() {
     return {
      write: function(t, e, n, i, o, a) {
       var s = [];
       s.push(t + "=" + encodeURIComponent(e)), r.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), r.isString(i) && s.push("path=" + i), r.isString(o) && s.push("domain=" + o), !0 === a && s.push("secure"), document.cookie = s.join("; ")
      },
      read: function(t) {
       var e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
       return e ? decodeURIComponent(e[3]) : null
      },
      remove: function(t) {
       this.write(t, "", Date.now() - 864e5)
      }
     }
    }() : function() {
     return {
      write: function() {},
      read: function() {
       return null
      },
      remove: function() {}
     }
    }()
   },
   "7b0b": function(t, e, n) {
    var r = n("1d80");
    t.exports = function(t) {
     return Object(r(t))
    }
   },
   "7c3e": function(t, e, n) {
    "use strict";
    (function(t, r, i) {
     n.d(e, "a", (function() {
      return Tp
     }));
     /**
      * @license
      * Copyright 2020 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      */
     var o = function(t, e) {
      return (o = Object.setPrototypeOf || {
        __proto__: []
       }
       instanceof Array && function(t, e) {
        t.__proto__ = e
       } || function(t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
       })(t, e)
     };
 
     function a(t, e) {
      function n() {
       this.constructor = t
      }
      o(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
     }
 
     function s(t, e, n, r) {
      return new(n || (n = Promise))((function(i, o) {
       function a(t) {
        try {
         u(r.next(t))
        } catch (t) {
         o(t)
        }
       }
 
       function s(t) {
        try {
         u(r.throw(t))
        } catch (t) {
         o(t)
        }
       }
 
       function u(t) {
        t.done ? i(t.value) : new n((function(e) {
         e(t.value)
        })).then(a, s)
       }
       u((r = r.apply(t, e || [])).next())
      }))
     }
 
     function u(t, e) {
      var n, r, i, o, a = {
       label: 0,
       sent: function() {
        if (1 & i[0]) throw i[1];
        return i[1]
       },
       trys: [],
       ops: []
      };
      return o = {
       next: s(0),
       throw: s(1),
       return: s(2)
      }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
       return this
      }), o;
 
      function s(o) {
       return function(s) {
        return function(o) {
         if (n) throw new TypeError("Generator is already executing.");
         for (; a;) try {
          if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
          switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
           case 0:
           case 1:
            i = o;
            break;
           case 4:
            return a.label++, {
             value: o[1],
             done: !1
            };
           case 5:
            a.label++, r = o[1], o = [0];
            continue;
           case 7:
            o = a.ops.pop(), a.trys.pop();
            continue;
           default:
            if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
             a = 0;
             continue
            }
            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
             a.label = o[1];
             break
            }
            if (6 === o[0] && a.label < i[1]) {
             a.label = i[1], i = o;
             break
            }
            if (i && a.label < i[2]) {
             a.label = i[2], a.ops.push(o);
             break
            }
            i[2] && a.ops.pop(), a.trys.pop();
            continue
          }
          o = e.call(t, a)
         } catch (t) {
          o = [6, t], r = 0
         } finally {
          n = i = 0
         }
         if (5 & o[0]) throw o[1];
         return {
          value: o[0] ? o[1] : void 0,
          done: !0
         }
        }([o, s])
       }
      }
     }
     var c = function() {
      function t(t) {
       this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags()
      }
      return t.prototype.setPlatform = function(t, e) {
       null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e + "."), this.platformName = t, this.platform = e
      }, t.prototype.registerFlag = function(t, e, n) {
       if (this.flagRegistry[t] = {
         evaluationFn: e,
         setHook: n
        }, null != this.urlFlags[t]) {
        var r = this.urlFlags[t];
        console.warn("Setting feature override from URL " + t + ": " + r + "."), this.set(t, r)
       }
      }, t.prototype.get = function(t) {
       return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t])
      }, t.prototype.getNumber = function(t) {
       return this.get(t)
      }, t.prototype.getBool = function(t) {
       return this.get(t)
      }, t.prototype.getFlags = function() {
       return this.flags
      }, Object.defineProperty(t.prototype, "features", {
       get: function() {
        return this.flags
       },
       enumerable: !0,
       configurable: !0
      }), t.prototype.set = function(t, e) {
       if (null == this.flagRegistry[t]) throw new Error("Cannot set flag " + t + " as it has not been registered.");
       this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e)
      }, t.prototype.evaluateFlag = function(t) {
       if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.");
       return this.flagRegistry[t].evaluationFn()
      }, t.prototype.setFlags = function(t) {
       this.flags = Object.assign({}, t)
      }, t.prototype.reset = function() {
       this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
      }, t.prototype.populateURLFlags = function() {
       var t = this;
       if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
        var e, n, r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (function(t) {
         for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
         return l(n, e[0], e[1]), e.join("=")
        })), n);
        "tfjsflags" in r && r.tfjsflags.split(",").forEach((function(e) {
         var n = e.split(":"),
          r = n[0],
          i = n[1];
         t.urlFlags[r] = function(t, e) {
          if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
          if ("" + +e === e) return +e;
          throw new Error("Could not parse value flag value " + e + " for flag " + t + ".")
         }(r, i)
        }))
       }
      }, t
     }();
 
     function l(t, e, n) {
      t[decodeURIComponent(e)] = decodeURIComponent(n || "")
     }
 
     function h() {
      return p
     }
     var p = null,
      f = new Map,
      d = new Map;
 
     function v(t, e) {
      var n = x(t, e);
      return f.get(n)
     }
 
     function m(t) {
      return d.get(t)
     }
 
     function g(t) {
      for (var e = f.entries(), n = [];;) {
       var r = e.next(),
        i = r.done,
        o = r.value;
       if (i) break;
       var a = o[0],
        s = o[1];
       a.split("_")[0] === t && n.push(s)
      }
      return n
     }
 
     function y(t) {
      var e = t.kernelName,
       n = t.backendName,
       r = x(e, n);
      if (f.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered");
      f.set(r, t)
     }
 
     function b(t) {
      var e = t.kernelName;
      d.has(e) && console.warn("Overriding the gradient for '" + e + "'"), d.set(e, t)
     }
 
     function x(t, e) {
      return e + "_" + t
     }
 
     function w(t) {
      for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n
     }
 
     function C(t, e, n) {
      return Math.max(t, Math.min(e, n))
     }
 
     function S(t) {
      return t % 2 == 0 ? t : t + 1
     }
 
     function E(t) {
      for (var e = 0, n = 0; n < t.length; n++) e += t[n];
      return e
     }
 
     function k(t, e) {
      if (!t) throw new Error("string" == typeof e ? e : e())
     }
 
     function I(t, e, n) {
      void 0 === n && (n = ""), k(R(t, e), (function() {
       return n + " Shapes " + t + " and " + e + " must match"
      }))
     }
 
     function O(t) {
      k(null != t, (function() {
       return "The input to the tensor constructor must be a non-null value."
      }))
     }
 
     function A(t, e, n) {
      if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || H(t) && !n)
       for (var r = 0; r < t.length; ++r) A(t[r], e, n);
      else e.push(t);
      return e
     }
 
     function N(t) {
      if (0 === t.length) return 1;
      for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];
      return e
     }
 
     function R(t, e) {
      if (t === e) return !0;
      if (null == t || null == e) return !1;
      if (t.length !== e.length) return !1;
      for (var n = 0; n < t.length; n++)
       if (t[n] !== e[n]) return !1;
      return !0
     }
 
     function T(t) {
      return t % 1 == 0
     }
 
     function _(t) {
      if (null != Math.tanh) return Math.tanh(t);
      if (t === 1 / 0) return 1;
      if (t === -1 / 0) return -1;
      var e = Math.exp(2 * t);
      return (e - 1) / (e + 1)
     }
 
     function D(t) {
      var e = Math.ceil(Math.sqrt(t));
      return [e, Math.ceil(t / e)]
     }
 
     function F(t, e) {
      return e <= t.length ? t : t + " ".repeat(e - t.length)
     }
 
     function M(t, e, n) {
      return void 0 === e && (e = function(t) {
       return 0
      }), new Promise((function(r, i) {
       var o = 0,
        a = function() {
         if (t()) r();
         else {
          o++;
          var s = e(o);
          null != n && o >= n ? i() : setTimeout(a, s)
         }
        };
       a()
      }))
     }
 
     function L(t, e) {
      for (var n = 1, r = -1, i = 0; i < t.length; ++i)
       if (t[i] >= 0) n *= t[i];
       else if (-1 === t[i]) {
       if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + i);
       r = i
      } else if (t[i] < 0) throw Error("Shapes can not be < 0. Found " + t[i] + " at dim " + i);
      if (-1 === r) {
       if (e > 0 && e !== n) throw Error("Size(" + e + ") must match the product of shape " + t);
       return t
      }
      if (0 === n) throw Error("Cannot infer the missing size in [" + t + "] when there are 0 elements");
      if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + n);
      var o = t.slice();
      return o[r] = e / n, o
     }
 
     function B(t, e) {
      var n = e.length;
      return k((t = null == t ? e.map((function(t, e) {
       return e
      })) : [].concat(t)).every((function(t) {
       return t >= -n && t < n
      })), (function() {
       return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + t
      })), k(t.every((function(t) {
       return T(t)
      })), (function() {
       return "All values in axis param must be integers but got axis " + t
      })), t.map((function(t) {
       return t < 0 ? n + t : t
      }))
     }
 
     function P(t, e) {
      for (var n = [], r = [], i = null != e && Array.isArray(e) && 0 === e.length, o = null == e || i ? null : B(e, t).sort(), a = 0, s = 0; s < t.length; ++s) {
       if (null != o) {
        if (o[a] === s && 1 !== t[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + t[s] + "' is not 1");
        (null == o[a] || o[a] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), o[a] <= s && a++
       }
       1 !== t[s] && (n.push(t[s]), r.push(s))
      }
      return {
       newShape: n,
       keptDims: r
      }
     }
 
     function z(t, e) {
      var n = null;
      if (null == t || "float32" === t) n = new Float32Array(e);
      else if ("int32" === t) n = new Int32Array(e);
      else {
       if ("bool" !== t) throw new Error("Unknown data type " + t);
       n = new Uint8Array(e)
      }
      return n
     }
 
     function j(t, e) {
      var n = null;
      if (null == t || "float32" === t) n = new Float32Array(e);
      else if ("int32" === t) n = new Int32Array(e);
      else if ("bool" === t) n = new Uint8Array(e);
      else {
       if ("string" !== t) throw new Error("Unknown data type " + t);
       n = new Array(e)
      }
      return n
     }
 
     function W(t, e) {
      for (var n = 0; n < t.length; n++) {
       var r = t[n];
       if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".")
      }
     }
 
     function V(t) {
      return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t
     }
 
     function U(t, e) {
      return "complex64" !== e && ("float32" !== e || "complex64" === t) && ("int32" !== e || "float32" === t || "complex64" === t) && ("bool" !== e || "bool" !== t)
     }
 
     function H(t) {
      return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array
     }
 
     function $(t) {
      if ("float32" === t || "int32" === t) return 4;
      if ("complex64" === t) return 8;
      if ("bool" === t) return 1;
      throw new Error("Unknown dtype " + t)
     }
 
     function G(t) {
      if (null == t) return 0;
      var e = 0;
      return t.forEach((function(t) {
       return e += t.length
      })), e
     }
 
     function q(t) {
      return "string" == typeof t || t instanceof String
     }
 
     function K(t) {
      return "boolean" == typeof t
     }
 
     function X(t) {
      return "number" == typeof t
     }
 
     function Y(t) {
      return Array.isArray(t) ? Y(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : X(t) ? "float32" : q(t) ? "string" : K(t) ? "bool" : "float32"
     }
 
     function Z(t) {
      return !!(t && t.constructor && t.call && t.apply)
     }
 
     function J(t, e) {
      for (var n = e; n < t; ++n)
       if (t % n == 0) return n;
      return t
     }
 
     function Q(t) {
      var e = t.length;
      if (e < 2) return [];
      var n = new Array(e - 1);
      n[e - 2] = t[e - 1];
      for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];
      return n
     }
 
     function tt(t, e, n) {
      if ("string" === e) throw new Error("Cannot convert a string[] to a TypedArray");
      if (Array.isArray(t) && (t = A(t)), n && W(t, e), function(t, e) {
        return t instanceof Float32Array && "float32" === e || t instanceof Int32Array && "int32" === e || t instanceof Uint8Array && "bool" === e
       }(t, e)) return t;
      if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
      if ("int32" === e) return new Int32Array(t);
      if ("bool" === e) {
       for (var r = new Uint8Array(t.length), i = 0; i < r.length; ++i) 0 !== Math.round(t[i]) && (r[i] = 1);
       return r
      }
      throw new Error("Unknown data type " + e)
     }
 
     function et(t, e) {
      if (0 === t.length) return e[0];
      var n = t.reduce((function(t, e) {
       return t * e
      }));
      if (0 === n) return [];
      if (n !== e.length) throw new Error("[" + t + "] does not match the input size.");
      return function t(e, n, r) {
       var i = new Array;
       if (1 === n.length)
        for (var o = n[0], a = 0; a < o; a++) i[a] = r[e + a];
       else {
        o = n[0];
        var s = n.slice(1),
         u = s.reduce((function(t, e) {
          return t * e
         }));
        for (a = 0; a < o; a++) i[a] = t(e + a * u, s, r)
       }
       return i
      }(0, t, e)
     }
 
     function nt(t, e) {
      for (var n = rt(t, e), r = 0; r < n.length; r++) n[r] = 1;
      return n
     }
 
     function rt(t, e) {
      if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
      if ("int32" === e) return new Int32Array(t);
      if ("bool" === e) return new Uint8Array(t);
      throw new Error("Unknown data type " + e)
     }
 
     function it() {
      return h().platform.now()
     }
 
     function ot(t) {
      t.forEach((function(e) {
       k(Number.isInteger(e) && e >= 0, (function() {
        return "Tensor must have a shape comprised of positive integers but got shape [" + t + "]."
       }))
      }))
     }
 
     function at(t, e) {
      return void 0 === e && (e = "utf-8"), e = e || "utf-8", h().platform.encode(t, e)
     }
 
     function st(t, e) {
      return void 0 === e && (e = "utf-8"), e = e || "utf-8", h().platform.decode(t, e)
     }
     Object.freeze({
      shuffle: w,
      clamp: C,
      nearestLargerEven: S,
      sum: E,
      randUniform: function(t, e) {
       var n = Math.random();
       return e * n + (1 - n) * t
      },
      distSquared: function(t, e) {
       for (var n = 0, r = 0; r < t.length; r++) {
        var i = Number(t[r]) - Number(e[r]);
        n += i * i
       }
       return n
      },
      assert: k,
      assertShapesMatch: I,
      assertNonNull: O,
      flatten: A,
      sizeFromShape: N,
      isScalarShape: function(t) {
       return 0 === t.length
      },
      arraysEqual: R,
      isInt: T,
      tanh: _,
      sizeToSquarishShape: D,
      createShuffledIndices: function(t) {
       for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;
       return w(e), e
      },
      rightPad: F,
      repeatedTry: M,
      inferFromImplicitShape: L,
      parseAxisParam: B,
      squeezeShape: P,
      getTypedArrayFromDType: z,
      getArrayFromDType: j,
      checkConversionForErrors: W,
      isValidDtype: V,
      hasEncodingLoss: U,
      isTypedArray: H,
      bytesPerElement: $,
      bytesFromStringArray: G,
      isString: q,
      isBoolean: K,
      isNumber: X,
      inferDtype: Y,
      isFunction: Z,
      nearestDivisor: J,
      computeStrides: Q,
      toTypedArray: tt,
      toNestedArray: et,
      makeOnesTypedArray: nt,
      makeZerosTypedArray: rt,
      now: it,
      assertNonNegativeIntegerDimensions: ot,
      fetch: function(t, e) {
       return h().platform.fetch(t, e)
      },
      encodeString: at,
      decodeString: st
     });
     var ut = function() {
       function t(t, e) {
        this.backendTimer = t, this.logger = e, null == e && (this.logger = new ct)
       }
       return t.prototype.profileKernel = function(t, e, n) {
        var r, i = this,
         o = this.backendTimer.time((function() {
          r = n()
         }));
        return r.forEach((function(n) {
         n.data().then((function(r) {
          ! function(t, e, n) {
           if ("float32" !== e) return !1;
           for (var r = 0; r < t.length; r++) {
            var i = t[r];
            if (isNaN(i) || !isFinite(i)) return console.warn("Found " + i + " in the result of '" + n + "'"), !0
           }
          }(r, n.dtype, t), o.then((function(o) {
           var a = "";
           null != o.getExtraProfileInfo && (a = o.getExtraProfileInfo()), i.logger.logKernelProfile(t, n, r, o.kernelMs, e, a)
          }))
         }))
        })), r
       }, t
      }(),
      ct = function() {
       function t() {}
       return t.prototype.logKernelProfile = function(t, e, n, r, i, o) {
        var a = F(r + "ms", 9),
         s = F(t, 25),
         u = e.rank,
         c = e.size,
         l = F(e.shape.toString(), 14),
         h = "";
        for (var p in i) {
         var f = i[p].shape || e.shape,
          d = f.length;
         h += p + ": " + d + "D " + (d > 0 ? f : "") + " "
        }
        console.log("%c" + s + "\t%c" + a + "\t%c" + u + "D " + l + "\t%c" + c + "\t%c" + h + "\t%c" + o, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
       }, t
      }(),
      lt = 20,
      ht = 3,
      pt = 7;
 
     function ft(t, e, n, r) {
      var i = Q(e),
       o = function(t, e, n, r) {
        var i = N(e),
         o = r[r.length - 1],
         a = new Array(o).fill(0),
         s = e.length,
         u = "complex64" === n ? mt(t) : t;
        if (s > 1)
         for (var c = 0; c < i / o; c++)
          for (var l = c * o, h = 0; h < o; h++) a[h] = Math.max(a[h], dt(u[l + h], 0, n).length);
        return a
       }(t, e, n, i),
       a = e.length,
       s = function t(e, n, r, i, o, a) {
        void 0 === a && (a = !0);
        var s = "complex64" === r ? 2 : 1,
         u = n[0],
         c = n.length;
        if (0 === c) return "complex64" === r ? [dt(mt(e)[0], 0, r)] : "bool" === r ? [vt(e[0])] : [e[0].toString()];
        if (1 === c) {
         if (u > lt) {
          var l = ht * s,
           h = Array.from(e.slice(0, l)),
           p = Array.from(e.slice((u - ht) * s, u * s));
          return "complex64" === r && (h = mt(h), p = mt(p)), ["[" + h.map((function(t, e) {
           return dt(t, o[e], r)
          })).join(", ") + ", ..., " + p.map((function(t, e) {
           return dt(t, o[u - ht + e], r)
          })).join(", ") + "]"]
         }
         return ["[" + ("complex64" === r ? mt(e) : Array.from(e)).map((function(t, e) {
          return dt(t, o[e], r)
         })).join(", ") + "]"]
        }
        var f = n.slice(1),
         d = i.slice(1),
         v = i[0] * s,
         m = [];
        if (u > lt) {
         for (var g = 0; g < ht; g++) {
          var y = (b = g * v) + v;
          m.push.apply(m, t(e.slice(b, y), f, r, d, o, !1))
         }
         for (m.push("..."), g = u - ht; g < u; g++) y = (b = g * v) + v, m.push.apply(m, t(e.slice(b, y), f, r, d, o, g === u - 1))
        } else
         for (g = 0; g < u; g++) {
          var b;
          y = (b = g * v) + v, m.push.apply(m, t(e.slice(b, y), f, r, d, o, g === u - 1))
         }
        var x = 2 === c ? "," : "";
        for (m[0] = "[" + m[0] + x, g = 1; g < m.length - 1; g++) m[g] = " " + m[g] + x;
        var w = ",\n";
        for (g = 2; g < c; g++) w += "\n";
        return m[m.length - 1] = " " + m[m.length - 1] + "]" + (a ? "" : w), m
       }(t, e, n, i, o),
       u = ["Tensor"];
      return r && (u.push("  dtype: " + n), u.push("  rank: " + a), u.push("  shape: [" + e + "]"), u.push("  values:")), u.push(s.map((function(t) {
       return "    " + t
      })).join("\n")), u.join("\n")
     }
 
     function dt(t, e, n) {
      return F(Array.isArray(t) ? parseFloat(t[0].toFixed(pt)) + " + " + parseFloat(t[1].toFixed(pt)) + "j" : q(t) ? "'" + t + "'" : "bool" === n ? vt(t) : parseFloat(t.toFixed(pt)).toString(), e)
     }
 
     function vt(t) {
      return 0 === t ? "false" : "true"
     }
 
     function mt(t) {
      for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);
      return e
     }
     var gt = function() {
       function t(t, e, n) {
        var r = this;
        if (this.dtype = e, this.shape = t.slice(), this.size = N(t), null != n) {
         var i = n.length;
         k(i === this.size, (function() {
          return "Length of values '" + i + "' does not match the size inferred by the shape '" + r.size + "'."
         }))
        }
        if ("complex64" === e) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
        this.values = n || j(e, this.size), this.strides = Q(t)
       }
       return t.prototype.set = function(t) {
        for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
        0 === n.length && (n = [0]), k(n.length === this.rank, (function() {
         return "The number of provided coordinates (" + n.length + ") must match the rank (" + e.rank + ")"
        }));
        var i = this.locToIndex(n);
        this.values[i] = t
       }, t.prototype.get = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        0 === t.length && (t = [0]);
        for (var n = 0, r = 0, i = t; r < i.length; r++) {
         var o = i[r];
         if (o < 0 || o >= this.shape[n]) {
          var a = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
          throw new Error(a)
         }
         n++
        }
        for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u) s += this.strides[u] * t[u];
        return this.values[s]
       }, t.prototype.locToIndex = function(t) {
        if (0 === this.rank) return 0;
        if (1 === this.rank) return t[0];
        for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];
        return e
       }, t.prototype.indexToLoc = function(t) {
        if (0 === this.rank) return [];
        if (1 === this.rank) return [t];
        for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];
        return e[e.length - 1] = t, e
       }, Object.defineProperty(t.prototype, "rank", {
        get: function() {
         return this.shape.length
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.toTensor = function() {
        return yt().makeTensor(this.values, this.shape, this.dtype)
       }, t
      }(),
      yt = null,
      bt = null,
      xt = null,
      wt = function() {
       function t(t, e, n, r) {
        this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || "float32", this.size = N(t), this.strides = Q(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
       }
       return t.prototype.flatten = function() {
        return this.throwIfDisposed(), this.as1D()
       }, t.prototype.asScalar = function() {
        return this.throwIfDisposed(), k(1 === this.size, (function() {
         return "The array must have only 1 element."
        })), this.reshape([])
       }, t.prototype.as1D = function() {
        return this.throwIfDisposed(), this.reshape([this.size])
       }, t.prototype.as2D = function(t, e) {
        return this.throwIfDisposed(), this.reshape([t, e])
       }, t.prototype.as3D = function(t, e, n) {
        return this.throwIfDisposed(), this.reshape([t, e, n])
       }, t.prototype.as4D = function(t, e, n, r) {
        return this.throwIfDisposed(), this.reshape([t, e, n, r])
       }, t.prototype.as5D = function(t, e, n, r, i) {
        return this.throwIfDisposed(), this.reshape([t, e, n, r, i])
       }, t.prototype.asType = function(t) {
        return this.throwIfDisposed(), bt.cast(this, t)
       }, Object.defineProperty(t.prototype, "rank", {
        get: function() {
         return this.shape.length
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.buffer = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.data()];
           case 1:
            return t = e.sent(), [2, bt.buffer(this.shape, this.dtype, t)]
          }
         }))
        }))
       }, t.prototype.bufferSync = function() {
        return bt.buffer(this.shape, this.dtype, this.dataSync())
       }, t.prototype.array = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return [4, this.data()];
           case 1:
            return t = e.sent(), [2, et(this.shape, t)]
          }
         }))
        }))
       }, t.prototype.arraySync = function() {
        return et(this.shape, this.dataSync())
       }, t.prototype.data = function() {
        return s(this, void 0, void 0, (function() {
         var t, e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return this.throwIfDisposed(), t = yt().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t];
           case 1:
            e = n.sent();
            try {
             return [2, e.map((function(t) {
              return st(t)
             }))]
            } catch (t) {
             throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
            }
            n.label = 2;
           case 2:
            return [2, t]
          }
         }))
        }))
       }, t.prototype.dataSync = function() {
        this.throwIfDisposed();
        var t = yt().readSync(this.dataId);
        if ("string" === this.dtype) try {
         return t.map((function(t) {
          return st(t)
         }))
        } catch (t) {
         throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
        }
        return t
       }, t.prototype.bytes = function() {
        return s(this, void 0, void 0, (function() {
         var t;
         return u(this, (function(e) {
          switch (e.label) {
           case 0:
            return this.throwIfDisposed(), [4, yt().read(this.dataId)];
           case 1:
            return t = e.sent(), "string" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)]
          }
         }))
        }))
       }, t.prototype.dispose = function() {
        this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0)
       }, Object.defineProperty(t.prototype, "isDisposed", {
        get: function() {
         return this.isDisposedInternal
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.throwIfDisposed = function() {
        if (this.isDisposed) throw new Error("Tensor is disposed.")
       }, t.prototype.toFloat = function() {
        return this.asType("float32")
       }, t.prototype.toInt = function() {
        return this.asType("int32")
       }, t.prototype.toBool = function() {
        return this.asType("bool")
       }, t.prototype.print = function(t) {
        return void 0 === t && (t = !1), bt.print(this, t)
       }, t.prototype.reshape = function(t) {
        return this.throwIfDisposed(), bt.reshape(this, t)
       }, t.prototype.reshapeAs = function(t) {
        return this.throwIfDisposed(), this.reshape(t.shape)
       }, t.prototype.expandDims = function(t) {
        return void 0 === t && (t = 0), bt.expandDims(this, t)
       }, t.prototype.cumsum = function(t, e, n) {
        return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), bt.cumsum(this, t, e, n)
       }, t.prototype.squeeze = function(t) {
        return this.throwIfDisposed(), bt.squeeze(this, t)
       }, t.prototype.clone = function() {
        return this.throwIfDisposed(), bt.clone(this)
       }, t.prototype.oneHot = function(t, e, n) {
        return this.throwIfDisposed(), bt.oneHot(this, t, e, n)
       }, t.prototype.toString = function(t) {
        return void 0 === t && (t = !1), ft(this.dataSync(), this.shape, this.dtype, t)
       }, t.prototype.tile = function(t) {
        return this.throwIfDisposed(), bt.tile(this, t)
       }, t.prototype.gather = function(t, e) {
        return void 0 === e && (e = 0), this.throwIfDisposed(), bt.gather(this, t, e)
       }, t.prototype.matMul = function(t, e, n) {
        return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), bt.matMul(this, t, e, n)
       }, t.prototype.dot = function(t) {
        return this.throwIfDisposed(), bt.dot(this, t)
       }, t.prototype.norm = function(t, e, n) {
        return void 0 === t && (t = "euclidean"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), bt.norm(this, t, e, n)
       }, t.prototype.slice = function(t, e) {
        return this.throwIfDisposed(), bt.slice(this, t, e)
       }, t.prototype.reverse = function(t) {
        return this.throwIfDisposed(), bt.reverse(this, t)
       }, t.prototype.concat = function(e, n) {
        return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), bt.concat([this].concat(e), n)
       }, t.prototype.split = function(t, e) {
        return void 0 === e && (e = 0), this.throwIfDisposed(), bt.split(this, t, e)
       }, t.prototype.stack = function(t, e) {
        return void 0 === e && (e = 0), bt.stack([this, t], e)
       }, t.prototype.unstack = function(t) {
        return void 0 === t && (t = 0), bt.unstack(this, t)
       }, t.prototype.pad = function(t, e) {
        return void 0 === e && (e = 0), bt.pad(this, t, e)
       }, t.prototype.batchNormalization = function(t, e, n, r, i) {
        return void 0 === n && (n = .001), xt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t, e, i, r, n)
       }, t.prototype.batchNorm = function(t, e, n, r, i) {
        return void 0 === i && (i = .001), this.throwIfDisposed(), bt.batchNorm(this, t, e, n, r, i)
       }, t.prototype.all = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.all(this, t, e)
       }, t.prototype.any = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.any(this, t, e)
       }, t.prototype.logSumExp = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.logSumExp(this, t, e)
       }, t.prototype.sum = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.sum(this, t, e)
       }, t.prototype.prod = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.prod(this, t, e)
       }, t.prototype.mean = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.mean(this, t, e)
       }, t.prototype.min = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.min(this, t, e)
       }, t.prototype.max = function(t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), bt.max(this, t, e)
       }, t.prototype.argMin = function(t) {
        return void 0 === t && (t = null), this.throwIfDisposed(), bt.argMin(this, t)
       }, t.prototype.argMax = function(t) {
        return void 0 === t && (t = null), this.throwIfDisposed(), bt.argMax(this, t)
       }, t.prototype.cast = function(t) {
        return this.throwIfDisposed(), bt.cast(this, t)
       }, t.prototype.add = function(t) {
        return this.throwIfDisposed(), bt.add(this, t)
       }, t.prototype.addStrict = function(t) {
        return this.throwIfDisposed(), bt.addStrict(this, t)
       }, t.prototype.atan2 = function(t) {
        return this.throwIfDisposed(), bt.atan2(this, t)
       }, t.prototype.sub = function(t) {
        return this.throwIfDisposed(), bt.sub(this, t)
       }, t.prototype.subStrict = function(t) {
        return this.throwIfDisposed(), bt.subStrict(this, t)
       }, t.prototype.pow = function(t) {
        return this.throwIfDisposed(), bt.pow(this, t)
       }, t.prototype.powStrict = function(t) {
        return this.throwIfDisposed(), bt.powStrict(this, t)
       }, t.prototype.mul = function(t) {
        return this.throwIfDisposed(), bt.mul(this, t)
       }, t.prototype.mulStrict = function(t) {
        return this.throwIfDisposed(), bt.mulStrict(this, t)
       }, t.prototype.div = function(t) {
        return this.throwIfDisposed(), bt.div(this, t)
       }, t.prototype.divNoNan = function(t) {
        return this.throwIfDisposed(), bt.divNoNan(this, t)
       }, t.prototype.floorDiv = function(t) {
        return this.throwIfDisposed(), bt.floorDiv(this, t)
       }, t.prototype.divStrict = function(t) {
        return this.throwIfDisposed(), bt.divStrict(this, t)
       }, t.prototype.minimum = function(t) {
        return this.throwIfDisposed(), bt.minimum(this, t)
       }, t.prototype.minimumStrict = function(t) {
        return this.throwIfDisposed(), bt.minimumStrict(this, t)
       }, t.prototype.maximum = function(t) {
        return this.throwIfDisposed(), bt.maximum(this, t)
       }, t.prototype.maximumStrict = function(t) {
        return this.throwIfDisposed(), bt.maximumStrict(this, t)
       }, t.prototype.mod = function(t) {
        return this.throwIfDisposed(), bt.mod(this, t)
       }, t.prototype.modStrict = function(t) {
        return this.throwIfDisposed(), bt.modStrict(this, t)
       }, t.prototype.squaredDifference = function(t) {
        return this.throwIfDisposed(), bt.squaredDifference(this, t)
       }, t.prototype.squaredDifferenceStrict = function(t) {
        return this.throwIfDisposed(), bt.squaredDifferenceStrict(this, t)
       }, t.prototype.transpose = function(t) {
        return this.throwIfDisposed(), bt.transpose(this, t)
       }, t.prototype.notEqual = function(t) {
        return this.throwIfDisposed(), bt.notEqual(this, t)
       }, t.prototype.notEqualStrict = function(t) {
        return this.throwIfDisposed(), bt.notEqualStrict(this, t)
       }, t.prototype.less = function(t) {
        return this.throwIfDisposed(), bt.less(this, t)
       }, t.prototype.lessStrict = function(t) {
        return this.throwIfDisposed(), bt.lessStrict(this, t)
       }, t.prototype.equal = function(t) {
        return this.throwIfDisposed(), bt.equal(this, t)
       }, t.prototype.equalStrict = function(t) {
        return this.throwIfDisposed(), bt.equalStrict(this, t)
       }, t.prototype.lessEqual = function(t) {
        return this.throwIfDisposed(), bt.lessEqual(this, t)
       }, t.prototype.lessEqualStrict = function(t) {
        return this.throwIfDisposed(), bt.lessEqualStrict(this, t)
       }, t.prototype.greater = function(t) {
        return this.throwIfDisposed(), bt.greater(this, t)
       }, t.prototype.greaterStrict = function(t) {
        return this.throwIfDisposed(), bt.greaterStrict(this, t)
       }, t.prototype.greaterEqual = function(t) {
        return this.throwIfDisposed(), bt.greaterEqual(this, t)
       }, t.prototype.greaterEqualStrict = function(t) {
        return this.throwIfDisposed(), bt.greaterEqualStrict(this, t)
       }, t.prototype.logicalAnd = function(t) {
        return this.throwIfDisposed(), bt.logicalAnd(this, t)
       }, t.prototype.logicalOr = function(t) {
        return this.throwIfDisposed(), bt.logicalOr(this, t)
       }, t.prototype.logicalNot = function() {
        return this.throwIfDisposed(), bt.logicalNot(this)
       }, t.prototype.logicalXor = function(t) {
        return this.throwIfDisposed(), bt.logicalXor(this, t)
       }, t.prototype.where = function(t, e) {
        return this.throwIfDisposed(), bt.where(t, this, e)
       }, t.prototype.neg = function() {
        return this.throwIfDisposed(), bt.neg(this)
       }, t.prototype.ceil = function() {
        return this.throwIfDisposed(), bt.ceil(this)
       }, t.prototype.floor = function() {
        return this.throwIfDisposed(), bt.floor(this)
       }, t.prototype.sign = function() {
        return this.throwIfDisposed(), bt.sign(this)
       }, t.prototype.isNaN = function() {
        return this.throwIfDisposed(), bt.isNaN(this)
       }, t.prototype.isInf = function() {
        return this.throwIfDisposed(), bt.isInf(this)
       }, t.prototype.isFinite = function() {
        return this.throwIfDisposed(), bt.isFinite(this)
       }, t.prototype.exp = function() {
        return this.throwIfDisposed(), bt.exp(this)
       }, t.prototype.expm1 = function() {
        return this.throwIfDisposed(), bt.expm1(this)
       }, t.prototype.log = function() {
        return this.throwIfDisposed(), bt.log(this)
       }, t.prototype.log1p = function() {
        return this.throwIfDisposed(), bt.log1p(this)
       }, t.prototype.sqrt = function() {
        return this.throwIfDisposed(), bt.sqrt(this)
       }, t.prototype.rsqrt = function() {
        return this.throwIfDisposed(), bt.rsqrt(this)
       }, t.prototype.square = function() {
        return this.throwIfDisposed(), bt.square(this)
       }, t.prototype.reciprocal = function() {
        return this.throwIfDisposed(), bt.reciprocal(this)
       }, t.prototype.abs = function() {
        return this.throwIfDisposed(), bt.abs(this)
       }, t.prototype.clipByValue = function(t, e) {
        return this.throwIfDisposed(), bt.clipByValue(this, t, e)
       }, t.prototype.relu = function() {
        return this.throwIfDisposed(), bt.relu(this)
       }, t.prototype.relu6 = function() {
        return this.throwIfDisposed(), bt.relu6(this)
       }, t.prototype.elu = function() {
        return this.throwIfDisposed(), bt.elu(this)
       }, t.prototype.selu = function() {
        return this.throwIfDisposed(), bt.selu(this)
       }, t.prototype.leakyRelu = function(t) {
        return void 0 === t && (t = .2), this.throwIfDisposed(), bt.leakyRelu(this, t)
       }, t.prototype.prelu = function(t) {
        return this.throwIfDisposed(), bt.prelu(this, t)
       }, t.prototype.sigmoid = function() {
        return this.throwIfDisposed(), bt.sigmoid(this)
       }, t.prototype.logSigmoid = function() {
        return this.throwIfDisposed(), bt.logSigmoid(this)
       }, t.prototype.softplus = function() {
        return this.throwIfDisposed(), bt.softplus(this)
       }, t.prototype.zerosLike = function() {
        return this.throwIfDisposed(), bt.zerosLike(this)
       }, t.prototype.onesLike = function() {
        return this.throwIfDisposed(), bt.onesLike(this)
       }, t.prototype.sin = function() {
        return this.throwIfDisposed(), bt.sin(this)
       }, t.prototype.cos = function() {
        return this.throwIfDisposed(), bt.cos(this)
       }, t.prototype.tan = function() {
        return this.throwIfDisposed(), bt.tan(this)
       }, t.prototype.asin = function() {
        return this.throwIfDisposed(), bt.asin(this)
       }, t.prototype.acos = function() {
        return this.throwIfDisposed(), bt.acos(this)
       }, t.prototype.atan = function() {
        return this.throwIfDisposed(), bt.atan(this)
       }, t.prototype.sinh = function() {
        return this.throwIfDisposed(), bt.sinh(this)
       }, t.prototype.cosh = function() {
        return this.throwIfDisposed(), bt.cosh(this)
       }, t.prototype.tanh = function() {
        return this.throwIfDisposed(), bt.tanh(this)
       }, t.prototype.asinh = function() {
        return this.throwIfDisposed(), bt.asinh(this)
       }, t.prototype.acosh = function() {
        return this.throwIfDisposed(), bt.acosh(this)
       }, t.prototype.atanh = function() {
        return this.throwIfDisposed(), bt.atanh(this)
       }, t.prototype.erf = function() {
        return this.throwIfDisposed(), bt.erf(this)
       }, t.prototype.round = function() {
        return this.throwIfDisposed(), bt.round(this)
       }, t.prototype.step = function(t) {
        return void 0 === t && (t = 0), this.throwIfDisposed(), bt.step(this, t)
       }, t.prototype.softmax = function(t) {
        return void 0 === t && (t = -1), this.throwIfDisposed(), bt.softmax(this, t)
       }, t.prototype.logSoftmax = function(t) {
        return void 0 === t && (t = -1), this.throwIfDisposed(), bt.logSoftmax(this, t)
       }, t.prototype.resizeBilinear = function(t, e) {
        return void 0 === e && (e = !1), this.throwIfDisposed(), bt.image.resizeBilinear(this, t, e)
       }, t.prototype.resizeNearestNeighbor = function(t, e) {
        return void 0 === e && (e = !1), this.throwIfDisposed(), bt.image.resizeNearestNeighbor(this, t, e)
       }, t.prototype.conv1d = function(t, e, n, r, i, o) {
        return void 0 === r && (r = "NWC"), void 0 === i && (i = 1), this.throwIfDisposed(), bt.conv1d(this, t, e, n, r, i, o)
       }, t.prototype.conv2d = function(t, e, n, r, i, o) {
        return void 0 === r && (r = "NHWC"), void 0 === i && (i = [1, 1]), this.throwIfDisposed(), bt.conv2d(this, t, e, n, r, i, o)
       }, t.prototype.conv2dTranspose = function(t, e, n, r, i) {
        return this.throwIfDisposed(), bt.conv2dTranspose(this, t, e, n, r, i)
       }, t.prototype.depthwiseConv2D = function(t, e, n, r, i, o) {
        return void 0 === r && (r = "NHWC"), void 0 === i && (i = [1, 1]), this.throwIfDisposed(), bt.depthwiseConv2d(this, t, e, n, r, i, o)
       }, t.prototype.separableConv2d = function(t, e, n, r, i, o) {
        return void 0 === i && (i = [1, 1]), void 0 === o && (o = "NHWC"), this.throwIfDisposed(), bt.separableConv2d(this, t, e, n, r, i, o)
       }, t.prototype.avgPool = function(t, e, n, r) {
        return this.throwIfDisposed(), bt.avgPool(this, t, e, n, r)
       }, t.prototype.maxPool = function(t, e, n, r) {
        return this.throwIfDisposed(), bt.maxPool(this, t, e, n, r)
       }, t.prototype.localResponseNormalization = function(t, e, n, r) {
        return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), bt.localResponseNormalization(this, t, e, n, r)
       }, t.prototype.pool = function(t, e, n, r, i) {
        return this.throwIfDisposed(), bt.pool(this, t, e, n, r, i)
       }, t.prototype.variable = function(t, e, n) {
        return void 0 === t && (t = !0), this.throwIfDisposed(), yt().makeVariable(this, t, e, n)
       }, t.prototype.unsortedSegmentSum = function(t, e) {
        return this.throwIfDisposed(), bt.unsortedSegmentSum(this, t, e)
       }, t.prototype.batchToSpaceND = function(t, e) {
        return this.throwIfDisposed(), bt.batchToSpaceND(this, t, e)
       }, t.prototype.spaceToBatchND = function(t, e) {
        return this.throwIfDisposed(), bt.spaceToBatchND(this, t, e)
       }, t.prototype.topk = function(t, e) {
        return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), bt.topk(this, t, e)
       }, t.prototype.stridedSlice = function(t, e, n, r, i, o, a, s) {
        return void 0 === r && (r = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), this.throwIfDisposed(), bt.stridedSlice(this, t, e, n, r, i, o, a, s)
       }, t.prototype.depthToSpace = function(t, e) {
        return this.throwIfDisposed(), bt.depthToSpace(this, t, e)
       }, t.prototype.fft = function() {
        return this.throwIfDisposed(), bt.spectral.fft(this)
       }, t.prototype.ifft = function() {
        return this.throwIfDisposed(), bt.spectral.ifft(this)
       }, t.prototype.rfft = function() {
        return this.throwIfDisposed(), bt.spectral.rfft(this)
       }, t.prototype.irfft = function() {
        return this.throwIfDisposed(), bt.spectral.irfft(this)
       }, t
      }();
     Object.defineProperty(wt, Symbol.hasInstance, {
      value: function(t) {
       return !!t && null != t.dataId && null != t.shape && null != t.dtype
      }
     });
     var Ct, St, Et, kt, It, Ot = function(t) {
      function e(e, n, r, i) {
       var o = t.call(this, e.shape, e.dtype, e.dataId, i) || this;
       return o.trainable = n, o.name = r, o
      }
      return a(e, t), e.prototype.assign = function(t) {
       if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
       if (!R(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
       yt().disposeTensor(this), this.dataId = t.dataId, yt().incRef(this, null)
      }, e.prototype.dispose = function() {
       yt().disposeVariable(this), this.isDisposedInternal = !0
      }, e
     }(wt);
     Object.defineProperty(Ot, Symbol.hasInstance, {
       value: function(t) {
        return t instanceof wt && null != t.assign && t.assign instanceof Function
       }
      }),
      function(t) {
       t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6"
      }(Ct || (Ct = {})),
      function(t) {
       t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64"
      }(St || (St = {})),
      function(t) {
       t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64"
      }(Et || (Et = {})),
      function(t) {
       t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64"
      }(kt || (kt = {})),
      function(t) {
       t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64"
      }(It || (It = {}));
     var At = {
      float32: kt,
      int32: St,
      bool: Et,
      complex64: It
     };
 
     function Nt(t, e) {
      if ("string" === t || "string" === e) {
       if ("string" === t && "string" === e) return "string";
       throw new Error("Can not upcast " + t + " with " + e)
      }
      return At[t][e]
     }
 
     function Rt(t) {
      return Nt(t, "int32")
     }
 
     function Tt(t, e) {
      if (t.dtype === e.dtype) return [t, e];
      var n = Nt(t.dtype, e.dtype);
      return [t.cast(n), e.cast(n)]
     }
 
     function _t(t, e) {
      k(t.dtype === e.dtype, (function() {
       return "The dtypes of the first(" + t.dtype + ") and second(" + e.dtype + ") input must match"
      }))
     }
 
     function Dt(t) {
      var e = [];
      return function t(e, n, r) {
       if (null != e)
        if (e instanceof wt) n.push(e);
        else if (i = e, Array.isArray(i) || "object" == typeof i) {
        var i, o = e;
        for (var a in o) {
         var s = o[a];
         r.has(s) || (r.add(s), t(s, n, r))
        }
       }
      }(t, e, new Set), e
     }
     Object.freeze({
      makeTypesMatch: Tt,
      assertTypesMatch: _t,
      isTensorInList: function(t, e) {
       for (var n = 0; n < e.length; n++)
        if (e[n].id === t.id) return !0;
       return !1
      },
      getTensorsInContainer: Dt
     });
     var Ft, Mt = function() {
       function t() {
        this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
         newBytes: 0,
         newTensors: 0,
         peakBytes: 0,
         kernels: [],
         result: null
        }
       }
       return t.prototype.dispose = function() {
        for (var t in this.registeredVariables) this.registeredVariables[t].dispose()
       }, t
      }(),
      Lt = function() {
       function t(t) {
        this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Mt
       }
       return t.prototype.ready = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then((function() {}))];
            if (null != this.backendInstance) return [2];
            t = this.getSortedBackends(), e = 0, r.label = 1;
           case 1:
            return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];
           case 2:
            return r.sent() ? [4, this.setBackend(n)] : [3, 4];
           case 3:
            return r.sent(), [2];
           case 4:
            return e++, [3, 1];
           case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.")
          }
         }))
        }))
       }, Object.defineProperty(t.prototype, "backend", {
        get: function() {
         if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
         if (null == this.backendInstance) {
          var t = this.initializeBackendsAndReturnBest(),
           e = t.name;
          if (t.asyncInit) throw new Error("The highest priority backend '" + e + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
          this.setBackend(e)
         }
         return this.backendInstance
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.backendNames = function() {
        return Object.keys(this.registryFactory)
       }, t.prototype.findBackend = function(t) {
        if (!(t in this.registry)) {
         if (!(t in this.registryFactory)) return null;
         if (this.initializeBackend(t).asyncInit) return null
        }
        return this.registry[t]
       }, t.prototype.findBackendFactory = function(t) {
        return t in this.registryFactory ? this.registryFactory[t].factory : null
       }, t.prototype.registerBackend = function(t, e, n) {
        return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t] = {
         factory: e,
         priority: n
        }, !0)
       }, t.prototype.setBackend = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r;
         return u(this, (function(i) {
          switch (i.label) {
           case 0:
            if (null == this.registryFactory[t]) throw new Error("Backend name '" + t + "' not found in registry");
            return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);
           case 1:
            return r = i.sent(), [3, 3];
           case 2:
            r = n, i.label = 3;
           case 3:
            if (!r) return [2, !1];
            i.label = 4;
           case 4:
            return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [2, !0]
          }
         }))
        }))
       }, t.prototype.setupRegisteredKernels = function() {
        var t = this;
        g(this.backendName).forEach((function(e) {
         null != e.setupFunc && e.setupFunc(t.backendInstance)
        }))
       }, t.prototype.disposeRegisteredKernels = function(t) {
        var e = this;
        g(t).forEach((function(n) {
         null != n.disposeFunc && n.disposeFunc(e.registry[t])
        }))
       }, t.prototype.initializeBackend = function(t) {
        var e = this,
         n = this.registryFactory[t];
        if (null == n) throw new Error("Cannot initialize backend " + t + ", no registration found.");
        try {
         var r = n.factory();
         if (Promise.resolve(r) === r) {
          var i = ++this.pendingBackendInitId,
           o = r.then((function(n) {
            return !(i < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0)
           })).catch((function(n) {
            return !(i < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn("Initialization of backend " + t + " failed"), console.warn(n.stack || n.message), !1)
           }));
          return this.pendingBackendInit = o, {
           success: o,
           asyncInit: !0
          }
         }
         return this.registry[t] = r, {
          success: !0,
          asyncInit: !1
         }
        } catch (e) {
         return console.warn("Initialization of backend " + t + " failed"), console.warn(e.stack || e.message), {
          success: !1,
          asyncInit: !1
         }
        }
       }, t.prototype.removeBackend = function(t) {
        if (!(t in this.registryFactory)) throw new Error(t + " backend not found in registry");
        this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
       }, t.prototype.getSortedBackends = function() {
        var t = this;
        if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
        return Object.keys(this.registryFactory).sort((function(e, n) {
         return t.registryFactory[n].priority - t.registryFactory[e].priority
        }))
       }, t.prototype.initializeBackendsAndReturnBest = function() {
        for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
         var n = t[e],
          r = this.initializeBackend(n),
          i = r.success,
          o = r.asyncInit;
         if (o || i) return {
          name: n,
          asyncInit: o
         }
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.")
       }, t.prototype.moveData = function(t, e) {
        var n = this.state.tensorInfo.get(e),
         r = n.backend,
         i = this.readSync(e);
        r.disposeData(e), n.backend = t, t.move(e, i, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
       }, t.prototype.tidy = function(t, e) {
        var n, r = this,
         i = null;
        if (null == e) {
         if ("function" != typeof t) throw new Error("Please provide a function to tidy()");
         e = t
        } else {
         if ("string" != typeof t && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
         if ("function" != typeof e) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
         i = t
        }
        return this.scopedRun((function() {
         return r.startScope(i)
        }), (function() {
         return r.endScope(n)
        }), (function() {
         return (n = e()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n
        }))
       }, t.prototype.scopedRun = function(t, e, n) {
        t();
        try {
         var r = n();
         return e(), r
        } catch (t) {
         throw e(), t
        }
       }, t.prototype.nextTensorId = function() {
        return t.nextTensorId++
       }, t.prototype.nextVariableId = function() {
        return t.nextVariableId++
       }, t.prototype.clone = function(t) {
        var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
         n = {
          x: t
         };
        return this.addTapeNode(this.state.activeScope.name, n, [e], (function(t) {
         return {
          x: function() {
           return t.toFloat()
          }
         }
        }), []), e
       }, t.prototype.runKernel = function(t, e, n, r, i) {
        return this.runKernelFunc(null, e, null, t, n, r, i)
       }, t.prototype.shouldCheckForMemLeaks = function() {
        return this.ENV.getBool("IS_TEST")
       }, t.prototype.checkKernelForMemLeak = function(t, e, n) {
        var r = this.backend.numDataIds(),
         i = 0;
        n.forEach((function(t) {
         i += "complex64" === t.dtype ? 3 : 1
        }));
        var o = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
         a = r - e - i - o;
        if (a > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + a + " data ids) after running '" + t + "'")
       }, t.prototype.runKernelFunc = function(t, e, n, r, i, o, a) {
        var s, u = this;
        void 0 === o && (o = []), void 0 === a && (a = []);
        var c = [],
         l = this.isTapeOn();
        null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : "");
        var h, p = function(t) {
          l && (c = t.map((function(t) {
           return u.keep(u.clone(t))
          })))
         },
         f = this.state.numBytes,
         d = this.state.numTensors;
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
        var m, g = v(r, this.backendName);
        return h = null != g ? function() {
         var t = u.backend.numDataIds();
         m = g.kernelFunc({
          inputs: e,
          attrs: i,
          backend: u.backend
         });
         var n = Array.isArray(m) ? m : [m];
         u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);
         var s = n.map((function(t) {
           var e = t.dataId,
            n = t.shape,
            r = t.dtype;
           return u.makeTensorFromDataId(e, n, r)
          })),
          c = s.filter((function(t, e) {
           return a[e]
          }));
         return p((o || []).slice().concat(c)), s
        } : function() {
         var e = u.backend.numDataIds();
         m = u.tidy((function() {
          return t(u.backend, p)
         }));
         var n = Array.isArray(m) ? m : [m];
         return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n
        }, this.scopedRun((function() {
         return u.state.kernelDepth++
        }), (function() {
         return u.state.kernelDepth--
        }), (function() {
         s = u.ENV.getBool("DEBUG") ? u.profiler.profileKernel(r, e, (function() {
          return h()
         })) : h()
        })), l && this.addTapeNode(r, e, s, n, c), this.state.profiling && this.state.activeProfile.kernels.push({
         name: r,
         bytesAdded: this.state.numBytes - f,
         totalBytesSnapshot: this.state.numBytes,
         tensorsAdded: this.state.numTensors - d,
         totalTensorsSnapshot: this.state.numTensors,
         inputShapes: Object.keys(e).map((function(t) {
          return e[t].shape
         })),
         outputShapes: s.map((function(t) {
          return t.shape
         }))
        }), Array.isArray(m) ? s : s[0]
       }, t.prototype.makeTensor = function(t, e, n, r) {
        if (null == t) throw new Error("Values passed to engine.makeTensor() are null");
        n = n || "float32", r = r || this.backend;
        var i = t;
        "string" === n && q(t[0]) && (i = t.map((function(t) {
         return at(t)
        })));
        var o = r.write(i, e, n),
         a = new wt(e, n, o, this.nextTensorId());
        if (this.incRef(a, r), "string" === n) {
         var s = this.state.tensorInfo.get(o),
          u = G(i);
         this.state.numBytes += u - s.bytes, s.bytes = u
        }
        return a
       }, t.prototype.makeTensorFromDataId = function(t, e, n, r) {
        var i = new wt(e, n = n || "float32", t, this.nextTensorId());
        return this.incRef(i, r), i
       }, t.prototype.makeVariable = function(t, e, n, r) {
        void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));
        var i = new Ot(t, e, n, this.nextTensorId());
        if (null != this.state.registeredVariables[i.name]) throw new Error("Variable with name " + i.name + " was already registered");
        return this.state.registeredVariables[i.name] = i, this.incRef(i, this.backend), i
       }, t.prototype.incRef = function(t, e) {
        var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;
        if (this.state.numTensors++, "string" === t.dtype && this.state.numStringTensors++, 0 === n) {
         this.state.numDataBuffers++;
         var r = 0;
         "complex64" !== t.dtype && "string" !== t.dtype && (r = t.size * $(t.dtype)), this.state.tensorInfo.set(t.dataId, {
          backend: e || this.backend,
          dtype: t.dtype,
          shape: t.shape,
          bytes: r,
          refCount: 0
         }), this.state.numBytes += r
        }
        this.state.tensorInfo.get(t.dataId).refCount++, t instanceof Ot || this.track(t)
       }, t.prototype.disposeTensor = function(t) {
        if (this.state.tensorInfo.has(t.dataId)) {
         this.state.numTensors--, "string" === t.dtype && this.state.numStringTensors--;
         var e = this.state.tensorInfo.get(t.dataId);
         e.refCount <= 1 ? ("complex64" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--
        }
       }, t.prototype.disposeVariables = function() {
        for (var t in this.state.registeredVariables) {
         var e = this.state.registeredVariables[t];
         this.disposeVariable(e)
        }
       }, t.prototype.disposeVariable = function(t) {
        this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name]
       }, t.prototype.memory = function() {
        var t = this.backend.memory();
        return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t
       }, t.prototype.profile = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n;
         return u(this, (function(r) {
          return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map((function(t) {
           return t.totalBytesSnapshot
          }))), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile]
         }))
        }))
       }, t.prototype.isTapeOn = function() {
        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
       }, t.prototype.addTapeNode = function(t, e, n, r, i) {
        var o = this,
         a = {
          id: this.state.nextTapeNodeId++,
          kernelName: t,
          inputs: e,
          outputs: n,
          saved: i
         },
         s = m(t);
        null != s && (r = s.gradFunc), null != r && (a.gradient = function(t) {
         return t = t.map((function(t, e) {
          if (null == t) {
           var r = n[e],
            i = rt(r.size, r.dtype);
           return o.makeTensor(i, r.shape, r.dtype)
          }
          return t
         })), r(t.length > 1 ? t : t[0], i)
        }), this.state.activeTape.push(a)
       }, t.prototype.keep = function(t) {
        return t.kept = !0, t
       }, t.prototype.startTape = function() {
        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
       }, t.prototype.endTape = function() {
        this.state.gradientDepth--
       }, t.prototype.startScope = function(t) {
        var e = {
         track: [],
         name: "unnamed scope",
         id: this.state.nextScopeId++
        };
        t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e
       }, t.prototype.endScope = function(t) {
        for (var e = this, n = Dt(t), r = new Set(n.map((function(t) {
          return t.id
         }))), i = 0; i < this.state.activeScope.track.length; i++) {
         var o = this.state.activeScope.track[i];
         o.kept || r.has(o.id) || o.dispose()
        }
        var a = this.state.scopeStack.pop();
        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach((function(t) {
         t.kept || t.scopeId !== a.id || e.track(t)
        }))
       }, t.prototype.gradients = function(t, e, n, r) {
        var i = this;
        if (void 0 === r && (r = !1), k(e.length > 0, (function() {
          return "gradients() received an empty list of xs."
         })), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
        var o = this.scopedRun((function() {
         return i.startTape()
        }), (function() {
         return i.endTape()
        }), (function() {
         return i.tidy("forward", t)
        }));
        k(o instanceof wt, (function() {
         return "The result y returned by f() must be a tensor."
        }));
        var a = function(t, e, n) {
         for (var r = {}, i = {}, o = 0; o < e.length; o++) r[e[o].id] = !0;
         for (o = 0; o < t.length; o++) {
          var a = (d = t[o]).inputs;
          for (var s in a) {
           for (var u = a[s], c = !1, l = 0; l < e.length; l++)
            if (r[u.id]) {
             d.outputs.forEach((function(t) {
              return r[t.id] = !0
             })), c = !0, i[d.id] = !0;
             break
            } if (c) break
          }
         }
         var h = {};
         h[n.id] = !0;
         var p = {};
         for (o = t.length - 1; o >= 0; o--)
          for (a = (d = t[o]).inputs, l = 0; l < d.outputs.length; l++)
           if (h[d.outputs[l].id]) {
            for (var s in a) h[a[s].id] = !0, p[d.id] = !0;
            break
           } var f = [];
         for (o = 0; o < t.length; o++) {
          var d;
          if (i[(d = t[o]).id] && p[d.id]) {
           var v = {};
           for (var s in d.inputs) {
            var m = d.inputs[s];
            r[m.id] && (v[s] = m)
           }
           var g = Object.assign({}, d);
           g.inputs = v, g.outputs = d.outputs, f.push(g)
          }
         }
         return f
        }(this.state.activeTape, e, o);
        if (!r && 0 === a.length && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy("backward", (function() {
         var t, r, s = {};
         s[o.id] = null == n ? (t = o.shape, r = nt(N(t), "float32"), Bt.makeTensor(r, t, "float32")) : n,
          function(t, e, n) {
           for (var r = function(r) {
             var i = e[r],
              o = [];
             if (i.outputs.forEach((function(e) {
               var n = t[e.id];
               null != n ? o.push(n) : o.push(null)
              })), null == i.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + i.kernelName + ".");
             var a = i.gradient(o),
              s = function(e) {
               if (!(e in a)) throw new Error("Cannot backprop through input " + e + ". Available gradients found: " + Object.keys(a) + ".");
               var r = n((function() {
                return a[e]()
               }));
               if ("float32" !== r.dtype) throw new Error("Error in gradient for op " + i.kernelName + ". The gradient of input " + e + " must have 'float32' dtype, but has '" + r.dtype + "'");
               var o = i.inputs[e];
               if (!R(r.shape, o.shape)) throw new Error("Error in gradient for op " + i.kernelName + ". The gradient of input '" + e + "' has shape '" + r.shape + "', which does not match the shape of the input '" + o.shape + "'");
               if (null == t[o.id]) t[o.id] = r;
               else {
                var s = t[o.id];
                t[o.id] = s.add(r), s.dispose()
               }
              };
             for (var u in i.inputs) s(u)
            }, i = e.length - 1; i >= 0; i--) r(i)
          }(s, a, (function(t) {
           return i.tidy(t)
          }));
         var u = e.map((function(t) {
          return s[t.id]
         }));
         return 0 === i.state.gradientDepth && (i.state.activeTape.forEach((function(t) {
          for (var e = 0, n = t.saved; e < n.length; e++) n[e].dispose()
         })), i.state.activeTape = null), {
          value: o,
          grads: u
         }
        }))
       }, t.prototype.customGrad = function(t) {
        var e = this;
        return k(Z(t), (function() {
          return "The f passed in customGrad(f) must be a function."
         })),
         function() {
          for (var n, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
          k(r.every((function(t) {
           return t instanceof wt
          })), (function() {
           return "The args passed in customGrad(f)(x1, x2,...) must all be tensors"
          }));
          var o = {};
          return r.forEach((function(t, e) {
           o[e] = t
          })), e.runKernelFunc((function(e, i) {
           return k((n = t.apply(void 0, r.concat([i]))).value instanceof wt, (function() {
            return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"
           })), k(Z(n.gradFunc), (function() {
            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."
           })), n.value
          }), o, (function(t, e) {
           var i = n.gradFunc(t, e),
            o = Array.isArray(i) ? i : [i];
           k(o.length === r.length, (function() {
            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."
           })), k(o.every((function(t) {
            return t instanceof wt
           })), (function() {
            return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."
           }));
           var a = {};
           return o.forEach((function(t, e) {
            a[e] = function() {
             return t
            }
           })), a
          }))
         }
       }, t.prototype.readSync = function(t) {
        return this.state.tensorInfo.get(t).backend.readSync(t)
       }, t.prototype.read = function(t) {
        return this.state.tensorInfo.get(t).backend.read(t)
       }, t.prototype.time = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return e = it(), [4, this.backend.time(t)];
           case 1:
            return (n = r.sent()).wallMs = it() - e, [2, n]
          }
         }))
        }))
       }, t.prototype.track = function(t) {
        return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t
       }, Object.defineProperty(t.prototype, "registeredVariables", {
        get: function() {
         return this.state.registeredVariables
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.reset = function() {
        for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Mt, this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];
        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
       }, t.nextTensorId = 0, t.nextVariableId = 0, t
      }(),
      Bt = function() {
       var e = function() {
        if (null == Ft) {
         var e = void 0;
         if ("undefined" != typeof window) e = window;
         else if ("undefined" != typeof t) e = t;
         else if ("undefined" != typeof r) e = r;
         else {
          if ("undefined" == typeof self) throw new Error("Could not find a global object");
          e = self
         }
         Ft = e
        }
        return Ft
       }();
       if (null == e._tfengine) {
        var n = new c(e);
        e._tfengine = new Lt(n)
       }
       return function(t) {
        p = t
       }(e._tfengine.ENV), yt = function() {
        return e._tfengine
       }, e._tfengine
      }();
 
     function Pt() {
      return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
     }
     var zt = h();
     zt.registerFlag("DEBUG", (function() {
      return !1
     }), (function(t) {
      t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
     })), zt.registerFlag("IS_BROWSER", (function() {
      return Pt()
     })), zt.registerFlag("IS_NODE", (function() {
      return "undefined" != typeof r && void 0 !== r.versions && void 0 !== r.versions.node
     })), zt.registerFlag("IS_CHROME", (function() {
      return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
     })), zt.registerFlag("PROD", (function() {
      return !1
     })), zt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", (function() {
      return zt.getBool("DEBUG")
     })), zt.registerFlag("DEPRECATION_WARNINGS_ENABLED", (function() {
      return !0
     })), zt.registerFlag("IS_TEST", (function() {
      return !1
     }));
     var jt, Wt, Vt, Ut = {},
      Ht = {
       alpha: !1,
       antialias: !1,
       premultipliedAlpha: !1,
       preserveDrawingBuffer: !1,
       depth: !1,
       stencil: !1,
       failIfMajorPerformanceCaveat: !0
      };
 
     function $t(t, e) {
      Ut[t] = e
     }
 
     function Gt(t) {
      t in Ut || (Ut[t] = function(t) {
       if (1 !== t && 2 !== t) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
       var e = function(t) {
        if ("undefined" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);
        if ("undefined" != typeof document) return document.createElement("canvas");
        throw new Error("Cannot create a canvas in this context")
       }(t);
       return e.addEventListener("webglcontextlost", (function(e) {
        e.preventDefault(), delete Ut[t]
       }), !1), 1 === t ? e.getContext("webgl", Ht) || e.getContext("experimental-webgl", Ht) : e.getContext("webgl2", Ht)
      }(t));
      var e = Ut[t];
      return e.isContextLost() ? (delete Ut[t], Gt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Ut[t])
     }
 
     function qt(t, e) {
      return [e, t]
     }
 
     function Kt(t) {
      var e = N(t);
      return D(Math.ceil(e / 4))
     }
 
     function Xt(t, e) {
      return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))]
     }
 
     function Yt(t, e) {
      var n, r, i, o, a, s, u, c, l, p = t;
      return 2 === h().getNumber("WEBGL_VERSION") ? (n = p.R32F, r = p.R16F, i = p.RGBA16F, o = p.RGBA32F, a = p.RED, s = 4, u = 1, c = p.HALF_FLOAT, l = p.FLOAT) : (n = t.RGBA, r = t.RGBA, i = t.RGBA, o = p.RGBA, a = t.RGBA, s = 4, u = 4, c = null != e ? e.HALF_FLOAT_OES : null, l = t.FLOAT), {
       internalFormatFloat: n,
       internalFormatHalfFloat: r,
       internalFormatPackedHalfFloat: i,
       internalFormatPackedFloat: o,
       textureFormatFloat: a,
       downloadTextureFormat: t.RGBA,
       downloadUnpackNumChannels: s,
       defaultNumChannels: u,
       textureTypeHalfFloat: c,
       textureTypeFloat: l
      }
     }
 
     function Zt(t, e, n) {
      var r = n();
      return e && function(t) {
       var e = t.getError();
       if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + ee(t, e))
      }(t), r
     }! function(t) {
      t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH"
     }(jt || (jt = {})),
     function(t) {
      t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD"
     }(Wt || (Wt = {})),
     function(t) {
      t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
     }(Vt || (Vt = {}));
     var Jt = 5.96e-8,
      Qt = 65504;
 
     function te(t) {
      return !!(h().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t || Jt < Math.abs(t) && Math.abs(t) < Qt)
     }
 
     function ee(t, e) {
      switch (e) {
       case t.NO_ERROR:
        return "NO_ERROR";
       case t.INVALID_ENUM:
        return "INVALID_ENUM";
       case t.INVALID_VALUE:
        return "INVALID_VALUE";
       case t.INVALID_OPERATION:
        return "INVALID_OPERATION";
       case t.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
       case t.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
       case t.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
       default:
        return "Unknown error code " + e
      }
     }
 
     function ne(t, e, n) {
      return ke(t, e, (function() {
       return t.getExtension(n)
      }), 'Extension "' + n + '" not supported on this browser.')
     }
 
     function re(t, e, n) {
      var r = ke(t, e, (function() {
       return t.createShader(t.VERTEX_SHADER)
      }), "Unable to create vertex WebGLShader.");
      if (Zt(t, e, (function() {
        return t.shaderSource(r, n)
       })), Zt(t, e, (function() {
        return t.compileShader(r)
       })), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
      return r
     }
 
     function ie(t, e, n) {
      var r = ke(t, e, (function() {
       return t.createShader(t.FRAGMENT_SHADER)
      }), "Unable to create fragment WebGLShader.");
      if (Zt(t, e, (function() {
        return t.shaderSource(r, n)
       })), Zt(t, e, (function() {
        return t.compileShader(r)
       })), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function(t, e) {
       var n = se.exec(e);
       if (null == n) return console.log("Couldn't parse line number in error: " + e), void console.log(t);
       for (var r = +n[1], i = t.split("\n"), o = i.length.toString().length + 2, a = i.map((function(t, e) {
         return F((e + 1).toString(), o) + t
        })), s = 0, u = 0; u < a.length; u++) s = Math.max(a[u].length, s);
       var c = a.slice(0, r - 1),
        l = a.slice(r - 1, r),
        h = a.slice(r);
       console.log(c.join("\n")), console.log(e.split("\n")[0]), console.log("%c " + F(l[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"))
      }(n, t.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
      return r
     }
     var oe, ae, se = /ERROR: [0-9]+:([0-9]+):/g;
 
     function ue(t, e) {
      return ke(t, e, (function() {
       return t.createProgram()
      }), "Unable to create WebGLProgram.")
     }
 
     function ce(t, e, n) {
      if (Zt(t, e, (function() {
        return t.linkProgram(n)
       })), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Failed to link vertex and fragment shaders.")
     }
 
     function le(t, e, n) {
      if (Zt(t, e, (function() {
        return t.validateProgram(n)
       })), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Shader program validation failed.")
     }
 
     function he(t, e, n) {
      var r = ke(t, e, (function() {
       return t.createBuffer()
      }), "Unable to create WebGLBuffer");
      return Zt(t, e, (function() {
       return t.bindBuffer(t.ARRAY_BUFFER, r)
      })), Zt(t, e, (function() {
       return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW)
      })), r
     }
 
     function pe(t, e, n) {
      var r = ke(t, e, (function() {
       return t.createBuffer()
      }), "Unable to create WebGLBuffer");
      return Zt(t, e, (function() {
       return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r)
      })), Zt(t, e, (function() {
       return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW)
      })), r
     }
 
     function fe(t, e) {
      return ke(t, e, (function() {
       return t.createTexture()
      }), "Unable to create WebGLTexture.")
     }
 
     function de(t, e) {
      var n = h().getNumber("WEBGL_MAX_TEXTURE_SIZE");
      if (t <= 0 || e <= 0) {
       var r = "[" + t + "x" + e + "]";
       throw new Error("Requested texture size " + r + " is invalid.")
      }
      if (t > n || e > n) throw r = "[" + t + "x" + e + "]", new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU [" + n + "x" + n + "].")
     }
 
     function ve(t, e) {
      return ke(t, e, (function() {
       return t.createFramebuffer()
      }), "Unable to create WebGLFramebuffer.")
     }
 
     function me(t, e, n, r, i, o, a, s) {
      var u = t.getAttribLocation(n, r);
      return -1 !== u && (Zt(t, e, (function() {
       return t.bindBuffer(t.ARRAY_BUFFER, i)
      })), Zt(t, e, (function() {
       return t.vertexAttribPointer(u, o, t.FLOAT, !1, a, s)
      })), Zt(t, e, (function() {
       return t.enableVertexAttribArray(u)
      })), !0)
     }
 
     function ge(t, e, n, r) {
      Ie(t, r), Zt(t, e, (function() {
       return t.activeTexture(t.TEXTURE0 + r)
      })), Zt(t, e, (function() {
       return t.bindTexture(t.TEXTURE_2D, n)
      }))
     }
 
     function ye(t, e, n, r) {
      return ke(t, e, (function() {
       return t.getUniformLocation(n, r)
      }), 'uniform "' + r + '" not present in program.')
     }
 
     function be(t, e, n) {
      return t.getUniformLocation(e, n)
     }
 
     function xe(t, e, n, r, i, o) {
      Zt(t, e, (function() {
       return ge(t, e, r, o)
      })), Zt(t, e, (function() {
       return t.uniform1i(i, o)
      }))
     }
 
     function we(t, e, n, r) {
      Zt(t, e, (function() {
       return t.bindFramebuffer(t.FRAMEBUFFER, r)
      })), Zt(t, e, (function() {
       return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
      }))
     }
 
     function Ce(t, e, n) {
      Zt(t, e, (function() {
       return t.bindFramebuffer(t.FRAMEBUFFER, n)
      })), Zt(t, e, (function() {
       return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)
      }))
     }
 
     function Se(t) {
      var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
      if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ee(t, e))
     }
 
     function Ee(t, e) {
      switch (e) {
       case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
       case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
       case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
       case t.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
       default:
        return "unknown error " + e
      }
     }
 
     function ke(t, e, n, r) {
      var i = Zt(t, e, (function() {
       return n()
      }));
      if (null == i) throw new Error(r);
      return i
     }
 
     function Ie(t, e) {
      var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
       r = e + t.TEXTURE0;
      if (r < t.TEXTURE0 || r > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE" + n + "].")
     }
 
     function Oe(t, e) {
      return void 0 === e && (e = 2), N(t.slice(0, t.length - e))
     }
 
     function Ae(t) {
      if (0 === t.length) throw Error("Cannot get rows and columns of an empty shape array.");
      return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]]
     }
 
     function Ne(t) {
      var e = [1, 1, 1];
      return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [Oe(t)].concat(Ae(t))), e
     }
 
     function Re(t, e) {
      var n;
      void 0 === e && (e = !1);
      var r = h().getNumber("WEBGL_MAX_TEXTURE_SIZE");
      if (e && (r *= 2, 1 === (t = t.map((function(e, n) {
        return n >= t.length - 2 ? S(t[n]) : t[n]
       }))).length && (t = [2, t[0]])), 2 !== t.length) {
       var i = P(t);
       t = i.newShape
      }
      var o = N(t);
      if (t.length <= 1 && o <= r) return [1, o];
      if (2 === t.length && t[0] <= r && t[1] <= r) return t;
      if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];
      if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];
      if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];
      if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];
      if (e) {
       var a = Oe(t),
        s = 2,
        u = 2;
       return t.length && (s = (n = Ae(t))[0], u = n[1]), D(o = a * (s / 2) * (u / 2)).map((function(t) {
        return 2 * t
       }))
      }
      return D(o)
     }
 
     function Te(t) {
      return t % 2 == 0
     }
 
     function _e(t, e) {
      if (R(t = t.slice(-2), e = e.slice(-2))) return !0;
      if (!t.length || !e.length) return !0;
      if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;
      if (t.length !== e.length) {
       var n = t.slice(-1)[0],
        r = e.slice(-1)[0];
       if (n === r) return !0;
       if (Te(n) && Te(r) && (1 === t[0] || 1 === e[0])) return !0
      }
      return t[1] === e[1] && Te(t[0]) && Te(e[0])
     }
 
     function De(t) {
      if (null == oe) {
       var e = Gt(t);
       oe = e.getParameter(e.MAX_TEXTURE_SIZE)
      }
      return oe
     }
 
     function Fe(t) {
      if (null == ae) {
       var e = Gt(t);
       ae = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
      }
      return Math.min(16, ae)
     }
 
     function Me(t) {
      if (0 === t) return 0;
      var e = Gt(t);
      return Le(e, "EXT_disjoint_timer_query_webgl2") && 2 === t ? 2 : Le(e, "EXT_disjoint_timer_query") ? 1 : 0
     }
 
     function Le(t, e) {
      return null != t.getExtension(e)
     }
 
     function Be(t) {
      try {
       if (null != Gt(t)) return !0
      } catch (t) {
       return !1
      }
      return !1
     }
 
     function Pe(t) {
      if (0 === t) return !1;
      var e = Gt(t);
      if (1 === t) {
       if (!Le(e, "OES_texture_float")) return !1
      } else if (!Le(e, "EXT_color_buffer_float")) return !1;
      return je(e)
     }
 
     function ze(t) {
      if (0 === t) return !1;
      var e = Gt(t);
      if (1 !== t) {
       if (Le(e, "EXT_color_buffer_float")) return je(e);
       if (Le(e, "EXT_color_buffer_half_float")) {
        var n = e.getExtension("EXT_color_buffer_half_float");
        return function(t, e) {
         var n = Yt(t, e),
          r = t.createTexture();
         t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
         var i = t.createFramebuffer();
         t.bindFramebuffer(t.FRAMEBUFFER, i), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);
         var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
         return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(i), o
        }(e, n)
       }
       return !1
      }
      return !!Le(e, "OES_texture_float") && !!Le(e, "WEBGL_color_buffer_float") && je(e)
     }
 
     function je(t) {
      var e = Yt(t),
       n = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
      var r = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
      var i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
      return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), i
     }
 
     function We(t) {
      return 2 === t && null != Gt(t).fenceSync
     }
     var Ve = Object.freeze({
       callAndCheck: Zt,
       canBeRepresented: te,
       getWebGLErrorMessage: ee,
       getExtensionOrThrow: ne,
       createVertexShader: re,
       createFragmentShader: ie,
       createProgram: ue,
       linkProgram: ce,
       validateProgram: le,
       createStaticVertexBuffer: he,
       createStaticIndexBuffer: pe,
       getNumChannels: function() {
        return 2 === h().getNumber("WEBGL_VERSION") ? 1 : 4
       },
       createTexture: fe,
       validateTextureSize: de,
       createFramebuffer: ve,
       bindVertexBufferToProgramAttribute: me,
       bindTextureUnit: ge,
       unbindTextureUnit: function(t, e, n) {
        Ie(t, n), Zt(t, e, (function() {
         return t.activeTexture(t.TEXTURE0 + n)
        })), Zt(t, e, (function() {
         return t.bindTexture(t.TEXTURE_2D, null)
        }))
       },
       getProgramUniformLocationOrThrow: ye,
       getProgramUniformLocation: be,
       bindTextureToProgramUniformSampler: xe,
       bindCanvasToFramebuffer: function(t, e) {
        Zt(t, e, (function() {
         return t.bindFramebuffer(t.FRAMEBUFFER, null)
        })), Zt(t, e, (function() {
         return t.viewport(0, 0, t.canvas.width, t.canvas.height)
        })), Zt(t, e, (function() {
         return t.scissor(0, 0, t.canvas.width, t.canvas.height)
        }))
       },
       bindColorTextureToFramebuffer: we,
       unbindColorTextureFromFramebuffer: Ce,
       validateFramebuffer: Se,
       getFramebufferErrorMessage: Ee,
       getBatchDim: Oe,
       getRowsCols: Ae,
       getShapeAs3D: Ne,
       getTextureShapeFromLogicalShape: Re,
       isReshapeFree: _e,
       getWebGLMaxTextureSize: De,
       resetMaxTextureSize: function() {
        oe = null
       },
       resetMaxTexturesInShader: function() {
        ae = null
       },
       getMaxTexturesInShader: Fe,
       getWebGLDisjointQueryTimerVersion: Me,
       hasExtension: Le,
       isWebGLVersionEnabled: Be,
       isCapableOfRenderingToFloatTexture: Pe,
       isDownloadFloatTextureEnabled: ze,
       isWebGLFenceEnabled: We
      }),
      Ue = h();
 
     function He(t) {
      h().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
     }
 
     function $e(t, e) {
      return Bt.tidy(t, e)
     }
 
     function Ge(t) {
      Dt(t).forEach((function(t) {
       return t.dispose()
      }))
     }
 
     function qe(t) {
      return Bt.keep(t)
     }
 
     function Ke() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      h().getBool("IS_TEST") || console.warn.apply(console, t)
     }
 
     function Xe(t, e) {
      var n = t;
      if (H(t)) return "string" === e ? [] : [t.length];
      if (!Array.isArray(t)) return [];
      for (var r = []; Array.isArray(n) || H(n) && "string" !== e;) r.push(n.length), n = n[0];
      return Array.isArray(t) && h().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t(e, n, r) {
       if (r = r || [], Array.isArray(e) || H(e)) {
        k(n.length > 0, (function() {
         return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + e.length + " elements"
        })), k(e.length === n[0], (function() {
         return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + e.length + " elements"
        }));
        for (var i = n.slice(1), o = 0; o < e.length; ++o) t(e[o], i, r.concat(o))
       } else k(0 === n.length, (function() {
        return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements"
       }))
      }(t, r, []), r
     }
 
     function Ye(t, e, n, r) {
      if (null != t && ("numeric" !== t && t !== e || "numeric" === t && "string" === e)) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + " tensor, but got " + e + " tensor")
     }
 
     function Ze(t, e, n, r) {
      if (void 0 === r && (r = "numeric"), t instanceof wt) return Ye(r, t.dtype, e, n), t;
      var i = Y(t);
      if ("string" !== i && ["bool", "int32", "float32"].indexOf(r) >= 0 && (i = r), Ye(r, i, e, n), null == t || !H(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) {
       var o = null == t ? "null" : t.constructor.name;
       throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + o + "'")
      }
      var a = Xe(t, i);
      H(t) || Array.isArray(t) || (t = [t]);
      var s = "string" !== i ? tt(t, i, h().getBool("DEBUG")) : A(t, [], !0);
      return Bt.makeTensor(s, a, i)
     }
 
     function Je(t, e, n, r) {
      if (void 0 === r && (r = "numeric"), !Array.isArray(t)) throw new Error("Argument " + e + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
      return t.map((function(t, r) {
       return Ze(t, e + "[" + r + "]", n)
      }), r)
     }
 
     function Qe(t, e) {
      for (var n = 0; n < t.length; ++n)
       if (t[t.length - n - 1] !== e - 1 - n) return !1;
      return !0
     }
 
     function tn(t, e, n) {
      for (var r = t.length + e.length, i = [], o = 0, a = 0, s = 0; s < r; s++) - 1 === n.indexOf(s) ? i.push(t[o++]) : i.push(e[a++]);
      return i
     }
 
     function en(t, e) {
      for (var n = [], r = t.length, i = 0; i < r; i++) - 1 === e.indexOf(i) && n.push(t[i]);
      return [n, e.map((function(e) {
       return t[e]
      }))]
     }
 
     function nn(t, e) {
      return tn(t, e.map((function(t) {
       return 1
      })), e)
     }
 
     function rn(t, e, n) {
      k(Qe(e, n), (function() {
       return t + " supports only inner-most axes for now. Got axes " + e + " and rank-" + n + " input."
      }))
     }
 
     function on(t, e) {
      if (Qe(t, e)) return null;
      for (var n = [], r = 0; r < e; ++r) - 1 === t.indexOf(r) && n.push(r);
      return t.forEach((function(t) {
       return n.push(t)
      })), n
     }
 
     function an(t) {
      return t.map((function(t, e) {
       return [e, t]
      })).sort((function(t, e) {
       return t[1] - e[1]
      })).map((function(t) {
       return t[0]
      }))
     }
 
     function sn(t, e) {
      for (var n = [], r = e - t; r < e; ++r) n.push(r);
      return n
     }
 
     function un(t, e) {
      var n = t[0].length;
      t.forEach((function(t, e) {
       k(t.length === n, (function() {
        return "Error in concat" + n + "D: rank of tensors[" + e + "] must be the same as the rank of the rest (" + n + ")"
       }))
      })), k(e >= 0 && e < n, (function() {
       return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + "."
      }));
      var r = t[0];
      t.forEach((function(t, i) {
       for (var o = 0; o < n; o++) k(o === e || t[o] === r[o], (function() {
        return "Error in concat" + n + "D: Shape of tensors[" + i + "] (" + t + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + i + "."
       }))
      }))
     }
 
     function cn(t, e) {
      for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];
      return n
     }
 
     function ln(t) {
      var e = Object.keys(t);
      if (1 !== e.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
      var n = e[0],
       r = t[n];
      n.endsWith("_") && (n = n.substring(0, n.length - 1));
      var i = function() {
       for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
       Bt.startScope(n);
       try {
        var i = r.apply(void 0, t);
        return i instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Bt.endScope(i), i
       } catch (t) {
        throw Bt.endScope(null), t
       }
      };
      return Object.defineProperty(i, "name", {
       value: n,
       configurable: !0
      }), i
     }
     Ue.registerFlag("HAS_WEBGL", (function() {
      return Ue.getNumber("WEBGL_VERSION") > 0
     })), Ue.registerFlag("WEBGL_VERSION", (function() {
      return Be(2) ? 2 : Be(1) ? 1 : 0
     })), Ue.registerFlag("WEBGL_BUFFER_SUPPORTED", (function() {
      return 2 === Ue.get("WEBGL_VERSION")
     })), Ue.registerFlag("WEBGL_CPU_FORWARD", (function() {
      return !0
     })), Ue.registerFlag("WEBGL_FORCE_F16_TEXTURES", (function() {
      return !1
     })), Ue.registerFlag("WEBGL_PACK", (function() {
      return Ue.getBool("HAS_WEBGL")
     })), Ue.registerFlag("WEBGL_PACK_NORMALIZATION", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_PACK_CLIP", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_PACK_DEPTHWISECONV", (function() {
      return !1
     })), Ue.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_PACK_REDUCE", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_LAZILY_UNPACK", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_CONV_IM2COL", (function() {
      return Ue.getBool("WEBGL_PACK")
     })), Ue.registerFlag("WEBGL_MAX_TEXTURE_SIZE", (function() {
      return De(Ue.getNumber("WEBGL_VERSION"))
     })), Ue.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", (function() {
      return Fe(Ue.getNumber("WEBGL_VERSION"))
     })), Ue.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", (function() {
      var t = Ue.getNumber("WEBGL_VERSION");
      return 0 === t ? 0 : Me(t)
     })), Ue.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", (function() {
      return Ue.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))));
      var t
     })), Ue.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", (function() {
      return Pe(Ue.getNumber("WEBGL_VERSION"))
     })), Ue.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", (function() {
      return !Ue.getBool("WEBGL_FORCE_F16_TEXTURES") && Ue.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")
     })), Ue.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", (function() {
      return ze(Ue.getNumber("WEBGL_VERSION"))
     })), Ue.registerFlag("WEBGL_FENCE_API_ENABLED", (function() {
      return We(Ue.getNumber("WEBGL_VERSION"))
     })), Ue.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", (function() {
      return Ue.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0
     })), xt = He;
     var hn = ln({
       complex_: function(t, e) {
        var n = Ze(t, "real", "complex"),
         r = Ze(e, "imag", "complex");
        return I(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."), Bt.runKernelFunc((function(t) {
         return t.complex(n, r)
        }), {
         $real: n,
         $imag: r
        })
       }
      }),
      pn = ln({
       real_: function(t) {
        var e = Ze(t, "input", "real");
        return Bt.runKernelFunc((function(t) {
         return t.real(e)
        }), {
         $input: e
        })
       }
      }),
      fn = ln({
       imag_: function(t) {
        var e = Ze(t, "input", "imag");
        return Bt.runKernelFunc((function(t) {
         return t.imag(e)
        }), {
         $input: e
        })
       }
      });
 
     function dn(t, e, n) {
      return vn(t, e, Xe(t, n), n)
     }
 
     function vn(t, e, n, r) {
      if (null == r && (r = Y(t)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
      if (!H(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
      if (null != e) {
       ot(e);
       var i = N(e),
        o = N(n);
       k(i === o, (function() {
        return "Based on the provided shape, [" + e + "], the tensor should have " + i + " values but has " + o
       }));
       for (var a = 0; a < n.length; ++a) {
        var s = n[a],
         u = a !== n.length - 1 || s !== N(e.slice(a));
        k(n[a] === e[a] || !u, (function() {
         return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + e + "). "
        }))
       }
      }
      return H(t) || Array.isArray(t) || (t = [t]), e = e || n, t = "string" !== r ? tt(t, r, h().getBool("DEBUG")) : A(t, [], !0), Bt.makeTensor(t, e, r)
     }
 
     function mn(t, e) {
      if ((H(t) && "string" !== e || Array.isArray(t)) && "complex64" !== e) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
      if ("string" === e && H(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
      return vn(t, [], [], e)
     }
 
     function gn(t, e) {
      O(t);
      var n = Xe(t, e);
      if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
      return vn(t, null, n, e)
     }
 
     function yn(t, e, n) {
      if (O(t), null != e && 2 !== e.length) throw new Error("tensor2d() requires shape to have two numbers");
      var r = Xe(t, n);
      if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
      if (1 === r.length && null == e) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
      return vn(t, e, r, n)
     }
 
     function bn(t, e, n) {
      if (O(t), null != e && 3 !== e.length) throw new Error("tensor3d() requires shape to have three numbers");
      var r = Xe(t, n);
      if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
      if (1 === r.length && null == e) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
      return vn(t, e, r, n)
     }
 
     function xn(t, e, n) {
      if (O(t), null != e && 4 !== e.length) throw new Error("tensor4d() requires shape to have four numbers");
      var r = Xe(t, n);
      if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
      if (1 === r.length && null == e) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
      return vn(t, e, r, n)
     }
 
     function wn(t, e, n) {
      if (O(t), null != e && 5 !== e.length) throw new Error("tensor5d() requires shape to have five numbers");
      var r = Xe(t, n);
      if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
      if (1 === r.length && null == e) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
      return vn(t, e, r, n)
     }
 
     function Cn(t, e, n) {
      if (O(t), null != e && 6 !== e.length) throw new Error("tensor6d() requires shape to have six numbers");
      var r = Xe(t, n);
      if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
      if (1 === r.length && null == e) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
      return vn(t, e = e || r, r, n)
     }
 
     function Sn(t, e, n, r) {
      return void 0 === e && (e = !0), Bt.makeVariable(t, e, n, r)
     }
 
     function En(t, e) {
      if (void 0 === e && (e = "float32"), "complex64" === e) {
       var n = En(t, "float32"),
        r = kn(t, "float32");
       return hn(n, r)
      }
      var i = nt(N(t), e);
      return Bt.makeTensor(i, t, e)
     }
 
     function kn(t, e) {
      if (void 0 === e && (e = "float32"), "complex64" === e) {
       var n = kn(t, "float32"),
        r = kn(t, "float32");
       return hn(n, r)
      }
      var i = rt(N(t), e);
      return Bt.makeTensor(i, t, e)
     }
 
     function In(t, e, n) {
      return Bt.runKernelFunc((function(r) {
       return r.fill(t, e, n)
      }), {})
     }
 
     function On(t, e, n) {
      if (n <= 0) throw new Error("The number of values should be positive.");
      return Bt.runKernelFunc((function(r) {
       return r.linspace(t, e, n)
      }), {})
     }
 
     function An(t, e, n, r) {
      if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
      if (t === e || t < e && n < 0 || e < t && n > 1) return kn([0], r);
      var i = rt(Math.abs(Math.ceil((e - t) / n)), r);
      e < t && 1 === n && (n = -1), i[0] = t;
      for (var o = 1; o < i.length; o++) i[o] = i[o - 1] + n;
      return gn(i, r)
     }
     var Nn = ln({
       onesLike_: function(t) {
        var e = Ze(t, "x", "onesLike");
        if ("complex64" === e.dtype) {
         var n = Nn(pn(e)),
          r = Rn(fn(e));
         return hn(n, r)
        }
        return Bt.runKernelFunc((function(t) {
         return t.onesLike(e)
        }), {
         $x: e
        }, (function(t, e) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Rn = ln({
       zerosLike_: function(t) {
        var e = Ze(t, "x", "zerosLike");
        return Bt.runKernelFunc((function(t) {
         return t.zerosLike(e)
        }), {
         $x: e
        }, (function(t, e) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Tn = ln({
       concat_: function(t, e) {
        void 0 === e && (e = 0), k(t.length >= 1, (function() {
         return "Pass at least one tensor to concat"
        }));
        var n = Je(t, "tensors", "concat");
        "complex64" === n[0].dtype && n.forEach((function(t) {
         if ("complex64" !== t.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t.dtype + ". ")
        })), e = B(e, n[0].shape)[0];
        var r = cn(n.map((function(t) {
         return t.shape
        })), e);
        if (0 === N(r)) return dn([], r);
        if (1 === (n = n.filter((function(t) {
          return t.size > 0
         }))).length) return n[0];
        var i = n.map((function(t) {
         return t.shape
        }));
        un(i, e);
        var o = n,
         a = {
          axis: e
         };
        return Bt.runKernelFunc((function(t) {
         return t.concat(n, e)
        }), o, (function(t) {
         var n = i.map((function(t) {
          return t[e]
         }));
         return Ln(t, n, e).map((function(t) {
          return function() {
           return t
          }
         }))
        }), "Concat", a)
       }
      }),
      _n = ln({
       concat1d_: function(t) {
        return Tn(t, 0)
       }
      }),
      Dn = ln({
       concat2d_: function(t, e) {
        return Tn(t, e)
       }
      }),
      Fn = ln({
       concat3d_: function(t, e) {
        return Tn(t, e)
       }
      }),
      Mn = ln({
       concat4d_: function(t, e) {
        return Tn(t, e)
       }
      }),
      Ln = ln({
       split_: function(t, e, n) {
        void 0 === n && (n = 0);
        var r, i = Ze(t, "x", "split");
        return n = B(n, i.shape)[0], "number" == typeof e ? (k(i.shape[n] % e == 0, (function() {
         return "Number of splits must evenly divide the axis."
        })), r = new Array(e).fill(i.shape[n] / e)) : (k(i.shape[n] === e.reduce((function(t, e) {
         return t + e
        })), (function() {
         return "The sum of sizes must match the size of the axis dimension."
        })), r = e), Bt.runKernelFunc((function(t) {
         return t.split(i, r, n)
        }), {
         $x: i
        }, (function(t) {
         return {
          $x: function() {
           return Tn(t, n)
          }
         }
        }))
       }
      });
 
     function Bn(t, e) {
      return t(e = {
       exports: {}
      }, e.exports), e.exports
     }
     "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof t || "undefined" != typeof self && self;
     var Pn = Bn((function(t) {
       ! function(t, e, n) {
        function r(t) {
         var e, n = this,
          r = (e = 4022871197, function(t) {
           t = t.toString();
           for (var n = 0; n < t.length; n++) {
            var r = .02519603282416938 * (e += t.charCodeAt(n));
            r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
           }
           return 2.3283064365386963e-10 * (e >>> 0)
          });
         n.next = function() {
          var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
          return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t)
         }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null
        }
 
        function i(t, e) {
         return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e
        }
 
        function o(t, e) {
         var n = new r(t),
          o = e && e.state,
          a = n.next;
         return a.int32 = function() {
          return 4294967296 * n.next() | 0
         }, a.double = function() {
          return a() + 11102230246251565e-32 * (2097152 * a() | 0)
         }, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
          return i(n, {})
         }), a
        }
        e && e.exports ? e.exports = o : n && n.amd ? n((function() {
         return o
        })) : this.alea = o
       }(0, t, !1)
      })),
      zn = Bn((function(t) {
       ! function(t, e, n) {
        function r(t) {
         var e = this,
          n = "";
         e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function() {
          var t = e.x ^ e.x << 11;
          return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8
         }, t === (0 | t) ? e.x = t : n += t;
         for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next()
        }
 
        function i(t, e) {
         return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
        }
 
        function o(t, e) {
         var n = new r(t),
          o = e && e.state,
          a = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return a.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, a.int32 = n.next, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
          return i(n, {})
         }), a
        }
        e && e.exports ? e.exports = o : n && n.amd ? n((function() {
         return o
        })) : this.xor128 = o
       }(0, t, !1)
      })),
      jn = Bn((function(t) {
       ! function(t, e, n) {
        function r(t) {
         var e = this,
          n = "";
         e.next = function() {
          var t = e.x ^ e.x >>> 2;
          return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0
         }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;
         for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next()
        }
 
        function i(t, e) {
         return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e
        }
 
        function o(t, e) {
         var n = new r(t),
          o = e && e.state,
          a = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return a.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, a.int32 = n.next, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
          return i(n, {})
         }), a
        }
        e && e.exports ? e.exports = o : n && n.amd ? n((function() {
         return o
        })) : this.xorwow = o
       }(0, t, !1)
      })),
      Wn = Bn((function(t) {
       ! function(t, e, n) {
        function r(t) {
         var e = this;
         e.next = function() {
           var t, n, r = e.x,
            i = e.i;
           return t = r[i], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[i + 1 & 7]) ^ t >>> 10, n ^= (t = r[i + 3 & 7]) ^ t >>> 3, n ^= (t = r[i + 4 & 7]) ^ t << 7, t = r[i + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[i] = n, e.i = i + 1 & 7, n
          },
          function(t, e) {
           var n, r = [];
           if (e === (0 | e)) r[0] = e;
           else
            for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;
           for (; r.length < 8;) r.push(0);
           for (n = 0; n < 8 && 0 === r[n]; ++n);
           for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next()
          }(e, t)
        }
 
        function i(t, e) {
         return e.x = t.x.slice(), e.i = t.i, e
        }
 
        function o(t, e) {
         null == t && (t = +new Date);
         var n = new r(t),
          o = e && e.state,
          a = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return a.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, a.int32 = n.next, a.quick = a, o && (o.x && i(o, n), a.state = function() {
          return i(n, {})
         }), a
        }
        e && e.exports ? e.exports = o : n && n.amd ? n((function() {
         return o
        })) : this.xorshift7 = o
       }(0, t, !1)
      })),
      Vn = Bn((function(t) {
       ! function(t, e, n) {
        function r(t) {
         var e = this;
         e.next = function() {
           var t, n, r = e.w,
            i = e.X,
            o = e.i;
           return e.w = r = r + 1640531527 | 0, n = i[o + 34 & 127], t = i[o = o + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = i[o] = n ^ t, e.i = o, n + (r ^ r >>> 16) | 0
          },
          function(t, e) {
           var n, r, i, o, a, s = [],
            u = 128;
           for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o) e && (r ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (a = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = 0 == (n = s[127 & o] ^= r + a) ? i + 1 : 0);
           for (i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o) r = s[i + 34 & 127], n = s[i = i + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[i] = r ^ n;
           t.w = a, t.X = s, t.i = i
          }(e, t)
        }
 
        function i(t, e) {
         return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e
        }
 
        function o(t, e) {
         null == t && (t = +new Date);
         var n = new r(t),
          o = e && e.state,
          a = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return a.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, a.int32 = n.next, a.quick = a, o && (o.X && i(o, n), a.state = function() {
          return i(n, {})
         }), a
        }
        e && e.exports ? e.exports = o : n && n.amd ? n((function() {
         return o
        })) : this.xor4096 = o
       }(0, t, !1)
      })),
      Un = Bn((function(t) {
       ! function(t, e, n) {
        function r(t) {
         var e = this,
          n = "";
         e.next = function() {
          var t = e.b,
           n = e.c,
           r = e.d,
           i = e.a;
          return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ i, e.a = i - t | 0
         }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;
         for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next()
        }
 
        function i(t, e) {
         return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e
        }
 
        function o(t, e) {
         var n = new r(t),
          o = e && e.state,
          a = function() {
           return (n.next() >>> 0) / 4294967296
          };
         return a.double = function() {
          do {
           var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
          } while (0 === t);
          return t
         }, a.int32 = n.next, a.quick = a, o && ("object" == typeof o && i(o, n), a.state = function() {
          return i(n, {})
         }), a
        }
        e && e.exports ? e.exports = o : n && n.amd ? n((function() {
         return o
        })) : this.tychei = o
       }(0, t, !1)
      })),
      Hn = Bn((function(t) {
       ! function(e, r) {
        var i, o = this,
         a = 256,
         s = 6,
         u = "random",
         c = r.pow(a, s),
         l = r.pow(2, 52),
         h = 2 * l,
         p = a - 1;
 
        function f(t, n, p) {
         var f = [],
          y = m(function t(e, n) {
           var r, i = [],
            o = typeof e;
           if (n && "object" == o)
            for (r in e) try {
             i.push(t(e[r], n - 1))
            } catch (t) {}
           return i.length ? i : "string" == o ? e : e + "\0"
          }((n = 1 == n ? {
           entropy: !0
          } : n || {}).entropy ? [t, g(e)] : null == t ? function() {
           try {
            var t;
            return i && (t = i.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), g(t)
           } catch (t) {
            var n = o.navigator,
             r = n && n.plugins;
            return [+new Date, o, r, o.screen, g(e)]
           }
          }() : t, 3), f),
          b = new d(f),
          x = function() {
           for (var t = b.g(s), e = c, n = 0; t < l;) t = (t + n) * a, e *= a, n = b.g(1);
           for (; t >= h;) t /= 2, e /= 2, n >>>= 1;
           return (t + n) / e
          };
         return x.int32 = function() {
          return 0 | b.g(4)
         }, x.quick = function() {
          return b.g(4) / 4294967296
         }, x.double = x, m(g(b.S), e), (n.pass || p || function(t, e, n, i) {
          return i && (i.S && v(i, b), t.state = function() {
           return v(b, {})
          }), n ? (r[u] = t, e) : t
         })(x, y, "global" in n ? n.global : this == r, n.state)
        }
 
        function d(t) {
         var e, n = t.length,
          r = this,
          i = 0,
          o = r.i = r.j = 0,
          s = r.S = [];
         for (n || (t = [n++]); i < a;) s[i] = i++;
         for (i = 0; i < a; i++) s[i] = s[o = p & o + t[i % n] + (e = s[i])], s[o] = e;
         (r.g = function(t) {
          for (var e, n = 0, i = r.i, o = r.j, s = r.S; t--;) e = s[i = p & i + 1], n = n * a + s[p & (s[i] = s[o = p & o + e]) + (s[o] = e)];
          return r.i = i, r.j = o, n
         })(a)
        }
 
        function v(t, e) {
         return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
        }
 
        function m(t, e) {
         for (var n, r = t + "", i = 0; i < r.length;) e[p & i] = p & (n ^= 19 * e[p & i]) + r.charCodeAt(i++);
         return g(e)
        }
 
        function g(t) {
         return String.fromCharCode.apply(0, t)
        }
        if (r["seed" + u] = f, m(r.random(), e), t.exports) {
         t.exports = f;
         try {
          i = n(4)
         } catch (t) {}
        }
       }([], Math)
      }));
     Hn.alea = Pn, Hn.xor128 = zn, Hn.xorwow = jn, Hn.xorshift7 = Wn, Hn.xor4096 = Vn, Hn.tychei = Un;
     var $n = Hn.alea,
      Gn = function() {
       function t(t, e, n, r, i) {
        this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
        var o = i || Math.random();
        this.random = $n(o.toString())
       }
       return t.prototype.nextValue = function() {
        if (!isNaN(this.nextVal)) {
         var t = this.nextVal;
         return this.nextVal = NaN, t
        }
        for (var e, n, r = !1; !r;) {
         var i = void 0,
          o = void 0,
          a = void 0;
         do {
          a = (i = 2 * this.random() - 1) * i + (o = 2 * this.random() - 1) * o
         } while (a >= 1 || 0 === a);
         var s = Math.sqrt(-2 * Math.log(a) / a);
         e = this.mean + this.stdDev * i * s, n = this.mean + this.stdDev * o * s, this.truncated && !this.isValidTruncated(e) || (r = !0)
        }
        return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e)
       }, t.prototype.convertValue = function(t) {
        return null == this.dtype || "float32" === this.dtype ? t : Math.round(t)
       }, t.prototype.isValidTruncated = function(t) {
        return t <= this.upper && t >= this.lower
       }, t
      }(),
      qn = function() {
       function t(t, e, n, r) {
        this.alpha = t, this.beta = 1 / e, this.dtype = n;
        var i = r || Math.random();
        this.randu = $n(i.toString()), this.randn = new Gn(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d)
       }
       return t.prototype.nextValue = function() {
        for (var t, e, n, r, i, o;;) {
         do {
          r = this.randn.nextValue(), o = 1 + this.c * r
         } while (o <= 0);
         if (o *= o * o, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - o + Math.log(o)), (i = this.randu()) < e || Math.log(i) < n) break
        }
        return o = 1 / this.beta * this.d * o, this.alpha < 1 && (o *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(o)
       }, t.prototype.convertValue = function(t) {
        return "float32" === this.dtype ? t : Math.round(t)
       }, t
      }(),
      Kn = function() {
       function t(t, e, n, r) {
        var i = this;
        if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function() {
          return null == i.dtype || "float32" === i.dtype
         }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t + " - " + e + " <= 1 and dtype is not float");
        this.random = $n(r)
       }
       return t.prototype.convertValue = function(t) {
        return this.canReturnFloat() ? t : Math.round(t)
       }, t.prototype.nextValue = function() {
        return this.convertValue(this.min + this.range * this.random())
       }, t
      }();
 
     function Xn(t, e, n) {
      return void 0 === e && (e = "float32"), e = e || "float32", ot(t), new gt(t, e, n)
     }
 
     function Yn(t, e) {
      void 0 === e && (e = !1), console.log(t.toString(e))
     }
     var Zn = ln({
       batchToSpaceND_: function(t, e, n) {
        var r = Ze(t, "x", "batchToSpaceND"),
         i = e.reduce((function(t, e) {
          return t * e
         }));
        return k(r.rank >= 1 + e.length, (function() {
         return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length
        })), k(n.length === e.length, (function() {
         return "crops.length is " + n.length + " but should be equal to blockShape.length  " + e.length
        })), k(r.shape[0] % i == 0, (function() {
         return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + i
        })), Bt.runKernelFunc((function(t) {
         return t.batchToSpaceND(r, e, n)
        }), {
         $x: r
        }, (function(t) {
         return {
          $x: function() {
           return t.spaceToBatchND(e, n)
          }
         }
        }))
       }
      }),
      Jn = ln({
       broadcastTo_: function(t, e) {
        var n = Ze(t, "broadcastTo", "x"),
         r = n.shape;
        if (e.some((function(t) {
          return !(t > 0) || t % 1 != 0
         }))) throw new Error("broadcastTo(): Invalid broadcast shape [" + e + "].");
        if (e.length < n.rank) throw new Error("broadcastTo(): shape.length=" + e.length + " < input.rank=" + n.rank + ".");
        if (e.length > n.rank) {
         for (var i = n.shape.slice(); i.length < e.length;) i.unshift(1);
         n = n.reshape(i)
        }
        for (var o = Array.from(e), a = e.length - 1; a >= 0; a--)
         if (n.shape[a] === e[a]) o[a] = 1;
         else if (1 !== n.shape[a]) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + e + "].");
        var s = o.map((function(t, e) {
         return t > 1 ? e : -1
        })).filter((function(t) {
         return t >= 0
        }));
        return 0 === s.length ? n.clone() : Bt.runKernelFunc((function(t) {
         return t.tile(n, o)
        }), {
         input: n
        }, (function(t) {
         return {
          input: function() {
           return t.sum(s, !0)
          }
         }
        }))
       }
      }),
      Qn = ln({
       cast_: function(t, e) {
        var n = Ze(t, "x", "cast");
        if (!V(e)) throw new Error("Failed to cast to unknown dtype " + e);
        if ("string" === e && "string" !== n.dtype || "string" !== e && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
        var r = {
         dtype: e
        };
        return Bt.runKernelFunc((function(t) {
         return t.cast(n, e)
        }), {
         x: n
        }, (function(t) {
         return {
          x: function() {
           return t.clone()
          }
         }
        }), "Cast", r)
       }
      }),
      tr = ln({
       clone_: function(t) {
        var e = Ze(t, "x", "clone", null);
        return Bt.runKernelFunc((function() {
         return Bt.makeTensorFromDataId(e.dataId, e.shape, e.dtype)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return t.toFloat()
          }
         }
        }))
       }
      }),
      er = ln({
       cumsum_: function(t, e, n, r) {
        void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
        var i = Ze(t, "x", "cumsum"),
         o = on([e |= 0], i.rank),
         a = i;
        null != o && (a = i.transpose(o));
        var s = sn(1, i.rank)[0],
         u = Bt.runKernelFunc((function(t) {
          return t.cumsum(a, s, n, r)
         }), {
          permutedX: a
         }, (function(t) {
          return {
           permutedX: function() {
            return t.cumsum(e, n, !r)
           }
          }
         }));
        return null != o && (u = u.transpose(o)), u
       }
      }),
      nr = ln({
       depthToSpace_: function(t, e, n) {
        void 0 === n && (n = "NHWC");
        var r = Ze(t, "x", "depthToSpace"),
         i = "NHWC" === n ? r.shape[1] : r.shape[2],
         o = "NHWC" === n ? r.shape[2] : r.shape[3],
         a = "NHWC" === n ? r.shape[3] : r.shape[1];
        return k(i * e >= 0, (function() {
         return "Negative dimension size caused by overflow when multiplying\n      " + i + " and " + e + "  for depthToSpace with input shape\n      " + r.shape
        })), k(o * e >= 0, (function() {
         return "Negative dimension size caused by overflow when multiplying\n      " + o + " and " + e + " for depthToSpace with input shape\n          " + r.shape
        })), k(a % (e * e) == 0, (function() {
         return "Dimension size must be evenly divisible by " + e * e + " but is " + a + " for depthToSpace with input shape " + r.shape
        })), Bt.runKernelFunc((function(t) {
         return t.depthToSpace(r, e, n)
        }), {
         $x: r
        })
       }
      }),
      rr = ln({
       expandDims_: function(t, e) {
        void 0 === e && (e = 0);
        var n = Ze(t, "x", "expandDims", null);
        k(e <= n.rank, (function() {
         return "Axis must be <= rank of the tensor"
        }));
        var r = n.shape.slice();
        return e < 0 && (k(-(n.rank + 1) <= e, (function() {
         return "Axis must be in the interval [" + -(n.rank + 1) + ", " + n.rank + "]"
        })), e = n.rank + e + 1), r.splice(e, 0, 1), mr(n, r)
       }
      }),
      ir = ln({
       eye_: function(t, e, n, r) {
        void 0 === r && (r = "float32"), null == e && (e = t);
        for (var i = Xn([t, e], r), o = t <= e ? t : e, a = 0; a < o; ++a) i.set(1, a, a);
        var s = i.toTensor().as2D(t, e);
        if (null == n) return s;
        if (1 === n.length) return xr(rr(s, 0), [n[0], 1, 1]);
        if (2 === n.length) return xr(rr(rr(s, 0), 0), [n[0], n[1], 1, 1]);
        if (3 === n.length) return xr(rr(rr(rr(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
        throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.")
       }
      }),
      or = ln({
       multinomial_: function(t, e, n, r) {
        void 0 === r && (r = !1);
        var i = Ze(t, "logits", "multinomial"),
         o = i.size,
         a = i.rank;
        if (o < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + o + ".");
        if (a > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + a);
        n = n || Math.random();
        var s = 1 === a ? i.as2D(1, -1) : i,
         u = Bt.runKernelFunc((function(t) {
          return t.multinomial(s, r, e, n)
         }), {
          logits2D: s
         });
        return 1 === a ? u.as1D() : u
       }
      }),
      ar = ln({
       oneHot_: function(t, e, n, r) {
        if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
        var i = Ze(t, "indices", "oneHot", "int32"),
         o = i.shape.concat([e]);
        return i = i.flatten(), Bt.runKernelFunc((function(t) {
         return t.oneHot(i, e, n, r)
        }), {
         $indices: i
        }, (function(t) {
         return {
          $indices: function() {
           return kn(i.shape, "float32")
          }
         }
        })).reshape(o)
       }
      }),
      sr = ln({
       pad_: function(t, e, n) {
        void 0 === n && (n = 0);
        var r = Ze(t, "x", "pad");
        if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
        var i = {
         paddings: e,
         constantValue: n
        };
        return Bt.runKernelFunc((function(t) {
         return t.pad(r, e, n)
        }), {
         x: r
        }, (function(t) {
         var n = e.map((function(t) {
          return t[0]
         }));
         return {
          x: function() {
           return t.slice(n, r.shape)
          }
         }
        }), "PadV2", i)
       }
      }),
      ur = ln({
       pad1d_: function(t, e, n) {
        return void 0 === n && (n = 0), k(2 === e.length, (function() {
         return "Invalid number of paddings. Must be length of 2."
        })), sr(t, [e], n)
       }
      }),
      cr = ln({
       pad2d_: function(t, e, n) {
        return void 0 === n && (n = 0), k(2 === e.length && 2 === e[0].length && 2 === e[1].length, (function() {
         return "Invalid number of paddings. Must be length of 2 each."
        })), sr(t, e, n)
       }
      }),
      lr = ln({
       pad3d_: function(t, e, n) {
        return void 0 === n && (n = 0), k(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, (function() {
         return "Invalid number of paddings. Must be length of 2 each."
        })), sr(t, e, n)
       }
      }),
      hr = ln({
       pad4d_: function(t, e, n) {
        return void 0 === n && (n = 0), k(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, (function() {
         return "Invalid number of paddings. Must be length of 2 each."
        })), sr(t, e, n)
       }
      }),
      pr = ln({
       rand_: function(t, e, n) {
        var r = N(t),
         i = null;
        if (null == n || "float32" === n) i = new Float32Array(r);
        else if ("int32" === n) i = new Int32Array(r);
        else {
         if ("bool" !== n) throw new Error("Unknown data type " + n);
         i = new Uint8Array(r)
        }
        for (var o = 0; o < r; o++) i[o] = e();
        return Bt.makeTensor(i, t, n)
       }
      }),
      fr = ln({
       randomNormal_: function(t, e, n, r, i) {
        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
        for (var o = new Gn(e, n, r, !1, i), a = Xn(t, r), s = 0; s < a.values.length; s++) a.values[s] = o.nextValue();
        return a.toTensor()
       }
      }),
      dr = ln({
       randomGamma_: function(t, e, n, r, i) {
        if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);
        for (var o = new qn(e, n, r, i), a = Xn(t, r), s = 0; s < a.values.length; s++) a.values[s] = o.nextValue();
        return a.toTensor()
       }
      }),
      vr = ln({
       randomUniform_: function(t, e, n, r, i) {
        void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");
        for (var o = Xn(t, r), a = new Kn(e, n, null, i), s = 0; s < o.values.length; s++) o.values[s] = a.nextValue();
        return o.toTensor()
       }
      }),
      mr = ln({
       reshape_: function(t, e) {
        var n = Ze(t, "x", "reshape", null);
        e = L(e, n.size), k(n.size === N(e), (function() {
         return "new shape and old shape must have the same number of elements."
        }));
        var r = {
         shape: e
        };
        return Bt.runKernelFunc((function(t) {
         return t.reshape(n, e)
        }), {
         x: n
        }, (function(t) {
         return {
          x: function() {
           return t.reshape(n.shape)
          }
         }
        }), "Reshape", r)
       }
      }),
      gr = ln({
       spaceToBatchND_: function(t, e, n) {
        var r = Ze(t, "x", "spaceToBatchND");
        return k(r.rank >= 1 + e.length, (function() {
         return "input rank " + r.rank + " should be > than [blockShape] " + e.length
        })), k(n.length === e.length, (function() {
         return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + e.length
        })), k(r.shape.reduce((function(t, r, i) {
         return i > 0 && i <= e.length ? t && (r + n[i - 1][0] + n[i - 1][1]) % e[i - 1] == 0 : t
        }), !0), (function() {
         return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + e.toString()
        })), Bt.runKernelFunc((function(t) {
         return t.spaceToBatchND(r, e, n)
        }), {
         $x: r
        }, (function(t) {
         return {
          $x: function() {
           return t.batchToSpaceND(e, n)
          }
         }
        }))
       }
      }),
      yr = ln({
       squeeze_: function(t, e) {
        var n = Ze(t, "x", "squeeze");
        return mr(n, P(n.shape, e).newShape)
       }
      }),
      br = ln({
       stack_: function(t, e) {
        void 0 === e && (e = 0);
        var n = Je(t, "tensors", "stack");
        if (k(n.length >= 1, (function() {
          return "Pass at least one tensor to tf.stack"
         })), 1 === n.length) return n[0].expandDims(e);
        var r = n[0].rank,
         i = n[0].shape,
         o = n[0].dtype;
        k(e <= r, (function() {
         return "Axis must be <= rank of the tensor"
        })), n.forEach((function(t) {
         I(i, t.shape, "All tensors passed to stack must have matching shapes")
        })), n.forEach((function(t) {
         k(o === t.dtype, (function() {
          return "All tensors passed to stack must have matching dtypes"
         }))
        }));
        var a = n.map((function(t) {
         return t.expandDims(e)
        }));
        return Tn(a, e)
       }
      }),
      xr = ln({
       tile_: function(t, e) {
        var n = Ze(t, "x", "tile", null);
        k(n.rank === e.length, (function() {
         return "Error in transpose: rank of input " + n.rank + " must match length of reps " + e + "."
        }));
        var r = [n],
         i = {
          reps: e
         };
        return Bt.runKernelFunc((function(t, r) {
         var i = t.tile(n, e);
         return r([n]), i
        }), {
         x: n
        }, (function(t, n) {
         var r = n[0];
         return {
          x: function() {
           var n = Rn(r);
           if (1 === r.rank)
            for (var i = 0; i < e[0]; ++i) n = n.add(t.slice([i * r.shape[0]], [r.shape[0]]));
           else if (2 === r.rank)
            for (i = 0; i < e[0]; ++i)
             for (var o = 0; o < e[1]; ++o) n = n.add(t.slice([i * r.shape[0], o * r.shape[1]], [r.shape[0], r.shape[1]]));
           else if (3 === r.rank)
            for (i = 0; i < e[0]; ++i)
             for (o = 0; o < e[1]; ++o)
              for (var a = 0; a < e[2]; ++a) n = n.add(t.slice([i * r.shape[0], o * r.shape[1], a * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
           else {
            if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");
            for (i = 0; i < e[0]; ++i)
             for (o = 0; o < e[1]; ++o)
              for (a = 0; a < e[2]; ++a)
               for (var s = 0; s < e[3]; ++s) n = n.add(t.slice([i * r.shape[0], o * r.shape[1], a * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]))
           }
           return n
          }
         }
        }), "Tile", i, r)
       }
      }),
      wr = ln({
       truncatedNormal_: function(t, e, n, r, i) {
        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
        for (var o = new Gn(e, n, r, !0, i), a = Xn(t, r), s = 0; s < a.values.length; s++) a.values[s] = o.nextValue();
        return a.toTensor()
       }
      }),
      Cr = ln({
       unstack_: function(t, e) {
        void 0 === e && (e = 0), e = e || 0;
        var n = Ze(t, "x", "unstack");
        k(e >= -n.shape.length && e < n.shape.length, (function() {
         return "Axis = " + e + " is not in [-" + n.shape.length + ", " + n.shape.length + ")"
        })), e < 0 && (e += n.shape.length);
        var r = {
         axis: e
        };
        return Bt.runKernelFunc((function(t) {
         return t.unstack(n, e)
        }), {
         x: n
        }, (function(t) {
         return {
          x: function() {
           return br(t, e)
          }
         }
        }), "Unpack", r)
       }
      }),
      Sr = function(t, e) {
       return s(this, void 0, void 0, (function() {
        var n, r, i, o, a, s, c, l, h, p;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return n = Ze(t, "x", "setdiff1d"), r = Ze(e, "y", "setdiff1d"), k(n.dtype === r.dtype, (function() {
            return "x and y should have the same dtype, but got x (" + n.dtype + ") and y (" + r.dtype + ")."
           })), k(1 === n.rank, (function() {
            return "x should be 1D tensor, but got x (" + n.shape + ")."
           })), k(1 === r.rank, (function() {
            return "y should be 1D tensor, but got y (" + r.shape + ")."
           })), [4, n.data()];
          case 1:
           return i = u.sent(), [4, r.data()];
          case 2:
           for (o = u.sent(), a = new Set(o), s = 0, h = 0; h < i.length; h++) a.has(i[h]) || s++;
           for (c = new gt([s], n.dtype), l = new gt([s], "int32"), h = 0, p = 0; h < i.length; h++) a.has(i[h]) || (c.values[p] = i[h], l.values[p] = h, p++);
           return [2, [c.toTensor(), l.toTensor()]]
         }
        }))
       }))
      };
 
     function Er(t, e, n, r) {
      void 0 === r && (r = !0);
      var i = [];
      if (r)(i = i.concat(e.slice(0))).push(t[0] / n), i = i.concat(t.slice(1));
      else {
       i = i.concat(t[0]);
       for (var o = e.length, a = 0; a < o; ++a) i = i.concat([t[a + 1] / e[a], e[a]]);
       i = i.concat(t.slice(o + 1))
      }
      return i
     }
 
     function kr(t, e, n) {
      void 0 === n && (n = !0);
      var r = [];
      if (n) {
       r.push(e);
       for (var i = e + 1; i < t; ++i) i <= 2 * e ? (r.push(i), r.push(i - (e + 1))) : r.push(i)
      } else {
       var o = [],
        a = [];
       for (i = 1; i < t; ++i) i >= 2 * e + 1 || i % 2 == 1 ? a.push(i) : o.push(i);
       r.push.apply(r, o), r.push(0), r.push.apply(r, a)
      }
      return r
     }
 
     function Ir(t, e, n, r) {
      void 0 === r && (r = !0);
      var i = [];
      r ? i.push(t[0] / n) : i.push(t[0] * n);
      for (var o = 1; o < t.length; ++o) o <= e.length ? r ? i.push(e[o - 1] * t[o]) : i.push(t[o] / e[o - 1]) : i.push(t[o]);
      return i
     }
 
     function Or(t, e) {
      for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);
      return n
     }
 
     function Ar(t, e, n) {
      for (var r = t.slice(0, 1), i = 0; i < n; ++i) r.push(t[i + 1] - e[i][0] - e[i][1]);
      return r
     }
 
     function Nr(t, e) {
      if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t.rank + ".");
      if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
      if ("int32" !== e.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
      if (e.shape[e.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + t.rank);
      if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t.shape + ".");
      for (var n = e.shape, r = n[n.length - 1], i = 1, o = 0; o < n.length - 1; ++o) i *= n[o];
      var a = t.shape,
       s = n.slice();
      s.pop();
      var u = 1;
      for (o = r; o < t.rank; ++o) u *= a[o], s.push(a[o]);
      var c = Q(t.shape).map((function(t) {
       return t / u
      })).concat([1]).slice(0, r);
      return [s, i, u, c]
     }
     Object.freeze({
      prepareAndValidate: Nr
     });
     var Rr = 30;
 
     function Tr(t) {
      return t <= Rr ? t : J(t, Math.floor(Math.sqrt(t)))
     }
 
     function _r(t, e, n) {
      var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
       i = e.rank > 1 ? e.rank - 1 : 1,
       o = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + e.shape + ", shape: " + t + ", sliceDim: " + r + ", and batchDim: " + i + ".";
      if (n.rank < i) throw new Error(o + " update.rank < " + i + ". ");
      if (t.length < r + (n.rank - i)) throw new Error(o + " Output shape length < " + (r + (n.rank - i)));
      if (n.rank !== i + t.length - r) throw new Error(o + " update.rank != " + (i + t.length - r));
      for (var a = 0; a < i; ++a)
       if (n.shape[a] !== e.shape[a]) throw new Error(o + " updates.shape[" + a + "] (" + n.shape[a] + ") != indices.shape[" + a + "] (" + e.shape[a] + ").");
      for (a = 0; a < n.rank - i; ++a)
       if (n.shape[a + i] !== t[a + r]) throw new Error(o + " updates.shape[" + (a + i) + "] (" + n.shape[a + i] + ") != shape[" + (a + i) + "] (" + t[a + i] + ")")
     }
 
     function Dr(t, e, n) {
      if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
      if (t.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t.rank + ".");
      if ("int32" !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
      if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);
      if (0 === n.length) {
       if (0 === e.size) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
       if (0 === t.size) throw new Error("Updates specified for empty output. updates shape: " + t.shape)
      }
      _r(n, e, t)
     }
 
     function Fr(t, e, n) {
      for (var r = e.shape.length, i = r > 1 ? e.shape[r - 1] : 1, o = n.length, a = 1, s = i; s < o; ++s) a *= n[s];
      var u = i < 1 ? 1 : i;
      return {
       sliceRank: i,
       numUpdates: N(e.shape) / u,
       sliceSize: a,
       strides: Q(n.slice(0, i)).concat([1]),
       outputSize: N(n)
      }
     }
     Object.freeze({
      validateUpdateShape: _r,
      validateInput: Dr,
      calculateShapes: Fr
     });
 
     function Mr(t, e, n) {
      k(t.rank === e.length, (function() {
       return "Error in slice" + t.rank + "D: Length of begin " + e + " must match the rank of the array (" + t.rank + ")."
      })), k(t.rank === n.length, (function() {
       return "Error in slice" + t.rank + "D: Length of size " + n + " must match the rank of the array (" + t.rank + ")."
      }));
      for (var r = function(r) {
        k(e[r] + n[r] <= t.shape[r], (function() {
         return "Error in slice" + t.rank + "D: begin[" + r + "] + size[" + r + "] (" + (e[r] + n[r]) + ") would overflow input.shape[" + r + "] (" + t.shape[r] + ")"
        }))
       }, i = 0; i < t.rank; ++i) r(i)
     }
 
     function Lr(t) {
      for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;
      return e
     }
 
     function Br(t, e, n) {
      for (var r = [], i = 0; i < t.length; i++) r[i] = Math.ceil((e[i] - t[i]) / n[i]);
      return r
     }
 
     function Pr(t, e, n, r, i) {
      var o = e[i],
       a = n[i] || 1;
      (t & 1 << i || null == o) && (o = a > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
      var s = r[i];
      return o < 0 && (o += s), C(0, o, s - 1)
     }
 
     function zr(t, e, n, r, i) {
      var o = e[i],
       a = n[i] || 1;
      (t & 1 << i || null == o) && (o = a > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
      var s = r[i];
      return o < 0 && (o += s), a > 0 ? C(0, o, s) : C(-1, o, s - 1)
     }
 
     function jr(t, e, n) {
      for (var r = n.length, i = 0; i < n.length; i++)
       if (n[i] > 1) {
        r = i;
        break
       } for (i = r + 1; i < n.length; i++)
       if (e[i] > 0 || n[i] !== t[i]) return !1;
      return !0
     }
 
     function Wr(t, e) {
      for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];
      return n
     }
     Object.freeze({
      assertParamsValid: Mr,
      maskToAxes: Lr,
      computeOutShape: Br,
      startForAxis: Pr,
      stopForAxis: zr,
      isSliceContinous: jr,
      computeFlatOffset: Wr
     });
 
     function Vr(t, e) {
      k(Z(t), (function() {
       return "The f passed in variableGrads(f) must be a function"
      })), k(null == e || Array.isArray(e) && e.every((function(t) {
       return t instanceof Ot
      })), (function() {
       return "The varList passed in variableGrads(f, varList) must be an array of variables"
      }));
      var n = null != e;
      if (!n)
       for (var r in e = [], Bt.registeredVariables) e.push(Bt.registeredVariables[r]);
      var i = n ? e.filter((function(t) {
        return !t.trainable
       })) : null,
       o = e.length;
      k((e = e.filter((function(t) {
       return t.trainable
      }))).length > 0, (function() {
       return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + o + " variables is trainable."
      }));
      var a = Bt.gradients(t, e, null, !0),
       s = a.value,
       u = a.grads;
      k(u.some((function(t) {
       return null != t
      })), (function() {
       return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."
      })), k(0 === s.rank, (function() {
       return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor"
      }));
      var c = {};
      return e.forEach((function(t, e) {
       null != u[e] && (c[t.name] = u[e])
      })), null != i && i.forEach((function(t) {
       return c[t.name] = null
      })), {
       value: s,
       grads: c
      }
     }
 
     function Ur(t) {
      return Bt.customGrad(t)
     }
     var Hr = ln({
       softmax_: function(t, e) {
        void 0 === e && (e = -1);
        var n = Ze(t, "logits", "softmax");
        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + e);
        return Ur((function(t, n) {
         var r = t.logSumExp([e], !0),
          i = t.toFloat().sub(r).exp();
         return n([i]), {
          value: i,
          gradFunc: function(t, n) {
           var r = n[0],
            i = t.mul(r);
           return i.sub(i.sum([e], !0).mul(r))
          }
         }
        }))(n)
       }
      }),
      $r = ln({
       logSoftmax_: function(t, e) {
        void 0 === e && (e = -1);
        var n = Ze(t, "logits", "logSoftmax");
        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + e);
        return Ur((function(t, n) {
         var r = t.max(e, !0),
          i = t.sub(r),
          o = i.toFloat().sub(i.exp().sum(e, !0).log());
         return n([o]), {
          value: o,
          gradFunc: function(t, n) {
           var r = n[0].exp();
           return t.sub(t.sum(e, !0).mul(r))
          }
         }
        }))(n)
       }
      }),
      Gr = function() {
       function t(t, e) {
        this.backend = t, this.dataMover = e, this.data = new WeakMap, this.dataIdsCount = 0
       }
       return t.prototype.get = function(t) {
        return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t)
       }, t.prototype.set = function(t, e) {
        this.dataIdsCount++, this.data.set(t, e)
       }, t.prototype.has = function(t) {
        return this.data.has(t)
       }, t.prototype.delete = function(t) {
        return this.dataIdsCount--, this.data.delete(t)
       }, t.prototype.numDataIds = function() {
        return this.dataIdsCount
       }, t
      }(),
      qr = function() {
       function t() {}
       return t.prototype.time = function(t) {
        return Kr("time")
       }, t.prototype.read = function(t) {
        return Kr("read")
       }, t.prototype.readSync = function(t) {
        return Kr("readSync")
       }, t.prototype.numDataIds = function() {
        return Kr("numDataIds")
       }, t.prototype.disposeData = function(t) {
        return Kr("disposeData")
       }, t.prototype.write = function(t, e, n) {
        return Kr("write")
       }, t.prototype.move = function(t, e, n, r) {
        return Kr("move")
       }, t.prototype.memory = function() {
        return Kr("memory")
       }, t.prototype.floatPrecision = function() {
        return Kr("floatPrecision")
       }, t.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4
       }, t.prototype.batchMatMul = function(t, e, n, r) {
        return Kr("batchMatMul")
       }, t.prototype.fusedBatchMatMul = function(t) {
        return t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights, Kr("fusedBatchMatMul")
       }, t.prototype.slice = function(t, e, n) {
        return Kr("slice")
       }, t.prototype.stridedSlice = function(t, e, n, r) {
        return Kr("stridedSlice")
       }, t.prototype.unstack = function(t, e) {
        return Kr("unstack")
       }, t.prototype.reverse = function(t, e) {
        return Kr("reverse")
       }, t.prototype.concat = function(t, e) {
        return Kr("concat")
       }, t.prototype.neg = function(t) {
        return Kr("neg")
       }, t.prototype.add = function(t, e) {
        return Kr("add")
       }, t.prototype.addN = function(t) {
        return Kr("addN")
       }, t.prototype.subtract = function(t, e) {
        return Kr("subtract")
       }, t.prototype.multiply = function(t, e) {
        return Kr("multiply")
       }, t.prototype.realDivide = function(t, e) {
        return Kr("realDivide")
       }, t.prototype.floorDiv = function(t, e) {
        return Kr("floorDiv")
       }, t.prototype.sum = function(t, e) {
        return Kr("sum")
       }, t.prototype.prod = function(t, e) {
        return Kr("prod")
       }, t.prototype.unsortedSegmentSum = function(t, e, n) {
        return Kr("unsortedSegmentSum")
       }, t.prototype.argMin = function(t, e) {
        return Kr("argMin")
       }, t.prototype.argMax = function(t, e) {
        return Kr("argMax")
       }, t.prototype.equal = function(t, e) {
        return Kr("equal")
       }, t.prototype.notEqual = function(t, e) {
        return Kr("notEqual")
       }, t.prototype.less = function(t, e) {
        return Kr("less")
       }, t.prototype.lessEqual = function(t, e) {
        return Kr("lessEqual")
       }, t.prototype.greater = function(t, e) {
        return Kr("greater")
       }, t.prototype.greaterEqual = function(t, e) {
        return Kr("greaterEqual")
       }, t.prototype.logicalNot = function(t) {
        return Kr("logicalNot")
       }, t.prototype.logicalAnd = function(t, e) {
        return Kr("logicalAnd")
       }, t.prototype.logicalOr = function(t, e) {
        return Kr("logicalOr")
       }, t.prototype.where = function(t) {
        return Kr("where")
       }, t.prototype.select = function(t, e, n) {
        return Kr("select")
       }, t.prototype.topk = function(t, e, n) {
        return Kr("topk")
       }, t.prototype.min = function(t, e) {
        return Kr("min")
       }, t.prototype.minimum = function(t, e) {
        return Kr("minimum")
       }, t.prototype.mod = function(t, e) {
        return Kr("mod")
       }, t.prototype.max = function(t, e) {
        return Kr("max")
       }, t.prototype.maximum = function(t, e) {
        return Kr("maximum")
       }, t.prototype.all = function(t, e) {
        return Kr("all")
       }, t.prototype.any = function(t, e) {
        return Kr("any")
       }, t.prototype.squaredDifference = function(t, e) {
        return Kr("squaredDifference")
       }, t.prototype.ceil = function(t) {
        return Kr("ceil")
       }, t.prototype.floor = function(t) {
        return Kr("floor")
       }, t.prototype.round = function(t) {
        return Kr("round")
       }, t.prototype.sign = function(t) {
        return Kr("sign")
       }, t.prototype.isNaN = function(t) {
        return Kr("isNaN")
       }, t.prototype.isInf = function(t) {
        return Kr("isInf")
       }, t.prototype.isFinite = function(t) {
        return Kr("isFinite")
       }, t.prototype.pow = function(t, e) {
        return Kr("pow")
       }, t.prototype.exp = function(t) {
        return Kr("exp")
       }, t.prototype.expm1 = function(t) {
        return Kr("expm1")
       }, t.prototype.log = function(t) {
        return Kr("log")
       }, t.prototype.log1p = function(t) {
        return Kr("log1p")
       }, t.prototype.sqrt = function(t) {
        return Kr("sqrt")
       }, t.prototype.rsqrt = function(t) {
        return Kr("rsqrt")
       }, t.prototype.square = function(t) {
        return Kr("square")
       }, t.prototype.reciprocal = function(t) {
        return Kr("reciprocal")
       }, t.prototype.relu = function(t) {
        return Kr("relu")
       }, t.prototype.relu6 = function(t) {
        return Kr("relu6")
       }, t.prototype.prelu = function(t, e) {
        return Kr("prelu")
       }, t.prototype.elu = function(t) {
        return Kr("elu")
       }, t.prototype.eluDer = function(t, e) {
        return Kr("eluDer")
       }, t.prototype.selu = function(t) {
        return Kr("selu")
       }, t.prototype.int = function(t) {
        return Kr("int")
       }, t.prototype.clip = function(t, e, n) {
        return Kr("clip")
       }, t.prototype.abs = function(t) {
        return Kr("abs")
       }, t.prototype.complexAbs = function(t) {
        return Kr("complexAbs")
       }, t.prototype.sigmoid = function(t) {
        return Kr("sigmoid")
       }, t.prototype.softplus = function(t) {
        return Kr("softplus")
       }, t.prototype.sin = function(t) {
        return Kr("sin")
       }, t.prototype.cos = function(t) {
        return Kr("cos")
       }, t.prototype.tan = function(t) {
        return Kr("tan")
       }, t.prototype.asin = function(t) {
        return Kr("asin")
       }, t.prototype.acos = function(t) {
        return Kr("acos")
       }, t.prototype.atan = function(t) {
        return Kr("atan")
       }, t.prototype.atan2 = function(t, e) {
        return Kr("atan2")
       }, t.prototype.sinh = function(t) {
        return Kr("sinh")
       }, t.prototype.cosh = function(t) {
        return Kr("cosh")
       }, t.prototype.tanh = function(t) {
        return Kr("tanh")
       }, t.prototype.asinh = function(t) {
        return Kr("asinh")
       }, t.prototype.acosh = function(t) {
        return Kr("acosh")
       }, t.prototype.atanh = function(t) {
        return Kr("atanh")
       }, t.prototype.erf = function(t) {
        return Kr("erf")
       }, t.prototype.step = function(t, e) {
        return Kr("step")
       }, t.prototype.fusedConv2d = function(t) {
        return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Kr("fusedConv2d")
       }, t.prototype.conv2d = function(t, e, n) {
        return Kr("conv2d")
       }, t.prototype.conv2dDerInput = function(t, e, n) {
        return Kr("conv2dDerInput")
       }, t.prototype.conv2dDerFilter = function(t, e, n) {
        return Kr("conv2dDerFilter")
       }, t.prototype.fusedDepthwiseConv2D = function(t) {
        return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Kr("fusedDepthwiseConv2D")
       }, t.prototype.depthwiseConv2D = function(t, e, n) {
        return Kr("depthwiseConv2D")
       }, t.prototype.depthwiseConv2DDerInput = function(t, e, n) {
        return Kr("depthwiseConv2DDerInput")
       }, t.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
        return Kr("depthwiseConv2DDerFilter")
       }, t.prototype.conv3d = function(t, e, n) {
        return Kr("conv3d")
       }, t.prototype.conv3dDerInput = function(t, e, n) {
        return Kr("conv3dDerInput")
       }, t.prototype.conv3dDerFilter = function(t, e, n) {
        return Kr("conv3dDerFilter")
       }, t.prototype.maxPool = function(t, e) {
        return Kr("maxPool")
       }, t.prototype.maxPoolBackprop = function(t, e, n, r) {
        return Kr("maxPoolBackprop")
       }, t.prototype.avgPool = function(t, e) {
        return Kr("avgPool")
       }, t.prototype.avgPoolBackprop = function(t, e, n) {
        return Kr("avgPoolBackprop")
       }, t.prototype.avgPool3d = function(t, e) {
        return Kr("avgPool3d")
       }, t.prototype.avgPool3dBackprop = function(t, e, n) {
        return Kr("avgPool3dBackprop")
       }, t.prototype.maxPool3d = function(t, e) {
        return Kr("maxPool3d")
       }, t.prototype.maxPool3dBackprop = function(t, e, n, r) {
        return Kr("maxPool3dBackprop")
       }, t.prototype.reshape = function(t, e) {
        return Kr("reshape")
       }, t.prototype.cast = function(t, e) {
        return Kr("cast")
       }, t.prototype.tile = function(t, e) {
        return Kr("tile")
       }, t.prototype.pad = function(t, e, n) {
        return Kr("pad")
       }, t.prototype.transpose = function(t, e) {
        return Kr("transpose")
       }, t.prototype.gather = function(t, e, n) {
        return Kr("gather")
       }, t.prototype.gatherND = function(t, e) {
        return Kr("gatherND")
       }, t.prototype.scatterND = function(t, e, n) {
        return Kr("scatterND")
       }, t.prototype.batchToSpaceND = function(t, e, n) {
        return Kr("batchToSpaceND")
       }, t.prototype.spaceToBatchND = function(t, e, n) {
        return Kr("spaceToBatchND")
       }, t.prototype.resizeBilinear = function(t, e, n, r) {
        return Kr("resizeBilinear")
       }, t.prototype.resizeBilinearBackprop = function(t, e, n) {
        return Kr("resizeBilinearBackprop")
       }, t.prototype.resizeNearestNeighbor = function(t, e, n, r) {
        return Kr("resizeNearestNeighbor")
       }, t.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
        return Kr("resizeNearestNeighborBackprop")
       }, t.prototype.batchNormalization = function(t, e, n, r, i, o) {
        return Kr("batchNormalization")
       }, t.prototype.localResponseNormalization4D = function(t, e, n, r, i) {
        return Kr("localResponseNormalization4D")
       }, t.prototype.LRNGrad = function(t, e, n, r, i, o, a) {
        return Kr("LRNGrad")
       }, t.prototype.multinomial = function(t, e, n, r) {
        return Kr("multinomial")
       }, t.prototype.oneHot = function(t, e, n, r) {
        return Kr("oneHot")
       }, t.prototype.cumsum = function(t, e, n, r) {
        return Kr("cumsum")
       }, t.prototype.nonMaxSuppression = function(t, e, n, r, i) {
        return Kr("nonMaxSuppression")
       }, t.prototype.fft = function(t) {
        return Kr("fft")
       }, t.prototype.ifft = function(t) {
        return Kr("ifft")
       }, t.prototype.complex = function(t, e) {
        return Kr("complex")
       }, t.prototype.real = function(t) {
        return Kr("real")
       }, t.prototype.imag = function(t) {
        return Kr("imag")
       }, t.prototype.cropAndResize = function(t, e, n, r, i, o) {
        return Kr("cropAndResize")
       }, t.prototype.depthToSpace = function(t, e, n) {
        return Kr("depthToSpace")
       }, t.prototype.split = function(t, e, n) {
        return Kr("split")
       }, t.prototype.sparseToDense = function(t, e, n, r) {
        return Kr("sparseToDense")
       }, t.prototype.diag = function(t) {
        return Kr("diag")
       }, t.prototype.fill = function(t, e, n) {
        return Kr("fill")
       }, t.prototype.onesLike = function(t) {
        return Kr("onesLike")
       }, t.prototype.zerosLike = function(t) {
        return Kr("zerosLike")
       }, t.prototype.linspace = function(t, e, n) {
        return Kr("linspace")
       }, t.prototype.dispose = function() {
        return Kr("dispose")
       }, t
      }();
 
     function Kr(t) {
      throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?")
     }
 
     function Xr(t, e) {
      for (var n = t.length, r = [], i = 0; i < n; i++) {
       var o = n - 1 - i,
        a = t[o] || 1;
       (e[e.length - 1 - i] || 1) > 1 && 1 === a && r.unshift(o)
      }
      return r
     }
 
     function Yr(t, e) {
      for (var n = [], r = 0; r < e.length; r++) {
       var i = t[t.length - r - 1],
        o = e.length - r - 1,
        a = e[o];
       (null == i || 1 === i && a > 1) && n.unshift(o)
      }
      return n
     }
 
     function Zr(t, e) {
      for (var n = [], r = Math.max(t.length, e.length), i = 0; i < r; i++) {
       var o = t[t.length - i - 1];
       null == o && (o = 1);
       var a = e[e.length - i - 1];
       if (null == a && (a = 1), 1 === o) n.unshift(a);
       else if (1 === a) n.unshift(o);
       else {
        if (o !== a) throw Error("Operands could not be broadcast together with shapes " + t + " and " + e + ".");
        n.unshift(o)
       }
      }
      return n
     }
 
     function Jr(t, e, n, r, i, o, a) {
      void 0 === a && (a = "channelsLast");
      var s, u = ri(e),
       c = u[0],
       l = u[1];
      if ("channelsLast" === a) s = [c, l, t[3], t[3]];
      else {
       if ("channelsFirst" !== a) throw new Error("Unknown dataFormat " + a);
       s = [c, l, t[1], t[1]]
      }
      return ti(t, s, n, r, i, o, !1, a)
     }
 
     function Qr(t, e, n, r, i, o, a) {
      void 0 === a && (a = "NDHWC");
      var s, u, c = ii(e),
       l = c[0],
       h = c[1],
       p = c[2];
      if ("NDHWC" === a) u = "channelsLast", s = [l, h, p, t[4], t[4]];
      else {
       if ("NCDHW" !== a) throw new Error("Unknown dataFormat " + a);
       u = "channelsFirst", s = [l, h, p, t[1], t[1]]
      }
      return ei(t, s, n, r, i, !1, u, o)
     }
 
     function ti(t, e, n, r, i, o, a, s) {
      void 0 === a && (a = !1), void 0 === s && (s = "channelsLast");
      var u = [-1, -1, -1, -1],
       c = u[0],
       l = u[1],
       h = u[2],
       p = u[3];
      if ("channelsLast" === s) c = t[0], l = t[1], h = t[2], p = t[3];
      else {
       if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
       c = t[0], p = t[1], l = t[2], h = t[3]
      }
      var f, d = e[0],
       v = e[1],
       m = e[3],
       g = ri(n),
       y = g[0],
       b = g[1],
       x = ri(r),
       w = x[0],
       C = x[1],
       S = oi(d, w),
       E = oi(v, C),
       I = function(t, e, n, r, i, o, a, s) {
        var u, c, l;
        if ("number" == typeof t) {
         u = {
          top: t,
          bottom: t,
          left: t,
          right: t,
          type: 0 === t ? "VALID" : "NUMBER"
         };
         var h = function(t, e, n, r, i) {
          null == r && (r = ni(t, e, n));
          var o = t[0],
           a = t[1],
           s = ai((o - e + 2 * r) / n + 1, i);
          k(T(s), (function() {
           return "The output # of rows (" + s + ") must be an integer. Change the stride and/or zero pad parameters"
          }));
          var u = ai((a - e + 2 * r) / n + 1, i);
          return k(T(u), (function() {
           return "The output # of columns (" + u + ") must be an integer. Change the stride and/or zero pad parameters"
          })), [s, u]
         }([e, n], o, r, t, s);
         c = h[0], l = h[1]
        } else if ("same" === t) {
         c = Math.ceil(e / r), l = Math.ceil(n / i);
         var p = Math.max(0, (c - 1) * r + o - e),
          f = Math.max(0, (l - 1) * i + a - n),
          d = Math.floor(p / 2),
          v = p - d,
          m = Math.floor(f / 2);
         u = {
          top: d,
          bottom: v,
          left: m,
          right: f - m,
          type: "SAME"
         }
        } else {
         if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
         u = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          type: "VALID"
         }, c = Math.ceil((e - o + 1) / r), l = Math.ceil((n - a + 1) / i)
        }
        return {
         padInfo: u,
         outHeight: c,
         outWidth: l
        }
       }(i, l, h, y, b, S, E, o),
       O = I.padInfo,
       A = I.outHeight,
       N = I.outWidth,
       R = a ? m * p : m;
      return "channelsFirst" === s ? f = [c, R, A, N] : "channelsLast" === s && (f = [c, A, N, R]), {
       batchSize: c,
       dataFormat: s,
       inHeight: l,
       inWidth: h,
       inChannels: p,
       outHeight: A,
       outWidth: N,
       outChannels: R,
       padInfo: O,
       strideHeight: y,
       strideWidth: b,
       filterHeight: d,
       filterWidth: v,
       effectiveFilterHeight: S,
       effectiveFilterWidth: E,
       dilationHeight: w,
       dilationWidth: C,
       inShape: t,
       outShape: f,
       filterShape: e
      }
     }
 
     function ei(t, e, n, r, i, o, a, s) {
      void 0 === o && (o = !1), void 0 === a && (a = "channelsLast");
      var u = [-1, -1, -1, -1, -1],
       c = u[0],
       l = u[1],
       h = u[2],
       p = u[3],
       f = u[4];
      if ("channelsLast" === a) c = t[0], l = t[1], h = t[2], p = t[3], f = t[4];
      else {
       if ("channelsFirst" !== a) throw new Error("Unknown dataFormat " + a);
       c = t[0], f = t[1], l = t[2], h = t[3], p = t[4]
      }
      var d, v = e[0],
       m = e[1],
       g = e[2],
       y = e[4],
       b = ii(n),
       x = b[0],
       w = b[1],
       C = b[2],
       S = ii(r),
       E = S[0],
       I = S[1],
       O = S[2],
       A = oi(v, E),
       N = oi(m, I),
       R = oi(g, O),
       _ = function(t, e, n, r, i, o, a, s, u, c, l) {
        var h, p, f, d;
        if ("number" == typeof t) {
         h = {
          top: t,
          bottom: t,
          left: t,
          right: t,
          front: t,
          back: t,
          type: 0 === t ? "VALID" : "NUMBER"
         };
         var v = function(t, e, n, r, i, o) {
          null == i && (i = ni(t, e, r));
          var a = t[0],
           s = t[1],
           u = t[2],
           c = ai((a - e + 2 * i) / r + 1, o);
          k(T(c), (function() {
           return "The output # of depths (" + c + ") must be an integer. Change the stride and/or zero pad parameters"
          }));
          var l = ai((s - e + 2 * i) / r + 1, o);
          k(T(l), (function() {
           return "The output # of rows (" + l + ") must be an integer. Change the stride and/or zero pad parameters"
          }));
          var h = ai((u - e + 2 * i) / r + 1, o);
          return k(T(h), (function() {
           return "The output # of columns (" + h + ") must be an integer. Change the stride and/or zero pad parameters"
          })), [c, l, h, n]
         }([e, n, r, 1], s, 1, i, t, l);
         p = v[0], f = v[1], d = v[2]
        } else if ("same" === t) {
         p = Math.ceil(e / i), f = Math.ceil(n / o), d = Math.ceil(r / a);
         var m = (p - 1) * i + s - e,
          g = (f - 1) * o + u - n,
          y = (d - 1) * a + c - r,
          b = Math.floor(m / 2),
          x = m - b,
          w = Math.floor(g / 2),
          C = g - w,
          S = Math.floor(y / 2);
         h = {
          top: w,
          bottom: C,
          left: S,
          right: y - S,
          front: b,
          back: x,
          type: "SAME"
         }
        } else {
         if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
         h = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          front: 0,
          back: 0,
          type: "VALID"
         }, p = Math.ceil((e - s + 1) / i), f = Math.ceil((n - u + 1) / o), d = Math.ceil((r - c + 1) / a)
        }
        return {
         padInfo: h,
         outDepth: p,
         outHeight: f,
         outWidth: d
        }
       }(i, l, h, p, x, w, C, A, N, R, s),
       D = _.padInfo,
       F = _.outDepth,
       M = _.outHeight,
       L = _.outWidth,
       B = o ? y * f : y;
      return "channelsFirst" === a ? d = [c, B, F, M, L] : "channelsLast" === a && (d = [c, F, M, L, B]), {
       batchSize: c,
       dataFormat: a,
       inDepth: l,
       inHeight: h,
       inWidth: p,
       inChannels: f,
       outDepth: F,
       outHeight: M,
       outWidth: L,
       outChannels: B,
       padInfo: D,
       strideDepth: x,
       strideHeight: w,
       strideWidth: C,
       filterDepth: v,
       filterHeight: m,
       filterWidth: g,
       effectiveFilterDepth: A,
       effectiveFilterHeight: N,
       effectiveFilterWidth: R,
       dilationDepth: E,
       dilationHeight: I,
       dilationWidth: O,
       inShape: t,
       outShape: d,
       filterShape: e
      }
     }
 
     function ni(t, e, n, r) {
      void 0 === r && (r = 1);
      var i = oi(e, r);
      return Math.floor((t[0] * (n - 1) - n + i) / 2)
     }
 
     function ri(t) {
      return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
     }
 
     function ii(t) {
      return "number" == typeof t ? [t, t, t] : t
     }
 
     function oi(t, e) {
      return e <= 1 ? t : t + (t - 1) * (e - 1)
     }
 
     function ai(t, e) {
      if (!e) return t;
      switch (e) {
       case "round":
        return Math.round(t);
       case "ceil":
        return Math.ceil(t);
       case "floor":
        return Math.floor(t);
       default:
        throw new Error("Unknown roundingMode " + e)
      }
     }
 
     function si(t) {
      var e = ri(t),
       n = e[0],
       r = e[1],
       i = e[2];
      return 1 === n && 1 === r && 1 === i
     }
 
     function ui(t, e) {
      return si(t) || si(e)
     }
 
     function ci(t) {
      if ("NHWC" === t) return "channelsLast";
      if ("NCHW" === t) return "channelsFirst";
      throw new Error("Unknown dataFormat " + t)
     }
 
     function li(t, e, n) {
      if ("complex64" === e) {
       if ("complex64" === t.dtype) return t.clone();
       var r = kn(t.shape),
        i = t.toFloat(),
        o = n.complex(i, r);
       return r.dispose(), i.dispose(), o
      }
      if (!U(t.dtype, e)) return Bt.makeTensorFromDataId(t.dataId, t.shape, e);
      if ("complex64" === t.dtype) {
       var a = n.real(t);
       return o = a.cast(e), a.dispose(), o
      }
      if ("int32" === e) return n.int(t);
      if ("bool" === e) {
       var s = mn(0, t.dtype);
       return o = n.notEqual(t, s), s.dispose(), o
      }
      throw new Error("Error in Cast: failed to cast " + t.dtype + " to " + e)
     }
 
     function hi(t, e) {
      return Bt.makeTensorFromDataId(t.dataId, e, t.dtype)
     }
 
     function pi(t, e, n) {
      var r = (e - t) / (n - 1),
       i = rt(n, "float32");
      i[0] = t;
      for (var o = 1; o < i.length; o++) i[o] = i[o - 1] + r;
      return gn(i, "float32")
     }
     Object.freeze({
      castTensor: li,
      reshapeTensor: hi,
      linspaceImpl: pi,
      upcastType: Nt,
      axesAreInnerMostDims: Qe,
      combineLocations: tn,
      computeOutAndReduceShapes: en,
      expandShapeToKeepDim: nn,
      assertAxesAreInnerMostDims: rn,
      getAxesPermutation: on,
      getUndoAxesPermutation: an,
      getInnerMostAxes: sn,
      getBroadcastDims: Xr,
      getReductionAxes: Yr,
      assertAndGetBroadcastShape: Zr,
      assertParamsConsistent: un,
      computeOutShape: cn,
      computePool2DInfo: Jr,
      computePool3DInfo: Qr,
      computeConv2DInfo: ti,
      computeConv3DInfo: ei,
      computeDefaultPad: ni,
      tupleValuesAreOne: si,
      eitherStridesOrDilationsAreOne: ui,
      convertConv2DDataFormat: ci,
      PARALLELIZE_THRESHOLD: Rr,
      computeOptimalWindowSize: Tr
     });
 
     function fi(t, e) {
      if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t.length + ", imag: " + e.length + ".");
      for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];
      return n
     }
 
     function di(t, e) {
      return {
       real: t[2 * e],
       imag: t[2 * e + 1]
      }
     }
 
     function vi(t, e, n, r) {
      t[2 * r] = e, t[2 * r + 1] = n
     }
 
     function mi(t, e, n) {
      var r = (n ? 2 : -2) * Math.PI * (t / e);
      return {
       real: Math.cos(r),
       imag: Math.sin(r)
      }
     }
 
     function gi(t, e, n) {
      var r = function(t, e, n) {
        return function(t, e, n) {
         for (var r = 0, i = t.length, o = 0, a = !1; r < i;) {
          var s = n(e, t[o = r + (i - r >>> 1)]);
          s > 0 ? r = o + 1 : (i = o, a = !s)
         }
         return a ? r : -r - 1
        }(t, e, n || yi)
       }(t, e, n),
       i = r < 0 ? -(r + 1) : r;
      t.splice(i, 0, e)
     }
 
     function yi(t, e) {
      return t > e ? 1 : t < e ? -1 : 0
     }
 
     function bi(t, e, n, r, i) {
      return wi(t, e, n, r, i, 0).selectedIndices
     }
 
     function xi(t, e, n, r, i, o) {
      var a = wi(t, e, n, r, i, o, !0);
      return a.numValidOutputs.dispose(), {
       selectedIndices: a.selectedIndices,
       selectedScores: a.selectedScores
      }
     }
 
     function wi(t, e, n, r, i, o, a, s) {
      void 0 === a && (a = !1), void 0 === s && (s = !1);
      for (var u = Array.from(e).map((function(t, e) {
        return {
         score: t,
         boxIndex: e,
         suppressBeginIndex: 0
        }
       })).filter((function(t) {
        return t.score > i
       })).sort(Ei), c = o > 0 ? -.5 / o : 0, l = [], h = []; l.length < n && u.length > 0;) {
       var p = u.pop(),
        f = p.score,
        d = p.boxIndex,
        v = p.suppressBeginIndex;
       if (f < i) break;
       for (var m = !1, g = l.length - 1; g >= v; --g) {
        var y = Ci(t, d, l[g]);
        if (y >= r) {
         m = !0;
         break
        }
        if (p.score = p.score * Si(r, c, y), p.score <= i) break
       }
       p.suppressBeginIndex = l.length, m || (p.score === f ? (l.push(d), h.push(p.score)) : p.score > i && gi(u, p, Ei))
      }
      var b = l.length;
      return s && (l.fill(0, b), h.fill(0, b)), {
       selectedIndices: gn(l, "int32"),
       selectedScores: gn(h, "float32"),
       numValidOutputs: mn(b, "int32")
      }
     }
 
     function Ci(t, e, n) {
      var r = t.subarray(4 * e, 4 * e + 4),
       i = t.subarray(4 * n, 4 * n + 4),
       o = Math.min(r[0], r[2]),
       a = Math.min(r[1], r[3]),
       s = Math.max(r[0], r[2]),
       u = Math.max(r[1], r[3]),
       c = Math.min(i[0], i[2]),
       l = Math.min(i[1], i[3]),
       h = Math.max(i[0], i[2]),
       p = Math.max(i[1], i[3]),
       f = (s - o) * (u - a),
       d = (h - c) * (p - l);
      if (f <= 0 || d <= 0) return 0;
      var v = Math.max(o, c),
       m = Math.max(a, l),
       g = Math.min(s, h),
       y = Math.min(u, p),
       b = Math.max(g - v, 0) * Math.max(y - m, 0);
      return b / (f + d - b)
     }
 
     function Si(t, e, n) {
      var r = Math.exp(e * n * n);
      return n <= t ? r : 0
     }
 
     function Ei(t, e) {
      return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex
     }
 
     function ki(t, e, n) {
      var r = new Array(t.rank).fill(0),
       i = t.shape.slice();
      return e.map((function(e) {
       i[n] = e;
       var o = t.slice(r, i);
       return r[n] += e, o
      }))
     }
 
     function Ii(t, e) {
      for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];
      var i = Xn(n, t.dtype);
      for (r = 0; r < i.values.length; ++r) {
       for (var o = i.indexToLoc(r), a = new Array(t.rank), s = 0; s < a.length; s++) a[s] = o[s] % t.shape[s];
       var u = t.locToIndex(a);
       i.values[r] = t.values[u]
      }
      return i.toTensor()
     }
 
     function Oi(t, e, n, r, i) {
      for (var o = e[e.length - 1], a = [t.length / o, o], s = a[0], u = a[1], c = z(n, s * r), l = z("int32", s * r), h = 0; h < s; h++) {
       for (var p = h * u, f = t.subarray(p, p + u), d = [], v = 0; v < f.length; v++) d.push({
        value: f[v],
        index: v
       });
       d.sort((function(t, e) {
        return e.value - t.value
       }));
       var m = h * r,
        g = c.subarray(m, m + r),
        y = l.subarray(m, m + r);
       for (v = 0; v < r; v++) g[v] = d[v].value, y[v] = d[v].index
      }
      var b = e.slice();
      return b[b.length - 1] = r, [dn(c, b, n), dn(l, b, "int32")]
     }
 
     function Ai(t, e) {
      for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);
      var i = Xn(t, "int32"),
       o = Xn([n.length, t.length], "int32");
      for (r = 0; r < n.length; r++) {
       var a = i.indexToLoc(n[r]),
        s = r * t.length;
       o.values.set(a, s)
      }
      return o.toTensor()
     }
     var Ni = function(t, e) {
       this.outputShape = [], this.outputShape = t, this.variableNames = e.map((function(t, e) {
        return "T" + e
       }));
       var n = [];
       this.variableNames.forEach((function(t) {
        n.push("float v" + t + " = get" + t + "AtOutCoords();")
       }));
       var r = this.variableNames.map((function(t) {
        return "v" + t
       })).join(" + ");
       this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    "
      },
      Ri = function(t, e) {
       this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map((function(t, e) {
        return "T" + e
       }));
       var n = [];
       this.variableNames.forEach((function(t) {
        n.push("vec4 v" + t + " = get" + t + "AtOutCoords();")
       }));
       var r = this.variableNames.map((function(t) {
        return "v" + t
       })).join(" + ");
       this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    "
      },
      Ti = function(t, e, n) {
       this.variableNames = ["A"];
       var r = t.windowSize,
        i = t.batchSize,
        o = t.inSize,
        a = Math.ceil(o / r);
       n || this.variableNames.push("bestIndicesA"), this.outputShape = [i, a];
       var s = "max" === e ? ">" : "<",
        u = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
       this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + u + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "
      };
 
     function _i(t, e) {
      return ["x", "y", "z", "w", "u", "v"].slice(0, e).map((function(e) {
       return t + "." + e
      }))
     }
 
     function Di(t, e) {
      return 1 === e ? [t] : _i(t, e)
     }
 
     function Fi() {
      var t, e, n, r, i, o, a, s, u, c;
      return 2 === h().getNumber("WEBGL_VERSION") ? (t = "#version 300 es", e = "in", n = "out", r = "in", i = "texture", o = "outputColor", a = "out vec4 outputColor;", s = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", u = "", c = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t = "", e = "attribute", n = "varying", r = "varying", i = "texture2D", o = "gl_FragColor", a = "", s = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", u = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", c = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
       version: t,
       attribute: e,
       varyingVs: n,
       varyingFs: r,
       texture2D: i,
       output: o,
       defineOutput: a,
       defineSpecialNaN: s,
       defineSpecialInf: u,
       defineRound: c
      }
     }
 
     function Mi(t, e, n) {
      void 0 === n && (n = "index");
      var r = Q(e);
      return r.map((function(e, i) {
       return "int " + t[i] + " = " + n + " / " + e + "; " + (i === r.length - 1 ? "int " + t[i + 1] + " = " + n + " - " + t[i] + " * " + e : "index -= " + t[i] + " * " + e) + ";"
      })).join("")
     }
 
     function Li(t) {
      var e = Q(t).map((function(t) {
       return t.toString()
      }));
      return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e[0] + " + coords.y * " + e[1] + " + coords.z;\n  }\n"
     }
     var Bi = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
 
     function Pi(t, e, n, r) {
      var i = [];
      t.forEach((function(t) {
       var e = N(t.shapeInfo.logicalShape);
       t.shapeInfo.isUniform ? i.push("uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";") : (i.push("uniform sampler2D " + t.name + ";"), i.push("uniform int offset" + t.name + ";"))
      }));
      var o, a, s = i.join("\n"),
       u = t.map((function(t) {
        return function(t, e, n) {
         void 0 === n && (n = !1);
         var r = "";
         r += n ? ji(t) : zi(t);
         var i = t.shapeInfo.logicalShape,
          o = e.logicalShape;
         return i.length <= o.length && (r += n ? function(t, e) {
          var n, r = t.name,
           i = r.charAt(0).toUpperCase() + r.slice(1),
           o = "get" + i + "AtOutCoords",
           a = t.shapeInfo.logicalShape.length,
           s = e.logicalShape.length,
           u = Xr(t.shapeInfo.logicalShape, e.logicalShape),
           c = qi(s),
           l = s - a,
           h = ["x", "y", "z", "w", "u", "v"];
          n = 0 === a ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map((function(t) {
           return "coords." + h[t + l] + " = 0;"
          })).join("\n");
          var p = "";
          p = s < 2 && a > 0 ? "coords" : t.shapeInfo.logicalShape.map((function(t, e) {
           return "coords." + h[e + l]
          })).join(", ");
          var f = "return outputValue;",
           d = 1 === N(t.shapeInfo.logicalShape),
           v = 1 === N(e.logicalShape);
          if (1 !== a || d || v) {
           if (d && !v) f = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
           else if (u.length) {
            var m = a - 2,
             g = a - 1;
            u.indexOf(m) > -1 && u.indexOf(g) > -1 ? f = "return vec4(outputValue.x);" : u.indexOf(m) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(g) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);")
           }
          } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
          return "\n    vec4 " + o + "() {\n      " + c + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + i + "(" + p + ");\n      " + f + "\n    }\n  "
         }(t, e) : function(t, e) {
          var n = t.name,
           r = n.charAt(0).toUpperCase() + n.slice(1),
           i = "get" + r + "AtOutCoords",
           o = e.texShape,
           a = t.shapeInfo.texShape,
           s = t.shapeInfo.logicalShape.length,
           u = e.logicalShape.length;
          if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && R(a, o)) return "\n      float " + i + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
          var c, l = qi(u),
           h = Xr(t.shapeInfo.logicalShape, e.logicalShape),
           p = u - s,
           f = ["x", "y", "z", "w", "u", "v"];
          c = 0 === s ? "" : u < 2 && h.length >= 1 ? "coords = 0;" : h.map((function(t) {
           return "coords." + f[t + p] + " = 0;"
          })).join("\n");
          var d = "";
          return d = u < 2 && s > 0 ? "coords" : t.shapeInfo.logicalShape.map((function(t, e) {
           return "coords." + f[e + p]
          })).join(", "), "\n    float " + i + "() {\n      " + l + " coords = getOutputCoords();\n      " + c + "\n      return get" + r + "(" + d + ");\n    }\n  "
         }(t, e)), r
        }(t, e, r)
       })).join("\n"),
       c = e.texShape,
       l = Fi(),
       h = function(t) {
        return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t.texture2D + "(textureSampler, uv).r;\n    }\n  "
       }(l),
       p = function(t) {
        return t.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t.varyingFs + " vec2 resultUV;\n    " + t.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t.defineSpecialNaN + "\n    " + t.defineSpecialInf + "\n    " + t.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + Wi + "\n    " + Vi + "\n    " + Ui + "\n  "
       }(l);
      return e.isPacked ? (o = function(t, e) {
       switch (t.length) {
        case 0:
         return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
        case 1:
         return function(t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          return 1 === n[0] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    " : 1 === n[1] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  "
         }(0, e);
        case 2:
         return function(t, e) {
          var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
          if (R(t, e)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
          var r = Math.ceil(t[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  "
         }(t, e);
        case 3:
         return n = t, r = e, i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], o = Math.ceil(n[2] / 2), a = o * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + i[0] + ", " + i[1] + "));\n      int index = resTexRC.x * " + i[1] + " + resTexRC.y;\n\n      int b = index / " + a + ";\n      index -= b * " + a + ";\n\n      int r = 2 * (index / " + o + ");\n      int c = imod(index, " + o + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
        default:
         return function(t, e) {
          for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), i = r * Math.ceil(t[t.length - 2] / 2), o = i, a = "", s = "b, r, c", u = 2; u < t.length - 1; u++) o *= t[t.length - u - 1], a = "\n      int b" + u + " = index / " + o + ";\n      index -= b" + u + " * " + o + ";\n    " + a, s = "b" + u + ", " + s;
          return "\n    ivec" + t.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + a + "\n\n      int b = index / " + i + ";\n      index -= b * " + i + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + t.length + "(" + s + ");\n    }\n  "
         }(t, e)
       }
       var n, r, i, o, a
      }(e.logicalShape, c), a = function(t) {
       return "\n    void setOutput(vec4 val) {\n      " + t.output + " = val;\n    }\n  "
      }(l)) : (o = function(t, e) {
       switch (t.length) {
        case 0:
         return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
        case 1:
         return function(t, e) {
          return 1 === e[0] ? "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e[1] + ".0);\n      }\n    " : 1 === e[1] ? "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      return resTexRC.x * " + e[1] + " + resTexRC.y;\n    }\n  "
         }(0, e);
        case 2:
         return function(t, e) {
          return R(t, e) ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e[0] + ", " + e[1] + "));\n      }\n    " : 1 === t[1] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : 1 === t[0] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      int r = index / " + t[1] + ";\n      int c = index - r * " + t[1] + ";\n      return ivec2(r, c);\n    }\n  "
         }(t, e);
        case 3:
         return n = e, r = Mi(["r", "c", "d"], t), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";
        case 4:
         return function(t, e) {
          var n = Mi(["r", "c", "d", "d2"], t);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  "
         }(t, e);
        case 5:
         return function(t, e) {
          var n = Mi(["r", "c", "d", "d2", "d3"], t);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e[0] + ",\n                             " + e[1] + "));\n\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "
         }(t, e);
        case 6:
         return function(t, e) {
          var n = Mi(["r", "c", "d", "d2", "d3", "d4"], t);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "
         }(t, e);
        default:
         throw new Error(t.length + "-D output sampling is not yet supported")
       }
       var n, r
      }(e.logicalShape, c), a = function(t) {
       return "\n    void setOutput(float val) {\n      " + t.output + " = vec4(val, 0, 0, 0);\n    }\n  "
      }(l)), r && (p += Hi), [p, h, a, s, o, u, n].join("\n")
     }
 
     function zi(t) {
      var e = t.shapeInfo.logicalShape;
      switch (e.length) {
       case 0:
        return function(t) {
         var e = t.name,
          n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
         if (t.shapeInfo.isUniform) return "float " + n + "() {return " + e + ";}";
         var r = t.shapeInfo.texShape,
          i = r[0],
          o = r[1];
         if (1 === i && 1 === o) return "\n      float " + n + "() {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
         var a = t.shapeInfo.texShape,
          s = a[0],
          u = a[1],
          c = $i(e);
         return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + s + ", " + u + ", " + c + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  "
        }(t);
       case 1:
        return function(t) {
         var e = t.name,
          n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
         if (t.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + Gi(t) + "\n      }\n    ";
         var r = t.shapeInfo.texShape,
          i = r[0],
          o = r[1];
         if (1 === o && 1 === i) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
         var a = $i(e);
         return 1 === o ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + a + ") + 0.5) / " + i + ".0);\n        return sampleTexture(" + e + ", uv);\n      }\n    " : 1 === i ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + a + ") + 0.5) / " + o + ".0, 0.5);\n        return sampleTexture(" + e + ", uv);\n      }\n    " : "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + i + ", " + o + ", index + " + a + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  "
        }(t);
       case 2:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = t.shapeInfo.texShape;
         if (null != i && R(e, i)) {
          var o = i[0],
           a = i[1];
          return "\n    float " + r + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  "
         }
         var s = P(e),
          u = s.newShape,
          c = s.keptDims,
          l = u;
         if (l.length < e.length) {
          var h = Ki(t, l);
          return "\n      " + zi(h) + "\n      float " + r + "(int row, int col) {\n        return " + r + "(" + Xi(["row", "col"], c) + ");\n      }\n    "
         }
         if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e[1] + ", 1)));\n        " + Gi(t) + "\n      }\n    ";
         var p = i[0],
          f = i[1],
          d = $i(n);
         return 1 === f ? "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + p + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  " : 1 === p ? "\n    float " + r + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d + "), vec3(" + e[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + f + ".0, 0.5);\n      return sampleTexture(" + n + ", uv);\n    }\n  " : "\n  float " + r + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e[1] + " + col + " + d + ";\n    vec2 uv = uvFromFlat(" + p + ", " + f + ", index);\n    return sampleTexture(" + n + ", uv);\n  }\n"
        }(t);
       case 3:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = e[1] * e[2],
          o = e[2],
          a = P(e),
          s = a.newShape,
          u = a.keptDims,
          c = s;
         if (c.length < e.length) {
          var l = Ki(t, c);
          return "\n        " + zi(l) + "\n        float " + r + "(int row, int col, int depth) {\n          return " + r + "(" + Xi(["row", "col", "depth"], u) + ");\n        }\n      "
         }
         if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + i + ", " + o + ", 1)));\n        " + Gi(t) + "\n      }\n    ";
         var h = t.shapeInfo.texShape,
          p = h[0],
          f = h[1],
          d = t.shapeInfo.flatOffset;
         if (f === i && null == d) return "\n        float " + r + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + o + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + f + ".0, " + p + ".0);\n          return sampleTexture(" + n + ", uv);\n        }\n      ";
         if (f === o && null == d) return "\n    float " + r + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + f + ".0, " + p + ".0);\n      return sampleTexture(" + n + ", uv);\n    }\n  ";
         var v = $i(n);
         return "\n      float " + r + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + i + " + col * " + o + " + depth + " + v + ";\n        vec2 uv = uvFromFlat(" + p + ", " + f + ", index);\n        return sampleTexture(" + n + ", uv);\n      }\n  "
        }(t);
       case 4:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = e[3],
          o = e[2] * i,
          a = e[1] * o,
          s = P(e),
          u = s.newShape,
          c = s.keptDims;
         if (u.length < e.length) {
          var l = Ki(t, u);
          return "\n      " + zi(l) + "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        return " + r + "(" + Xi(["row", "col", "depth", "depth2"], c) + ");\n      }\n    "
         }
         if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + a + ", " + o + ", " + i + ", 1)));\n        " + Gi(t) + "\n      }\n    ";
         var h = t.shapeInfo.flatOffset,
          p = t.shapeInfo.texShape,
          f = p[0],
          d = p[1];
         if (d === a && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + d + ".0, " + f + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
         if (d === i && null == h) return "\n      float " + r + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e[1] * e[2] + ", " + e[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + d + ".0, " + f + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
         var v = $i(n);
         return "\n    float " + r + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + a + " + col * " + o + " +\n          depth * " + i + " + depth2;\n      vec2 uv = uvFromFlat(" + f + ", " + d + ", index + " + v + ");\n      return sampleTexture(" + n + ", uv);\n    }\n  "
        }(t);
       case 5:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = e[4],
          o = e[3] * i,
          a = e[2] * o,
          s = e[1] * a,
          u = P(e),
          c = u.newShape,
          l = u.keptDims;
         if (c.length < e.length) {
          var h = Ki(t, c);
          return "\n      " + zi(h) + "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r + "(" + Xi(["row", "col", "depth", "depth2", "depth3"], l) + ");\n      }\n    "
         }
         if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s + ", " + a + ", " + o + ", " + i + ")) +\n          depth3;\n        " + Gi(t) + "\n      }\n    ";
         var p = t.shapeInfo.flatOffset,
          f = t.shapeInfo.texShape,
          d = f[0],
          v = f[1];
         if (v === s && null == p) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + a + ", " + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
         if (v === i && null == p) return "\n      float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] + ",\n               " + e[2] * e[3] + ", " + e[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + d + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
         var m = $i(n);
         return "\n    float " + r + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s + " + col * " + a + " + depth * " + o + " +\n          depth2 * " + i + " + depth3 + " + m + ";\n      vec2 uv = uvFromFlat(" + d + ", " + v + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  "
        }(t);
       case 6:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = P(e),
          o = i.newShape,
          a = i.keptDims;
         if (o.length < e.length) {
          var s = Ki(t, o);
          return "\n      " + zi(s) + "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r + "(" + Xi(["row", "col", "depth", "depth2", "depth3", "depth4"], a) + ");\n      }\n    "
         }
         var u = e[5],
          c = e[4] * u,
          l = e[3] * c,
          h = e[2] * l,
          p = e[1] * h;
         if (t.shapeInfo.isUniform) return "\n      float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + p + ", " + h + ", " + l + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u + ", 1)));\n        " + Gi(t) + "\n      }\n    ";
         var f = t.shapeInfo.flatOffset,
          d = t.shapeInfo.texShape,
          v = d[0],
          m = d[1];
         if (m === p && null == f) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + l + ", " + c + ", " + u + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
         if (m === u && null == f) return "\n      float " + r + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e[1] * e[2] * e[3] * e[4] + ",\n               " + e[2] * e[3] * e[4] + ",\n               " + e[3] * e[4] + ",\n               " + e[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + v + ".0);\n        return sampleTexture(" + n + ", uv);\n      }\n    ";
         var g = $i(n);
         return "\n    float " + r + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + p + " + col * " + h + " + depth * " + l + " +\n          depth2 * " + c + " + depth3 * " + u + " + depth4 + " + g + ";\n      vec2 uv = uvFromFlat(" + v + ", " + m + ", index);\n      return sampleTexture(" + n + ", uv);\n    }\n  "
        }(t);
       default:
        throw new Error(e.length + "-D input sampling is not yet supported")
      }
     }
 
     function ji(t) {
      var e, n, r;
      switch (t.shapeInfo.logicalShape.length) {
       case 0:
        return e = t.name, n = "get" + e.charAt(0).toUpperCase() + e.slice(1), r = Fi(), "\n    vec4 " + n + "() {\n      return " + r.texture2D + "(" + e + ", halfCR);\n    }\n  ";
       case 1:
        return function(t) {
         var e = t.name,
          n = "get" + e.charAt(0).toUpperCase() + e.slice(1),
          r = t.shapeInfo.texShape,
          i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
          o = Fi();
         return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + i[0] + ", " + i[1] + ", index);\n      return " + o.texture2D + "(" + e + ", uv);\n    }\n  "
        }(t);
       case 2:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = t.shapeInfo.texShape,
          o = i[0],
          a = i[1],
          s = Fi();
         if (null != i && R(e, i)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + a + ".0, " + o + ".0);\n\n        return " + s.texture2D + "(" + n + ", uv);\n      }\n    ";
         var u = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)],
          c = Math.ceil(e[1] / 2);
         return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c + ", " + u[0] + ", " + u[1] + ", row, col);\n      return " + s.texture2D + "(" + n + ", uv);\n    }\n  "
        }(t);
       case 3:
        return function(t) {
         var e = t.shapeInfo.logicalShape,
          n = t.name,
          r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
          i = t.shapeInfo.texShape,
          o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
         if (1 === e[0]) {
          var a = e.slice(1),
           s = Ki(t, a);
          return "\n        " + ji(s) + "\n        vec4 " + r + "(int b, int row, int col) {\n          return " + r + "(" + Xi(["b", "row", "col"], [1, 2]) + ");\n        }\n      "
         }
         var u = o[0],
          c = o[1],
          l = Math.ceil(e[2] / 2),
          h = l * Math.ceil(e[1] / 2),
          p = Fi();
         return "\n    vec4 " + r + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u + ", " + c + ", " + h + ", " + l + ", b, row, col);\n      return " + p.texture2D + "(" + n + ", uv);\n    }\n  "
        }(t);
       default:
        return function(t) {
         for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, i = "get" + r.charAt(0).toUpperCase() + r.slice(1), o = t.shapeInfo.texShape, a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)], s = a[0], u = a[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = "int b, int row, int col", p = "b * " + l + " + (row / 2) * " + c + " + (col / 2)", f = 2; f < n - 1; f++) h = "int b" + f + ", " + h, l *= e[n - f - 1], p = "b" + f + " * " + l + " + " + p;
         var d = Fi();
         return "\n    vec4 " + i + "(" + h + ") {\n      int index = " + p + ";\n      int texR = index / " + u + ";\n      int texC = index - texR * " + u + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u + ", " + s + ");\n      return " + d.texture2D + "(" + r + ", uv);\n    }\n  "
        }(t)
      }
     }
     var Wi = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
      Vi = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
      Ui = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
      Hi = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
 
     function $i(t) {
      return "offset" + t
     }
 
     function Gi(t) {
      var e = t.name,
       n = N(t.shapeInfo.logicalShape);
      return n < 2 ? "return " + e + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + e + "[i];\n      }\n    }\n  "
     }
 
     function qi(t) {
      if (t <= 1) return "int";
      if (2 === t) return "ivec2";
      if (3 === t) return "ivec3";
      if (4 === t) return "ivec4";
      if (5 === t) return "ivec5";
      if (6 === t) return "ivec6";
      throw Error("GPU for rank " + t + " is not yet supported")
     }
 
     function Ki(t, e) {
      var n = JSON.parse(JSON.stringify(t));
      return n.shapeInfo.logicalShape = e, n
     }
 
     function Xi(t, e) {
      return e.map((function(e) {
       return t[e]
      })).join(", ")
     }
     var Yi = function(t, e, n, r) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, k(t.length > 2, (function() {
        return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2."
       }));
       var i = t[t.length - 1],
        o = Math.ceil(i / e);
       this.outputShape = t.slice(0, -1), o > 1 && this.outputShape.push(o), r || this.variableNames.push("bestIndicesA");
       var a, s, u = this.outputShape,
        c = u.length,
        l = qi(c),
        h = Di("coords", c);
       if (1 === o) {
        var p = qi(s = c + 1);
        a = "\n        " + p + " sourceLocR = " + p + "(" + h.join() + ", 0);\n        ++" + h[c - 1] + ";\n        " + p + " sourceLocG = " + p + "(" + h.join() + ", 0);\n        ++" + h[c - 2] + ";\n        " + p + " sourceLocA = " + p + "(" + h.join() + ", 0);\n        --" + h[c - 1] + ";\n        " + p + " sourceLocB = " + p + "(" + h.join() + ", 0);\n        --" + h[c - 2] + ";"
       } else s = c, a = "\n        " + l + " sourceLocR = coords;\n        ++" + h[c - 1] + ";\n        " + l + " sourceLocG = coords;\n        ++" + h[c - 2] + ";\n        " + l + " sourceLocA = coords;\n        --" + h[c - 1] + ";\n        " + l + " sourceLocB = coords;\n        --" + h[c - 2] + ";";
       var f = ["x", "y", "z", "w", "u", "v"].slice(0, s),
        d = "." + f[s - 1],
        v = f.map((function(t) {
         return "int " + t
        })),
        m = Di("sourceLocR", s - 1).concat("inIdx.r"),
        g = Di("sourceLocG", s - 1).concat("inIdx.g"),
        y = Di("sourceLocB", s - 1).concat("inIdx.b"),
        b = Di("sourceLocA", s - 1).concat("inIdx.a"),
        x = "max" === n ? "greaterThan" : "lessThan",
        w = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m.join() + "),\n                             getBestIndicesAChannel(" + g.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + b.join() + ")));",
        C = "vec4(\n            getAChannel(" + m.join() + "),\n            hasNextCol ? getAChannel(" + g.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b.join() + ") : 0.)",
        S = r ? "" : "\n      float getBestIndicesAChannel(" + v.join() + ") {\n        return getChannel(getBestIndicesA(" + f.join() + "),\n                                          vec2(" + f.slice(-2).join() + "));\n      }";
       this.userCode = "\n      float getAChannel(" + v.join() + ") {\n        return getChannel(getA(" + f.join() + "),\n                               vec2(" + f.slice(-2).join() + "));\n      }\n      " + S + "\n      void main() {\n        " + l + " coords = getOutputCoords();\n        bool hasNextCol = " + h[c - 1] + " < " + (u[c - 1] - 1) + ";\n        bool hasNextRow = " + h[c - 2] + " < " + (u[c - 2] - 1) + ";\n        " + a + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d + ", sourceLocG" + d + ",\n          sourceLocB" + d + ", sourceLocA" + d + ") * " + e + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + C + ";\n\n        for (int i = 0; i < " + e + "; i++) {\n          inIdx = srcIdx;\n          " + w + "\n          vec4 candidate = " + C + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + x + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "
      },
      Zi = function(t) {
       this.variableNames = ["dy"], this.outputShape = t.inShape;
       var e = t.filterHeight,
        n = t.filterWidth,
        r = t.strideHeight,
        i = t.strideWidth,
        o = t.dilationHeight,
        a = t.dilationWidth,
        s = t.effectiveFilterHeight,
        u = t.effectiveFilterWidth,
        c = s - 1 - t.padInfo.top,
        l = u - 1 - t.padInfo.left,
        h = 1 / (e * n);
       this.userCode = "\n      const ivec2 pads = ivec2(" + c + ", " + l + ");\n      const float avgMultiplier = float(" + h + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s + ";\n            wR += " + o + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u + ";\n            wC+= " + a + ") {\n            float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      Ji = function(t) {
       this.variableNames = ["dy"], this.outputShape = t.inShape;
       var e = t.filterDepth,
        n = t.filterHeight,
        r = t.filterWidth,
        i = t.strideDepth,
        o = t.strideHeight,
        a = t.strideWidth,
        s = t.dilationDepth,
        u = t.dilationHeight,
        c = t.dilationWidth,
        l = t.effectiveFilterDepth,
        h = t.effectiveFilterHeight,
        p = t.effectiveFilterWidth,
        f = l - 1 - t.padInfo.front,
        d = h - 1 - t.padInfo.top,
        v = p - 1 - t.padInfo.left,
        m = 1 / (e * n * r);
       this.userCode = "\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + v + ");\n      const float avgMultiplier = float(" + m + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          float dyD = float(dyDCorner + wD) / " + i + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h + ";\n              wR += " + u + ") {\n            float dyR = float(dyRCorner + wR) / " + o + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + p + ";\n                wC += " + c + ") {\n              float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      Qi = function(t, e, n, r, i, o) {
       this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Zr(t, e), Zr(t, n);
       var a = "0.0";
       null != r && (Zr(t, r), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
       var s = "1.0";
       null != i && (Zr(t, i), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + a + ";\n        float scale = " + s + ";\n        float inv = scale * inversesqrt(variance + float(" + o + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "
      },
      to = function(t, e, n, r, i, o) {
       this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], Zr(t, e), Zr(t, n);
       var a = "vec4(0.0)";
       null != r && (Zr(t, r), this.variableNames.push("offset"), a = "getOffsetAtOutCoords()");
       var s = "vec4(1.0)";
       null != i && (Zr(t, i), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = " + a + ";\n        vec4 scale = " + s + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + o + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "
      },
      eo = "return areal * breal - aimag * bimag;",
      no = "return areal * bimag + aimag * breal;",
      ro = function(t, e, n) {
       this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Zr(e, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "
      },
      io = "return a + b;",
      oo = "return a - b;",
      ao = "return a * b;",
      so = "return (a < 0.) ? b * a : a;",
      uo = function(t, e, n) {
       this.variableNames = ["A", "B"], this.outputShape = Zr(e, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "
      },
      co = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
      lo = function(t, e, n, r) {
       void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Zr(e, n);
       var i = this.outputShape.length,
        o = "";
       if (r)
        if (0 === i || 1 === N(this.outputShape)) o = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
        else if (o = "\n          " + qi(i) + " coords = getOutputCoords();\n        ", 1 === i) o += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
       else {
        var a = Di("coords", i);
        o += "\n            bool nextRowOutOfBounds =\n              (" + a[i - 2] + " + 1) >= " + this.outputShape[i - 2] + ";\n            bool nextColOutOfBounds =\n              (" + a[i - 1] + " + 1) >= " + this.outputShape[i - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "
       }
       this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + o + "\n\n        setOutput(result);\n      }\n    "
      },
      ho = function() {
       function t(t) {
        this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
       }
       return t.prototype.getCustomSetupFunc = function(t, e) {
        var n = this;
        return function(r, i) {
         null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(i, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(i, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e)
        }
       }, t
      }(),
      po = function() {
       function t(t) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
       }
       return t.prototype.getCustomSetupFunc = function(t, e) {
        var n = this;
        return function(r, i) {
         null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(i, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(i, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e)
        }
       }, t
      }(),
      fo = function(t) {
       this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
      },
      vo = function(t) {
       this.outputShape = [], this.outputShape = cn(t, 1), this.variableNames = t.map((function(t, e) {
        return "T" + e
       }));
       var e = new Array(t.length - 1);
       e[0] = t[0][1];
       for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];
       var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];
       for (n = 1; n < e.length; n++) {
        var i = e[n - 1];
        r.push("else if (yC < " + e[n] + ") setOutput(getT" + n + "(yR, yC-" + i + "));")
       }
       var o = e.length,
        a = e[e.length - 1];
       r.push("else setOutput(getT" + o + "(yR, yC-" + a + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    "
      },
      mo = function(t, e) {
       this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = cn(t, e);
       var n = this.outputShape,
        r = n.length,
        i = qi(r),
        o = Di("coords", r),
        a = ["x", "y", "z", "w", "u", "v"].slice(0, r);
       this.variableNames = t.map((function(t, e) {
        return "T" + e
       }));
       var s = new Array(t.length - 1);
       s[0] = t[0][e];
       for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];
       var c = a[e],
        l = a.slice(-2),
        h = a.join(),
        p = "if (" + c + " < " + s[0] + ") {\n        return getChannel(\n            getT0(" + h + "), vec2(" + l.join() + "));\n        }";
       for (u = 1; u < s.length; u++) {
        var f = s[u - 1];
        p += "\n        if (" + c + " < " + s[u] + "  && " + c + " >= " + s[u - 1] + ") {\n          return getChannel(\n            getT" + u + "(" + go(a, c, f) + "),\n            vec2(" + go(l, c, f) + "));\n        }"
       }
       var d = s.length,
        v = s[s.length - 1];
       p += "\n        return getChannel(\n          getT" + d + "(" + go(a, c, v) + "),\n          vec2(" + go(l, c, v) + "));", this.userCode = "\n      float getValue(" + a.map((function(t) {
        return "int " + t
       })) + ") {\n        " + p + "\n      }\n\n      void main() {\n        " + i + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + o + "), 0., 0., 0.);\n\n        " + o[r - 1] + " = " + o[r - 1] + " + 1;\n        if (" + o[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + o + ");\n        }\n\n        " + o[r - 2] + " = " + o[r - 2] + " + 1;\n        if (" + o[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + o + ");\n        }\n\n        " + o[r - 1] + " = " + o[r - 1] + " - 1;\n        if (" + o[r - 2] + " < " + n[r - 2] + " &&\n            " + o[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + o + ");\n        }\n        setOutput(result);\n      }\n    "
      };
 
     function go(t, e, n) {
      var r = t.indexOf(e);
      return t.map((function(t, e) {
       return e === r ? t + " - " + n : t
      })).join()
     }
     var yo = function(t) {
       this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
       var e = t.strideHeight,
        n = t.strideWidth,
        r = t.padInfo.top,
        i = t.padInfo.left,
        o = "channelsLast" === t.dataFormat;
       this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + i + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              if (" + o + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      bo = function(t) {
       this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
       var e = t.filterHeight,
        n = t.filterWidth,
        r = t.strideHeight,
        i = t.strideWidth,
        o = "channelsLast" === t.dataFormat,
        a = e - 1 - t.padInfo.top,
        s = n - 1 - t.padInfo.left,
        u = o ? 1 : 2,
        c = o ? 2 : 3,
        l = o ? 3 : 1;
       this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u + "], coords[" + c + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n\n              if (" + o + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      xo = function(t) {
       this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
       var e = t.strideDepth,
        n = t.strideHeight,
        r = t.strideWidth,
        i = t.padInfo.front,
        o = t.padInfo.top,
        a = t.padInfo.left;
       this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t.outDepth + "; yF++) {\n            int xF = wF + yF * " + e + " - " + i + ";\n\n            if (xF < 0 || xF >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + o + ";\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + a + ";\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      wo = function(t) {
       this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
       var e = t.filterDepth,
        n = t.filterHeight,
        r = t.filterWidth,
        i = t.strideDepth,
        o = t.strideHeight,
        a = t.strideWidth,
        s = e - 1 - t.padInfo.front,
        u = n - 1 - t.padInfo.top,
        c = r - 1 - t.padInfo.left;
       this.userCode = "\n      const ivec3 pads = ivec3(" + s + ", " + u + ", " + c + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + i + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + o + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      Co = function(t) {
       this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
       var e = t.strideHeight,
        n = t.strideWidth,
        r = t.padInfo.top,
        i = t.padInfo.left,
        o = t.outChannels / t.inChannels;
       this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + o + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + i + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      So = function(t) {
       this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
       var e = t.filterHeight,
        n = t.filterWidth,
        r = t.strideHeight,
        i = t.strideWidth,
        o = e - 1 - t.padInfo.top,
        a = n - 1 - t.padInfo.left,
        s = t.outChannels / t.inChannels;
       this.userCode = "\n      const ivec2 pads = ivec2(" + o + ", " + a + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + i + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s + "; dm++) {\n              int d2 = d1 * " + s + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      Eo = function(t, e, n, r) {
       void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
       var i = t.padInfo.top,
        o = t.padInfo.left,
        a = t.strideHeight,
        s = t.strideWidth,
        u = t.dilationHeight,
        c = t.dilationWidth,
        l = t.filterHeight,
        h = t.filterWidth,
        p = 4 * Math.floor(t.inChannels / 4),
        f = t.inChannels % 4,
        d = "channelsLast" === t.dataFormat,
        v = d ? 1 : 2,
        m = d ? 2 : 3,
        g = d ? 3 : 1,
        y = "",
        b = "";
       n && (y = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", b = "result = activation(result);");
       var x = e ? "result += getBiasAtOutCoords();" : "";
       e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y + "\n\n      const ivec2 strides = ivec2(" + a + ", " + s + ");\n      const ivec2 pads = ivec2(" + i + ", " + o + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v + "], coords[" + m + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l + "; wR++) {\n          int xR = xRCorner + wR * " + u + ";\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h + "; wC++) {\n            int xC = xCCorner + wC * " + c + ";\n\n            if (xC < 0 || xC >= " + t.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + p + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === f) + ") {\n\n              if (" + d + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + p + ") *\n                    getW(wR, wC, " + p + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + p + ", xR, xC) *\n                    getW(wR, wC, " + p + ", d2);\n              }\n\n            } else if (" + (2 === f) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + p + ", d2),\n                getW(wR, wC, " + p + " + 1, d2)\n              );\n\n              if (" + d + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + p + "),\n                  getX(batch, xR, xC, " + p + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + p + ", xR, xC),\n                  getX(batch, " + p + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === f) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + p + ", d2),\n                getW(wR, wC, " + p + " + 1, d2),\n                getW(wR, wC, " + p + " + 2, d2)\n              );\n\n              if (" + d + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + p + "),\n                  getX(batch, xR, xC, " + p + " + 1),\n                  getX(batch, xR, xC, " + p + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + p + ", xR, xC),\n                  getX(batch, " + p + " + 1, xR, xC),\n                  getX(batch, " + p + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + x + "\n        " + b + "\n        setOutput(result);\n      }\n    "
      },
      ko = function(t) {
       this.variableNames = ["x", "W"], this.outputShape = t.outShape;
       var e = t.padInfo.front,
        n = t.padInfo.top,
        r = t.padInfo.left,
        i = t.strideDepth,
        o = t.strideHeight,
        a = t.strideWidth,
        s = t.dilationDepth,
        u = t.dilationHeight,
        c = t.dilationWidth,
        l = t.filterDepth,
        h = t.filterHeight,
        p = t.filterWidth,
        f = 4 * Math.floor(t.inChannels / 4),
        d = t.inChannels % 4;
       this.userCode = "\n      const ivec3 strides = ivec3(" + i + ", " + o + ", " + a + ");\n      const ivec3 pads = ivec3(" + e + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l + "; wF++) {\n          int xF = xFCorner + wF * " + s + ";\n\n          if (xF < 0 || xF >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + "; wR++) {\n            int xR = xRCorner + wR * " + u + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + p + "; wC++) {\n              int xC = xCCorner + wC * " + c + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + f + ") *\n                  getW(wF, wR, wC, " + f + ", d2);\n              } else if (" + (2 === d) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1),\n                  getX(batch, xF, xR, xC, " + f + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2),\n                  getW(wF, wR, wC, " + f + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      Io = function(t, e, n, r) {
       void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
       var i = t.inHeight,
        o = t.inWidth,
        a = t.padInfo.top,
        s = t.padInfo.left,
        u = t.strideHeight,
        c = t.strideWidth,
        l = t.dilationHeight,
        h = t.dilationWidth,
        p = t.filterHeight,
        f = t.filterWidth,
        d = t.outChannels / t.inChannels,
        v = "",
        m = "";
       n && (v = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", m = "result = activation(result);");
       var g = e ? "result += getBiasAtOutCoords();" : "";
       e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d + ";\n        int q = d2 - d1 * " + d + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + p + "; wR++) {\n          int xR = xRCorner + wR * " + l + ";\n\n          if (xR < 0 || xR >= " + i + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + f + "; wC++) {\n            int xC = xCCorner + wC * " + h + ";\n\n            if (xC < 0 || xC >= " + o + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g + "\n        " + m + "\n        setOutput(result);\n      }\n    "
      },
      Oo = function(t, e, n, r) {
       void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;
       for (var i = t.inHeight, o = t.inWidth, a = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, p = t.filterHeight, f = t.filterWidth, d = f, v = "int xR; int xC; int xCOffset;", m = 0; m < p; m++)
        for (var g = 0; g < f; g++) v += "\n          vec4 xTexelR" + m + "C" + 2 * g + " = vec4(0.);\n          vec4 wR" + m + "C" + g + " = vec4(0.);\n          vec4 xR" + m + "C" + g + " = vec4(0.);";
       for (m = 0; m < p; m++)
        for (var y = 0; y < d; y++) {
         if (v += "\n          xR = xRCorner + " + m * l + ";\n          xC = xCCorner + " + (g = 2 * y) * h + ";\n        ", 1 === c) {
          if (g < f && (v += s % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + i + " && xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + i + " && xCOffset >= 0 && xCOffset < " + o + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + m + "C" + g + " = vec4(previous.zw, xTexelR" + m + "C" + g + ".xy);\n                } else {\n                  xR" + m + "C" + g + " = vec4(0, 0, xTexelR" + m + "C" + g + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + i + " && xC >= 0 && xC < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = xTexelR" + m + "C" + g + ";\n              ", g + 1 < f)) {
           var b = s % 2 == 0 ? S(h) : h;
           h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (v += "\n                  xCOffset = xC + " + s % 2 + " + " + b + ";\n\n                  if(xR >= 0 && xR < " + i + " &&\n                    xCOffset >= 0 && xCOffset < " + o + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h > 1 && (v += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + i + " &&\n                      xCOffset >= 0 && xCOffset < " + o + ") {\n                      xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + m + "C" + g + " = vec4(0.);\n                    }\n                  "), v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".xy);\n                ") : v += "\n                  xCOffset = xC + " + b + ";\n\n                  if(xR >= 0 && xR < " + i + " &&\n                    xCOffset >= 0 && xCOffset < " + o + ") {\n                    xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + m + "C" + (g + 1) + " = xTexelR" + m + "C" + (g + 2) + ";\n                "
          }
         } else g < f && (v += "\n              if(xR >= 0 && xR < " + i + ") {\n            ", s % 2 == 1 ? (v += "\n                xCOffset = xC + 1 - " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + o + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n              ", g + 1 < f && (v += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c + ";\n                  if(xCOffset >= 0 && xCOffset < " + o + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + m + "C" + (g + 1) + " = vec4(xTexelR" + m + "C" + (g + 2) + ".xy, final.xy);\n                ")) : (v += "\n                if(xC >= 0 && xC < " + o + ") {\n                  xTexelR" + m + "C" + g + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + m + "C" + g + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c + ";\n                if(xCOffset >= 0 && xCOffset < " + o + ") {\n                  xTexelR" + m + "C" + (g + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + m + "C" + (g + 2) + " = vec4(0.);\n                }\n\n                xR" + m + "C" + g + " = vec4(\n                  xTexelR" + m + "C" + g + ".xy, xTexelR" + m + "C" + (g + 2) + ".xy);\n              ", g + 1 < f && (v += "\n                  xR" + m + "C" + (g + 1) + " = vec4(\n                    xTexelR" + m + "C" + g + ".zw, xTexelR" + m + "C" + (g + 2) + ".zw);\n                ")), v += "}");
         g < f && (v += "\n            vec4 wTexelR" + m + "C" + g + " = getW(" + m + ", " + g + ", d1, q);\n            wR" + m + "C" + g + " = vec4(wTexelR" + m + "C" + g + ".xz, wTexelR" + m + "C" + g + ".xz);\n          ", g + 1 < f && (v += "\n              vec4 wTexelR" + m + "C" + (g + 1) + " = getW(" + m + ", " + (g + 1) + ", d1, q);\n              wR" + m + "C" + (g + 1) + " =\n                vec4(wTexelR" + m + "C" + (g + 1) + ".xz, wTexelR" + m + "C" + (g + 1) + ".xz);"))
        }
       for (m = 0; m < p; m++)
        for (g = 0; g < f; g++) v += "dotProd += xR" + m + "C" + g + " * wR" + m + "C" + g + ";";
       var x = "",
        w = "";
       n && (x = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", w = "result = activation(result);");
       var C = e ? "result += getBiasAtOutCoords();" : "";
       e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + x + "\n\n      const ivec2 strides = ivec2(" + u + ", " + c + ");\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v + "\n\n        vec4 result = dotProd;\n        " + C + "\n        " + w + "\n        setOutput(result);\n      }\n    "
      },
      Ao = function(t, e, n, r, i) {
       this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
       var o = t[0],
        a = t[1],
        s = t[2],
        u = t[3],
        c = e[0],
        l = n[0],
        h = n[1];
       this.outputShape = [c, l, h, u];
       var p = "bilinear" === r ? 1 : 0,
        f = [a - 1 + ".0", s - 1 + ".0"],
        d = f[0],
        v = f[1],
        m = l > 1 ? ["" + (a - 1) / (l - 1), "(y2-y1) * height_ratio", "y1*" + d + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d],
        g = m[0],
        y = m[1],
        b = m[2],
        x = h > 1 ? ["" + (s - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + v + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v],
        w = x[0],
        C = x[1],
        S = x[2];
       this.userCode = "\n      const float height_ratio = float(" + g + ");\n      const float width_ratio = float(" + w + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + o + ") {\n          return;\n        }\n\n        float height_scale = " + y + ";\n        float width_scale = " + C + ";\n\n        float in_y = " + b + ";\n        if( in_y < 0.0 || in_y > " + d + " ) {\n          setOutput(float(" + i + "));\n          return;\n        }\n        float in_x = " + S + ";\n        if( in_x < 0.0 || in_x > " + v + " ) {\n          setOutput(float(" + i + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + p + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "
      },
      No = function(t, e, n) {
       this.variableNames = ["x"], this.outputShape = t;
       var r = t.length,
        i = t[t.length - 1],
        o = n ? "<" : ">";
       this.userCode = "\n      int getIndex(int i) {\n        " + (n ? "return " + i + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + qi(r) + " coords = getOutputCoords();\n        int end = " + Ro(r, "coords") + ";\n        float val = 0.0;\n        for (int i = " + i + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + o + " end) {\n            continue;\n          }\n          if (idx == end && " + e + ") {\n            continue;\n          }\n          " + Ro(r, "coords") + " = idx;\n          val += getX(" + function(t, e) {
        if (1 === t) return "" + e;
        if (2 === t) return e + ".x, " + e + ".y";
        if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
        if (4 === t) return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
        throw Error("Cumulative sum for rank " + t + " is not yet supported")
       }(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    "
      };
 
     function Ro(t, e) {
      if (1 === t) return "" + e;
      if (2 === t) return e + ".y";
      if (3 === t) return e + ".z";
      if (4 === t) return e + ".w";
      throw Error("Cumulative sum for rank " + t + " is not yet supported")
     }
     var To = function(t) {
       this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = jt.DENSE;
       var e = Kt(t),
        n = Fi();
       this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + Mi(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    "
      },
      _o = function(t) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = jt.DENSE;
       var e = Kt(t),
        n = Fi();
       this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + Mi(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    "
      },
      Do = function() {
       function t(t, e, n) {
        this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e + ";\n      int offset_h = imod(h, " + e + ");\n      int in_w = w / " + e + ";\n      int offset_w = imod(w, " + e + ");\n      int offset_d = (offset_h * " + e + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  "
       }
       return t.prototype.getHeightCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
       }, t.prototype.getWidthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
       }, t.prototype.getDepthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
       }, t.prototype.getOutputDepthSize = function() {
        return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
       }, t.prototype.getInputSamplingString = function() {
        return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
       }, t
      }(),
      Fo = function(t) {
       this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
      },
      Mo = function(t) {
       this.variableNames = ["A"], this.outTexUsage = Wt.DOWNLOAD;
       var e = Fi();
       this.outputShape = t, this.userCode = "\n      " + Bi + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e.output + " = encode_float(x);\n      }\n    "
      },
      Lo = function(t) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = Wt.DOWNLOAD;
       var e = Fi();
       this.outputShape = t, this.userCode = "\n      " + Bi + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e.output + " = encode_float(x);\n      }\n    "
      },
      Bo = function(t, e, n) {
       void 0 === n && (n = !1), this.variableNames = ["A"];
       var r = Fi(),
        i = e[0],
        o = e[1];
       this.outputShape = t;
       var a = "result";
       n && (a = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Li(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + o + ";\n        int c = imod(flatIndex, " + o + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + o + ".0, " + i + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + a + ", 0., 0., 0.);\n      }\n    "
      },
      Po = function(t, e, n) {
       void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
       var r = Fi(),
        i = e[0],
        o = e[1];
       this.outputShape = t;
       var a = "",
        s = "result";
       n && (s = "floor(result * 255. + 0.5)");
       for (var u = 0; u <= 1; u++)
        for (var c = 0; c <= 1; c++) {
         var l = 2 * u + c;
         a += "\n          localCoords = coords;\n          if(localCoords[2] + " + c + " < " + t[2] + ") {\n            localCoords[2] += " + c + ";\n            if(localCoords[1] + " + u + " < " + t[1] + ") {\n              localCoords[1] += " + u + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + o + ";\n              c = imod(flatIndex, " + o + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + o + ".0, " + i + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l + "] = values[2];\n              } else {\n                result[" + l + "] = values[3];\n              }\n            }\n          }\n        "
        }
       this.userCode = "\n      " + Li(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + a + "\n\n        " + r.output + " = " + s + ";\n      }\n    "
      },
      zo = "return real * expR - imag * expI;",
      jo = "return real * expI + imag * expR;",
      Wo = function(t, e, n) {
       this.variableNames = ["real", "imag"];
       var r = e[1];
       this.outputShape = e;
       var i = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
        o = n ? r + ".0" : "1.0";
       this.userCode = "\n      const float exponentMultiplier = " + i + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + o + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "
      },
      Vo = function() {
       function t(t, e) {
        this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
       }
       return t.prototype.getCustomSetupFunc = function(t) {
        var e = this;
        return function(n, r) {
         null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(e.valueLoc, t)
        }
       }, t
      }(),
      Uo = function(t, e, n) {
       this.variableNames = ["A", "indices"];
       var r = t.slice();
       r[n] = e, this.outputShape = r, this.rank = r.length;
       var i = qi(this.rank),
        o = function(t, e) {
         var n = t.length;
         if (n > 4) throw Error("Gather for rank " + n + " is not yet supported");
         if (1 === n) return "int(getIndices(resRC))";
         for (var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i = [], o = 0; o < t.length; o++) o === e ? i.push("int(getIndices(" + r[o] + "))") : i.push("" + r[o]);
         return i.join()
        }(t, n);
       this.userCode = "\n      void main() {\n        " + i + " resRC = getOutputCoords();\n        setOutput(getA(" + o + "));\n      }\n    "
      },
      Ho = function(t, e, n) {
       this.sliceDim = t, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = n;
       var r = qi(e.length),
        i = qi(n.length),
        o = this.sliceDim > 1 ? "strides[j]" : "strides";
       this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + i + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + o + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "
      };
 
     function $o(t, e) {
      var n = Fi();
      return re(t, e, n.version + "\n    precision highp float;\n    " + n.attribute + " vec3 clipSpacePos;\n    " + n.attribute + " vec2 uv;\n    " + n.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")
     }
 
     function Go(t, e) {
      return he(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
     }
 
     function qo(t, e) {
      return pe(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]))
     }
 
     function Ko(t, e, n, r, i, o, a) {
      de(n, r);
      var s = fe(t, e),
       u = t.TEXTURE_2D;
      return Zt(t, e, (function() {
       return t.bindTexture(u, s)
      })), Zt(t, e, (function() {
       return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE)
      })), Zt(t, e, (function() {
       return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)
      })), Zt(t, e, (function() {
       return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST)
      })), Zt(t, e, (function() {
       return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST)
      })), Zt(t, e, (function() {
       return t.texImage2D(u, 0, i, n, r, 0, o, a, null)
      })), Zt(t, e, (function() {
       return t.bindTexture(t.TEXTURE_2D, null)
      })), s
     }
 
     function Xo(t, e, n, r, i) {
      var o = qt(n, r);
      return Ko(t, e, o[0], o[1], i.internalFormatFloat, i.textureFormatFloat, t.FLOAT)
     }
 
     function Yo(t, e, n, r, i) {
      var o = qt(n, r);
      return Ko(t, e, o[0], o[1], i.internalFormatHalfFloat, i.textureFormatFloat, i.textureTypeHalfFloat)
     }
 
     function Zo(t, e, n, r, i) {
      var o = qt(n, r);
      return Ko(t, e, o[0], o[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE)
     }
 
     function Jo(t, e, n, r, i) {
      var o = Xt(n, r);
      return Ko(t, e, o[0], o[1], i.internalFormatPackedFloat, t.RGBA, t.FLOAT)
     }
 
     function Qo(t, e, n, r, i) {
      var o = Xt(n, r);
      return Ko(t, e, o[0], o[1], i.internalFormatPackedHalfFloat, t.RGBA, i.textureTypeHalfFloat)
     }
 
     function ta(t, e, n, r) {
      return Zt(t, e, (function() {
       return t.bindBuffer(t.ARRAY_BUFFER, r)
      })), me(t, e, n, "clipSpacePos", r, 3, 20, 0) && me(t, e, n, "uv", r, 2, 20, 12)
     }
 
     function ea(t, e, n, r, i, o, a) {
      var s, u, c;
      Zt(t, e, (function() {
       return t.bindTexture(t.TEXTURE_2D, n)
      })), o instanceof Uint8Array ? (s = new Uint8Array(r * i * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * i * 4), u = t.FLOAT, c = a.internalFormatPackedFloat), s.set(o), Zt(t, e, (function() {
       return t.texImage2D(t.TEXTURE_2D, 0, c, r, i, 0, t.RGBA, u, s)
      })), Zt(t, e, (function() {
       return t.bindTexture(t.TEXTURE_2D, null)
      }))
     }
 
     function na(t, e, n, r) {
      Zt(t, e, (function() {
       return t.bindTexture(t.TEXTURE_2D, n)
      })), r.data instanceof Uint8Array ? Zt(t, e, (function() {
       return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data)
      })) : Zt(t, e, (function() {
       return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r)
      })), Zt(t, e, (function() {
       return t.bindTexture(t.TEXTURE_2D, null)
      }))
     }
 
     function ra(t, e, n, r, i) {
      var o = t.createBuffer();
      Zt(t, e, (function() {
       return t.bindBuffer(t.PIXEL_PACK_BUFFER, o)
      }));
      var a = 16 * n * r;
      return Zt(t, e, (function() {
       return t.bufferData(t.PIXEL_PACK_BUFFER, a, t.STREAM_READ)
      })), Zt(t, e, (function() {
       return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0)
      })), Zt(t, e, (function() {
       return t.bindBuffer(t.PIXEL_PACK_BUFFER, null)
      })), o
     }
 
     function ia(t, e, n) {
      var r = t,
       i = new Float32Array(n);
      return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, i), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), i
     }
 
     function oa(t, e, n, r, i) {
      var o = qt(n, r),
       a = o[0],
       s = o[1],
       u = new Uint8Array(n * r * 4);
      return Zt(t, e, (function() {
       return t.readPixels(0, 0, a, s, i.downloadTextureFormat, t.UNSIGNED_BYTE, u)
      })), new Float32Array(u.buffer)
     }
 
     function aa(t, e, n, r, i, o, a, s) {
      var u = t,
       c = new Float32Array(function(t, e) {
        var n = Xt(t, e);
        return n[0] * n[1] * 4
       }(o, a));
      return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c
     }
 
     function sa(t, e, n, r) {
      var i = new Float32Array(n * r * 4);
      return Zt(t, e, (function() {
       return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, i)
      })), i
     }
     var ua = Object.freeze({
       createVertexShader: $o,
       createVertexBuffer: Go,
       createIndexBuffer: qo,
       createFloat32MatrixTexture: Xo,
       createFloat16MatrixTexture: Yo,
       createUnsignedBytesMatrixTexture: Zo,
       createPackedMatrixTexture: Jo,
       createFloat16PackedMatrixTexture: Qo,
       bindVertexProgramAttributeStreams: ta,
       uploadDenseMatrixToTexture: ea,
       uploadPixelDataToTexture: na,
       createBufferFromOutputTexture: ra,
       downloadFloat32MatrixFromBuffer: ia,
       downloadByteEncodedFloatMatrixFromOutputTexture: oa,
       downloadPackedMatrixFromBuffer: aa,
       downloadMatrixFromPackedOutputTexture: sa
      }),
      ca = function() {
       function t(t) {
        this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
        var e = h().getNumber("WEBGL_VERSION");
        null != t ? (this.gl = t, $t(e, t)) : this.gl = Gt(e);
        var n = "WEBGL_color_buffer_float";
        if (1 === h().getNumber("WEBGL_VERSION")) {
         if (this.textureFloatExtension = ne(this.gl, this.debug, "OES_texture_float"), Le(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = ne(this.gl, this.debug, "OES_texture_half_float");
         else if (h().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
         if (this.colorBufferFloatExtension = this.gl.getExtension(n), Le(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = ne(this.gl, this.debug, "EXT_color_buffer_half_float");
         else if (h().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
        } else if (n = "EXT_color_buffer_float", Le(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);
        else {
         if (!Le(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
         this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float")
        }
        this.vertexBuffer = Go(this.gl, this.debug), this.indexBuffer = qo(this.gl, this.debug), this.framebuffer = ve(this.gl, this.debug), this.textureConfig = Yt(this.gl, this.textureHalfFloatExtension)
       }
       return Object.defineProperty(t.prototype, "debug", {
        get: function() {
         return h().getBool("DEBUG")
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.dispose = function() {
        var t = this;
        if (!this.disposed) {
         null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
         var e = this.gl;
         Zt(e, this.debug, (function() {
          return e.finish()
         })), Zt(e, this.debug, (function() {
          return e.bindFramebuffer(e.FRAMEBUFFER, null)
         })), Zt(e, this.debug, (function() {
          return e.deleteFramebuffer(t.framebuffer)
         })), Zt(e, this.debug, (function() {
          return e.bindBuffer(e.ARRAY_BUFFER, null)
         })), Zt(e, this.debug, (function() {
          return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)
         })), Zt(e, this.debug, (function() {
          return e.deleteBuffer(t.indexBuffer)
         })), this.disposed = !0
        }
       }, t.prototype.createFloat32MatrixTexture = function(t, e) {
        return this.throwIfDisposed(), Xo(this.gl, this.debug, t, e, this.textureConfig)
       }, t.prototype.createFloat16MatrixTexture = function(t, e) {
        return this.throwIfDisposed(), Yo(this.gl, this.debug, t, e, this.textureConfig)
       }, t.prototype.createUnsignedBytesMatrixTexture = function(t, e) {
        return this.throwIfDisposed(), Zo(this.gl, this.debug, t, e, this.textureConfig)
       }, t.prototype.uploadPixelDataToTexture = function(t, e) {
        this.throwIfDisposed(), na(this.gl, this.debug, t, e)
       }, t.prototype.uploadDenseMatrixToTexture = function(t, e, n, r) {
        this.throwIfDisposed(), ea(this.gl, this.debug, t, e, n, r, this.textureConfig)
       }, t.prototype.createFloat16PackedMatrixTexture = function(t, e) {
        return this.throwIfDisposed(), Qo(this.gl, this.debug, t, e, this.textureConfig)
       }, t.prototype.createPackedMatrixTexture = function(t, e) {
        return this.throwIfDisposed(), Jo(this.gl, this.debug, t, e, this.textureConfig)
       }, t.prototype.deleteMatrixTexture = function(t) {
        var e = this;
        this.throwIfDisposed(), this.outputTexture === t && (Ce(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Zt(this.gl, this.debug, (function() {
         return e.gl.deleteTexture(t)
        }))
       }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t, e, n) {
        var r = this;
        return this.downloadMatrixDriver(t, (function() {
         return oa(r.gl, r.debug, e, n, r.textureConfig)
        }))
       }, t.prototype.downloadPackedMatrixFromBuffer = function(t, e, n, r, i, o) {
        return aa(this.gl, t, 0, 0, 0, i, o, this.textureConfig)
       }, t.prototype.downloadFloat32MatrixFromBuffer = function(t, e) {
        return ia(this.gl, t, e)
       }, t.prototype.createBufferFromTexture = function(t, e, n) {
        this.bindTextureToFrameBuffer(t);
        var r = ra(this.gl, this.debug, e, n, this.textureConfig);
        return this.unbindTextureToFrameBuffer(), r
       }, t.prototype.createAndWaitForFence = function() {
        var t = this.createFence(this.gl);
        return this.pollFence(t)
       }, t.prototype.createFence = function(t) {
        var e, n, r = this;
        if (h().getBool("WEBGL_FENCE_API_ENABLED")) {
         var i = t,
          o = i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
         t.flush(), n = function() {
          var t = i.clientWaitSync(o, 0, 0);
          return t === i.ALREADY_SIGNALED || t === i.CONDITION_SATISFIED
         }, e = o
        } else h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function() {
         return r.isQueryAvailable(e, h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
        }) : n = function() {
         return !0
        };
        return {
         query: e,
         isFencePassed: n
        }
       }, t.prototype.downloadMatrixFromPackedTexture = function(t, e, n) {
        var r = this;
        return this.downloadMatrixDriver(t, (function() {
         return sa(r.gl, r.debug, e, n)
        }))
       }, t.prototype.createProgram = function(t) {
        this.throwIfDisposed();
        var e = this.gl,
         n = ie(e, this.debug, t),
         r = $o(e, this.debug),
         i = ue(e, this.debug);
        return Zt(e, this.debug, (function() {
         return e.attachShader(i, r)
        })), Zt(e, this.debug, (function() {
         return e.attachShader(i, n)
        })), ce(e, this.debug, i), this.debug && le(e, this.debug, i), this.vertexAttrsAreBound || (this.setProgram(i), this.vertexAttrsAreBound = ta(e, this.debug, this.program, this.vertexBuffer)), i
       }, t.prototype.deleteProgram = function(t) {
        var e = this;
        this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Zt(this.gl, this.debug, (function() {
         return e.gl.deleteProgram(t)
        }))
       }, t.prototype.setProgram = function(t) {
        var e = this;
        this.throwIfDisposed(), this.program = t, null != this.program && this.debug && le(this.gl, this.debug, this.program), Zt(this.gl, this.debug, (function() {
         return e.gl.useProgram(t)
        }))
       }, t.prototype.getUniformLocation = function(t, e, n) {
        return void 0 === n && (n = !0), this.throwIfDisposed(), n ? ye(this.gl, this.debug, t, e) : be(this.gl, t, e)
       }, t.prototype.getAttributeLocation = function(t, e) {
        var n = this;
        return this.throwIfDisposed(), Zt(this.gl, this.debug, (function() {
         return n.gl.getAttribLocation(t, e)
        }))
       }, t.prototype.getUniformLocationNoThrow = function(t, e) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(t, e)
       }, t.prototype.setInputMatrixTexture = function(t, e, n) {
        this.throwIfDisposed(), this.throwIfNoProgram(), xe(this.gl, this.debug, this.program, t, e, n)
       }, t.prototype.setOutputMatrixTexture = function(t, e, n) {
        this.setOutputMatrixTextureDriver(t, n, e)
       }, t.prototype.setOutputPackedMatrixTexture = function(t, e, n) {
        this.throwIfDisposed();
        var r = Xt(e, n),
         i = r[0],
         o = r[1];
        this.setOutputMatrixTextureDriver(t, i, o)
       }, t.prototype.setOutputMatrixWriteRegion = function(t, e, n, r) {
        this.setOutputMatrixWriteRegionDriver(n, t, r, e)
       }, t.prototype.setOutputPackedMatrixWriteRegion = function(t, e, n, r) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
       }, t.prototype.debugValidate = function() {
        null != this.program && le(this.gl, this.debug, this.program), Se(this.gl)
       }, t.prototype.executeProgram = function() {
        this.throwIfDisposed(), this.throwIfNoProgram();
        var t = this.gl;
        this.debug && this.debugValidate(), Zt(t, this.debug, (function() {
         return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0)
        }))
       }, t.prototype.blockUntilAllProgramsCompleted = function() {
        var t = this;
        this.throwIfDisposed(), Zt(this.gl, this.debug, (function() {
         return t.gl.finish()
        }))
       }, t.prototype.getQueryTimerExtension = function() {
        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = ne(this.gl, this.debug, 2 === h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
       }, t.prototype.getQueryTimerExtensionWebGL2 = function() {
        return this.getQueryTimerExtension()
       }, t.prototype.getQueryTimerExtensionWebGL1 = function() {
        return this.getQueryTimerExtension()
       }, t.prototype.beginQuery = function() {
        if (2 === h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
         var t = this.gl,
          e = this.getQueryTimerExtensionWebGL2(),
          n = t.createQuery();
         return t.beginQuery(e.TIME_ELAPSED_EXT, n), n
        }
        var r = this.getQueryTimerExtensionWebGL1(),
         i = r.createQueryEXT();
        return r.beginQueryEXT(r.TIME_ELAPSED_EXT, i), i
       }, t.prototype.endQuery = function() {
        if (2 !== h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
         var t = this.getQueryTimerExtensionWebGL1();
         t.endQueryEXT(t.TIME_ELAPSED_EXT)
        } else {
         var e = this.gl,
          n = this.getQueryTimerExtensionWebGL2();
         e.endQuery(n.TIME_ELAPSED_EXT)
        }
       }, t.prototype.waitForQueryAndGetTime = function(t) {
        return s(this, void 0, void 0, (function() {
         var e = this;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return [4, M((function() {
             return e.disposed || e.isQueryAvailable(t, h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
            }))];
           case 1:
            return n.sent(), [2, this.getQueryTime(t, h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]
          }
         }))
        }))
       }, t.prototype.getQueryTime = function(t, e) {
        if (0 === e) return null;
        if (2 === e) {
         var n = this.gl;
         return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6
        }
        var r = this.getQueryTimerExtensionWebGL1();
        return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6
       }, t.prototype.isQueryAvailable = function(t, e) {
        if (0 === e) return !0;
        if (2 === e) {
         var n = this.gl,
          r = this.getQueryTimerExtensionWebGL2(),
          i = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
         return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint
        }
        return i = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT), null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), i && !this.disjoint
       }, t.prototype.pollFence = function(t) {
        var e = this;
        return new Promise((function(n) {
         e.addItemToPoll((function() {
          return t.isFencePassed()
         }), (function() {
          return n()
         }))
        }))
       }, t.prototype.pollItems = function() {
        for (var t = function(t) {
          for (var e = 0; e < t.length; ++e)
           if (!t[e]()) break;
          return e - 1
         }(this.itemsToPoll.map((function(t) {
          return t.isDoneFn
         }))), e = 0; e <= t; ++e)(0, this.itemsToPoll[e].resolveFn)();
        this.itemsToPoll = this.itemsToPoll.slice(t + 1)
       }, t.prototype.addItemToPoll = function(t, e) {
        var n = this;
        this.itemsToPoll.push({
         isDoneFn: t,
         resolveFn: e
        }), this.itemsToPoll.length > 1 || M((function() {
         return n.pollItems(), 0 === n.itemsToPoll.length
        }))
       }, t.prototype.bindTextureToFrameBuffer = function(t) {
        this.throwIfDisposed(), we(this.gl, this.debug, t, this.framebuffer), this.debug && Se(this.gl)
       }, t.prototype.unbindTextureToFrameBuffer = function() {
        null != this.outputTexture ? (we(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Se(this.gl)) : Ce(this.gl, this.debug, this.framebuffer)
       }, t.prototype.downloadMatrixDriver = function(t, e) {
        this.bindTextureToFrameBuffer(t);
        var n = e();
        return this.unbindTextureToFrameBuffer(), n
       }, t.prototype.setOutputMatrixTextureDriver = function(t, e, n) {
        this.throwIfDisposed();
        var r = this.gl;
        we(r, this.debug, t, this.framebuffer), this.debug && Se(r), this.outputTexture = t, Zt(r, this.debug, (function() {
         return r.viewport(0, 0, e, n)
        })), Zt(r, this.debug, (function() {
         return r.scissor(0, 0, e, n)
        }))
       }, t.prototype.setOutputMatrixWriteRegionDriver = function(t, e, n, r) {
        var i = this;
        this.throwIfDisposed(), Zt(this.gl, this.debug, (function() {
         return i.gl.scissor(t, e, n, r)
        }))
       }, t.prototype.throwIfDisposed = function() {
        if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
       }, t.prototype.throwIfNoProgram = function() {
        if (null == this.program) throw new Error("No GPU program is currently set.")
       }, t
      }();
 
     function la(t, e) {
      if (t.length !== e.length) throw Error("Binary was compiled with " + t.length + " inputs, but was executed with " + e.length + " inputs");
      t.forEach((function(t, n) {
       var r = t.logicalShape,
        i = e[n],
        o = i.shape;
       if (!R(r, o)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + o + " must match");
       if (!t.isUniform || !i.isUniform) {
        var a = t.texShape,
         s = i.isUniform ? null : i.texData.texShape;
        if (!R(a, s)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + a + " and " + s + " must match")
       }
      }))
     }
     var ha = function(t, e, n) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;
       for (var r = n.filterWidth, i = n.inChannels, o = n.strideWidth, a = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, p = s.left, f = s.top, d = i * r, v = Fi(), m = "channelsLast" === h, g = m ? 0 : 1, y = m ? 1 : 2, b = "", x = 0; x <= 1; x++)
        for (var w = 0; w <= 1; w++) b += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + x + ";\n\n          if(blockIndex < " + t[1] + " && pos < " + t[0] + ") {\n            offsetY = int(blockIndex / (" + u + ")) * " + a + " - " + f + ";\n            d0 = offsetY + " + l + " * (pos / " + d + ");\n\n            if(d0 < " + e[g] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u + ".) * " + o + ". - " + p + ".);\n              d1 = offsetX + " + c + " * (int(mod(float(pos), " + d + ".) / " + i + ".));\n\n              if(d1 < " + e[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + i + ".));\n\n                if (" + m + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
       this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + b + "\n\n        " + v.output + " = result;\n      }\n    "
      },
      pa = function(t, e, n, r, i) {
       this.variableNames = ["x"], this.outputShape = [];
       var o, a = e,
        s = t[3] - 1;
       this.outputShape = t;
       var u = "float(" + n + ") + float(" + r + ") * sum";
       o = .5 === i ? "inversesqrt(" + u + ")" : 1 === i ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + i + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + a + "; j <= " + a + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + o + ";\n        setOutput(val);\n      }\n    "
      },
      fa = function(t, e, n, r, i) {
       this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = i, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + i + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + i + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "
      },
      da = function(t, e, n, r, i) {
       this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
       var o, a = e,
        s = t[3] - 1;
       this.outputShape = t;
       var u = "float(" + n + ") + float(" + r + ") * sum";
       o = .5 === i ? "inversesqrt(" + u + ")" : 1 === i ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + i + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + a + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + a + "; j <= " + a + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + o + ";\n        setOutput(result);\n      }\n    "
      },
      va = function(t) {
       this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
       var e = t.strideHeight,
        n = t.strideWidth,
        r = t.dilationHeight,
        i = t.effectiveFilterHeight,
        o = t.effectiveFilterWidth,
        a = i - 1 - t.padInfo.top,
        s = o - 1 - t.padInfo.left,
        u = i * o - 1;
       this.userCode = "\n      const ivec2 pads = ivec2(" + a + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + i + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + e + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + o + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + o + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      ma = function(t) {
       this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
       var e = t.strideDepth,
        n = t.strideHeight,
        r = t.strideWidth,
        i = t.dilationDepth,
        o = t.dilationHeight,
        a = t.dilationWidth,
        s = t.effectiveFilterDepth,
        u = t.effectiveFilterHeight,
        c = t.effectiveFilterWidth,
        l = s - 1 - t.padInfo.front,
        h = u - 1 - t.padInfo.top,
        p = c - 1 - t.padInfo.left,
        f = s * u * c - 1;
       this.userCode = "\n      const ivec3 pads = ivec3(" + l + ", " + h + ", " + p + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s + ";\n           wD += " + i + ") {\n          float dyD = float(dyDCorner + wD) / " + e + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + o + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + a + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + f + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u + " * " + c + " +\n                  wR * " + c + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
      },
      ga = function(t, e, n, r, i, o, a) {
       void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === i && (i = !1), void 0 === o && (o = null), void 0 === a && (a = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
       var s = n ? t[1] : t[2],
        u = Math.ceil(s / 2),
        c = n ? "i * 2, rc.y" : "rc.y, i * 2",
        l = r ? "rc.z, i * 2" : "i * 2, rc.z",
        h = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
        p = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
        f = "",
        d = "";
       o && (f = a ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + o + "\n        }" : "vec4 activation(vec4 x) {\n          " + o + "\n        }", d = "result = activation(result);");
       var v = i ? "result += getBiasAtOutCoords();" : "";
       i && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + f + "\n\n      const float sharedDimension = " + u + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c + ");\n          vec4 b = getMatrixB(rc.x, " + l + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h[0] + " * " + p[0] + ");\n          result += (" + h[1] + " * " + p[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v + "\n\n        " + d + "\n\n        setOutput(result);\n      }\n    "
      },
      ya = function() {
       function t(t, e, n) {
        this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e - 1) + "));\n      }\n    "
       }
       return t.prototype.getCustomSetupFunc = function(t) {
        var e = this;
        return function(n, r) {
         null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(e.seedLoc, t)
        }
       }, t
      }(),
      ba = function(t, e, n, r) {
       this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    "
      },
      xa = function(t) {
       this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;
       var e = t.length;
       if (0 === e) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
       else {
        var n = Di("rc", e),
         r = qi(e),
         i = function(t, e, n) {
          if (1 === t) return "rc > " + e[0];
          for (var r = "", i = t - 2; i < t; i++) r += n[i] + " >= " + e[i], i < t - 1 && (r += "||");
          return r
         }(e, t, n),
         o = function(t, e, n, r) {
          if (1 === t) return "";
          var i = r.slice(-2);
          return "\n    int r = " + i[0] + ";\n    int c = " + i[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e + ";\n    bool rEdge = rp1 >= " + n + ";\n  "
         }(e, t[t.length - 1], t[t.length - 2], n),
         a = function(t, e) {
          var n = t.length,
           r = function(t, e) {
            for (var n = [], r = 0; r <= 1; r++)
             for (var i = 0; i <= 1; i++) {
              for (var o = (0 === r ? "r" : "rp1") + ", " + (0 === i ? "c" : "cp1"), a = 2; a < t; a++) o = e[e.length - 1 - a] + "," + o;
              n.push(o)
             }
            return n
           }(n, e);
          return 1 === n ? "getA(rc),\n            rc + 1 >= " + t[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")"
         }(t, n);
        this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + i + ") {\n            setOutput(vec4(0));\n          } else {\n            " + o + "\n\n            setOutput(vec4(" + a + "));\n          }\n        }\n      "
       }
      },
      wa = function(t, e, n) {
       this.variableNames = ["x"], this.outputShape = e.map((function(e, n) {
        return e[0] + t[n] + e[1]
       }));
       var r = t.length,
        i = qi(r),
        o = e.map((function(t) {
         return t[0]
        })).join(","),
        a = e.map((function(e, n) {
         return e[0] + t[n]
        })).join(","),
        s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
       this.userCode = 1 !== r ? "\n      " + i + " start = " + i + "(" + o + ");\n      " + i + " end = " + i + "(" + a + ");\n\n      void main() {\n        " + i + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n + "));\n        } else {\n          " + i + " coords = outC - start;\n          setOutput(getX(" + s + "));\n        }\n      }\n    " : "\n        int start = " + o + ";\n        int end = " + a + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "
      },
      Ca = function(t, e, n) {
       this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map((function(e, n) {
        return e[0] + t[n] + e[1]
       }));
       for (var r = t.length, i = qi(r), o = e.map((function(t) {
         return t[0]
        })).join(","), a = e.map((function(e, n) {
         return e[0] + t[n]
        })).join(","), s = Di("rc", r), u = Di("source", r), c = s[r - 1] + " < " + this.outputShape[r - 1], l = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")", h = [i + " rc = outputLoc;", s[r - 1] + " += 1;\n       if(" + c + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + s[r - 2] + " += 1;\n       if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + c + ") {"], p = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", f = "", d = 0, v = 1 === r ? 2 : 4; d < v; d++) f += "\n        " + h[d] + "\n        if (" + p + ") {\n          result[" + d + "] = float(" + n + ");\n        } else {\n          " + i + " source = rc - start;\n          result[" + d + "] = getChannel(getX(" + u.join() + "), " + l + ");\n        }\n      ";
       f += 1 === r ? "} " : "}}", this.userCode = "\n      const " + i + " start = " + i + "(" + o + ");\n      const " + i + " end = " + i + "(" + a + ");\n\n      void main() {\n        " + i + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + f + "\n        setOutput(result);\n      }\n    "
      },
      Sa = function(t, e, n) {
       if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
       var r = t.filterWidth,
        i = t.strideHeight,
        o = t.strideWidth,
        a = t.dilationHeight,
        s = t.dilationWidth,
        u = t.effectiveFilterHeight,
        c = t.effectiveFilterWidth,
        l = t.padInfo.top,
        h = t.padInfo.left;
       this.outputShape = t.outShape;
       var p = "avg" === e,
        f = "0.0";
       if (p || (f = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + i + ", " + o + ");\n        const ivec2 pads = ivec2(" + l + ", " + h + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + a + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c + ";\n                wC += " + s + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
       else {
        var d = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e && (d = "avgValue / count");
        var v = 4 * Math.floor(r / 4),
         m = r % 4,
         g = "\n      if (" + p + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + i + ", " + o + ");\n      const ivec2 pads = ivec2(" + l + ", " + h + ");\n      const float initializationValue = " + f + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + f + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u + ";\n            wR += " + a + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v + "; wC += 4) {\n            int xC = xCCorner + wC * " + s + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              getValue(batch, xR, xC + 3 * " + s + ", d)\n            );\n\n            " + g + "\n          }\n\n          int xC = xCCorner + " + v + ";\n          if (" + (1 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (2 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g + "\n          } else if (" + (3 === m) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              initializationValue\n            );\n\n            " + g + "\n          }\n        }\n        setOutput(" + d + ");\n      }\n    "
       }
      },
      Ea = function(t, e, n) {
       if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
       var r = t.filterWidth,
        i = t.strideDepth,
        o = t.strideHeight,
        a = t.strideWidth,
        s = t.dilationDepth,
        u = t.dilationHeight,
        c = t.dilationWidth,
        l = t.effectiveFilterDepth,
        h = t.effectiveFilterHeight,
        p = t.effectiveFilterWidth,
        f = t.padInfo.front,
        d = t.padInfo.top,
        v = t.padInfo.left;
       this.outputShape = t.outShape;
       var m = "avg" === e,
        g = "0.0";
       if (m || (g = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + i + ", " + o + ", " + a + ");\n        const ivec3 pads = ivec3(" + f + ", " + d + ", " + v + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l + ";\n              wD += " + s + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h + ";\n                wR += " + u + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + p + ";\n                  wC += " + c + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h + " * " + p + " +\n                      wR * " + p + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
       else {
        var y = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e && (y = "avgValue / count");
        var b = 4 * Math.floor(r / 4),
         x = r % 4,
         w = "\n      if (" + m + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec3 strides =\n        ivec3(" + i + ", " + o + ", " + a + ");\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + v + ");\n      const float initializationValue = " + g + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l + ";\n            wD += " + s + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h + ";\n            wR += " + u + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + b + "; wC += 4) {\n              int xC = xCCorner + wC * " + c + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c + ", ch)\n              );\n\n              " + w + "\n            }\n\n            int xC = xCCorner + " + b + ";\n            if (" + (1 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (2 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (3 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c + ", ch),\n                initializationValue\n              );\n\n              " + w + "\n            }\n          }\n          setOutput(" + y + ");\n        }\n      }\n    "
       }
      },
      ka = function(t, e) {
       this.variableNames = ["x"];
       var n = t.windowSize,
        r = t.batchSize,
        i = t.inSize,
        o = Math.ceil(i / n);
       this.outputShape = [r, o];
       var a = "0.0",
        s = "";
       "prod" === e ? a = "1.0" : "min" === e ? (a = "1.0 / 1e-20", s = "min") : "max" === e && (a = "-1.0 / 1e-20", s = "max");
       var u = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
       "sum" === e ? u = "sumValue" : "prod" === e ? u = "prodValue" : "all" === e ? u = "allValue" : "any" === e && (u = "anyValue");
       var c = 4 * Math.floor(n / 4),
        l = n % 4,
        h = "\n      if (" + ("sum" === e) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s + "(values, minMaxValue);\n      }\n    ",
        p = "vec4";
       "all" === e ? (a = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", p = "bvec4") : "any" === e && (a = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", p = "bvec4");
       var f = "";
       i % n > 0 && (f = "\n        if (inIdx < 0 || inIdx >= " + i + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + a + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + f + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + a + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h + "\n        }\n\n        int inIdx = inOffset + " + c + ";\n        if (" + (1 === l) + ") {\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (2 === l) + ") {\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h + "\n        } else if (" + (3 === l) + ") {\n          " + p + " values = " + p + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h + "\n        }\n        setOutput(" + u + ");\n      }\n    "
      },
      Ia = function(t, e) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;
       for (var n = "", r = 0; r < 4; r++) {
        var i = "thisRC = rc;";
        r % 2 == 1 && (i += "thisRC.z += 1;"), r > 1 && (i += "thisRC.y += 1;"), n += "\n        " + i + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      "
       }
       this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + Mi(["r", "c", "d"], e) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Li(t) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t[1] + ";\n        int cols = " + t[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    "
      },
      Oa = function(t, e, n) {
       this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
       var r = e.shape,
        i = r[1],
        o = r[2],
        a = t.shape,
        s = a[1],
        u = a[2],
        c = [n && s > 1 ? i - 1 : i, n && u > 1 ? o - 1 : o],
        l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
        h = c[0] / l[0],
        p = c[1] / l[1],
        f = 1 / h,
        d = 1 / p,
        v = 2 * Math.ceil(f) + 2,
        m = 2 * Math.ceil(d) + 2;
       this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + p + ");\n\n        const float invHeightScale = float(" + f + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (i - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (o - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
      },
      Aa = function(t, e, n, r) {
       this.variableNames = ["A"], this.outputShape = [];
       var i = t[0],
        o = t[1],
        a = t[2],
        s = t[3];
       this.outputShape = [i, e, n, s];
       var u = [r && e > 1 ? o - 1 : o, r && n > 1 ? a - 1 : a],
        c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
       this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + o + ".0, " + a + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "
      },
      Na = function(t, e, n, r) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
       var i = t[0],
        o = t[1],
        a = t[2],
        s = t[3];
       this.outputShape = [i, e, n, s];
       var u = [r && e > 1 ? o - 1 : o, r && n > 1 ? a - 1 : a],
        c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
       this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ",\n          " + u[1] / c[1] + ");\n      const vec3 inputShapeRC = vec3(" + o + ".0, " + a + ".0,\n                                     " + a + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "
      },
      Ra = function(t, e, n) {
       this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
       var r = e.shape,
        i = r[1],
        o = r[2],
        a = t.shape,
        s = a[1],
        u = a[2],
        c = [n && s > 1 ? i - 1 : i, n && u > 1 ? o - 1 : o],
        l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
        h = c[0] / l[0],
        p = c[1] / l[1],
        f = 1 / h,
        d = 1 / p,
        v = 2 * Math.ceil(f) + 2,
        m = 2 * Math.ceil(d) + 2;
       this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h + ");\n        const float widthScale = float(" + p + ");\n\n        const float invHeightScale = float(" + f + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + v + ");\n        const int winWidth = int(" + m + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c[0] + ") *\n                (float(dyR) / float(" + l[0] + "));\n\n            float sourceFracCol =\n                float(" + c[1] + ") *\n                  (float(dyC) / float(" + l[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + i + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + o + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
      },
      Ta = function(t, e, n, r) {
       this.variableNames = ["A"], this.outputShape = [];
       var i = t[0],
        o = t[1],
        a = t[2],
        s = t[3];
       this.outputShape = [i, e, n, s];
       var u = [r && e > 1 ? o - 1 : o, r && n > 1 ? a - 1 : a],
        c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
        l = r ? "0.5" : "0.0";
       this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / c[0] + ",\n          " + u[1] / c[1] + ");\n      const vec2 inputShapeRC = vec2(" + o + ".0, " + a + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "
      },
      _a = function(t, e) {
       this.variableNames = ["x"];
       var n = t.length;
       if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
       if (this.outputShape = t, 1 !== n) {
        var r = t.map((function(n, r) {
          return function(n) {
           return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]"
          }(r)
         })).join(","),
         i = qi(n);
        this.userCode = "\n      void main() {\n        " + i + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    "
       } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t[0] + " - coord - 1));\n        }\n      "
      },
      Da = function(t, e) {
       this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
       var n = t.length;
       if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
       this.outputShape = t;
       var r = Di("rc", n),
        i = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
        o = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
        a = qi(n);
 
       function s(n) {
        var r = t.map((function(r, i) {
         return function(n, r) {
          return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - " + r[n] + " - 1" : "" + r[n]
         }(i, n)
        }));
        return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))"
       }
       this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t[0] + " - rc - 1),\n            " + t[0] + " - rc - 1);\n          if(" + i + "){\n              result.g = getChannel(getX(" + t[0] + " - (rc  + 1) - 1),\n                " + t[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + a + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function(t) {
        return s(t)
       }(r.slice()) + ";\n          if(" + i + "){\n            result.g = " + function(t) {
        return t[n - 1] = "(" + t[n - 1] + " + 1)", s(t)
       }(r.slice()) + ";\n          }\n          if(" + o + ") {\n            result.b = " + function(t) {
        return t[n - 2] = "(" + t[n - 2] + " + 1)", s(t)
       }(r.slice()) + ";\n            if(" + i + ") {\n              result.a = " + function(t) {
        return t[n - 1] = "(" + t[n - 1] + " + 1)", t[n - 2] = "(" + t[n - 2] + " + 1)", s(t)
       }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    "
      },
      Fa = function(t, e, n, r, i, o, a) {
       void 0 === a && (a = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = o;
       var s = qi(i.length),
        u = qi(o.length),
        c = "";
       1 === n ? c = "i" : 2 === n && (c = "i, j");
       var l = "getIndices(" + c + ")",
        h = "";
       1 === r ? h = "i" : 2 === r && (h = "i, coords[1]");
       var p = "getUpdates(" + h + ")",
        f = e > 1 ? "strides[j]" : "strides";
       this.userCode = "\n        " + s + " strides = " + s + "(" + i + ");\n\n        void main() {\n          " + u + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e + "; j++) {\n              int index = round(" + l + ");\n              flattenedIndex += index * " + f + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + p + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "
      },
      Ma = function(t, e) {
       this.variableNames = ["x", "segmentIds"];
       var n = t.windowSize,
        r = t.batchSize,
        i = t.inSize,
        o = t.numSegments,
        a = o * Math.ceil(i / n);
       this.outputShape = [r, a];
       var s = 4 * Math.floor(n / 4),
        u = n % 4,
        c = "\n        sumValue += dot(values, segFilter);\n    ",
        l = "";
       i % n > 0 && (l = "\n        if (inIdx < 0 || inIdx >= " + i + ") {\n          return initializationValue;\n        }\n      ");
       var h = "";
       i % n > 0 && (h = "\n        if (inIdx < 0 || inIdx >= " + i + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + o + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + o + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c + "\n        }\n\n        int inIdx = inOffset + " + s + ";\n        if (" + (1 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c + "\n        } else if (" + (2 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c + "\n        } else if (" + (3 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c + "\n        }\n        setOutput(sumValue);\n      }\n    "
      },
      La = function(t, e, n) {
       var r, i;
       if (this.variableNames = ["c", "a", "b"], this.outputShape = e, n > 4) throw Error("Where for rank " + n + " is not yet supported");
       if (1 === n) i = "resRC", r = "resRC";
       else {
        for (var o = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], a = [], s = [], u = 0; u < e.length; u++) s.push("" + o[u]), u < t && a.push("" + o[u]);
        r = a.join(), i = s.join()
       }
       var c = qi(n);
       this.userCode = "\n      void main() {\n        " + c + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + i + "));\n        } else {\n          setOutput(getB(" + i + "));\n        }\n      }\n    "
      },
      Ba = function() {
       function t(t) {
        this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;
        var e, n = qi(this.rank),
         r = "uniform int start[" + this.rank + "];",
         i = function(t) {
          if (1 === t) return "sourceLoc";
          if (t <= 6) return Pa.slice(0, t).map((function(t) {
           return "sourceLoc." + t
          })).join(",");
          throw Error("Slicing for rank " + t + " is not yet supported")
         }(this.rank);
        e = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + t.map((function(t, e) {
         return "sourceLoc." + Pa[e] + " = start[" + e + "] + coords." + Pa[e] + ";"
        })).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + e + "\n        setOutput(getSource(" + i + "));\n      }\n    "
       }
       return t.prototype.getCustomSetupFunc = function(t) {
        var e = this;
        if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
        return function(n, r) {
         null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t)
        }
       }, t
      }(),
      Pa = ["x", "y", "z", "w", "u", "v"],
      za = function() {
       function t(t) {
        this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;
        var e = qi(this.rank),
         n = Di("coords", this.rank),
         r = Di("sourceLoc", this.rank),
         i = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
         o = "getChannel(getSource(" + r.join() + "), " + i + ")",
         a = "\n      result.x = " + o + ";\n      if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + o + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
         s = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + t[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + o + ";\n        if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + o + ";\n        }\n      }\n    ",
         u = this.rank <= 4 ? "sourceLoc = coords +\n            " + e + "(" + t.map((function(t, e) {
          return "start[" + e + "]"
         })).join() + ");" : t.map((function(t, e) {
          return r[e] + " = " + n[e] + " + start[" + e + "];"
         })).join("\n");
        this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e + " coords = getOutputCoords();\n        " + e + " sourceLoc;\n        " + u + "\n        vec4 result = vec4(0.);\n        " + a + "\n        " + s + "\n        setOutput(result);\n      }\n    "
       }
       return t.prototype.getCustomSetupFunc = function(t) {
        var e = this;
        if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
        return function(n, r) {
         null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t)
        }
       }, t
      }(),
      ja = function(t, e, n) {
       this.variableNames = ["x"], this.outputShape = n;
       var r = n.length,
        i = qi(n.length),
        o = qi(n.length),
        a = "";
       if (1 === r) a = "coords * strides + begin";
       else {
        var s = 0;
        a = n.map((function(t, e) {
         return s++, 1 === n.length ? "coords * strides[" + e + "] + begin[" + e + "]" : "coords[" + (s - 1) + "] * strides[" + e + "] + begin[" + e + "]"
        })).join(",")
       }
       this.userCode = "\n      " + i + " begin = " + i + "(" + t + ");\n      " + i + " strides = " + i + "(" + e + ");\n\n      void main() {\n        " + o + " coords = getOutputCoords();\n        setOutput(getX(" + a + "));\n      }\n    "
      },
      Wa = function() {
       function t(t) {
        this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}
       }
       return t.prototype.acquireTexture = function(t, e, n) {
        var r, i = Va(e, n),
         o = Ua(t, i, n);
        if (o in this.freeTextures || (this.freeTextures[o] = []), o in this.usedTextures || (this.usedTextures[o] = []), this.freeTextures[o].length > 0) {
         this.numFreeTextures--, this.numUsedTextures++, this.log();
         var a = this.freeTextures[o].shift();
         return this.usedTextures[o].push(a), a
        }
        return this.numUsedTextures++, this.log(), i === Vt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : i === Vt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : i === Vt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : i === Vt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : i === Vt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[o].push(r), r
       }, t.prototype.releaseTexture = function(t, e, n, r) {
        if (null != this.freeTextures) {
         var i = Ua(e, Va(n, r), r);
         i in this.freeTextures || (this.freeTextures[i] = []), this.freeTextures[i].push(t), this.numFreeTextures++, this.numUsedTextures--;
         var o = this.usedTextures[i],
          a = o.indexOf(t);
         if (a < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
         o.splice(a, 1), this.log()
        }
       }, t.prototype.log = function() {
        if (this.logEnabled) {
         var t = this.numFreeTextures + this.numUsedTextures;
         console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t + ")")
        }
       }, t.prototype.getNumUsedTextures = function() {
        return this.numUsedTextures
       }, t.prototype.getNumFreeTextures = function() {
        return this.numFreeTextures
       }, t.prototype.dispose = function() {
        var t = this;
        if (null != this.freeTextures) {
         for (var e in this.freeTextures) this.freeTextures[e].forEach((function(e) {
          t.gpgpu.deleteMatrixTexture(e)
         }));
         for (var e in this.usedTextures) this.usedTextures[e].forEach((function(e) {
          t.gpgpu.deleteMatrixTexture(e)
         }));
         this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0
        }
       }, t
      }();
 
     function Va(t, e) {
      if (t === Wt.UPLOAD) return Vt.PACKED_2X2_FLOAT32;
      if (t === Wt.RENDER || null == t) return function(t) {
       return h().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? Vt.PACKED_2X2_FLOAT32 : Vt.UNPACKED_FLOAT32 : t ? Vt.PACKED_2X2_FLOAT16 : Vt.UNPACKED_FLOAT16
      }(e);
      if (t === Wt.DOWNLOAD || t === Wt.PIXELS) return Vt.PACKED_4X1_UNSIGNED_BYTE;
      throw new Error("Unknown logical texture type " + t)
     }
 
     function Ua(t, e, n) {
      return t[0] + "_" + t[1] + "_" + e + "_" + n
     }
     var Ha = function(t, e) {
       this.variableNames = ["A"];
       for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];
       this.outputShape = n, this.rank = n.length;
       var i = qi(this.rank),
        o = function(t) {
         var e = t.length;
         if (e > 5) throw Error("Tile for rank " + e + " is not yet supported");
         if (1 === e) return "imod(resRC, " + t[0] + ")";
         for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], i = 0; i < t.length; i++) r.push("imod(" + n[i] + ", " + t[i] + ")");
         return r.join()
        }(t);
       this.userCode = "\n      void main() {\n        " + i + " resRC = getOutputCoords();\n        setOutput(getA(" + o + "));\n      }\n    "
      },
      $a = function(t, e) {
       this.variableNames = ["A"];
       for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];
       this.outputShape = n, this.rank = n.length;
       var i = qi(this.rank),
        o = function(t) {
         var e = t.length;
         if (e > 6) throw Error("Transpose for rank " + e + " is not yet supported");
         for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(e), i = 0; i < t.length; i++) r[t[i]] = n[i];
         return r.join()
        }(e);
       this.userCode = "\n    void main() {\n      " + i + " resRC = getOutputCoords();\n      setOutput(getA(" + o + "));\n    }\n    "
      },
      Ga = function(t, e) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
       for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];
       if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
       var i = qi(this.rank),
        o = _i("rc", this.rank),
        a = new Array(this.rank);
       for (r = 0; r < e.length; r++) a[e[r]] = o[r];
       var s = "vec2(" + a.slice(-2).join() + ")",
        u = "++" + o[this.rank - 1] + " < " + n[this.rank - 1],
        c = "getChannel(getA(" + a.join() + "), " + s + ")";
       this.userCode = "\n    void main() {\n      " + i + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c + ";\n      if(" + u + ") {\n        result[1] = " + c + ";\n      }\n      --" + o[this.rank - 1] + ";\n      if(++" + o[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + c + ";\n        if(" + u + ") {\n          result[3] = " + c + ";\n        }\n      }\n      setOutput(result);\n    }\n    "
      },
      qa = 1.7580993408473768,
      Ka = 1.0507009873554805,
      Xa = function(t, e) {
       this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      float unaryOperation(float x) {\n        " + e + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
      },
      Ya = "if (isnan(x)) return x;",
      Za = "return x;",
      Ja = "return abs(x);",
      Qa = Ya + "\n  return (x < 0.0) ? 0.0 : x;\n",
      ts = Ya + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
      es = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
      ns = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + qa + ";\n  float scale = " + Ka + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n",
      rs = "return -x;",
      is = "return ceil(x);",
      os = "return floor(x);",
      as = "return exp(x);",
      ss = "return exp(x) - 1.0;",
      us = Ya + "\n  return sin(x);\n",
      cs = Ya + "\n  return cos(x);\n",
      ls = Ya + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",
      hs = Ya + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",
      ps = Ya + "\n  return atan(x);\n",
      fs = Ya + "return log(x + sqrt(x * x + 1.0));",
      ds = Ya + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",
      vs = Ya + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",
      ms = "return x;",
      gs = "return x;",
      ys = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
      bs = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
      xs = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
      ws = function(t, e) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
      },
      Cs = function(t) {
       this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;
       var e = t.length,
        n = Di("rc", e),
        r = qi(e),
        i = function(t, e) {
         if (1 === t) return "rc";
         for (var n = "", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += ",");
         return n
        }(e, n),
        o = n.slice(-2),
        a = e <= 1 ? "rc" : "vec2(" + o.join(",") + ")";
       this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + i + ");\n\n        setOutput(getChannel(packedInput, " + a + "));\n      }\n    "
      },
      Ss = {};
 
     function Es(t, e) {
      if (void 0 === e && (e = !1), "linear" === t) return e ? gs : Za;
      if ("relu" === t) return e ? ys : Qa;
      if ("elu" === t) return e ? xs : es;
      if ("relu6" === t) return e ? bs : ts;
      if ("prelu" === t) return e ? co : so;
      throw new Error("Activation " + t + " has not been implemented for the WebGL backend.")
     }
     var ks = 600,
      Is = function(t) {
       function e(e) {
        var n, r = t.call(this) || this;
        if (r.pendingRead = new WeakMap, r.pendingDisposal = new WeakSet, r.dataRefCount = new WeakMap, r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !h().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
        if (null == e) {
         var i = Gt(h().getNumber("WEBGL_VERSION"));
         r.binaryCache = (n = h().getNumber("WEBGL_VERSION")) in Ss ? Ss[n] : (Ss[n] = {}, Ss[n]), r.gpgpu = new ca(i), r.canvas = i.canvas, r.gpgpuCreatedLocally = !0
        } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;
        return r.textureManager = new Wa(r.gpgpu), r.numMBBeforeWarning = null == h().global.screen ? 1024 : h().global.screen.height * h().global.screen.width * window.devicePixelRatio * ks / 1024 / 1024, r.texData = new Gr(r, Bt), r
       }
       return a(e, t), e.prototype.numDataIds = function() {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes
       }, e.prototype.write = function(t, e, n) {
        if (h().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === n && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        var r = {};
        return this.texData.set(r, {
         shape: e,
         dtype: n,
         values: t,
         usage: Wt.UPLOAD
        }), r
       }, e.prototype.move = function(t, e, n, r) {
        if (h().getBool("DEBUG") && this.checkNumericalProblems(e), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.texData.set(t, {
         shape: n,
         dtype: r,
         values: e,
         usage: Wt.UPLOAD
        })
       }, e.prototype.readSync = function(t) {
        var e = this.texData.get(t),
         n = e.values,
         r = e.dtype,
         i = e.complexTensors,
         o = e.slice,
         a = e.shape,
         s = e.isPacked;
        if (null != o) {
         var u = void 0;
         u = s ? new ws(a, ms) : new Xa(a, ms);
         var c = this.runWebGLProgram(u, [{
           dataId: t,
           shape: a,
           dtype: r
          }], r),
          l = this.readSync(c.dataId);
         return this.disposeData(c.dataId), l
        }
        if (null != n) return this.convertAndCacheOnCPU(t);
        if ("string" === r) return n;
        var h, p, f = null != this.activeTimers;
        return f && (h = it()), p = "complex64" === r ? fi(i.real.dataSync(), i.imag.dataSync()) : this.getValuesFromTexture(t), f && (this.downloadWaitMs += it() - h), this.convertAndCacheOnCPU(t, p)
       }, e.prototype.read = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r, i, o, a, s, c, l, p, f, d, v, m, g, y, b, x, w, C, S, E;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise((function(t) {
             return e.push(t)
            }))];
            if (n = this.texData.get(t), r = n.values, i = n.shape, o = n.slice, a = n.dtype, s = n.complexTensors, c = n.isPacked, null != o) return l = void 0, l = c ? new ws(i, ms) : new Xa(i, ms), p = this.runWebGLProgram(l, [{
             dataId: t,
             shape: i,
             dtype: a
            }], a), f = this.read(p.dataId), this.disposeData(p.dataId), [2, f];
            if (null != r) return [2, this.convertAndCacheOnCPU(t)];
            if (!h().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === h().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return d = null, "complex64" !== a && h().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t), m = this.texData.get(v.dataId), d = (E = this.gpgpu).createBufferFromTexture.apply(E, [m.texture].concat(Kt(i)))), this.pendingRead.set(t, []), "complex64" === a ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
           case 1:
            u.sent(), u.label = 2;
           case 2:
            return "complex64" !== a ? [3, 4] : [4, Promise.all([s.real.data(), s.imag.data()])];
           case 3:
            return y = u.sent(), b = y[0], x = y[1], g = fi(b, x), [3, 5];
           case 4:
            null == d ? g = this.getValuesFromTexture(t) : (w = N(i), g = this.gpgpu.downloadFloat32MatrixFromBuffer(d, w)), u.label = 5;
           case 5:
            return null != v && this.disposeData(v.dataId), C = this.convertAndCacheOnCPU(t, g), S = this.pendingRead.get(t), this.pendingRead.delete(t), S.forEach((function(t) {
             return t(C)
            })), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, C]
          }
         }))
        }))
       }, e.prototype.checkNumericalProblems = function(t) {
        if (null != t)
         for (var e = 0; e < t.length; e++) {
          var n = t[e];
          if (!te(n)) {
           if (h().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
           throw Error("The value " + n + " cannot be represented on this device.")
          }
         }
       }, e.prototype.getValuesFromTexture = function(t) {
        var e, n = this.texData.get(t),
         r = n.shape,
         i = n.dtype,
         o = n.isPacked,
         a = N(r);
        if (h().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
         var s = this.decode(t),
          u = this.texData.get(s.dataId),
          c = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [u.texture].concat(Kt(r))).subarray(0, a);
         return this.disposeData(s.dataId), c
        }
        var l = h().getBool("WEBGL_PACK") && !0 === o,
         p = l ? Ne(r) : r,
         f = l ? new Lo(p) : new Mo(p),
         d = this.runWebGLProgram(f, [{
          shape: p,
          dtype: i,
          dataId: t
         }], "float32"),
         v = this.texData.get(d.dataId),
         m = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, a);
        return this.disposeData(d.dataId), m
       }, e.prototype.time = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r, i, o, a, s;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return e = this.activeTimers, n = [], r = !1, null == this.programTimersStack ? (this.programTimersStack = n, r = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), i = A(this.activeTimers.map((function(t) {
             return t.query
            }))).filter((function(t) {
             return null != t
            })), o = A(this.activeTimers.map((function(t) {
             return t.name
            }))).filter((function(t) {
             return null != t
            })), this.activeTimers = e, r && (this.programTimersStack = null), [4, Promise.all(i)];
           case 1:
            return a = u.sent(), s = {
             uploadWaitMs: this.uploadWaitMs,
             downloadWaitMs: this.downloadWaitMs,
             kernelMs: E(a),
             getExtraProfileInfo: function() {
              return a.map((function(t, e) {
               return {
                name: o[e],
                ms: t
               }
              })).map((function(t) {
               return t.name + ": " + t.ms
              })).join(", ")
             },
             wallMs: null
            }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s]
          }
         }))
        }))
       }, e.prototype.memory = function() {
        return {
         unreliable: !1,
         numBytesInGPU: this.numBytesInGPU
        }
       }, e.prototype.startTimer = function() {
        return h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : {
         startMs: it(),
         endMs: null
        }
       }, e.prototype.endTimer = function(t) {
        return h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = it(), t)
       }, e.prototype.getQueryTime = function(t) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          return h().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs]
         }))
        }))
       }, e.prototype.disposeData = function(t) {
        if (!this.pendingDisposal.has(t)) {
         if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;
         if (this.texData.has(t)) {
          this.releaseGPUData(t);
          var e = this.texData.get(t).complexTensors;
          null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t)
         }
        }
       }, e.prototype.releaseGPUData = function(t) {
        var e = this.texData.get(t),
         n = e.texture,
         r = e.dtype,
         i = e.texShape,
         o = e.usage,
         a = e.isPacked,
         s = e.slice,
         u = s && s.origDataId || t,
         c = this.dataRefCount.get(u);
        c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(i, r), this.textureManager.releaseTexture(n, i, o, a)));
        var l = this.texData.get(t);
        l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null
       }, e.prototype.getTexture = function(t) {
        return this.uploadToGPU(t), this.texData.get(t).texture
       }, e.prototype.getDataInfo = function(t) {
        return this.texData.get(t)
       }, e.prototype.getCPUBackend = function() {
        return h().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Bt.findBackend("cpu")), this.cpuBackend) : null
       }, e.prototype.shouldExecuteOnCPU = function(t, e) {
        var n = this;
        return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every((function(t) {
         return null == n.texData.get(t.dataId).texture && t.size < e
        }))
       }, e.prototype.getGPGPUContext = function() {
        return this.gpgpu
       }, e.prototype.complex = function(t, e) {
        var n = this.makeOutput(t.shape, "complex64");
        return this.texData.get(n.dataId).complexTensors = {
         real: Bt.keep(t.clone()),
         imag: Bt.keep(e.clone())
        }, n
       }, e.prototype.real = function(t) {
        return this.texData.get(t.dataId).complexTensors.real.clone()
       }, e.prototype.imag = function(t) {
        return this.texData.get(t.dataId).complexTensors.imag.clone()
       }, e.prototype.slice = function(t, e, n) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);
        if (0 === N(n)) return dn([], n, t.dtype);
        var r = this.texData.get(t.dataId).isPacked,
         i = jr(t.shape, e, n);
        if (r || !i) {
         var o = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new za(n) : new Ba(n),
          a = o.getCustomSetupFunc(e);
         return this.compileAndRun(o, [t], null, a)
        }
        return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n)
       }, e.prototype.shallowSlice = function(t, e, n) {
        var r = this.texData.get(t.dataId),
         i = this.makeOutput(n, t.dtype),
         o = this.texData.get(i.dataId);
        Object.assign(o, r), o.shape = n, o.dtype = t.dtype;
        var a = Wr(e, t.strides);
        r.slice && (a += r.slice.flatOffset), o.slice = {
         flatOffset: a,
         origDataId: r.slice && r.slice.origDataId || t.dataId
        };
        var s = this.dataRefCount.get(o.slice.origDataId) || 1;
        return this.dataRefCount.set(o.slice.origDataId, s + 1), i
       }, e.prototype.stridedSlice = function(t, e, n, r) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);
        var i = Br(e, n, r);
        if (i.some((function(t) {
          return 0 === t
         }))) return dn([], i);
        var o = new ja(e, r, i);
        return this.compileAndRun(o, [t])
       }, e.prototype.reverse = function(t, e) {
        var n = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Da(t.shape, e) : new _a(t.shape, e);
        return this.compileAndRun(n, [t])
       }, e.prototype.concat = function(t, e) {
        if ("complex64" === t[0].dtype) {
         var n = t.map((function(t) {
           return pn(t)
          })),
          r = t.map((function(t) {
           return fn(t)
          }));
         return hn(this.concat(n, e), this.concat(r, e))
        }
        if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
        if (1 === t.length) return t[0];
        if (t.length > h().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
         var i = Math.floor(t.length / 2),
          o = this.concat(t.slice(0, i), e),
          a = this.concat(t.slice(i), e);
         return this.concat([o, a], e)
        }
        if (h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
         var s = new mo(t.map((function(t) {
          return t.shape
         })), e);
         return this.compileAndRun(s, t)
        }
        var u = cn(t.map((function(t) {
          return t.shape
         })), e),
         c = t.map((function(t) {
          return t.as2D(-1, N(t.shape.slice(e)))
         })),
         l = new vo(c.map((function(t) {
          return t.shape
         })));
        return this.compileAndRun(l, c).reshape(u)
       }, e.prototype.neg = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, rs, t.dtype);
        var e = new Xa(t.shape, rs);
        return this.compileAndRun(e, [t])
       }, e.prototype.batchMatMul = function(t, e, n, r) {
        var i = n ? t.shape[2] : t.shape[1],
         o = r ? e.shape[1] : e.shape[2],
         a = n ? t.shape[1] : t.shape[2],
         s = t.shape[0];
        if ((1 === i || 1 === o) && a > 1e3) {
         n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));
         var u = 1 === o ? t : t.as3D(s, a, 1),
          c = 1 === o ? 2 : 1,
          l = 1 === o ? e.as3D(s, 1, a) : e;
         return this.multiply(u, l).sum(c, !0)
        }
        var h = Nt(t.dtype, e.dtype),
         p = new ga(t.shape, [s, i, o], n, r);
        return this.compileAndRun(p, [t, e], h)
       }, e.prototype.fusedBatchMatMul = function(t) {
        var e = t.a,
         n = t.b,
         r = t.transposeA,
         i = t.transposeB,
         o = t.bias,
         a = t.activation,
         s = t.preluActivationWeights,
         u = r ? e.shape[2] : e.shape[1],
         c = i ? n.shape[1] : n.shape[2],
         l = e.shape[0],
         h = Nt(e.dtype, n.dtype),
         p = null != o,
         f = null != s,
         d = a ? Es(a, !0) : null,
         v = new ga(e.shape, [l, u, c], r, i, p, d, f),
         m = [e, n];
        return o && m.push(o), s && m.push(s), this.compileAndRun(v, m, h)
       }, e.prototype.multiply = function(t, e) {
        if ("complex64" === t.dtype) {
         var n = this.texData.get(t.dataId),
          r = this.texData.get(e.dataId),
          i = new ro(eo, t.shape, e.shape),
          o = new ro(no, t.shape, e.shape),
          a = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],
          s = this.compileAndRun(i, a),
          u = this.compileAndRun(o, a),
          c = this.complex(s, u);
         return s.dispose(), u.dispose(), c
        }
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, ao, t.dtype);
        var l = new uo(ao, t.shape, e.shape);
        return this.compileAndRun(l, [t, e], t.dtype)
       }, e.prototype.batchNormalization = function(t, e, n, r, i, o) {
        var a = [t, e, n],
         s = null;
        null != o && (s = o.shape, a.push(o));
        var u = null;
        if (null != i && (u = i.shape, a.push(i)), h().getBool("WEBGL_PACK_NORMALIZATION")) {
         var c = new to(t.shape, e.shape, n.shape, s, u, r);
         return this.compileAndRun(c, a)
        }
        var l = new Qi(t.shape, e.shape, n.shape, s, u, r);
        return this.compileAndRun(l, a)
       }, e.prototype.localResponseNormalization4D = function(t, e, n, r, i) {
        var o = h().getBool("WEBGL_PACK_NORMALIZATION") ? new da(t.shape, e, n, r, i) : new pa(t.shape, e, n, r, i);
        return this.compileAndRun(o, [t])
       }, e.prototype.LRNGrad = function(t, e, n, r, i, o, a) {
        var s = new fa(e.shape, r, i, o, a);
        return this.compileAndRun(s, [e, n, t])
       }, e.prototype.tile = function(t, e) {
        if ("string" === t.dtype) {
         var n = this.readSync(t.dataId).map((function(t) {
          return st(t)
         }));
         return Ii(Xn(t.shape, t.dtype, n), e)
        }
        var r = new Ha(t.shape, e);
        return this.compileAndRun(r, [t])
       }, e.prototype.pad = function(t, e, n) {
        var r = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ca(t.shape, e, n) : new wa(t.shape, e, n);
        return this.compileAndRun(r, [t])
       }, e.prototype.transpose = function(t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);
        var n = h().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ga(t.shape, e) : new $a(t.shape, e);
        return this.compileAndRun(n, [t])
       }, e.prototype.gather = function(t, e, n) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);
        var r = new Uo(t.shape, e.size, n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.batchToSpaceND = function(t, e, n) {
        k(t.rank <= 4, (function() {
         return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"
        }));
        var r = e.reduce((function(t, e) {
          return t * e
         })),
         i = Er(t.shape, e, r),
         o = kr(i.length, e.length),
         a = Ir(t.shape, e, r),
         s = Or(n, e.length),
         u = Ar(a, n, e.length);
        return t.reshape(i).transpose(o).reshape(a).slice(s, u)
       }, e.prototype.spaceToBatchND = function(t, e, n) {
        k(t.rank <= 4, (function() {
         return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"
        }));
        var r = e.reduce((function(t, e) {
          return t * e
         })),
         i = [
          [0, 0]
         ];
        i.push.apply(i, n);
        for (var o = 1 + e.length; o < t.shape.length; ++o) i.push([0, 0]);
        var a = t.pad(i),
         s = Er(a.shape, e, r, !1),
         u = kr(s.length, e.length, !1),
         c = Ir(a.shape, e, r, !1);
        return a.reshape(s).transpose(u).reshape(c)
       }, e.prototype.reduce = function(t, e, n) {
        var r = t.shape[0],
         i = t.shape[1],
         o = Tr(i),
         a = new ka({
          windowSize: o,
          inSize: i,
          batchSize: r
         }, e),
         s = this.compileAndRun(a, [t], n);
        return 1 === s.shape[1] ? s : this.reduce(s, e, n)
       }, e.prototype.argReduce = function(t, e, n) {
        void 0 === n && (n = null);
        var r = t.shape[0],
         i = t.shape[1];
        null != n && (r = n.shape[0], i = n.shape[1]);
        var o = Tr(i),
         a = new Ti({
          windowSize: o,
          inSize: i,
          batchSize: r
         }, e, null == n),
         s = [t];
        null != n && s.push(n);
        var u = this.compileAndRun(a, s, "int32");
        return 1 === u.shape[1] ? u : this.argReduce(t, e, u)
       }, e.prototype.argReducePacked = function(t, e, n) {
        void 0 === n && (n = null);
        var r = null != n ? n.shape : t.shape,
         i = Tr(r[r.length - 1]),
         o = new Yi(r, i, e, null == n),
         a = null == n ? [t] : [t, n],
         s = this.compileAndRun(o, a, "int32");
        return s.rank === t.rank ? this.argReducePacked(t, e, s) : s
       }, e.prototype.sum = function(t, e) {
        rn("sum", e, t.rank);
        var n = en(t.shape, e),
         r = n[0],
         i = N(n[1]),
         o = t.as2D(-1, i),
         a = Rt(t.dtype);
        return this.reduce(o, "sum", a).reshape(r)
       }, e.prototype.prod = function(t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
        var n = en(t.shape, e),
         r = n[0],
         i = N(n[1]),
         o = t.as2D(-1, i),
         a = Rt(t.dtype);
        return this.reduce(o, "prod", a).reshape(r)
       }, e.prototype.unsortedSegmentSum = function(t, e, n) {
        var r = 0,
         i = on([r], t.rank),
         o = t;
        null != i && (o = t.transpose(i), r = sn(1, t.rank)[0]);
        var a = function(t, e, n) {
          for (var r = [], i = t.length, o = 0; o < i; o++) o !== e ? r.push(t[o]) : r.push(n);
          return r
         }(o.shape, r, n),
         s = N([o.shape[r]]),
         u = o.as2D(-1, s),
         c = Rt(t.dtype),
         l = this.segOpCompute(u, "unsortedSegmentSum", e, c, n).reshape(a);
        return null != i && (l = l.transpose(an(i))), l
       }, e.prototype.segOpCompute = function(t, e, n, r, i) {
        var o = t.shape[0],
         a = t.shape[1],
         s = function(t, e) {
          var n, r = !1;
          for (t <= Rr ? (n = t, r = !0) : n = J(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = J(t, n + 1);
          return n
         }(a, i),
         u = new Ma({
          windowSize: s,
          inSize: a,
          batchSize: o,
          numSegments: i
         }, e),
         c = this.compileAndRun(u, [t, n], r);
        return c.shape[1] === i ? c : (n = An(0, i).tile([a / s]), this.segOpCompute(c, e, n, r, i))
       }, e.prototype.argMinMaxReduce = function(t, e, n) {
        var r = [e];
        if (rn("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !h().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
         var i = en(t.shape, r),
          o = i[0],
          a = N(i[1]),
          s = t.as2D(-1, a);
         return this.argReduce(s, n).reshape(o)
        }
        return this.argReducePacked(t, n)
       }, e.prototype.argMin = function(t, e) {
        return this.argMinMaxReduce(t, e, "min")
       }, e.prototype.argMax = function(t, e) {
        return this.argMinMaxReduce(t, e, "max")
       }, e.prototype.cumsum = function(t, e, n, r) {
        if (e !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
        var i = new No(t.shape, n, r);
        return this.compileAndRun(i, [t])
       }, e.prototype.equal = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(equal(a, b));\n", "bool");
        var n = new uo("return float(a == b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.notEqual = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(notEqual(a, b));\n", "bool");
        var n = new uo("return float(a != b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.less = function(t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThan(a, b));\n", "bool");
        var n = new uo("return float(a < b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.lessEqual = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
        var n = new uo("return float(a <= b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.greater = function(t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThan(a, b));\n", "bool");
        var n = new uo("return float(a > b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.greaterEqual = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
        var n = new uo("return float(a >= b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.logicalNot = function(t) {
        var e = new Xa(t.shape, "return float(!(x >= 1.0));");
        return this.compileAndRun(e, [t])
       }, e.prototype.logicalAnd = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
        var n = new uo("return float(a >= 1.0 && b >= 1.0);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.logicalOr = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
        var n = new uo("return float(a >= 1.0 || b >= 1.0);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
       }, e.prototype.select = function(t, e, n) {
        var r = new La(t.rank, e.shape, e.rank);
        return this.compileAndRun(r, [t, e, n], Nt(e.dtype, n.dtype))
       }, e.prototype.where = function(t) {
        Ke("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        var e = t.dataSync();
        return Ai(t.shape, e)
       }, e.prototype.topk = function(t, e, n) {
        return Oi(t.dataSync(), t.shape, t.dtype, e)
       }, e.prototype.min = function(t, e) {
        rn("min", e, t.rank);
        var n = en(t.shape, e),
         r = n[0],
         i = N(n[1]),
         o = t.as2D(-1, i);
        return this.reduce(o, "min", o.dtype).reshape(r)
       }, e.prototype.minimum = function(t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new uo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.mod = function(t, e) {
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new uo("if (b == 0.0) return NAN;\n  return mod(a, b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.max = function(t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
        rn("max", e, t.rank);
        var n = en(t.shape, e),
         r = n[0],
         i = N(n[1]),
         o = t.as2D(-1, i);
        return this.reduce(o, "max", o.dtype).reshape(r)
       }, e.prototype.maximum = function(t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new uo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.all = function(t, e) {
        rn("all", e, t.rank);
        var n = en(t.shape, e),
         r = n[0],
         i = N(n[1]),
         o = t.as2D(-1, i);
        return this.reduce(o, "all", o.dtype).reshape(r)
       }, e.prototype.any = function(t, e) {
        rn("any", e, t.rank);
        var n = en(t.shape, e),
         r = n[0],
         i = N(n[1]),
         o = t.as2D(-1, i);
        return this.reduce(o, "any", o.dtype).reshape(r)
       }, e.prototype.squaredDifference = function(t, e) {
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("return (a - b) * (a - b);", t.shape, e.shape) : new uo("return (a - b) * (a - b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.realDivide = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", !0);
        var n = new uo("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "float32")
       }, e.prototype.floorDiv = function(t, e) {
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
        var n = new uo("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "int32")
       }, e.prototype.add = function(t, e) {
        if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, io);
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);
        var n = Nt(t.dtype, e.dtype);
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, io, n);
        var r = new uo(io, t.shape, e.shape);
        return this.compileAndRun(r, [t, e], n)
       }, e.prototype.packedUnaryOp = function(t, e, n) {
        var r = new ws(t.shape, e);
        return this.compileAndRun(r, [t], n)
       }, e.prototype.packedBinaryOp = function(t, e, n, r, i) {
        void 0 === i && (i = !1);
        var o = new lo(n, t.shape, e.shape, i);
        return this.compileAndRun(o, [t, e], r)
       }, e.prototype.complexSeparableBinaryOp = function(t, e, n) {
        var r = this,
         i = this.texData.get(t.dataId),
         o = this.texData.get(e.dataId),
         a = [
          [i.complexTensors.real, o.complexTensors.real],
          [i.complexTensors.imag, o.complexTensors.imag]
         ].map((function(i) {
          var o = i[0],
           a = i[1],
           s = r.makeComplexComponentTensorInfo(t, o),
           u = r.makeComplexComponentTensorInfo(e, a),
           c = new uo(n, t.shape, e.shape);
          return r.compileAndRun(c, [s, u], Nt(o.dtype, a.dtype))
         })),
         s = a[0],
         u = a[1],
         c = this.complex(s, u);
        return s.dispose(), u.dispose(), c
       }, e.prototype.makeComplexComponentTensorInfo = function(t, e) {
        return {
         dataId: e.dataId,
         dtype: e.dtype,
         shape: t.shape
        }
       }, e.prototype.addN = function(t) {
        if (1 === t.length) return t[0];
        if (t.length > h().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
         var e = Math.floor(t.length / 2),
          n = this.addN(t.slice(0, e)),
          r = this.addN(t.slice(e));
         return this.addN([n, r])
        }
        var i = t.map((function(t) {
          return t.dtype
         })).reduce((function(t, e) {
          return Nt(t, e)
         })),
         o = t.map((function(t) {
          return t.shape
         })),
         a = h().getBool("WEBGL_PACK") ? new Ri(t[0].shape, o) : new Ni(t[0].shape, o);
        return this.compileAndRun(a, t, i)
       }, e.prototype.subtract = function(t, e) {
        if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, oo);
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);
        var n = Nt(t.dtype, e.dtype);
        if (h().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, oo, t.dtype);
        var r = new uo(oo, t.shape, e.shape);
        return this.compileAndRun(r, [t, e], n)
       }, e.prototype.pow = function(t, e) {
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new uo("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t.shape, e.shape),
         r = Nt(t.dtype, e.dtype);
        return this.compileAndRun(n, [t, e], r)
       }, e.prototype.ceil = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, is, t.dtype);
        var e = new Xa(t.shape, is);
        return this.compileAndRun(e, [t])
       }, e.prototype.floor = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, os, t.dtype);
        var e = new Xa(t.shape, os);
        return this.compileAndRun(e, [t])
       }, e.prototype.sign = function(t) {
        var e = new Xa(t.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
        return this.compileAndRun(e, [t])
       }, e.prototype.isNaN = function(t) {
        var e = new Xa(t.shape, "return float(isnan(x));");
        return this.compileAndRun(e, [t], "bool")
       }, e.prototype.isInf = function(t) {
        var e = new Xa(t.shape, "return float(isinf(x));");
        return this.compileAndRun(e, [t], "bool")
       }, e.prototype.isFinite = function(t) {
        var e = new Xa(t.shape, "return float(!isnan(x) && !isinf(x));");
        return this.compileAndRun(e, [t], "bool")
       }, e.prototype.round = function(t) {
        var e = new Xa(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
        return this.compileAndRun(e, [t])
       }, e.prototype.exp = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, as, t.dtype);
        var e = new Xa(t.shape, as);
        return this.compileAndRun(e, [t])
       }, e.prototype.expm1 = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, ss, t.dtype);
        var e = new Xa(t.shape, ss);
        return this.compileAndRun(e, [t])
       }, e.prototype.log = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t.dtype);
        var e = new Xa(t.shape, "if (x < 0.0) return NAN;\n  return log(x);");
        return this.compileAndRun(e, [t])
       }, e.prototype.log1p = function(t) {
        var e = new Xa(t.shape, "return log(1.0 + x);");
        return this.compileAndRun(e, [t])
       }, e.prototype.sqrt = function(t) {
        var e = new Xa(t.shape, "return sqrt(x);");
        return this.compileAndRun(e, [t])
       }, e.prototype.rsqrt = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
        var e = new Xa(t.shape, "return inversesqrt(x);");
        return this.compileAndRun(e, [t])
       }, e.prototype.reciprocal = function(t) {
        var e = new Xa(t.shape, "return 1.0 / x;");
        return this.compileAndRun(e, [t])
       }, e.prototype.relu = function(t) {
        var e;
        return e = h().getBool("WEBGL_PACK") ? new ws(t.shape, ys) : new Xa(t.shape, Qa), this.compileAndRun(e, [t])
       }, e.prototype.relu6 = function(t) {
        var e;
        return e = h().getBool("WEBGL_PACK") ? new ws(t.shape, bs) : new Xa(t.shape, ts), this.compileAndRun(e, [t])
       }, e.prototype.prelu = function(t, e) {
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo(co, t.shape, e.shape) : new uo(so, t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.elu = function(t) {
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, xs, t.dtype);
        var e = new Xa(t.shape, es);
        return this.compileAndRun(e, [t])
       }, e.prototype.eluDer = function(t, e) {
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t.shape, e.shape) : new uo("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.selu = function(t) {
        var e = new Xa(t.shape, ns);
        return this.compileAndRun(e, [t])
       }, e.prototype.int = function(t) {
        var e = new Xa(t.shape, "return float(int(x));");
        return this.compileAndRun(e, [t], "int32")
       }, e.prototype.clip = function(t, e, n) {
        var r, i = (r = h().getBool("WEBGL_PACK_CLIP") ? new po(t.shape) : new ho(t.shape)).getCustomSetupFunc(e, n);
        return this.compileAndRun(r, [t], null, i)
       }, e.prototype.abs = function(t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
        if (h().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ja, t.dtype);
        var e = new Xa(t.shape, Ja);
        return this.compileAndRun(e, [t])
       }, e.prototype.complexAbs = function(t) {
        var e = this.texData.get(t.dataId),
         n = new fo(t.shape),
         r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];
        return this.compileAndRun(n, r)
       }, e.prototype.sigmoid = function(t) {
        var e = new Xa(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
        return this.compileAndRun(e, [t])
       }, e.prototype.softplus = function(t) {
        var e = new Xa(t.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
        return this.compileAndRun(e, [t])
       }, e.prototype.sin = function(t) {
        var e = new Xa(t.shape, us);
        return this.compileAndRun(e, [t])
       }, e.prototype.cos = function(t) {
        var e = new Xa(t.shape, cs);
        return this.compileAndRun(e, [t])
       }, e.prototype.tan = function(t) {
        var e = new Xa(t.shape, "return tan(x);");
        return this.compileAndRun(e, [t])
       }, e.prototype.asin = function(t) {
        var e = new Xa(t.shape, ls);
        return this.compileAndRun(e, [t])
       }, e.prototype.acos = function(t) {
        var e = new Xa(t.shape, hs);
        return this.compileAndRun(e, [t])
       }, e.prototype.atan = function(t) {
        var e = new Xa(t.shape, ps);
        return this.compileAndRun(e, [t])
       }, e.prototype.atan2 = function(t, e) {
        var n = h().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new lo("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new uo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
       }, e.prototype.sinh = function(t) {
        var e = new Xa(t.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e, [t])
       }, e.prototype.cosh = function(t) {
        var e = new Xa(t.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e, [t])
       }, e.prototype.tanh = function(t) {
        var e = new Xa(t.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
        return this.compileAndRun(e, [t])
       }, e.prototype.asinh = function(t) {
        var e = new Xa(t.shape, fs);
        return this.compileAndRun(e, [t])
       }, e.prototype.acosh = function(t) {
        var e = new Xa(t.shape, ds);
        return this.compileAndRun(e, [t])
       }, e.prototype.atanh = function(t) {
        var e = new Xa(t.shape, vs);
        return this.compileAndRun(e, [t])
       }, e.prototype.erf = function(t) {
        var e = new Xa(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
        return this.compileAndRun(e, [t])
       }, e.prototype.step = function(t, e) {
        var n = new Xa(t.shape, function(t) {
         return void 0 === t && (t = 0), Ya + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  "
        }(e));
        return this.compileAndRun(n, [t])
       }, e.prototype.conv2dByMatMul = function(t, e, n, r, i, o) {
        var a = t.shape,
         s = this.texData.get(t.dataId),
         u = n.inChannels,
         c = a[0] * a[1] * a[2],
         l = n.outChannels,
         p = "channelsLast" === n.dataFormat,
         f = (1 === c || 1 === l) && u > 1e3,
         d = a[2] % 2 != 0 && !!s.isPacked;
        if (f || !h().getBool("WEBGL_LAZILY_UNPACK") || !h().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d) {
         var v = p ? a[0] * a[1] * a[2] : a[0] * a[2] * a[3],
          m = this.reshape(t, [1, v, n.inChannels]),
          g = this.reshape(e, [1, n.inChannels, n.outChannels]);
         return this.reshape(this.fusedBatchMatMul({
          a: m,
          b: g,
          transposeA: !1,
          transposeB: !1,
          bias: r,
          activation: i,
          preluActivationWeights: o
         }), n.outShape)
        }
        var y = p ? a[0] * a[1] * (a[2] + 1) : a[0] * a[2] * (a[3] + 1),
         b = {
          dataId: t.dataId,
          shape: [1, y, n.inChannels],
          dtype: t.dtype
         },
         x = s.shape;
        s.shape = s.shape.slice(), s.shape[s.shape.length - 2]++, k(_e(s.shape, b.shape), (function() {
         return "packed reshape " + s.shape + " to " + b.shape + " isn't free"
        }));
        var w = this.reshape(e, [1, n.inChannels, n.outChannels]),
         C = this.fusedBatchMatMul({
          a: b,
          b: w,
          transposeA: !1,
          transposeB: !1,
          bias: r,
          activation: i,
          preluActivationWeights: o
         }),
         S = this.texData.get(C.dataId);
        return k(S.isPacked, (function() {
         return "batchMatMul result is expected to be packed"
        })), s.shape = x, S.shape = n.outShape, Bt.makeTensorFromDataId(C.dataId, n.outShape, C.dtype)
       }, e.prototype.conv2dWithIm2Row = function(t, e, n, r, i, o) {
        var a = n.filterWidth,
         s = n.filterHeight,
         u = n.inChannels,
         c = n.outWidth,
         l = n.outHeight,
         h = "channelsLast" === n.dataFormat,
         p = a * s * u,
         f = l * c,
         d = [p, f],
         v = t.squeeze([0]),
         m = e.reshape([1, p, -1]),
         g = new ha(d, v.shape, n),
         y = this.compileAndRun(g, [v]).reshape([1, d[0], d[1]]),
         b = null != r,
         x = null != o,
         w = i ? Es(i, !0) : null,
         C = new ga(y.shape, [1, f, n.outChannels], !0, !1, b, w, x),
         S = [y, m];
        r && S.push(r), x && S.push(o);
        var E = this.compileAndRun(C, S);
        return h ? E.reshape([1, l, c, n.outChannels]) : E.reshape([1, n.outChannels, l, c])
       }, e.prototype.fusedConv2d = function(t) {
        var e = t.input,
         n = t.filter,
         r = t.convInfo,
         i = t.bias,
         o = t.activation,
         a = t.preluActivationWeights;
        if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, i, o, a);
        if (h().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, i, o, a);
        var s = null != i,
         u = null != a,
         c = o ? Es(o, !1) : null,
         l = new Eo(r, s, c, u),
         p = [e, n];
        return i && p.push(i), a && p.push(a), this.compileAndRun(l, p)
       }, e.prototype.conv2d = function(t, e, n) {
        if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);
        if (h().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);
        var r = new Eo(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.conv2dDerInput = function(t, e, n) {
        var r = new bo(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.conv2dDerFilter = function(t, e, n) {
        var r = new yo(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.fusedDepthwiseConv2D = function(t) {
        var e, n = t.input,
         r = t.filter,
         i = t.convInfo,
         o = t.bias,
         a = t.activation,
         s = t.preluActivationWeights,
         u = h().getBool("WEBGL_PACK_DEPTHWISECONV") && i.strideWidth <= 2 && i.outChannels / i.inChannels == 1,
         c = a ? Es(a, u) : null,
         l = [n, r],
         p = null != o,
         f = null != s;
        return p && l.push(o), f && l.push(s), u ? (e = new Oo(i, p, c, f), this.compileAndRun(e, l)) : (e = new Io(i, p, c, f), this.compileAndRun(e, l))
       }, e.prototype.depthwiseConv2D = function(t, e, n) {
        var r;
        return h().getBool("WEBGL_PACK_DEPTHWISECONV") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new Oo(n), this.compileAndRun(r, [t, e])) : (r = new Io(n), this.compileAndRun(r, [t, e]))
       }, e.prototype.depthwiseConv2DDerInput = function(t, e, n) {
        var r = new So(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
        var r = new Co(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.conv3d = function(t, e, n) {
        var r = new ko(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.conv3dDerInput = function(t, e, n) {
        var r = new wo(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.conv3dDerFilter = function(t, e, n) {
        var r = new xo(n);
        return this.compileAndRun(r, [t, e])
       }, e.prototype.maxPool = function(t, e) {
        var n = new Sa(e, "max", !1);
        return this.compileAndRun(n, [t])
       }, e.prototype.avgPool = function(t, e) {
        var n = new Sa(e, "avg", !1);
        return this.compileAndRun(n, [t], "float32")
       }, e.prototype.maxPoolBackprop = function(t, e, n, r) {
        var i = new Sa(r, "max", !0),
         o = this.compileAndRun(i, [e]),
         a = new va(r),
         s = this.compileAndRun(a, [t, o], e.dtype);
        return o.dispose(), s
       }, e.prototype.avgPoolBackprop = function(t, e, n) {
        var r = new Zi(n);
        return this.compileAndRun(r, [t], e.dtype)
       }, e.prototype.cast = function(t, e) {
        return li(t, e, this)
       }, e.prototype.unstack = function(t, e) {
        for (var n = t.shape[e], r = new Array(t.rank - 1), i = 0, o = 0; o < t.rank; o++) o !== e && (r[i++] = t.shape[o]);
        var a = new Array(t.rank).fill(0),
         s = t.shape.slice();
        s[e] = 1;
        var u = new Array(n);
        for (o = 0; o < u.length; o++) a[e] = o, u[o] = this.slice(t, a, s).reshape(r);
        return u
       }, e.prototype.avgPool3d = function(t, e) {
        var n = new Ea(e, "avg", !1);
        return this.compileAndRun(n, [t], "float32")
       }, e.prototype.avgPool3dBackprop = function(t, e, n) {
        var r = new Ji(n);
        return this.compileAndRun(r, [t], e.dtype)
       }, e.prototype.maxPool3d = function(t, e) {
        var n = new Ea(e, "max", !1);
        return this.compileAndRun(n, [t], "float32")
       }, e.prototype.maxPool3dBackprop = function(t, e, n, r) {
        var i = new Ea(r, "max", !0),
         o = this.compileAndRun(i, [e]),
         a = new ma(r),
         s = this.compileAndRun(a, [t, o], e.dtype);
        return o.dispose(), s
       }, e.prototype.reshape = function(t, e) {
        var n = this.texData.get(t.dataId);
        if (n.isPacked && !_e(t.shape, e) && (null === n.texture || !_e(n.shape, e))) {
         var r = this.packedReshape(t, e);
         return Bt.makeTensorFromDataId(r.dataId, r.shape, r.dtype)
        }
        return hi(t, e)
       }, e.prototype.resizeBilinear = function(t, e, n, r) {
        var i = h().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new Na(t.shape, e, n, r) : new Aa(t.shape, e, n, r);
        return this.compileAndRun(i, [t], "float32")
       }, e.prototype.resizeBilinearBackprop = function(t, e, n) {
        var r = new Oa(t, e, n);
        return this.compileAndRun(r, [t])
       }, e.prototype.resizeNearestNeighbor = function(t, e, n, r) {
        var i = new Ta(t.shape, e, n, r);
        return this.compileAndRun(i, [t])
       }, e.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
        var r = new Ra(t, e, n);
        return this.compileAndRun(r, [t])
       }, e.prototype.multinomial = function(t, e, n, r) {
        var i = e ? t : Hr(t),
         o = i.shape[0],
         a = i.shape[1],
         s = new ya(o, a, n),
         u = s.getCustomSetupFunc(r);
        return this.compileAndRun(s, [i], "int32", u)
       }, e.prototype.oneHot = function(t, e, n, r) {
        var i = new ba(t.size, e, n, r);
        return this.compileAndRun(i, [t])
       }, e.prototype.diag = function(t) {
        var e = new Fo(t.size);
        return this.compileAndRun(e, [t])
       }, e.prototype.nonMaxSuppression = function(t, e, n, r, i) {
        return Ke("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), bi(t.dataSync(), e.dataSync(), n, r, i)
       }, e.prototype.cropAndResize = function(t, e, n, r, i, o) {
        var a = new Ao(t.shape, e.shape, r, i, o);
        return this.compileAndRun(a, [t, e, n], "float32")
       }, e.prototype.depthToSpace = function(t, e, n) {
        k(e > 1, (function() {
         return "blockSize should be > 1 for depthToSpace, but was: " + e
        }));
        var r = t.shape[0],
         i = "NHWC" === n ? t.shape[1] : t.shape[2],
         o = "NHWC" === n ? t.shape[2] : t.shape[3],
         a = "NHWC" === n ? t.shape[3] : t.shape[1],
         s = i * e,
         u = o * e,
         c = a / (e * e),
         l = new Do("NHWC" === n ? [r, s, u, c] : [r, c, s, u], e, n);
        return this.compileAndRun(l, [t])
       }, e.prototype.split = function(t, e, n) {
        return ki(t, e, n)
       }, e.prototype.scatterND = function(t, e, n) {
        var r = Fr(0, t, n),
         i = r.sliceRank,
         o = r.numUpdates,
         a = r.sliceSize,
         s = r.strides,
         u = r.outputSize,
         c = [u / a, a],
         l = t.reshape([o, i]),
         h = e.reshape([o, a]);
        if (0 === u) return hi(dn([]), n);
        var p = mn(0),
         f = new Fa(o, i, l.rank, h.rank, s, c);
        return this.compileAndRun(f, [h, l, p]).reshape(n)
       }, e.prototype.sparseToDense = function(t, e, n, r) {
        var i = Fr(0, t, n),
         o = i.sliceRank,
         a = i.numUpdates,
         s = i.strides,
         u = i.outputSize,
         c = new Fa(a, o, t.rank, e.rank, s, [u, 1], !1);
        return this.compileAndRun(c, [e, t, r]).reshape(n)
       }, e.prototype.fft = function(t) {
        return this.fftImpl(t, !1)
       }, e.prototype.ifft = function(t) {
        return this.fftImpl(t, !0)
       }, e.prototype.fftImpl = function(t, e) {
        var n = this.texData.get(t.dataId),
         r = new Wo(zo, t.shape, e),
         i = new Wo(jo, t.shape, e),
         o = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],
         a = this.compileAndRun(r, o),
         s = this.compileAndRun(i, o),
         u = this.complex(a, s).as2D(t.shape[0], t.shape[1]);
        return a.dispose(), s.dispose(), u
       }, e.prototype.gatherND = function(t, e) {
        var n = e.shape,
         r = n[n.length - 1],
         i = Nr(t, e),
         o = i[0],
         a = i[1],
         s = i[2],
         u = i[3],
         c = e.reshape([a, r]),
         l = t.reshape([t.size / s, s]),
         h = new Ho(r, u, [a, s]);
        return this.compileAndRun(h, [l, c]).reshape(o)
       }, e.prototype.fill = function(t, e, n) {
        if ("string" === (n = n || Y(e))) {
         var r = j(n, N(t));
         return r.fill(e), Bt.makeTensor(r, t, n, this)
        }
        var i = new Vo(t, e),
         o = i.getCustomSetupFunc(e);
        return this.compileAndRun(i, [], n, o)
       }, e.prototype.onesLike = function(t) {
        if ("string" === t.dtype) throw new Error("onesLike is not supported under string dtype");
        return this.fill(t.shape, 1, t.dtype)
       }, e.prototype.zerosLike = function(t) {
        return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype)
       }, e.prototype.linspace = function(t, e, n) {
        return pi(t, e, n)
       }, e.prototype.makeTensorInfo = function(t, e) {
        var n = this.write(null, t, e);
        return this.texData.get(n).usage = null, {
         dataId: n,
         shape: t,
         dtype: e
        }
       }, e.prototype.makeOutput = function(t, e) {
        var n = this.makeTensorInfo(t, e).dataId;
        return Bt.makeTensorFromDataId(n, t, e, this)
       }, e.prototype.unpackTensor = function(t) {
        var e = new Cs(t.shape);
        return this.runWebGLProgram(e, [t], t.dtype)
       }, e.prototype.packTensor = function(t) {
        var e = new xa(t.shape);
        return this.runWebGLProgram(e, [t], t.dtype, null, !0)
       }, e.prototype.packedReshape = function(t, e) {
        var n = [Oe(t.shape)].concat(Ae(t.shape)),
         r = {
          dtype: t.dtype,
          shape: n,
          dataId: t.dataId
         },
         i = [Oe(e)].concat(Ae(e)),
         o = new Ia(i, n),
         a = this.runWebGLProgram(o, [r], t.dtype, null, !0);
        return {
         dataId: a.dataId,
         shape: e,
         dtype: a.dtype
        }
       }, e.prototype.decode = function(t) {
        var e, n = this.texData.get(t),
         r = n.isPacked,
         i = n.shape,
         o = n.dtype,
         a = Ne(i);
        return e = r ? new _o(a) : new To(a), {
         dtype: o,
         shape: i,
         dataId: this.runWebGLProgram(e, [{
          shape: a,
          dtype: o,
          dataId: t
         }], o, null, !0).dataId
        }
       }, e.prototype.runWebGLProgram = function(t, e, n, r, i) {
        var o = this;
        void 0 === i && (i = !1);
        var a = this.makeTensorInfo(t.outputShape, n),
         s = this.texData.get(a.dataId);
        if (t.packedOutput && (s.isPacked = !0), t.outPackingScheme === jt.DENSE) {
         var u = Kt(t.outputShape);
         s.texShape = u.map((function(t) {
          return 2 * t
         }))
        }
        if (null != t.outTexUsage && (s.usage = t.outTexUsage), 0 === N(a.shape)) return s.values = z(a.dtype, 0), a;
        var c = [],
         l = e.map((function(e) {
          if ("complex64" === e.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
          var n = o.texData.get(e.dataId);
          if (null == n.texture) {
           if (!t.packedInputs && N(e.shape) <= h().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
            shape: e.shape,
            texData: null,
            isUniform: !0,
            uniformValues: n.values
           };
           t.packedInputs && (n.isPacked = !0, n.shape = e.shape)
          } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? o.unpackTensor(e) : o.packTensor(e), c.push(e), n = o.texData.get(e.dataId);
          else if (n.isPacked && !_e(n.shape, e.shape)) {
           var r = e,
            i = e.shape;
           e.shape = n.shape, e = o.packedReshape(e, i), c.push(e), n = o.texData.get(e.dataId), r.shape = i
          }
          return o.uploadToGPU(e.dataId), {
           shape: e.shape,
           texData: n,
           isUniform: !1
          }
         }));
        this.uploadToGPU(a.dataId);
        var p, f = {
          shape: a.shape,
          texData: s,
          isUniform: !1
         },
         d = function(t, e, n) {
          var r = "";
          e.concat(n).forEach((function(t) {
           var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,
            n = t.isUniform ? "uniform" : t.texData.texShape;
           r += t.shape + "_" + n + "_" + e
          }));
          var i = t.userCode,
           o = t.constructor.name;
          return o + "_" + r + "_" + i
         }(t, l, f),
         v = this.getAndSaveBinary(d, (function() {
          return function(t, e, n, r) {
           var i = e.userCode,
            o = n.map((function(t, n) {
             var r = {
              logicalShape: t.shape,
              texShape: t.isUniform ? null : t.texData.texShape,
              isUniform: t.isUniform,
              isPacked: !t.isUniform && t.texData.isPacked,
              flatOffset: null
             };
             return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {
              name: e.variableNames[n],
              shapeInfo: r
             }
            })),
            a = o.map((function(t) {
             return t.shapeInfo
            })),
            s = {
             logicalShape: r.shape,
             texShape: r.texData.texShape,
             isUniform: !1,
             isPacked: r.texData.isPacked,
             flatOffset: null
            },
            u = Pi(o, s, i, e.packedInputs),
            c = t.createProgram(u),
            l = null,
            p = t.getUniformLocation(c, "NAN", !1);
           1 === h().getNumber("WEBGL_VERSION") && (l = t.getUniformLocation(c, "INFINITY", !1));
           for (var f = {}, d = 0; d < e.variableNames.length; d++) {
            var v = e.variableNames[d];
            f[v] = t.getUniformLocation(c, v, !1), f["offset" + v] = t.getUniformLocation(c, "offset" + v, !1)
           }
           return {
            program: e,
            source: u,
            webGLProgram: c,
            uniformLocations: f,
            inShapeInfos: a,
            outShapeInfo: s,
            infLoc: l,
            nanLoc: p
           }
          }(o.gpgpu, t, l, f)
         })),
         m = null != this.activeTimers;
        if (m && (p = this.startTimer()), function(t, e, n, r, i) {
          la(e.inShapeInfos, n), la([e.outShapeInfo], [r]);
          var o = r.texData.texture,
           a = r.texData.texShape;
          r.texData.isPacked ? t.setOutputPackedMatrixTexture(o, a[0], a[1]) : t.setOutputMatrixTexture(o, a[0], a[1]), t.setProgram(e.webGLProgram), 1 === h().getNumber("WEBGL_VERSION") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach((function(n, r) {
           var i = e.program.variableNames[r],
            o = e.uniformLocations[i],
            a = e.uniformLocations["offset" + i];
           if (null != o)
            if (n.isUniform)
             if (N(n.shape) < 2) t.gl.uniform1f(o, n.uniformValues[0]);
             else {
              var s = n.uniformValues;
              s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(o, s)
             }
           else null != n.texData.slice && null != a && t.gl.uniform1i(a, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, o, r)
          })), null != i && i(t, e.webGLProgram), t.executeProgram()
         }(this.gpgpu, v, l, f, r), c.forEach((function(t) {
          return o.disposeData(t.dataId)
         })), m && (p = this.endTimer(p), this.activeTimers.push({
          name: t.constructor.name,
          query: this.getQueryTime(p)
         })), !h().getBool("WEBGL_LAZILY_UNPACK") && s.isPacked && !1 === i) {
         var g = this.unpackTensor(a);
         return this.disposeData(a.dataId), g
        }
        return a
       }, e.prototype.compileAndRun = function(t, e, n, r, i) {
        void 0 === i && (i = !1), n = n || e[0].dtype;
        var o = this.runWebGLProgram(t, e, n, r, i);
        return Bt.makeTensorFromDataId(o.dataId, o.shape, o.dtype)
       }, e.prototype.getAndSaveBinary = function(t, e) {
        return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t]
       }, e.prototype.getTextureManager = function() {
        return this.textureManager
       }, e.prototype.dispose = function() {
        var t = this;
        this.disposed || (h().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((function(e) {
         t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e]
        })), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0)
       }, e.prototype.floatPrecision = function() {
        var t = this;
        return null == this.floatPrecisionValue && (this.floatPrecisionValue = $e((function() {
         if (!h().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
          var e = h().getBool("DEBUG");
          h().set("DEBUG", !1);
          var n = t.abs(mn(1e-8)).dataSync()[0];
          if (h().set("DEBUG", e), n > 0) return 32
         }
         return 16
        }))), this.floatPrecisionValue
       }, e.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4
       }, e.prototype.uploadToGPU = function(t) {
        var e, n = this.texData.get(t),
         r = n.shape,
         i = n.dtype,
         o = n.values,
         a = n.texture,
         s = n.usage,
         u = n.isPacked;
        if (null == a) {
         var c, l = null != this.activeTimers;
         l && (c = it());
         var h = n.texShape;
         if (null == h && (h = Re(r, u), n.texShape = h), null != o) {
          var p = Ne(r),
           f = void 0,
           d = h[1],
           v = h[0],
           m = o instanceof Uint8Array;
          u ? (d = (e = Xt(h[0], h[1]))[0], v = e[1], f = new Po(p, [v, d], m)) : f = new Bo(p, [v, d], m);
          var g = this.makeTensorInfo([v, d], i);
          this.texData.get(g.dataId).usage = m ? Wt.PIXELS : Wt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g.dataId), d, v, o);
          var y = this.runWebGLProgram(f, [g], i, null, !0),
           b = this.texData.get(y.dataId);
          n.texture = b.texture, n.texShape = b.texShape, n.isPacked = b.isPacked, n.usage = b.usage, this.disposeData(g.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += it() - c)
         } else {
          var x = this.acquireTexture(h, s, i, u);
          n.texture = x
         }
        }
       }, e.prototype.convertAndCacheOnCPU = function(t, e) {
        var n = this.texData.get(t),
         r = n.dtype;
        return this.releaseGPUData(t), null != e && (n.values = function(t, e) {
         if ("float32" === e || "complex64" === e) return t;
         if ("int32" === e || "bool" === e) {
          for (var n = "int32" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);
          return n
         }
         throw new Error("Unknown dtype " + e)
        }(e, r)), n.values
       }, e.prototype.acquireTexture = function(t, e, n, r) {
        if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
         var i = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
         this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + i + " MB, most likely due to a memory leak")
        }
        return this.textureManager.acquireTexture(t, e, r)
       }, e.prototype.computeBytes = function(t, e) {
        return t[0] * t[1] * $(e)
       }, e
      }(qr);
     Pt() && Bt.registerBackend("webgl", (function() {
      return new Is
     }), 2), b({
      kernelName: "Square",
      gradFunc: function(t, e) {
       var n = e[0];
       return {
        x: function() {
         return t.mul(n.toFloat().mul(2))
        }
       }
      }
     });
     var Os = ln({
       square_: function(t) {
        var e = Ze(t, "x", "square"),
         n = [e];
        return Bt.runKernelFunc((function(t, n) {
         return n([e]), t.square(e)
        }), {
         x: e
        }, null, "Square", {}, n, [])
       }
      }),
      As = ln({
       abs_: function(t) {
        var e = Ze(t, "x", "abs");
        return "complex64" === e.dtype ? Bt.runKernelFunc((function(t) {
         return t.complexAbs(e)
        }), {
         $x: e
        }) : Bt.runKernelFunc((function(t, n) {
         var r = t.abs(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return t.mul(n.toFloat().step(-1))
          }
         }
        }), "Abs")
       }
      }),
      Ns = ln({
       acos_: function(t) {
        var e = Ze(t, "x", "acos");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.acos(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.divStrict(mn(1).sub(n.toFloat().square()).sqrt()).neg()
          }
         }
        }))
       }
      }),
      Rs = ln({
       acosh_: function(t) {
        var e = Ze(t, "x", "acosh");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.acosh(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.divStrict(n.toFloat().square().sub(1).sqrt())
          }
         }
        }))
       }
      }),
      Ts = ln({
       asin_: function(t) {
        var e = Ze(t, "x", "asin");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.asin(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.divStrict(mn(1).sub(n.toFloat().square()).sqrt())
          }
         }
        }))
       }
      }),
      _s = ln({
       asinh_: function(t) {
        var e = Ze(t, "x", "asinh");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.asinh(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.divStrict(mn(1).add(n.toFloat().square()).sqrt())
          }
         }
        }))
       }
      }),
      Ds = ln({
       atan_: function(t) {
        var e = Ze(t, "x", "atan");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.atan(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.div(n.toFloat().square().add(1))
          }
         }
        }))
       }
      }),
      Fs = ln({
       atanh_: function(t) {
        var e = Ze(t, "x", "atanh");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.atanh(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.div(mn(1).sub(n.toFloat().square()))
          }
         }
        }))
       }
      }),
      Ms = ln({
       ceil_: function(t) {
        var e = Ze(t, "x", "ceil");
        return Bt.runKernelFunc((function(t) {
         return t.ceil(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Ls = ln({
       clipByValue_: function(t, e, n) {
        var r = Ze(t, "x", "clipByValue");
        k(e <= n, (function() {
         return "Error in clip: min (" + e + ") must be less than or equal to max (" + n + ")."
        }));
        var i = [r],
         o = {
          min: e,
          max: n
         };
        return Bt.runKernelFunc((function(t, i) {
         var o = t.clip(r, e, n);
         return i([r]), o
        }), {
         x: r
        }, (function(t, r) {
         var i = r[0];
         return {
          x: function() {
           return t.where(i.greaterEqual(e).logicalAnd(i.lessEqual(n)), Rn(t))
          }
         }
        }), "ClipByValue", o, i)
       }
      }),
      Bs = ln({
       cos_: function(t) {
        var e = Ze(t, "x", "cos"),
         n = [e];
        return Bt.runKernelFunc((function(t, n) {
         var r = t.cos(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return n.toFloat().sin().neg().mul(t)
          }
         }
        }), "Cos", {}, n)
       }
      }),
      Ps = ln({
       cosh_: function(t) {
        var e = Ze(t, "x", "cosh");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.cosh(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return n.toFloat().sinh().mulStrict(t)
          }
         }
        }))
       }
      }),
      zs = ln({
       erf_: function(t) {
        var e = Ze(t, "x", "erf");
        return k("int32" === e.dtype || "float32" === e.dtype, (function() {
         return "Input dtype must be `int32` or `float32`."
        })), "int32" === e.dtype && (e = e.toFloat()), Bt.runKernelFunc((function(t, n) {
         var r = t.erf(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)))
          }
         }
        }))
       }
      }),
      js = ln({
       exp_: function(t) {
        var e = Ze(t, "x", "exp");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.exp(e);
         return n([r]), r
        }), {
         x: e
        }, (function(t, e) {
         return {
          x: function() {
           return t.mulStrict(e[0])
          }
         }
        }), "Exp", {}, [], [!0])
       }
      }),
      Ws = ln({
       expm1_: function(t) {
        var e = Ze(t, "x", "expm1");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.expm1(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.mul(n.exp())
          }
         }
        }))
       }
      }),
      Vs = ln({
       floor_: function(t) {
        var e = Ze(t, "x", "floor");
        return Bt.runKernelFunc((function(t) {
         return t.floor(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Us = ln({
       log_: function(t) {
        var e = Ze(t, "x", "log"),
         n = [e];
        return Bt.runKernelFunc((function(t, n) {
         var r = t.log(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return t.div(n.toFloat())
          }
         }
        }), "Log", {}, n)
       }
      }),
      Hs = ln({
       log1p_: function(t) {
        var e = Ze(t, "x", "log1p");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.log1p(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.div(n.add(1))
          }
         }
        }))
       }
      }),
      $s = ln({
       logSigmoid_: function(t) {
        var e = Ze(t, "x", "logSigmoid");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.softplus(e.neg()).neg();
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.mul(n.neg().sigmoid())
          }
         }
        }))
       }
      }),
      Gs = ln({
       neg_: function(t) {
        var e = Ze(t, "x", "neg");
        return Bt.runKernelFunc((function(t) {
         return t.neg(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return t.neg()
          }
         }
        }))
       }
      }),
      qs = ln({
       reciprocal_: function(t) {
        var e = Ze(t, "x", "reciprocal");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.reciprocal(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.div(n.square().neg())
          }
         }
        }))
       }
      }),
      Ks = ln({
       round_: function(t) {
        var e = Ze(t, "x", "round");
        return Bt.runKernelFunc((function(t) {
         return t.round(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Xs = ln({
       rsqrt_: function(t) {
        var e = Ze(t, "x", "rsqrt"),
         n = [e];
        return Bt.runKernelFunc((function(t, n) {
         var r = t.rsqrt(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return t.div(n.pow(1.5).mul(2)).neg()
          }
         }
        }), "Rsqrt", {}, n)
       }
      }),
      Ys = ln({
       sigmoid_: function(t) {
        var e = Ze(t, "x", "sigmoid");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.sigmoid(e);
         return n([r]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return t.mul(n.mul(mn(1).sub(n)))
          }
         }
        }), "Sigmoid")
       }
      }),
      Zs = ln({
       sign_: function(t) {
        var e = Ze(t, "x", "sign");
        return Bt.runKernelFunc((function(t) {
         return t.sign(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Js = ln({
       isNaN_: function(t) {
        var e = Ze(t, "x", "isNaN");
        return Bt.runKernelFunc((function(t) {
         return t.isNaN(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      Qs = ln({
       isInf_: function(t) {
        var e = Ze(t, "x", "isInf");
        return Bt.runKernelFunc((function(t) {
         return t.isInf(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      tu = ln({
       isFinite_: function(t) {
        var e = Ze(t, "x", "isFinite");
        return Bt.runKernelFunc((function(t) {
         return t.isFinite(e)
        }), {
         $x: e
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      eu = ln({
       sin_: function(t) {
        var e = Ze(t, "x", "sin"),
         n = [e];
        return Bt.runKernelFunc((function(t, n) {
         var r = t.sin(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return n.toFloat().cos().mul(t)
          }
         }
        }), "Sin", {}, n)
       }
      }),
      nu = ln({
       sinh_: function(t) {
        var e = Ze(t, "x", "sinh");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.sinh(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return n.toFloat().cosh().mulStrict(t)
          }
         }
        }))
       }
      }),
      ru = ln({
       softplus_: function(t) {
        var e = Ze(t, "x", "softplus");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.softplus(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.mul(n.sigmoid())
          }
         }
        }))
       }
      }),
      iu = ln({
       sqrt_: function(t) {
        var e = Ze(t, "x", "sqrt");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.sqrt(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.div(n.toFloat().sqrt().mul(2))
          }
         }
        }))
       }
      }),
      ou = ln({
       step_: function(t, e) {
        void 0 === e && (e = 0);
        var n = Ze(t, "x", "step");
        return Bt.runKernelFunc((function(t) {
         return t.step(n, e)
        }), {
         $x: n
        }, (function(t) {
         return {
          $x: function() {
           return Rn(t)
          }
         }
        }))
       }
      }),
      au = ln({
       tan_: function(t) {
        var e = Ze(t, "x", "tan");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.tan(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return t.div(n.cos().square())
          }
         }
        }))
       }
      }),
      su = ln({
       tanh_: function(t) {
        var e = Ze(t, "x", "tanh");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.tanh(e);
         return n([r]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return mn(1).sub(n.square()).mulStrict(t)
          }
         }
        }), "Tanh", {}, null, [!0])
       }
      });
 
     function uu(t, e, n, r, i, o) {
      var a, s, u = Ze(t, "x", "batchNorm"),
       c = Ze(e, "mean", "batchNorm"),
       l = Ze(n, "variance", "batchNorm");
      return null != i && (a = Ze(i, "scale", "batchNorm")), null != r && (s = Ze(r, "offset", "batchNorm")), k(2 === u.rank, (function() {
       return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
      })), k(2 === c.rank || 1 === c.rank, (function() {
       return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c.rank + "."
      })), k(2 === l.rank || 1 === l.rank, (function() {
       return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l.rank + "."
      })), null != a && k(2 === a.rank || 1 === a.rank, (function() {
       return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + a.rank + "."
      })), null != s && k(2 === s.rank || 1 === s.rank, (function() {
       return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + "."
      })), hu(u, c, l, s, a, o)
     }
 
     function cu(t, e, n, r, i, o) {
      var a, s, u = Ze(t, "x", "batchNorm"),
       c = Ze(e, "mean", "batchNorm"),
       l = Ze(n, "variance", "batchNorm");
      return null != i && (a = Ze(i, "scale", "batchNorm")), null != r && (s = Ze(r, "offset", "batchNorm")), k(3 === u.rank, (function() {
       return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
      })), k(3 === c.rank || 1 === c.rank, (function() {
       return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c.rank + "."
      })), k(3 === l.rank || 1 === l.rank, (function() {
       return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l.rank + "."
      })), null != a && k(3 === a.rank || 1 === a.rank, (function() {
       return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + a.rank + "."
      })), null != s && k(3 === s.rank || 1 === s.rank, (function() {
       return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + "."
      })), hu(u, c, l, s, a, o)
     }
 
     function lu(t, e, n, r, i, o) {
      var a, s, u = Ze(t, "x", "batchNorm"),
       c = Ze(e, "mean", "batchNorm"),
       l = Ze(n, "variance", "batchNorm");
      return null != i && (a = Ze(i, "scale", "batchNorm")), null != r && (s = Ze(r, "offset", "batchNorm")), k(4 === u.rank, (function() {
       return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + "."
      })), k(4 === c.rank || 1 === c.rank, (function() {
       return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c.rank + "."
      })), k(4 === l.rank || 1 === l.rank, (function() {
       return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l.rank + "."
      })), null != a && k(4 === a.rank || 1 === a.rank, (function() {
       return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + a.rank + "."
      })), null != s && k(4 === s.rank || 1 === s.rank, (function() {
       return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + "."
      })), hu(u, c, l, s, a, o)
     }
 
     function hu(t, e, n, r, i, o) {
      null == o && (o = .001);
      var a, s, u, c = Ze(t, "x", "batchNorm"),
       l = Ze(e, "mean", "batchNorm"),
       h = Ze(n, "variance", "batchNorm");
      null != i && (a = Ze(i, "scale", "batchNorm")), null != r && (s = Ze(r, "offset", "batchNorm")), k(l.rank === h.rank, (function() {
       return "Batch normalization gradient requires mean and variance to have equal ranks."
      })), k(null == s || l.rank === s.rank, (function() {
       return "Batch normalization gradient requires mean and offset to have equal ranks."
      })), k(null == a || l.rank === a.rank, (function() {
       return "Batch normalization gradient requires mean and scale to have equal ranks."
      })), u = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;
      var p = [c, l, h, a];
      return Bt.runKernelFunc((function(t, e) {
       var n = t.batchNormalization(u, pu(l), pu(h), o, pu(a), pu(s));
       return e([c, l, h, a]), n
      }), {
       x: c,
       mean: l,
       variance: h,
       scale: a,
       offset: s
      }, (function(t, e) {
       var n = e,
        r = n[0],
        i = n[1],
        a = n[2],
        s = n[3],
        c = null == s ? mn(1) : s,
        l = Yr(i.shape, u.shape),
        h = [];
       if (1 === i.rank) {
        for (var p = 0; p < u.shape.length - 1; ++p) h.push(u.shape[p]);
        h.push(1)
       }
       var f = r.sub(i),
        d = t.mul(c),
        v = Xs(a.add(mn(o))),
        m = v.mul(v).mul(v).mul(mn(-.5));
       return {
        x: function() {
         return 1 === i.rank ? t.mul(xr(v.as4D(1, 1, 1, i.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(v).mul(c).reshape(r.shape)
        },
        mean: function() {
         var t = v.mul(mn(-1)).mul(d);
         return 1 === i.rank && (t = t.sum(l)), t.reshape(i.shape)
        },
        variance: function() {
         var t = m.mul(f).mul(d);
         return 1 === i.rank && (t = t.sum(l)), t.reshape(i.shape)
        },
        scale: function() {
         var e = f.mul(v),
          n = t.mul(e);
         return 1 === i.rank && (n = n.sum(l)), n.reshape(i.shape)
        },
        offset: function() {
         var e = t;
         return 1 === i.rank && (e = e.sum(l)), e.reshape(i.shape)
        }
       }
      }), "BatchNormalization", {
       varianceEpsilon: o
      }, p).reshape(c.shape)
     }
 
     function pu(t) {
      return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t
     }
 
     function fu() {
      He("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")
     }
     var du = ln({
       batchNormalization2d_: function(t, e, n, r, i, o) {
        return void 0 === r && (r = .001), fu(), uu(t, e, n, o, i, r)
       }
      }),
      vu = ln({
       batchNormalization3d_: function(t, e, n, r, i, o) {
        return void 0 === r && (r = .001), fu(), cu(t, e, n, o, i, r)
       }
      }),
      mu = ln({
       batchNormalization4d_: function(t, e, n, r, i, o) {
        return void 0 === r && (r = .001), fu(), lu(t, e, n, o, i, r)
       }
      }),
      gu = ln({
       batchNormalization_: function(t, e, n, r, i, o) {
        return void 0 === r && (r = .001), fu(), hu(t, e, n, o, i, r)
       }
      }),
      yu = ln({
       batchNorm_: hu
      }),
      bu = ln({
       batchNorm2d_: uu
      }),
      xu = ln({
       batchNorm3d_: cu
      }),
      wu = ln({
       batchNorm4d_: lu
      }),
      Cu = ln({
       logicalAnd_: function(t, e) {
        var n = Ze(t, "a", "logicalAnd", "bool"),
         r = Ze(e, "b", "logicalAnd", "bool");
        return Zr(n.shape, r.shape), Bt.runKernelFunc((function(t) {
         return t.logicalAnd(n, r)
        }), {
         a: n,
         b: r
        }, null, "LogicalAnd")
       }
      }),
      Su = ln({
       logicalNot_: function(t) {
        var e = Ze(t, "x", "logicalNot", "bool");
        return Bt.runKernelFunc((function(t) {
         return t.logicalNot(e)
        }), {
         $x: e
        })
       }
      }),
      Eu = ln({
       logicalOr_: function(t, e) {
        var n = Ze(t, "a", "logicalOr", "bool"),
         r = Ze(e, "b", "logicalOr", "bool");
        return Zr(n.shape, r.shape), Bt.runKernelFunc((function(t) {
         return t.logicalOr(n, r)
        }), {
         $a: n,
         $b: r
        })
       }
      }),
      ku = ln({
       logicalXor_: function(t, e) {
        var n = Ze(t, "a", "logicalXor", "bool"),
         r = Ze(e, "b", "logicalXor", "bool");
        return Zr(n.shape, r.shape), Eu(t, e).logicalAnd(Cu(t, e).logicalNot())
       }
      }),
      Iu = ln({
       where_: function(t, e, n) {
        var r = Ze(e, "a", "where"),
         i = Ze(n, "b", "where"),
         o = Ze(t, "condition", "where", "bool");
        return I(r.shape, i.shape, "Error in where: "), 1 === o.rank ? k(o.shape[0] === r.shape[0], (function() {
         return "The first dimension of `a` must match the size of `condition`."
        })) : I(o.shape, i.shape, "Error in where: "), Bt.runKernelFunc((function(t, e) {
         var n = t.select(o, r, i);
         return e([o]), n
        }), {
         $condition: o,
         $a: r,
         $b: i
        }, (function(t, e) {
         var n = e[0];
         return {
          $condition: function() {
           return Rn(n).toFloat()
          },
          $a: function() {
           return t.mul(n.cast(t.dtype))
          },
          $b: function() {
           return t.mul(n.logicalNot().cast(t.dtype))
          }
         }
        }))
       }
      }),
      Ou = function(t) {
       return s(this, void 0, void 0, (function() {
        var e, n, r;
        return u(this, (function(i) {
         switch (i.label) {
          case 0:
           return [4, (e = Ze(t, "condition", "whereAsync", "bool")).data()];
          case 1:
           return n = i.sent(), r = Ai(e.shape, n), t !== e && e.dispose(), [2, r]
         }
        }))
       }))
      },
      Au = ln({
       add_: function(t, e) {
        var n, r = Ze(t, "a", "add"),
         i = Ze(e, "b", "add");
        n = Tt(r, i), r = n[0], i = n[1];
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t) {
         return t.add(r, i)
        }), {
         a: r,
         b: i
        }, (function(t) {
         return {
          a: function() {
           var e = t,
            n = Yr(r.shape, o);
           return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape)
          },
          b: function() {
           var e = t,
            n = Yr(i.shape, o);
           return n.length > 0 && (e = e.sum(n)), e.reshape(i.shape)
          }
         }
        }), "Add")
       }
      }),
      Nu = ln({
       addN_: function(t) {
        k(Array.isArray(t), (function() {
         return "The argument passed to tf.addN() must be a list of tensors"
        })), k(t.length >= 1, (function() {
         return "Must pass at least one tensor to tf.addN(), but got " + t.length
        }));
        var e = t.map((function(t, e) {
          return Ze(t, "tensors" + e, "addN")
         })),
         n = e[0];
        e.forEach((function(t) {
         if (t.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
        })), e.forEach((function(t) {
         if (!R(t.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
        }));
        var r = e;
        return Bt.runKernelFunc((function(t) {
         return t.addN(e)
        }), r, (function(t) {
         var n = {};
         return e.forEach((function(e, r) {
          n[r] = function() {
           return t.clone()
          }
         })), n
        }), "AddN")
       }
      }),
      Ru = ln({
       addStrict_: function(t, e) {
        var n = Ze(t, "a", "addStrict"),
         r = Ze(e, "b", "addStrict");
        return I(n.shape, r.shape, "Error in addStrict: "), n.add(r)
       }
      }),
      Tu = ln({
       atan2_: function(t, e) {
        var n, r = Ze(t, "a", "atan2"),
         i = Ze(e, "b", "atan2");
        n = Tt(r, i), r = n[0], i = n[1];
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t, e) {
         var n = t.atan2(r, i);
         return e([r, i]), n
        }), {
         $a: r,
         $b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          $a: function() {
           var e = Au(n.square(), r.square()),
            i = t.mul(r.div(e)),
            a = Yr(n.shape, o);
           return a.length > 0 && (i = i.sum(a)), i.reshape(n.shape)
          },
          $b: function() {
           var e = Au(n.square(), r.square()),
            i = Gs(t.mul(n.div(e))),
            a = Yr(r.shape, o);
           return a.length > 0 && (i = i.sum(a)), i.reshape(r.shape)
          }
         }
        }))
       }
      }),
      _u = ln({
       div_: function(t, e) {
        var n, r = Ze(t, "a", "div"),
         i = Ze(e, "b", "div");
        if (n = Tt(r, i), r = n[0], i = n[1], "int32" === r.dtype && "int32" === i.dtype) return Mu(r, i);
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t, e) {
         var n = t.realDivide(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          a: function() {
           var e = t.div(r.toFloat()),
            i = Yr(n.shape, o);
           return i.length > 0 ? e.sum(i).reshape(n.shape) : e
          },
          b: function() {
           var e = t.mul(n.toFloat()),
            i = Yr(r.shape, o);
           i.length > 0 && (e = e.sum(i).reshape(r.shape));
           var a = r.square();
           return e.div(a.toFloat()).neg()
          }
         }
        }), "Div")
       }
      }),
      Du = ln({
       divNoNan_: function(t, e) {
        var n, r = Ze(t, "a", "div"),
         i = Ze(e, "b", "div");
        r = (n = Tt(r, i))[0], i = n[1];
        var o = _u(r, i),
         a = Rn(o),
         s = i.equal(a);
        return Iu(s, a, o)
       }
      }),
      Fu = ln({
       divStrict_: function(t, e) {
        var n = Ze(t, "a", "div"),
         r = Ze(e, "b", "div");
        return I(n.shape, r.shape, "Error in divideStrict: "), n.div(r)
       }
      }),
      Mu = ln({
       floorDiv_: function(t, e) {
        var n, r = Ze(t, "a", "floorDiv"),
         i = Ze(e, "b", "floorDiv");
        n = Tt(r, i), r = n[0], i = n[1];
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t, e) {
         var n = t.floorDiv(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          a: function() {
           var e = t.div(r.toFloat()),
            i = Yr(n.shape, o);
           return i.length > 0 ? e.sum(i).reshape(n.shape) : e
          },
          b: function() {
           var e = t.mul(n.toFloat()),
            i = Yr(r.shape, o);
           i.length > 0 && (e = e.sum(i).reshape(r.shape));
           var a = r.square();
           return e.div(a.toFloat()).neg()
          }
         }
        }), "FloorDiv")
       }
      }),
      Lu = ln({
       maximum_: function(t, e) {
        var n, r = Ze(t, "a", "maximum"),
         i = Ze(e, "b", "maximum");
        return n = Tt(r, i), r = n[0], i = n[1], "bool" === r.dtype && (r = r.toInt(), i = i.toInt()), Zr(r.shape, i.shape), Bt.runKernelFunc((function(t, e) {
         var n = t.maximum(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          a: function() {
           return t.mul(n.greaterEqual(r).toFloat())
          },
          b: function() {
           return t.mul(n.less(r).toFloat())
          }
         }
        }), "Maximum")
       }
      }),
      Bu = ln({
       maximumStrict_: function(t, e) {
        var n = Ze(t, "a", "maximumStrict"),
         r = Ze(e, "b", "maximumStrict");
        return I(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r)
       }
      }),
      Pu = ln({
       minimum_: function(t, e) {
        var n, r = Ze(t, "a", "minimum"),
         i = Ze(e, "b", "minimum");
        return n = Tt(r, i), r = n[0], i = n[1], "bool" === r.dtype && (r = r.toInt(), i = i.toInt()), Zr(r.shape, i.shape), Bt.runKernelFunc((function(t, e) {
         var n = t.minimum(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          a: function() {
           return t.mul(n.lessEqual(r).toFloat())
          },
          b: function() {
           return t.mul(n.greater(r).toFloat())
          }
         }
        }), "Minimum")
       }
      }),
      zu = ln({
       minimumStrict_: function(t, e) {
        var n = Ze(t, "a", "minimumStrict"),
         r = Ze(e, "b", "minimumStrict");
        return I(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r)
       }
      }),
      ju = ln({
       mod_: function(t, e) {
        var n, r = Ze(t, "a", "mod"),
         i = Ze(e, "b", "mod");
        n = Tt(r, i), r = n[0], i = n[1];
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t, e) {
         var n = t.mod(r, i);
         return e([r, i]), n
        }), {
         $a: r,
         $b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          $a: function() {
           var e = Yr(n.shape, o);
           return e.length > 0 ? t.sum(e).reshape(n.shape) : t
          },
          $b: function() {
           var e = t.mul(n.div(r).floor().neg()),
            i = Yr(r.shape, o);
           return i.length > 0 ? e.sum(i).reshape(r.shape) : e
          }
         }
        }))
       }
      }),
      Wu = ln({
       modStrict_: function(t, e) {
        var n = Ze(t, "a", "modStrict"),
         r = Ze(e, "b", "modStrict");
        return I(n.shape, r.shape, "Error in modStrict: "), n.mod(r)
       }
      }),
      Vu = ln({
       mul_: function(t, e) {
        var n, r = Ze(t, "a", "mul"),
         i = Ze(e, "b", "mul");
        n = Tt(r, i), r = n[0], i = n[1];
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t, e) {
         var n = t.multiply(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          a: function() {
           var e = t.mul(r.toFloat()),
            i = Yr(n.shape, o);
           return i.length > 0 ? e.sum(i).reshape(n.shape) : e
          },
          b: function() {
           var e = t.mul(n.toFloat()),
            i = Yr(r.shape, o);
           return i.length > 0 ? e.sum(i).reshape(r.shape) : e
          }
         }
        }), "Mul")
       }
      }),
      Uu = ln({
       mulStrict_: function(t, e) {
        var n = Ze(t, "a", "mul"),
         r = Ze(e, "b", "mul");
        return I(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r)
       }
      }),
      Hu = ln({
       pow_: function(t, e) {
        var n = Ze(t, "base", "pow"),
         r = Ze(e, "exp", "pow"),
         i = Zr(n.shape, r.shape);
        return t = n.cast(Nt(n.dtype, r.dtype)), e = r.cast(Nt(n.dtype, r.dtype)), Bt.runKernelFunc((function(t, e) {
         var i = t.pow(n, r);
         return e([n, r, i]), i
        }), {
         $base: n,
         $exp: r
        }, (function(t, e) {
         var n = e[0],
          r = e[1],
          o = e[2];
         return {
          $base: function() {
           var e = r.toFloat(),
            o = t.mul(e.mul(n.pow(e.sub(mn(1))))),
            a = Yr(n.shape, i);
           return a.length > 0 && (o = o.sum(a)), o.reshape(n.shape)
          },
          $exp: function() {
           var e = n.greater(0),
            a = n.log().where(e, Rn(n)),
            s = t.mul(o.mul(a)),
            u = Yr(r.shape, i);
           return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape)
          }
         }
        }))
       }
      }),
      $u = ln({
       powStrict_: function(t, e) {
        return I(t.shape, e.shape, "Error in powStrict: "), t.pow(e)
       }
      }),
      Gu = ln({
       squaredDifference_: function(t, e) {
        var n, r = Ze(t, "a", "squaredDifference"),
         i = Ze(e, "b", "squaredDifference");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t, e) {
         var n = t.squaredDifference(r, i);
         return e([r, i]), n
        }), {
         $a: r,
         $b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1],
          i = mn(2);
         return {
          $a: function() {
           return t.mul(n.sub(r).mul(i))
          },
          $b: function() {
           return t.mul(r.sub(n).mul(i))
          }
         }
        }))
       }
      }),
      qu = ln({
       squaredDifferenceStrict_: function(t, e) {
        var n = Ze(t, "a", "squaredDifferenceStrict"),
         r = Ze(e, "b", "squaredDifferenceStrict");
        return I(n.shape, r.shape, "Error in squaredDifferenceStrict: "), n.squaredDifference(r)
       }
      }),
      Ku = ln({
       sub_: function(t, e) {
        var n, r = Ze(t, "a", "sub"),
         i = Ze(e, "b", "sub");
        n = Tt(r, i), r = n[0], i = n[1];
        var o = Zr(r.shape, i.shape);
        return Bt.runKernelFunc((function(t) {
         return t.subtract(r, i)
        }), {
         a: r,
         b: i
        }, (function(t) {
         return {
          a: function() {
           var e = t,
            n = Yr(r.shape, o);
           return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape)
          },
          b: function() {
           var e = t,
            n = Yr(i.shape, o);
           return n.length > 0 && (e = e.sum(n)), e.neg().reshape(i.shape)
          }
         }
        }), "Sub")
       }
      }),
      Xu = ln({
       subStrict_: function(t, e) {
        var n = Ze(t, "a", "subStrict"),
         r = Ze(e, "b", "subStrict");
        return I(n.shape, r.shape, "Error in subStrict: "), n.sub(r)
       }
      }),
      Yu = ln({
       equal_: function(t, e) {
        var n, r = Ze(t, "a", "equal"),
         i = Ze(e, "b", "equal");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t) {
         return t.equal(r, i)
        }), {
         $a: r,
         $b: i
        })
       }
      }),
      Zu = ln({
       equalStrict_: function(t, e) {
        var n = Ze(t, "a", "equalStrict"),
         r = Ze(e, "b", "equalStrict");
        return I(n.shape, r.shape, "Error in equalStrict: "), n.equal(r)
       }
      }),
      Ju = ln({
       greater_: function(t, e) {
        var n, r = Ze(t, "a", "greater"),
         i = Ze(e, "b", "greater");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t) {
         return t.greater(r, i)
        }), {
         a: r,
         b: i
        }, null, "Greater")
       }
      }),
      Qu = ln({
       greaterEqual_: function(t, e) {
        var n, r = Ze(t, "a", "greaterEqual"),
         i = Ze(e, "b", "greaterEqual");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t, e) {
         var n = t.greaterEqual(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, (function(t, e) {
         var n = e[0],
          r = e[1];
         return {
          a: function() {
           return Rn(n)
          },
          b: function() {
           return Rn(r)
          }
         }
        }), "GreaterEqual")
       }
      }),
      tc = ln({
       greaterEqualStrict_: function(t, e) {
        var n = Ze(t, "a", "greaterEqualStrict"),
         r = Ze(e, "b", "greaterEqualStrict");
        return I(n.shape, r.shape, "Error in greaterEqualStrict: "), n.greaterEqual(r)
       }
      }),
      ec = ln({
       greaterStrict_: function(t, e) {
        var n = Ze(t, "a", "greaterStrict"),
         r = Ze(e, "b", "greaterStrict");
        return I(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r)
       }
      }),
      nc = ln({
       less_: function(t, e) {
        var n, r = Ze(t, "a", "less"),
         i = Ze(e, "b", "less");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t) {
         return t.less(r, i)
        }), {
         a: r,
         b: i
        }, null, "Less")
       }
      }),
      rc = ln({
       lessEqual_: function(t, e) {
        var n, r = Ze(t, "a", "lessEqual"),
         i = Ze(e, "b", "lessEqual");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t, e) {
         var n = t.lessEqual(r, i);
         return e([r, i]), n
        }), {
         a: r,
         b: i
        }, null, "LessEqual")
       }
      }),
      ic = ln({
       lessEqualStrict_: function(t, e) {
        var n = Ze(t, "a", "lessEqualStrict"),
         r = Ze(e, "b", "lessEqualStrict");
        return I(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r)
       }
      }),
      oc = ln({
       lessStrict_: function(t, e) {
        var n = Ze(t, "a", "lessStrict"),
         r = Ze(e, "b", "lessStrict");
        return I(n.shape, r.shape, "Error in lessStrict: "), n.less(r)
       }
      }),
      ac = ln({
       notEqual_: function(t, e) {
        var n, r = Ze(t, "a", "notEqual"),
         i = Ze(e, "b", "notEqual");
        return n = Tt(r, i), r = n[0], i = n[1], Zr(r.shape, i.shape), Bt.runKernelFunc((function(t) {
         return t.notEqual(r, i)
        }), {
         $a: r,
         $b: i
        })
       }
      }),
      sc = ln({
       notEqualStrict_: function(t, e) {
        var n = Ze(t, "a", "notEqualStrict"),
         r = Ze(e, "b", "notEqualStrict");
        return I(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r)
       }
      });
 
     function uc(t, e) {
      for (var n = [], r = t; r < e; ++r) n.push(r);
      return n
     }
 
     function cc(t) {
      for (var e = [], n = 0; n < t.length; ++n)
       for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);
      return e
     }
     var lc = ln({
       gather_: function(t, e, n) {
        void 0 === n && (n = 0);
        var r = Ze(t, "x", "gather"),
         i = Ze(e, "indices", "gather", "int32");
        n = B(n, r.shape)[0];
        var o = function(t, e, n) {
         for (var r = t.shape[n], i = [], o = 1, a = 1, s = 0; s < n; s++) i.push(t.shape[s]), o *= t.shape[s];
         for (s = 0; s < e.rank; s++) i.push(e.shape[s]);
         for (s = n + 1; s < t.rank; s++) i.push(t.shape[s]), a *= t.shape[s];
         return {
          batchSize: o,
          sliceSize: a,
          dimSize: r,
          outputShape: i
         }
        }(r, i, n);
        return Bt.runKernelFunc((function(t, e) {
         var o = t.gather(r, i.flatten(), n);
         return e([i]), o
        }), {
         x: r,
         indices: i
        }, (function(t, e) {
         var i = e[0];
         return {
          x: function() {
           var e = r.shape,
            o = i.size,
            a = e.slice(0, n),
            s = a.length,
            u = e.slice(n, e.length).slice(1),
            c = u.length,
            l = uc(0, s),
            h = uc(s + 1, s + 1 + c),
            p = cc([a, [o], u]),
            f = t.reshape(p),
            d = i.reshape([o]),
            v = cc([
             [s], l, h
            ]),
            m = f.transpose(v),
            g = hc(m, d, r.shape[n]),
            y = an(v);
           return g.transpose(y)
          },
          indices: function() {
           return i
          }
         }
        }), "Gather", {
         axis: n
        }).reshape(o.outputShape)
       }
      }),
      hc = ln({
       unsortedSegmentSum_: function(t, e, n) {
        var r = Ze(t, "x", "unsortedSegmentSum"),
         i = Ze(e, "segmentIds", "unsortedSegmentSum", "int32");
        return k(T(n), (function() {
         return "numSegments must be of dtype int"
        })), Bt.runKernelFunc((function(t, e) {
         var o = t.unsortedSegmentSum(r, i, n);
         return e([i]), o
        }), {
         $x: r
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return function(t, e) {
            for (var n = Lu(e, Rn(e)), r = lc(t, n), i = Qu(e, mn(0, "int32")), o = r.rank - i.rank, a = 0; a < o; ++a) i = rr(i, a + 1);
            i = Cu(i, En(r.shape, "bool"));
            var s = Rn(r);
            return Iu(i, r, s)
           }(t, n)
          }
         }
        }))
       }
      }),
      pc = function(t, e, n) {
       return s(this, void 0, void 0, (function() {
        var r, i, o, a, s, c, l, h, p, f, d, v, m;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           for (r = Ze(t, "tensor", "boolMask"), i = Ze(e, "mask", "boolMask", "bool"), o = null == n ? 0 : n, a = i.rank, s = r.shape, k(a > 0, (function() {
             return "mask cannot be scalar"
            })), I(s.slice(o, o + a), i.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c = 1, l = o; l < o + a; l++) c *= s[l];
           return h = s.slice(0, o).concat([c], s.slice(o + a)), p = r.reshape(h), f = i.reshape([-1]), [4, Ou(f)];
          case 1:
           return d = u.sent(), v = d.squeeze([1]), m = lc(p, v, o), t !== r && r.dispose(), e !== i && i.dispose(), v.dispose(), p.dispose(), f.dispose(), d.dispose(), [2, m]
         }
        }))
       }))
      };
 
     function fc(t, e, n, r, i, o, a) {
      void 0 === o && (o = "NHWC"), k(t.length === e.rank, (function() {
       return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match"
      }));
      var s = t,
       u = e,
       c = !1;
      3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, t[0], t[1], t[2]]), k(4 === s.length, (function() {
       return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + "."
      })), k(4 === u.rank, (function() {
       return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank
      })), k(4 === n.rank, (function() {
       return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank
      }));
      var l = "NHWC" === o ? s[3] : s[1],
       h = "NHWC" === o ? u.shape[3] : u.shape[1];
      k(l === n.shape[2], (function() {
       return "Error in conv2dDerInput: depth of input (" + l + ") must match input depth for filter " + n.shape[2] + "."
      })), k(h === n.shape[3], (function() {
       return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + n.shape[3] + "."
      })), null != a && k(T(i), (function() {
       return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + i + "."
      }));
      var p = ci(o),
       f = ti(s, n.shape, r, 1, i, a, !1, p),
       d = Bt.runKernelFunc((function(t, e) {
        var r = t.conv2dDerInput(u, n, f);
        return e([n, u]), r
       }), {
        dy4D: u,
        filter: n
       }, (function(t, e) {
        var n = e[0],
         s = e[1];
        return {
         dy4D: function() {
          return gc(t, n, r, i, o, 1, a)
         },
         filter: function() {
          return bc(t, s, n.shape, r, i, o, a)
         }
        }
       }));
      return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d
     }
 
     function dc(t) {
      var e = function(t) {
        return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
       }(t),
       n = e[0],
       r = e[1],
       i = e[2];
      return 1 === n && 1 === r && 1 === i
     }
 
     function vc(t, e, n, r, i) {
      k(t.length === e.rank, (function() {
       return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match"
      }));
      var o = t,
       a = e,
       s = !1;
      4 === e.rank && (s = !0, a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), o = [1, t[0], t[1], t[2], t[3]]);
      var u = o[4],
       c = a.shape[4];
      k(5 === o.length, (function() {
       return "Error in conv3dDerInput: inShape must be length 5, but got length " + o.length + "."
      })), k(5 === a.rank, (function() {
       return "Error in conv3dDerInput: dy must be rank 5, but got rank " + a.rank
      })), k(5 === n.rank, (function() {
       return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank
      })), k(u === n.shape[3], (function() {
       return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + n.shape[3] + "."
      })), k(c === n.shape[4], (function() {
       return "Error in conv3dDerInput: depth of output (" + c + ") must match output depth for filter " + n.shape[4] + "."
      }));
      var l = ei(o, n.shape, r, 1, i),
       h = Bt.runKernelFunc((function(t) {
        return t.conv3dDerInput(a, n, l)
       }), {
        dy5D: a
       });
      return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
     }
     var mc = ln({
       conv1d_: function(t, e, n, r, i, o, a) {
        void 0 === i && (i = "NWC"), void 0 === o && (o = 1);
        var s = Ze(t, "x", "conv1d"),
         u = Ze(e, "filter", "conv1d"),
         c = s,
         l = !1;
        2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), k(3 === c.rank, (function() {
         return "Error in conv1d: input must be rank 3, but got rank " + c.rank + "."
        })), k(3 === u.rank, (function() {
         return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + "."
        })), null != a && k(T(r), (function() {
         return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
        })), k(c.shape[2] === u.shape[1], (function() {
         return "Error in conv1d: depth of input (" + c.shape[2] + ") must match input depth for filter " + u.shape[1] + "."
        })), k(ui(n, o), (function() {
         return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + o + "'"
        })), k("NWC" === i, (function() {
         return "Error in conv1d: got dataFormat of " + i + " but only NWC is currently supported."
        }));
        var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),
         p = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),
         f = gc(p, h, [1, n], r, "NHWC", [1, o], a);
        return l ? f.as2D(f.shape[2], f.shape[3]) : f.as3D(f.shape[0], f.shape[2], f.shape[3])
       }
      }),
      gc = ln({
       conv2d_: function(t, e, n, r, i, o, a) {
        void 0 === i && (i = "NHWC"), void 0 === o && (o = [1, 1]);
        var s = Ze(t, "x", "conv2d"),
         u = Ze(e, "filter", "conv2d"),
         c = s,
         l = !1;
        3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), k(4 === c.rank, (function() {
         return "Error in conv2d: input must be rank 4, but got rank " + c.rank + "."
        })), k(4 === u.rank, (function() {
         return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + "."
        })), null != a && k(T(r), (function() {
         return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
        }));
        var h = "NHWC" === i ? c.shape[3] : c.shape[1];
        k(h === u.shape[2], (function() {
         return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + u.shape[2] + "."
        })), k(ui(n, o), (function() {
         return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
        }));
        var p = ci(i),
         f = ti(c.shape, u.shape, n, o, r, a, !1, p),
         d = [u, c],
         v = Bt.runKernelFunc((function(t, e) {
          var n = t.conv2d(c, u, f);
          return e([u, c]), n
         }), {
          x: c,
          filter: u
         }, (function(t, e) {
          var a = e,
           s = a[0],
           u = a[1];
          return k(si(o), (function() {
           return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + o + "'"
          })), {
           x: function() {
            return xc(u.shape, t, s, n, r, i)
           },
           filter: function() {
            return bc(u, t, s.shape, n, r, i)
           }
          }
         }), "Conv2D", f, d);
        return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v
       }
      }),
      yc = ln({
       conv3d_: function(t, e, n, r, i, o) {
        void 0 === i && (i = "NDHWC"), void 0 === o && (o = [1, 1, 1]);
        var a = Ze(t, "x", "conv3d"),
         s = Ze(e, "filter", "conv3d"),
         u = a,
         c = !1;
        4 === a.rank && (c = !0, u = a.as5D(1, a.shape[0], a.shape[1], a.shape[2], a.shape[3])), k(5 === u.rank, (function() {
         return "Error in conv3d: input must be rank 5, but got rank " + u.rank + "."
        })), k(5 === s.rank, (function() {
         return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + "."
        })), k(u.shape[4] === s.shape[3], (function() {
         return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + "."
        })), k(function(t, e) {
         return dc(t) || dc(e)
        }(n, o), (function() {
         return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
        })), k("NDHWC" === i, (function() {
         return "Error in conv3d: got dataFormat of " + i + " but only NDHWC is currently supported."
        }));
        var l = ei(u.shape, s.shape, n, o, r),
         h = Bt.runKernelFunc((function(t, e) {
          var n = t.conv3d(u, s, l);
          return e([u, s]), n
         }), {
          x: u,
          $filter: s
         }, (function(t, e) {
          k(dc(o), (function() {
           return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + o + "'"
          }));
          var i = e[0],
           a = e[1];
          return {
           x: function() {
            return vc(i.shape, t, a, n, r)
           },
           $filter: function() {
            return function(t, e, n, r, i) {
             var o = t;
             4 === t.rank && (o = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));
             var a = e;
             4 === a.rank && (a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])), k(5 === o.rank, (function() {
              return "Error in conv3dDerFilter: input must be rank 5, but got shape " + o.shape + "."
             })), k(5 === a.rank, (function() {
              return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + a.shape + "."
             })), k(5 === n.length, (function() {
              return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + "."
             })), k(o.shape[4] === n[3], (function() {
              return "Error in conv3dDerFilter: depth of input " + o.shape[4] + ") must match input depth in filter (" + n[3] + "."
             })), k(a.shape[4] === n[4], (function() {
              return "Error in conv3dDerFilter: depth of dy (" + a.shape[4] + ") must match output depth for filter (" + n[4] + ")."
             }));
             var s = ei(o.shape, n, r, 1, i);
             return Bt.runKernelFunc((function(t) {
              return t.conv3dDerFilter(o, a, s)
             }), {
              x5D: o,
              dy5D: a
             })
            }(i, t, a.shape, n, r)
           }
          }
         }));
        return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
       }
      }),
      bc = ln({
       conv2dDerFilter_: function(t, e, n, r, i, o, a) {
        void 0 === o && (o = "NHWC");
        var s = t;
        3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
        var u = e;
        3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), k(4 === s.rank, (function() {
         return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + "."
        })), k(4 === u.rank, (function() {
         return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + "."
        })), k(4 === n.length, (function() {
         return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + "."
        }));
        var c = "NHWC" === o ? s.shape[3] : s.shape[1],
         l = "NHWC" === o ? u.shape[3] : u.shape[1];
        k(c === n[2], (function() {
         return "Error in conv2dDerFilter: depth of input " + c + ") must match input depth in filter (" + n[2] + "."
        })), k(l === n[3], (function() {
         return "Error in conv2dDerFilter: depth of dy (" + l + ") must match output depth for filter (" + n[3] + ")."
        })), null != a && k(T(i), (function() {
         return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + i + "."
        }));
        var h = ci(o),
         p = ti(s.shape, n, r, 1, i, a, !1, h);
        return Bt.runKernelFunc((function(t) {
         return t.conv2dDerFilter(s, u, p)
        }), {
         x4D: s,
         dy4D: u
        })
       }
      }),
      xc = ln({
       conv2dDerInput_: fc
      }),
      wc = ln({
       depthwiseConv2d_: function(t, e, n, r, i, o, a) {
        void 0 === i && (i = "NHWC"), void 0 === o && (o = [1, 1]);
        var s = Ze(t, "x", "depthwiseConv2d"),
         u = Ze(e, "filter", "depthwiseConv2d"),
         c = s,
         l = !1;
        3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), k(4 === c.rank, (function() {
         return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c.rank + "."
        })), k(4 === u.rank, (function() {
         return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + "."
        })), k(c.shape[3] === u.shape[2], (function() {
         return "Error in depthwiseConv2d: number of input channels (" + c.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + "."
        })), null == o && (o = [1, 1]), k(ui(n, o), (function() {
         return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
        })), null != a && k(T(r), (function() {
         return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
        }));
        var h = ti(c.shape, u.shape, n, o, r, a, !0),
         p = [c, u],
         f = Bt.runKernelFunc((function(t, e) {
          var n = t.depthwiseConv2D(c, u, h);
          return e([c, u]), n
         }), {
          x: c,
          filter: u
         }, (function(t, e) {
          k(si(o), (function() {
           return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + o + "'"
          }));
          var n = e[0],
           r = e[1];
          return {
           x: function() {
            return Cc(n.shape, t, r, h)
           },
           filter: function() {
            return Sc(n, t, r.shape, h)
           }
          }
         }), "DepthwiseConv2dNative", h, p);
        return l ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f
       }
      }),
      Cc = ln({
       depthwiseConv2dDerInput_: function(t, e, n, r) {
        var i = e,
         o = !1;
        3 === e.rank && (o = !0, i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
        var a = Bt.runKernelFunc((function(t) {
         return t.depthwiseConv2DDerInput(i, n, r)
        }), {
         dy4D: i
        });
        return o ? a.as3D(a.shape[1], a.shape[2], a.shape[3]) : a
       }
      }),
      Sc = ln({
       depthwiseConv2dDerFilter_: function(t, e, n, r) {
        var i = t;
        3 === t.rank && (i = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
        var o = e;
        return 3 === o.rank && (o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Bt.runKernelFunc((function(t) {
         return t.depthwiseConv2DDerFilter(i, o, r)
        }), {
         x4D: i,
         dy4D: o
        })
       }
      }),
      Ec = ln({
       separableConv2d_: function(t, e, n, r, i, o, a) {
        void 0 === o && (o = [1, 1]), void 0 === a && (a = "NHWC");
        var s = Ze(t, "x", "separableConv2d"),
         u = Ze(e, "depthwiseFilter", "separableConv2d"),
         c = Ze(n, "pointwiseFilter", "separableConv2d"),
         l = s,
         h = !1;
        if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), "NCHW" === a) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
        k(4 === l.rank, (function() {
         return "Error in separableConv2d: input must be rank 4, but got rank " + l.rank + "."
        })), k(4 === u.rank, (function() {
         return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + "."
        })), k(4 === c.rank, (function() {
         return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + "."
        })), k(1 === c.shape[0], (function() {
         return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c.shape[0] + "."
        })), k(1 === c.shape[1], (function() {
         return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c.shape[1] + "."
        }));
        var p = u.shape[2],
         f = u.shape[3];
        k(c.shape[2] === p * f, (function() {
         return "Error in separableConv2d: the third dimension of pointwise filter must be " + p * f + ", but got " + c.shape[2] + "."
        }));
        var d = wc(l, u, r, i, a, o),
         v = gc(d, c, 1, "valid", a);
        return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v
       }
      }),
      kc = ln({
       conv2dTranspose_: function(t, e, n, r, i, o) {
        return fc(n, Ze(t, "x", "conv2dTranspose"), Ze(e, "filter", "conv2dTranspose"), r, i, "NHWC", o)
       }
      }),
      Ic = ln({
       conv3dTranspose_: function(t, e, n, r, i) {
        return vc(n, Ze(t, "x", "conv3dTranspose"), Ze(e, "filter", "conv3dTranspose"), r, i)
       }
      }),
      Oc = ln({
       matMul_: function(t, e, n, r) {
        var i;
        void 0 === n && (n = !1), void 0 === r && (r = !1);
        var o = Ze(t, "a", "matMul"),
         a = Ze(e, "b", "matMul");
        i = Tt(o, a), o = i[0], a = i[1];
        var s = n ? o.shape[o.rank - 2] : o.shape[o.rank - 1],
         u = r ? a.shape[a.rank - 1] : a.shape[a.rank - 2],
         c = n ? o.shape[o.rank - 1] : o.shape[o.rank - 2],
         l = r ? a.shape[a.rank - 2] : a.shape[a.rank - 1],
         h = o.shape.slice(0, -2),
         p = a.shape.slice(0, -2),
         f = N(h),
         d = N(p);
        k(o.rank >= 2 && a.rank >= 2 && o.rank === a.rank, (function() {
         return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + o.rank + " and " + a.rank + "."
        })), k(R(h, p), (function() {
         return "Error in matMul: outer dimensions (" + h + ") and (" + p + ") of Tensors with shapes " + o.shape + " and " + a.shape + " must match."
        })), k(s === u, (function() {
         return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + o.shape + " and " + a.shape + " and transposeA=" + n + " and transposeB=" + r + " must match."
        }));
        var v = o.shape.slice(0, -2).concat([c, l]),
         m = n ? o.as3D(f, s, c) : o.as3D(f, c, s),
         g = r ? a.as3D(d, l, u) : a.as3D(d, u, l),
         y = {
          transposeA: n,
          transposeB: r
         };
        return Bt.runKernelFunc((function(t, e) {
         var i = t.batchMatMul(m, g, n, r);
         return e([m, g]), i
        }), {
         a: m,
         b: g
        }, (function(t, e) {
         var i = e,
          o = i[0],
          a = i[1];
         return n || r ? !n && r ? {
          a: function() {
           return t.matMul(a, !1, !1)
          },
          b: function() {
           return t.matMul(o, !0, !1)
          }
         } : n && !r ? {
          a: function() {
           return a.matMul(t, !1, !0)
          },
          b: function() {
           return o.matMul(t, !1, !1)
          }
         } : {
          a: function() {
           return a.matMul(t, !0, !0)
          },
          b: function() {
           return t.matMul(o, !0, !0)
          }
         } : {
          a: function() {
           return t.matMul(a, !1, !0)
          },
          b: function() {
           return o.matMul(t, !0, !1)
          }
         }
        }), "BatchMatMul", y).reshape(v)
       }
      }),
      Ac = ln({
       dot_: function(t, e) {
        var n = Ze(t, "t1", "dot"),
         r = Ze(e, "t2", "dot");
        k(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), (function() {
         return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + "."
        }));
        var i = 1 === n.rank ? n.size : n.shape[1],
         o = 1 === r.rank ? r.size : r.shape[0];
        return k(i === o, (function() {
         return "Error in dot: inner dimensions of inputs must match, but got " + i + " and " + o + "."
        })), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]))
       }
      }),
      Nc = ln({
       outerProduct_: function(t, e) {
        var n = Ze(t, "v1", "outerProduct"),
         r = Ze(e, "v2", "outerProduct");
        return k(1 === n.rank && 1 === r.rank, (function() {
         return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + "."
        })), n.as2D(-1, 1).matMul(r.as2D(1, -1))
       }
      }),
      Rc = ln({
       reverse_: function(t, e) {
        var n = Ze(t, "x", "reverse");
        if (0 === n.rank) return n.clone();
        var r = B(e, n.shape);
        return Bt.runKernelFunc((function(t) {
         return t.reverse(n, r)
        }), {
         $x: n
        }, (function(t) {
         return {
          $x: function() {
           return t.reverse(r)
          }
         }
        })).reshapeAs(n)
       }
      }),
      Tc = ln({
       reverse1d_: function(t) {
        var e = Ze(t, "x", "reverse");
        return k(1 === e.rank, (function() {
         return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + "."
        })), Rc(e, 0)
       }
      }),
      _c = ln({
       reverse2d_: function(t, e) {
        var n = Ze(t, "x", "reverse");
        return k(2 === n.rank, (function() {
         return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + "."
        })), Rc(n, e)
       }
      }),
      Dc = ln({
       reverse3d_: function(t, e) {
        var n = Ze(t, "x", "reverse");
        return k(3 === n.rank, (function() {
         return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + "."
        })), Rc(n, e)
       }
      }),
      Fc = ln({
       reverse4d_: function(t, e) {
        var n = Ze(t, "x", "reverse");
        return k(4 === n.rank, (function() {
         return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + "."
        })), Rc(n, e)
       }
      });
 
     function Mc(t, e, n, r, i, o) {
      var a = Ze(t, "x", "maxPool"),
       s = a,
       u = !1;
      3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), null == r && (r = [1, 1]), k(4 === s.rank, (function() {
       return "Error in maxPool: input must be rank 4 but got rank " + s.rank + "."
      })), k(ui(n, r), (function() {
       return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'"
      })), null != o && k(T(i), (function() {
       return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
      }));
      var c = Jr(s.shape, e, n, r, i, o);
      if (1 === c.filterWidth && 1 === c.filterHeight && R(c.inShape, c.outShape)) return a.clone();
      var l = [s],
       h = Bt.runKernelFunc((function(t, e) {
        var n = t.maxPool(s, c);
        return e([s, n]), n
       }), {
        x: s
       }, (function(t, o) {
        var a = o[0],
         s = o[1];
        return {
         x: function() {
          return function(t, e, n, r, i, o, a, s) {
           var u = Ze(t, "dy", "maxPoolBackprop"),
            c = Ze(e, "input", "maxPoolBackprop"),
            l = Ze(n, "output", "maxPoolBackprop");
           k(c.rank === u.rank, (function() {
            return "Rank of input (" + c.rank + ") does not match rank of dy (" + u.rank + ")"
           })), null == o && (o = [1, 1]), k(ui(i, o), (function() {
            return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + o + "'"
           })), k(4 === u.rank, (function() {
            return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u.rank + "."
           })), k(4 === c.rank, (function() {
            return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c.rank + "."
           })), null != s && k(T(a), (function() {
            return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + a + "."
           }));
           var h = Jr(c.shape, r, i, o, a, s);
           return Bt.runKernelFunc((function(t) {
            return t.maxPoolBackprop(u, c, l, h)
           }), {
            $dy: u,
            $input: c
           })
          }(t, a, s, e, n, r, i)
         }
        }
       }), "MaxPool", c, l);
      return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h
     }
 
     function Lc(t, e, n, r, i, o) {
      var a = Ze(t, "x", "avgPool", "float32");
      null == r && (r = [1, 1]), k(ui(n, r), (function() {
       return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'"
      }));
      var s = a,
       u = !1;
      3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), k(4 === s.rank, (function() {
       return "Error in avgPool: x must be rank 4 but got rank " + s.rank + "."
      })), null != o && k(T(i), (function() {
       return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
      }));
      var c = Jr(s.shape, e, n, r, i, o);
      if (1 === c.filterWidth && 1 === c.filterHeight && R(c.inShape, c.outShape)) return a.clone();
      var l = Bt.runKernelFunc((function(t) {
       return t.avgPool(s, c)
      }), {
       x: s
      }, (function(t) {
       return {
        x: function() {
         return function(t, e, n, r, i, o) {
          var a = Ze(t, "dy", "avgPoolBackprop"),
           s = Ze(e, "input", "avgPoolBackprop");
          k(s.rank === a.rank, (function() {
           return "Rank of input (" + s.rank + ") does not match rank of dy (" + a.rank + ")"
          })), null == i && (i = [1, 1]), k(ui(r, i), (function() {
           return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + i + "'"
          }));
          var u = s,
           c = a,
           l = !1;
          3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), k(4 === c.rank, (function() {
           return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c.rank + "."
          })), k(4 === u.rank, (function() {
           return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u.rank + "."
          }));
          var h = Jr(u.shape, n, r, i, o),
           p = Bt.runKernelFunc((function(t) {
            return t.avgPoolBackprop(c, u, h)
           }), {
            dy4D: c,
            input4D: u
           });
          return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p
         }(t, s, e, n, r, i)
        }
       }
      }), "AvgPool", c);
      return l = l.cast(a.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l
     }
     var Bc = ln({
       maxPool_: function(t, e, n, r, i) {
        return Mc(t, e, n, 1, r, i)
       }
      }),
      Pc = ln({
       avgPool_: function(t, e, n, r, i) {
        return Lc(t, e, n, 1, r, i)
       }
      }),
      zc = ln({
       pool_: function(t, e, n, r, i, o) {
        null == i && (i = [1, 1]), null == o && (o = 1), 0 === r && (r = "valid");
        var a = Ze(t, "x", "maxPool"),
         s = a,
         u = !1;
        3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), k(ui(o, i), (function() {
         return "Error in pool: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + i + "'"
        }));
        var c, l = Jr(s.shape, e, o, i, r),
         h = [l.dilationHeight, l.dilationWidth];
        c = "same" === r ? function(t, e) {
         var n = t.map((function(t, n) {
           return t + (t - 1) * (e[n] - 1)
          })).map((function(t) {
           return t - 1
          })),
          r = n.map((function(t) {
           return Math.floor(t / 2)
          })),
          i = n.map((function(t, e) {
           return t - r[e]
          }));
         return n.map((function(t, e) {
          return [r[e], i[e]]
         }))
        }([l.filterHeight, l.filterWidth], h) : [
         [0, 0],
         [0, 0]
        ];
        var p = 1 === h[0] && 1 === h[1],
         f = function(t, e, n) {
          var r = n.map((function(t) {
            return t[0]
           })),
           i = n.map((function(t) {
            return t[1]
           })),
           o = t.concat(r, i),
           a = e.map((function(t, e) {
            return (t - o[e] % t) % t
           })),
           s = i.map((function(t, e) {
            return t + a[e]
           })),
           u = e.map((function(t, e) {
            return [r[e], s[e]]
           })),
           c = e.map((function(t, e) {
            return [0, a[e]]
           }));
          return [u, c]
         }([l.inHeight, l.inWidth], h, c),
         d = f[0],
         v = f[1],
         m = p ? r : "valid",
         g = p ? s : gr(s, h, d),
         y = ("avg" === n ? function() {
          return Lc(g, e, o, 1, m)
         } : function() {
          return Mc(g, e, o, 1, m)
         })(),
         b = p ? y : Zn(y, h, v);
        return u ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b
       }
      }),
      jc = ln({
       maxPool3d_: function(t, e, n, r, i, o, a) {
        void 0 === o && (o = "NDHWC");
        var s = Ze(t, "x", "maxPool3d"),
         u = s,
         c = !1;
        4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == a && (a = [1, 1, 1]), k(5 === u.rank, (function() {
         return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + "."
        })), k("NDHWC" === o, (function() {
         return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + o
        })), k(ui(n, a), (function() {
         return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'"
        })), null != i && k(T(r), (function() {
         return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + "."
        }));
        var l = Qr(u.shape, e, n, a, r, i, o),
         h = Bt.runKernelFunc((function(t, e) {
          var n = t.maxPool3d(u, l);
          return e([u, n]), n
         }), {
          x: u
         }, (function(t, o) {
          var s = o[0],
           u = o[1];
          return {
           x: function() {
            return function(t, e, n, r, i, o, a, s) {
             var u = Ze(t, "dy", "maxPool3dBackprop"),
              c = Ze(e, "input", "maxPool3dBackprop"),
              l = Ze(n, "output", "maxPool3dBackprop"),
              h = u,
              p = c,
              f = l,
              d = !1;
             4 === c.rank && (d = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), p = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), f = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3])), k(5 === h.rank, (function() {
              return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h.rank + "."
             })), k(5 === p.rank, (function() {
              return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + p.rank + "."
             })), k(5 === f.rank, (function() {
              return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + f.rank + "."
             })), null == o && (o = [1, 1, 1]), k(ui(i, o), (function() {
              return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + o + "'"
             })), null != s && k(T(a), (function() {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + a + "."
             }));
             var v = Qr(p.shape, r, i, o, a, s),
              m = Bt.runKernelFunc((function(t) {
               return t.maxPool3dBackprop(h, p, f, v)
              }), {
               dy5D: h,
               input5D: p
              });
             return d ? m.as4D(m.shape[1], m.shape[2], m.shape[3], m.shape[4]) : m
            }(t, s, u, e, n, a, r, i)
           }
          }
         }));
        return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
       }
      }),
      Wc = ln({
       avgPool3d_: function(t, e, n, r, i, o, a) {
        void 0 === o && (o = "NDHWC");
        var s = Ze(t, "x", "avgPool3d", "float32"),
         u = s,
         c = !1;
        4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == a && (a = [1, 1, 1]), k(5 === u.rank, (function() {
         return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + "."
        })), k("NDHWC" === o, (function() {
         return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + o
        })), k(ui(n, a), (function() {
         return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + a + "'"
        })), null != i && k(T(r), (function() {
         return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + "."
        }));
        var l = Qr(u.shape, e, n, a, r, i, o),
         h = Bt.runKernelFunc((function(t) {
          return t.avgPool3d(u, l)
         }), {
          x: u
         }, (function(t) {
          return {
           x: function() {
            return function(t, e, n, r, i, o, a) {
             var s = Ze(t, "dy", "avgPool3dBackprop"),
              u = Ze(e, "input", "avgPool3dBackprop"),
              c = s,
              l = u,
              h = !1;
             4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])), k(5 === c.rank, (function() {
              return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c.rank + "."
             })), k(5 === l.rank, (function() {
              return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l.rank + "."
             })), null == i && (i = [1, 1, 1]), k(ui(r, i), (function() {
              return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + i + "'"
             })), null != a && k(T(o), (function() {
              return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + o + "."
             }));
             var p = Qr(l.shape, n, r, i, o, a),
              f = Bt.runKernelFunc((function(t) {
               return t.avgPool3dBackprop(c, l, p)
              }), {
               dy5D: c,
               input5D: l
              });
             return h ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f
            }(t, u, e, n, a, r, i)
           }
          }
         }));
        return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h
       }
      }),
      Vc = ln({
       slice_: function(t, e, n) {
        var r, i, o = Ze(t, "x", "slice");
        if (0 === o.rank) throw new Error("Slicing scalar is not possible");
        (r = "number" == typeof e ? [e].concat(new Array(o.rank - 1).fill(0)) : e.length < o.rank ? e.concat(new Array(o.rank - e.length).fill(0)) : e.slice()).forEach((function(t) {
         k(-1 !== t, (function() {
          return "slice() does not support negative begin indexing."
         }))
        })), i = (i = null == n ? new Array(o.rank).fill(-1) : "number" == typeof n ? [n].concat(new Array(o.rank - 1).fill(-1)) : n.length < o.rank ? n.concat(new Array(o.rank - n.length).fill(-1)) : n).map((function(t, e) {
         return t >= 0 ? t : (k(-1 === t, (function() {
          return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + e + "."
         })), o.shape[e] - r[e])
        })), Mr(o, r, i);
        var a = o.shape,
         s = {
          begin: r,
          size: i
         };
        return Bt.runKernelFunc((function(t) {
         return t.slice(o, r, i)
        }), {
         x: o
        }, (function(t) {
         for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], a[n] - r[n] - i[n]]);
         return {
          x: function() {
           return t.pad(e)
          }
         }
        }), "Slice", s)
       }
      }),
      Uc = ln({
       slice1d_: function(t, e, n) {
        var r = Ze(t, "x", "slice1d");
        return k(1 === r.rank, (function() {
         return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor"
        })), Vc(r, [e], [n])
       }
      }),
      Hc = ln({
       slice2d_: function(t, e, n) {
        var r = Ze(t, "x", "slice2d");
        return k(2 === r.rank, (function() {
         return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor"
        })), Vc(r, e, n)
       }
      }),
      $c = ln({
       slice3d_: function(t, e, n) {
        var r = Ze(t, "x", "slice3d");
        return k(3 === r.rank, (function() {
         return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor"
        })), Vc(r, e, n)
       }
      }),
      Gc = ln({
       slice4d_: function(t, e, n) {
        var r = Ze(t, "x", "slice4d");
        return k(4 === r.rank, (function() {
         return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor"
        })), Vc(r, e, n)
       }
      });
 
     function qc(t, e, n, r, i) {
      return e.rank < n.rank && (e = e.reshape(nn(e.shape, r))), t.rank < n.rank && (t = t.reshape(nn(t.shape, r))), {
       x: function() {
        var r = t.mul(n.equal(e).cast(t.dtype));
        return null == i ? r : r.transpose(i)
       }
      }
     }
     var Kc = ln({
       all_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "all", "bool"),
         i = B(e, r.shape),
         o = i,
         a = on(o, r.rank);
        null != a && (r = r.transpose(a), o = sn(o.length, r.rank));
        var s = Bt.runKernelFunc((function(t) {
         return t.all(r, o)
        }), {
         $x: r
        });
        if (n) {
         var u = nn(s.shape, i);
         return s.reshape(u)
        }
        return s
       }
      }),
      Xc = ln({
       any_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "any", "bool"),
         i = B(e, r.shape),
         o = i,
         a = on(o, r.rank);
        null != a && (r = r.transpose(a), o = sn(o.length, r.rank));
        var s = Bt.runKernelFunc((function(t) {
         return t.any(r, o)
        }), {
         $x: r
        });
        if (n) {
         var u = nn(s.shape, i);
         return s.reshape(u)
        }
        return s
       }
      }),
      Yc = ln({
       argMax_: function(t, e) {
        void 0 === e && (e = 0);
        var n = Ze(t, "x", "argMax");
        null == e && (e = 0);
        var r = B(e, n.shape),
         i = on(r, n.rank);
        null != i && (n = n.transpose(i), r = sn(r.length, n.rank));
        var o = {
          axis: r[0]
         },
         a = [n];
        return Bt.runKernelFunc((function(t, e) {
         var i = t.argMax(n, r[0]);
         return e([n]), i
        }), {
         x: n
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return Rn(n)
          }
         }
        }), "ArgMax", o, a)
       }
      }),
      Zc = ln({
       argMin_: function(t, e) {
        void 0 === e && (e = 0);
        var n = Ze(t, "x", "argMin");
        null == e && (e = 0);
        var r = B(e, n.shape),
         i = on(r, n.rank);
        return null != i && (n = n.transpose(i), r = sn(r.length, n.rank)), Bt.runKernelFunc((function(t, e) {
         var i = t.argMin(n, r[0]);
         return e([n]), i
        }), {
         $x: n
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return Rn(n)
          }
         }
        }))
       }
      }),
      Jc = ln({
       logSumExp_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "logSumExp"),
         i = B(e, r.shape),
         o = r.max(i, !0),
         a = r.sub(o).exp().sum(i).log(),
         s = o.reshape(a.shape).add(a);
        if (n) {
         var u = nn(s.shape, i);
         return s.reshape(u)
        }
        return s
       }
      }),
      Qc = ln({
       max_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "max"),
         i = r,
         o = B(e, r.shape),
         a = o,
         s = on(a, r.rank);
        null != s && (r = r.transpose(s), a = sn(a.length, r.rank));
        var u = [r],
         c = Bt.runKernelFunc((function(t, e) {
          var n = t.max(r, a);
          return e([i, n]), n
         }), {
          x: r
         }, (function(t, e) {
          return qc(t, e[1], e[0], o, s)
         }), "Max", {
          axes: a
         }, u, [!0]);
        if (n) {
         var l = nn(c.shape, o);
         c = c.reshape(l)
        }
        return c
       }
      }),
      tl = ln({
       mean_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "mean"),
         i = B(e, r.shape),
         o = N(en(r.shape, i)[1]);
        return Ur((function(t) {
         var r = mn(o);
         return {
          value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),
          gradFunc: function(e) {
           var n = t.shape.slice();
           return i.forEach((function(t) {
            n[t] = 1
           })), e.reshape(n).mul(En(t.shape, "float32")).div(o)
          }
         }
        }))(r)
       }
      }),
      el = ln({
       min_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "min"),
         i = r,
         o = B(e, r.shape),
         a = o,
         s = on(a, r.rank);
        null != s && (r = r.transpose(s), a = sn(a.length, r.rank));
        var u = [r],
         c = Bt.runKernelFunc((function(t, e) {
          var n = t.min(r, a);
          return e([i, n]), n
         }), {
          x: r
         }, (function(t, e) {
          return qc(t, e[1], e[0], o, s)
         }), "Min", {
          axes: a
         }, u, [!0]);
        if (n) {
         var l = nn(c.shape, o);
         c = c.reshape(l)
        }
        return c
       }
      }),
      nl = ln({
       moments_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = B(e, (t = Ze(t, "x", "moments")).shape),
         i = t.mean(r, n),
         o = i.shape;
        n || (o = nn(i.shape, r));
        var a = t.toFloat().sub(i.reshape(o)).square();
        return {
         mean: i,
         variance: a.mean(r, n)
        }
       }
      }),
      rl = ln({
       sum_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "sum");
        "bool" === r.dtype && (r = r.toInt());
        var i = B(e, r.shape);
        return Ur((function(t) {
         var e = on(i, t.rank),
          r = i,
          o = t;
         null != e && (o = t.transpose(e), r = sn(r.length, t.rank));
         var a = function(e) {
           var n = t.shape.slice();
           return i.forEach((function(t) {
            n[t] = 1
           })), e.reshape(n).mul(En(t.shape, "float32"))
          },
          s = {
           axes: r
          },
          u = Bt.runKernelFunc((function(t) {
           return t.sum(o, r)
          }), {
           x: o
          }, (function(t) {
           return {
            x: function() {
             return a(t)
            }
           }
          }), "Sum", s);
         if (n) {
          var c = nn(u.shape, i);
          u = u.reshape(c)
         }
         return {
          value: u,
          gradFunc: a
         }
        }))(r)
       }
      }),
      il = ln({
       prod_: function(t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ze(t, "x", "prod");
        "bool" === r.dtype && (r = r.toInt());
        var i = B(e, r.shape),
         o = on(i, r.rank),
         a = i,
         s = r;
        null != o && (s = r.transpose(o), a = sn(a.length, r.rank));
        var u = Bt.runKernelFunc((function(t) {
         return t.prod(s, a)
        }), {
         permutedX: s
        });
        if (n) {
         var c = nn(u.shape, i);
         u = u.reshape(c)
        }
        return u
       }
      }),
      ol = ln({
       elu_: function(t) {
        var e = Ze(t, "x", "elu");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.elu(e);
         return n([r]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           return Bt.runKernelFunc((function(e) {
            return e.eluDer(t, n)
           }), {
            dy: t,
            y: n
           })
          }
         }
        }))
       }
      }),
      al = ln({
       leakyRelu_: function(t, e) {
        void 0 === e && (e = .2);
        var n = Ze(t, "x", "leakyRelu");
        return Lu(mn(e).mul(n), n)
       }
      }),
      sl = ln({
       prelu_: function(t, e) {
        var n = Ze(t, "x", "prelu"),
         r = Ze(e, "alpha", "prelu");
        return Bt.runKernelFunc((function(t, e) {
         var i = t.prelu(n, r);
         return e([n, r]), i
        }), {
         x: n,
         alpha: r
        }, (function(t, e) {
         var n = e[0],
          r = e[1],
          i = n.greater(0);
         return {
          x: function() {
           return Iu(i, t, t.mul(r))
          },
          alpha: function() {
           var e = Iu(i, Rn(t), t.mul(n)),
            o = Yr(r.shape, t.shape);
           return o.length > 0 && (e = e.sum(o)), e.reshape(r.shape)
          }
         }
        }), "Prelu")
       }
      }),
      ul = ln({
       relu_: function(t) {
        var e = Ze(t, "x", "relu");
        return "bool" === e.dtype ? e.toInt() : Bt.runKernelFunc((function(t, n) {
         var r = t.relu(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          x: function() {
           return t.mulStrict(n.step().toFloat())
          }
         }
        }), "Relu")
       }
      }),
      cl = ln({
       relu6_: function(t) {
        var e = Ze(t, "x", "relu6");
        return "bool" === e.dtype ? e.toInt() : Bt.runKernelFunc((function(t, n) {
         var r = t.relu6(e);
         return n([e]), r
        }), {
         x: e
        }, (function(t, e) {
         var n = e[0],
          r = n.lessEqual(6).mul(n.step());
         return {
          x: function() {
           return t.mulStrict(r.toFloat())
          }
         }
        }), "Relu6")
       }
      }),
      ll = ln({
       selu_: function(t) {
        var e = Ze(t, "x", "selu");
        return Bt.runKernelFunc((function(t, n) {
         var r = t.selu(e);
         return n([e]), r
        }), {
         $x: e
        }, (function(t, e) {
         var n = e[0];
         return {
          $x: function() {
           var e = n.greater(mn(0)),
            r = mn(qa),
            i = mn(Ka),
            o = t.mul(i),
            a = t.mul(r).mul(n.toFloat().exp());
           return Iu(e, o, a)
          }
         }
        }))
       }
      }),
      hl = ln({
       transpose_: function(t, e) {
        var n = Ze(t, "x", "transpose");
        if (null == e && (e = n.shape.map((function(t, e) {
          return e
         })).reverse()), k(n.rank === e.length, (function() {
          return "Error in transpose: rank of input " + n.rank + " must match length of perm " + e + "."
         })), e.forEach((function(t) {
          k(t >= 0 && t < n.rank, (function() {
           return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + e
          }))
         })), n.rank <= 1) return n.clone();
        var r = {
         perm: e
        };
        return Bt.runKernelFunc((function(t) {
         return t.transpose(n, e)
        }), {
         x: n
        }, (function(t) {
         var n = an(e);
         return {
          x: function() {
           return t.transpose(n)
          }
         }
        }), "Transpose", r)
       }
      }),
      pl = ln({
       localResponseNormalization_: function(t, e, n, r, i) {
        void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === i && (i = .5);
        var o = Ze(t, "x", "localResponseNormalization");
        k(4 === o.rank || 3 === o.rank, (function() {
         return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + o.rank + "."
        })), k(T(e), (function() {
         return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + "."
        }));
        var a = o,
         s = !1;
        3 === o.rank && (s = !0, a = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]));
        var u = Bt.runKernelFunc((function(t, o) {
         var s = t.localResponseNormalization4D(a, e, n, r, i);
         return o([a, s]), s
        }), {
         x4D: a
        }, (function(t, o) {
         var a = o[0],
          s = o[1];
         return {
          x4D: function() {
           return Bt.runKernelFunc((function(o) {
            return o.LRNGrad(t, a, s, e, n, r, i)
           }), {})
          }
         }
        }));
        return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
       }
      }),
      fl = ln({
       norm_: function(t, e, n, r) {
        void 0 === e && (e = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);
        var i = function t(e, n, r) {
          if (void 0 === r && (r = null), 0 === e.rank) return e.abs();
          if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);
          if (1 === e.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
           if (1 === n) return e.abs().sum(r);
           if (n === 1 / 0) return e.abs().max(r);
           if (n === -1 / 0) return e.abs().min(r);
           if ("euclidean" === n || 2 === n) return e.abs().pow(mn(2, "int32")).sum(r).sqrt();
           throw new Error("Error in norm: invalid ord value: " + n)
          }
          if (Array.isArray(r) && 2 === r.length) {
           if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);
           if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
           if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
           if ("fro" === n || "euclidean" === n) return e.square().sum(r).sqrt();
           throw new Error("Error in norm: invalid ord value: " + n)
          }
          throw new Error("Error in norm: invalid axis: " + r)
         }(t = Ze(t, "x", "norm"), e, n),
         o = i.shape;
        if (r) {
         var a = B(n, t.shape);
         o = nn(i.shape, a)
        }
        return i.reshape(o)
       }
      }),
      dl = ln({
       basicLSTMCell_: function(t, e, n, r, i, o) {
        var a = Ze(t, "forgetBias", "basicLSTMCell"),
         s = Ze(e, "lstmKernel", "basicLSTMCell"),
         u = Ze(n, "lstmBias", "basicLSTMCell"),
         c = Ze(r, "data", "basicLSTMCell"),
         l = Ze(i, "c", "basicLSTMCell"),
         h = Ze(o, "h", "basicLSTMCell"),
         p = c.concat(h, 1).matMul(s).add(u),
         f = p.shape[0],
         d = p.shape[1] / 4,
         v = [f, d],
         m = p.slice([0, 0], v),
         g = p.slice([0, d], v),
         y = p.slice([0, 2 * d], v),
         b = p.slice([0, 3 * d], v),
         x = m.sigmoid().mulStrict(g.tanh()).addStrict(l.mulStrict(a.add(y).sigmoid())),
         w = x.tanh().mulStrict(b.sigmoid());
        return [x, w]
       }
      }),
      vl = ln({
       multiRNNCell_: function(t, e, n, r) {
        for (var i = Ze(e, "data", "multiRNNCell"), o = Je(n, "c", "multiRNNCell"), a = Je(r, "h", "multiRNNCell"), s = i, u = [], c = 0; c < t.length; c++) {
         var l = t[c](s, o[c], a[c]);
         u.push(l[0]), u.push(l[1]), s = l[1]
        }
        var h = [],
         p = [];
        for (c = 0; c < u.length; c += 2) h.push(u[c]), p.push(u[c + 1]);
        return [h, p]
       }
      }),
      ml = ln({
       movingAverage_: function(t, e, n, r, i) {
        void 0 === i && (i = !0);
        var o = Ze(t, "v", "movingAverage"),
         a = Ze(e, "x", "movingAverage"),
         s = Ze(n, "decay", "movingAverage");
        _t(o, a), k(R(o.shape, a.shape), (function() {
         return "Shape mismatch in v and x"
        }));
        var u = mn(1),
         c = u.sub(s),
         l = a.sub(o).mul(c);
        if (i) {
         k(null != r, (function() {
          return "When using zeroDebias: true, step is required."
         }));
         var h = Ze(r, "step", "movingAverage");
         l = l.div(u.sub(Hu(s, h)))
        }
        return o.add(l)
       }
      }),
      gl = ln({
       stridedSlice_: function(t, e, n, r, i, o, a, s, u) {
        if (void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== a) throw new Error("ellipsis mask is not yet supported");
        var c = Ze(t, "x", "stridedSlice"),
         l = Lr(s),
         h = c.shape.slice();
        l.forEach((function(t) {
         e[t] = 0, n[t] = 1, h.splice(t, 0, 1)
        })), c = c.reshape(h);
        for (var p = 0; p < c.rank; p++) e[p] = Pr(i, e, r, c.shape, p), n[p] = zr(o, n, r, c.shape, p), r[p] = r[p] || 1;
        var f = Lr(u);
        f.forEach((function(t) {
         n[t] = e[t] + 1, r[t] = 1
        }));
        var d = Br(e, n, r),
         v = d.filter((function(t, e) {
          return -1 === f.indexOf(e)
         }));
        return r.every((function(t) {
         return 1 === t
        })) ? Vc(c, e, d).reshape(v) : Bt.runKernelFunc((function(t) {
         return t.stridedSlice(c, e, n, r)
        }), {
         $x: c
        }).reshape(v)
       }
      }),
      yl = ln({
       topk_: function(t, e, n) {
        void 0 === e && (e = 1), void 0 === n && (n = !0);
        var r = Ze(t, "x", "topk");
        if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
        var i = r.shape[r.shape.length - 1];
        if (e > i) throw new Error("'k' passed to topk() must be <= the last dimension (" + i + ") but got " + e);
        var o = Bt.runKernelFunc((function(t) {
         return t.topk(r, e, n)
        }), {
         $x: r
        });
        return {
         values: o[0],
         indices: o[1]
        }
       }
      }),
      bl = ln({
       scatterND_: function(t, e, n) {
        var r = Ze(t, "indices", "scatterND", "int32"),
         i = Ze(e, "updates", "scatterND");
        return Dr(i, r, n), Bt.runKernelFunc((function(t) {
         return t.scatterND(r, i, n)
        }), {
         indices: r,
         updates: i
        }, null, "ScatterNd", {
         shape: n
        })
       }
      }),
      xl = ln({
       fft_: function(t) {
        k("complex64" === t.dtype, (function() {
         return "The dtype for tf.spectral.fft() must be complex64 but got " + t.dtype + "."
        }));
        var e = t.shape[t.shape.length - 1],
         n = t.size / e,
         r = t.as2D(n, e);
        return Bt.runKernelFunc((function(t) {
         return t.fft(r)
        }), {
         input: t
        }).reshape(t.shape)
       }
      }),
      wl = ln({
       ifft_: function(t) {
        k("complex64" === t.dtype, (function() {
         return "The dtype for tf.spectral.ifft() must be complex64 but got " + t.dtype + "."
        }));
        var e = t.shape[t.shape.length - 1],
         n = t.size / e,
         r = t.as2D(n, e);
        return Bt.runKernelFunc((function(t) {
         return t.ifft(r)
        }), {
         input: t
        }).reshape(t.shape)
       }
      }),
      Cl = ln({
       rfft_: function(t, e) {
        k("float32" === t.dtype, (function() {
         return "The dtype for rfft() must be real value but got " + t.dtype
        }));
        var n, r = t.shape[t.shape.length - 1],
         i = t.size / r;
        if (null != e && e < r) {
         var o = t.shape.map((function(t) {
           return 0
          })),
          a = t.shape.map((function(t) {
           return t
          }));
         a[t.shape.length - 1] = e, n = t.slice(o, a), r = e
        } else if (null != e && e > r) {
         var s = t.shape.map((function(t) {
          return t
         }));
         s[t.shape.length - 1] = e - r, n = t.concat(kn(s), t.shape.length - 1), r = e
        } else n = t;
        var u = n.zerosLike(),
         c = hn(n, u).as2D(i, r),
         l = xl(c),
         h = Math.floor(r / 2) + 1,
         p = pn(l),
         f = fn(l),
         d = p.split([h, r - h], p.shape.length - 1),
         v = f.split([h, r - h], f.shape.length - 1),
         m = n.shape.slice();
        return m[n.shape.length - 1] = h, hn(d[0], v[0]).reshape(m)
       }
      }),
      Sl = ln({
       irfft_: function(t) {
        var e = t.shape[t.shape.length - 1],
         n = t.size / e;
        if (e <= 2) {
         var r = t.as2D(n, e),
          i = wl(r);
         return pn(i)
        }
        var o = [n, 2 * (e - 1)],
         a = pn(t).as2D(n, e),
         s = fn(t).as2D(n, e),
         u = a.slice([0, 1], [n, e - 2]).reverse(1),
         c = s.slice([0, 1], [n, e - 2]).reverse(1).mul(mn(-1)),
         l = a.concat(u, 1),
         h = s.concat(c, 1);
        return r = hn(l, h).as2D(o[0], o[1]), i = wl(r), pn(i)
       }
      }),
      El = Object.freeze({
       fft: xl,
       ifft: wl,
       rfft: Cl,
       irfft: Sl
      }),
      kl = ln({
       sparseToDense_: function(t, e, n, r) {
        void 0 === r && (r = 0);
        var i = Ze(t, "sparseIndices", "sparseToDense", "int32"),
         o = Ze(e, "sparseValues", "sparseToDense"),
         a = Ze(r, "defaultValue", "sparseToDense", o.dtype);
        return function(t, e, n, r) {
         if ("int32" !== t.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
         if (t.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t.shape + ".");
         var i = t.rank > 0 ? t.shape[0] : 1,
          o = t.rank > 1 ? t.shape[1] : 1;
         if (n.length !== o) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + o + ".");
         var a = e.size;
         if (0 !== e.rank && (1 !== e.rank || a !== i)) throw new Error("sparseValues has incorrect shape " + e.shape + ", should be [] or [" + i + "]");
         if (e.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
        }(i, o, n, a), Bt.runKernelFunc((function(t) {
         return t.sparseToDense(i, o, n, a)
        }), {
         $sparseIndices: i,
         $sparseValues: o,
         $defaultValue: a
        })
       }
      }),
      Il = ln({
       gatherND_: function(t, e) {
        var n = Ze(e, "indices", "gatherND", "int32"),
         r = Ze(t, "x", "gatherND");
        return Bt.runKernelFunc((function(t) {
         return t.gatherND(r, n)
        }), {
         x: r,
         indices: n
        }, null, "GatherNd")
       }
      }),
      Ol = ln({
       diag_: function(t) {
        var e = Ze(t, "x", "diag").flatten(),
         n = t.shape.concat(t.shape);
        return Bt.runKernelFunc((function(t) {
         return t.diag(e)
        }), {
         $x: e
        }).reshape(n)
       }
      }),
      Al = ln({
       dropout_: function(t, e, n, r) {
        var i = Ze(t, "x", "dropout");
        if (k("float32" === i.dtype, (function() {
          return "x has to be a floating point tensor since it's going to be scaled, but got a " + i.dtype + " tensor instead."
         })), k(e >= 0 && e < 1, (function() {
          return "rate must be a float in the range [0, 1), but got " + e + "."
         })), 0 === e) return t instanceof wt ? i.clone() : i;
        var o = function(t, e) {
          if (null == e) return t.shape.slice();
          if (R(t.shape, e)) return e;
          if (t.shape.length === e.length) {
           for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);
           return n
          }
          return e
         }(i, n),
         a = 1 - e,
         s = vr(o, 0, 1, "float32", r).add(a).floor().div(a);
        return i.mul(s)
       }
      });
 
     function Nl(t, e, n) {
      for (var r = 1 - t % 2, i = new Float32Array(t), o = 0; o < t; ++o) {
       var a = 2 * Math.PI * o / (t + r - 1);
       i[o] = e - n * Math.cos(a)
      }
      return gn(i, "float32")
     }
     var Rl, Tl = ln({
       hannWindow_: function(t) {
        return Nl(t, .5, .5)
       }
      }),
      _l = ln({
       hammingWindow_: function(t) {
        return Nl(t, .54, .46)
       }
      }),
      Dl = ln({
       frame_: function(t, e, n, r, i) {
        void 0 === r && (r = !1), void 0 === i && (i = 0);
        for (var o = 0, a = []; o + e <= t.size;) a.push(Vc(t, o, e)), o += n;
        if (r)
         for (; o < t.size;) {
          var s = o + e - t.size,
           u = Tn([Vc(t, o, e - s), In([s], i)]);
          a.push(u), o += n
         }
        return 0 === a.length ? yn([], [0, e]) : Tn(a).as2D(a.length, e)
       }
      }),
      Fl = ln({
       stft_: function(t, e, n, r, i) {
        var o;
        void 0 === i && (i = Tl), null == r && (o = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(o) / Math.log(2)))));
        for (var a = Dl(t, e, n), s = Vu(a, i(e)), u = [], c = 0; c < a.shape[0]; c++) u.push(Cl(s.slice([c, 0], [1, e]), r));
        return Tn(u)
       }
      }),
      Ml = Object.freeze({
       hannWindow: Tl,
       hammingWindow: _l,
       frame: Dl,
       stft: Fl
      }),
      Ll = function(t, e, n) {
       return void 0 === n && (n = 1), s(this, void 0, void 0, (function() {
        var r, i, o, a, s, c, l, h, p, f, d, v, m, g;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return r = Ze(t, "predictions", "inTopK"), i = Ze(e, "targets", "inTopK"), k(r.rank > 1, (function() {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + r.rank
           })), k(r.rank - 1 === i.rank, (function() {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + r.rank + " and targets rank " + i.rank
           })), I(r.shape.slice(0, r.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), o = r.shape[r.shape.length - 1], k(n > 0 && n <= o, (function() {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + o + "), but got " + n
           })), [4, r.data()];
          case 1:
           return a = u.sent(), [4, i.data()];
          case 2:
           for (s = u.sent(), c = [a.length / o, o], h = c[1], p = z("bool", l = c[0]), f = 0; f < l; f++) {
            for (d = f * h, v = a.subarray(d, d + h), m = [], g = 0; g < v.length; g++) m.push({
             value: v[g],
             index: g
            });
            for (m.sort((function(t, e) {
              return e.value - t.value
             })), p[f] = 0, g = 0; g < n; g++)
             if (m[g].index === s[f]) {
              p[f] = 1;
              break
             }
           }
           return t !== r && r.dispose(), e !== i && i.dispose(), [2, dn(p, i.shape, "bool")]
         }
        }))
       }))
      };
     ! function(t) {
      t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS"
     }(Rl || (Rl = {}));
     var Bl = ln({
       absoluteDifference_: function(t, e, n, r) {
        void 0 === r && (r = Rl.SUM_BY_NONZERO_WEIGHTS);
        var i = Ze(t, "labels", "absoluteDifference"),
         o = Ze(e, "predictions", "absoluteDifference"),
         a = null;
        null != n && (a = Ze(n, "weights", "absoluteDifference")), I(i.shape, o.shape, "Error in absoluteDifference: ");
        var s = i.sub(o).abs();
        return Pl(s, a, r)
       }
      }),
      Pl = ln({
       computeWeightedLoss_: function(t, e, n) {
        void 0 === n && (n = Rl.SUM_BY_NONZERO_WEIGHTS);
        var r = Ze(t, "losses", "computeWeightedLoss"),
         i = null;
        null != e && (i = Ze(e, "weights", "computeWeightedLoss"));
        var o = null == i ? r : r.mul(i);
        if (n === Rl.NONE) return o;
        if (n === Rl.SUM) return o.sum();
        if (n === Rl.MEAN) {
         if (null == i) return o.mean();
         var a = r.size / i.size,
          s = o.sum().div(i.sum());
         return a > 1 ? s.div(mn(a)) : s
        }
        if (n === Rl.SUM_BY_NONZERO_WEIGHTS) {
         if (null == i) return o.sum().div(mn(r.size));
         var u = i.mul(En(r.shape)).notEqual(mn(0)).sum().toFloat();
         return o.sum().div(u)
        }
        throw Error("Unknown reduction: " + n)
       }
      }),
      zl = ln({
       cosineDistance_: function(t, e, n, r, i) {
        void 0 === i && (i = Rl.SUM_BY_NONZERO_WEIGHTS);
        var o = Ze(t, "labels", "cosineDistance"),
         a = Ze(e, "predictions", "cosineDistance"),
         s = null;
        null != r && (s = Ze(r, "weights", "cosineDistance")), I(o.shape, a.shape, "Error in cosineDistance: ");
        var u = mn(1).sub(o.mul(a).sum(n, !0));
        return Pl(u, s, i)
       }
      }),
      jl = ln({
       hingeLoss_: function(t, e, n, r) {
        void 0 === r && (r = Rl.SUM_BY_NONZERO_WEIGHTS);
        var i = Ze(t, "labels", "hingeLoss"),
         o = Ze(e, "predictions", "hingeLoss"),
         a = null;
        null != n && (a = Ze(n, "weights", "hingeLoss")), I(i.shape, o.shape, "Error in hingeLoss: ");
        var s = mn(1);
        i = mn(2).mul(i).sub(s);
        var u = s.sub(i.mul(o)).relu();
        return Pl(u, a, r)
       }
      }),
      Wl = ln({
       huberLoss_: function(t, e, n, r, i) {
        void 0 === r && (r = 1), void 0 === i && (i = Rl.SUM_BY_NONZERO_WEIGHTS);
        var o = Ze(t, "labels", "huberLoss"),
         a = Ze(e, "predictions", "huberLoss"),
         s = null;
        null != n && (s = Ze(n, "weights", "huberLoss")), I(o.shape, a.shape, "Error in huberLoss: ");
        var u = mn(r),
         c = a.sub(o).abs(),
         l = Pu(c, u),
         h = c.sub(l),
         p = mn(.5).mul(l.square()).add(u.mul(h));
        return Pl(p, s, i)
       }
      }),
      Vl = ln({
       logLoss_: function(t, e, n, r, i) {
        void 0 === r && (r = 1e-7), void 0 === i && (i = Rl.SUM_BY_NONZERO_WEIGHTS);
        var o = Ze(t, "labels", "logLoss"),
         a = Ze(e, "predictions", "logLoss"),
         s = null;
        null != n && (s = Ze(n, "weights", "logLoss")), I(o.shape, a.shape, "Error in logLoss: ");
        var u = mn(1),
         c = mn(r),
         l = o.mul(a.add(c).log()).neg().sub(u.sub(o).mul(u.sub(a).add(c).log()));
        return Pl(l, s, i)
       }
      }),
      Ul = ln({
       meanSquaredError_: function(t, e, n, r) {
        void 0 === r && (r = Rl.SUM_BY_NONZERO_WEIGHTS);
        var i = Ze(t, "labels", "meanSquaredError"),
         o = Ze(e, "predictions", "meanSquaredError"),
         a = null;
        null != n && (a = Ze(n, "weights", "meanSquaredError")), I(i.shape, o.shape, "Error in meanSquaredError: ");
        var s = i.squaredDifference(o);
        return Pl(s, a, r)
       }
      }),
      Hl = ln({
       sigmoidCrossEntropy_: function(t, e, n, r, i) {
        void 0 === r && (r = 0), void 0 === i && (i = Rl.SUM_BY_NONZERO_WEIGHTS);
        var o = Ze(t, "multiClassLabels", "sigmoidCrossEntropy"),
         a = Ze(e, "logits", "sigmoidCrossEntropy"),
         s = null;
        if (null != n && (s = Ze(n, "weights", "sigmoidCrossEntropy")), I(o.shape, a.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
         var u = mn(r),
          c = mn(1),
          l = mn(.5);
         o = o.mul(c.sub(u)).add(l.mul(u))
        }
        var h = function(t, e) {
         var n = Ze(t, "labels", "sigmoidCrossEntropyWithLogits"),
          r = Ze(e, "logits", "sigmoidCrossEntropyWithLogits");
         I(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
         var i = r.relu(),
          o = r.mul(n),
          a = r.abs().neg().exp().log1p();
         return i.sub(o).add(a)
        }(o, a);
        return Pl(h, s, i)
       }
      }),
      $l = ln({
       softmaxCrossEntropy_: function(t, e, n, r, i) {
        void 0 === r && (r = 0), void 0 === i && (i = Rl.SUM_BY_NONZERO_WEIGHTS);
        var o = Ze(t, "onehotLabels", "softmaxCrossEntropy"),
         a = Ze(e, "logits", "softmaxCrossEntropy"),
         s = null;
        if (null != n && (s = Ze(n, "weights", "softmaxCrossEntropy")), I(o.shape, a.shape, "Error in softmaxCrossEntropy: "), r > 0) {
         var u = mn(r),
          c = mn(1),
          l = mn(o.shape[1]);
         o = o.mul(c.sub(u)).add(u.div(l))
        }
        var h = function(t, e, n) {
         if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e.rank + " and dim was " + n);
         return Ur((function(t, e, r) {
          var i = e.logSumExp([n], !0),
           o = e.toFloat().sub(i);
          return r([t, o]), {
           value: o.mul(t).neg().sum([n]),
           gradFunc: function(t, e) {
            var r = e[0],
             i = e[1],
             o = nn(t.shape, [n]);
            return [t.reshape(o).mul(r.toFloat().sub(i.exp())), t.reshape(o).mul(i.exp().sub(r.toFloat()))]
           }
          }
         }))(t, e)
        }(o, a);
        return Pl(h, s, i)
       }
      }),
      Gl = Object.freeze({
       get Reduction() {
        return Rl
       },
       absoluteDifference: Bl,
       computeWeightedLoss: Pl,
       cosineDistance: zl,
       hingeLoss: jl,
       huberLoss: Wl,
       logLoss: Vl,
       meanSquaredError: Ul,
       sigmoidCrossEntropy: Hl,
       softmaxCrossEntropy: $l
      });
 
     function ql(t, e) {
      return void 0 === e && (e = !1), Bt.tidy((function() {
       if (2 !== t.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t.shape.length + "D Tensor.");
       for (var n = t.shape[0], r = t.shape[1], i = ir(n), o = t.clone(), a = yn([
         [1]
        ], [1, 1]), s = a.clone(), u = n >= r ? r : n, c = function(t) {
         var e, u = o,
          c = s,
          l = i;
         e = Bt.tidy((function() {
          var e = o.slice([t, t], [n - t, 1]),
           u = e.norm(),
           c = o.slice([t, t], [1, 1]),
           l = yn([
            [-1]
           ]).where(c.greater(0), yn([
            [1]
           ])),
           h = c.sub(l.mul(u)),
           p = e.div(h);
          s = 1 === p.shape[0] ? a.clone() : a.concat(p.slice([1, 0], [p.shape[0] - 1, p.shape[1]]), 0);
          var f = l.matMul(h).div(u).neg(),
           d = o.slice([t, 0], [n - t, r]),
           v = f.mul(s);
          if (0 === t) o = d.sub(v.matMul(s.transpose().matMul(d)));
          else {
           var m = d.sub(v.matMul(s.transpose().matMul(d)));
           o = o.slice([0, 0], [t, r]).concat(m, 0)
          }
          var g = i.slice([0, t], [n, i.shape[1] - t]);
          if (0 === t) i = g.sub(g.matMul(s).matMul(v.transpose()));
          else {
           var y = g.sub(g.matMul(s).matMul(v.transpose()));
           i = i.slice([0, 0], [n, t]).concat(y, 1)
          }
          return [s, o, i]
         })), s = e[0], o = e[1], i = e[2], Ge([u, c, l])
        }, l = 0; l < u; ++l) c(l);
       return !e && n > r && (i = i.slice([0, 0], [n, r]), o = o.slice([0, 0], [r, r])), [i, o]
      }))
     }
     var Kl = ln({
       bandPart_: function(t, e, n) {
        if (e % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e + ".");
        if (n % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n + ".");
        var r = Ze(t, "a", "bandPart");
        if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
        var i = r.shape,
         o = r.shape.slice(-2),
         a = o[0],
         s = o[1];
        if (!(e <= a)) throw new Error("bandPart(): numLower (" + e + ") must not be greater than the number of rows (" + a + ").");
        if (!(n <= s)) throw new Error("bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ").");
        e < 0 && (e = a), n < 0 && (n = s);
        var u = An(0, a, 1, "int32").reshape([-1, 1]),
         c = An(0, s, 1, "int32"),
         l = Ku(u, c),
         h = Cu(l.lessEqual(mn(+e, "int32")), l.greaterEqual(mn(-n, "int32"))),
         p = kn([a, s], r.dtype);
        return br(Cr(r.reshape([-1, a, s])).map((function(t) {
         return Iu(h, t, p)
        }))).reshape(i)
       }
      }),
      Xl = ln({
       gramSchmidt_: function(t) {
        var e;
        if (Array.isArray(t)) {
         e = !1, k(null != t && t.length > 0, (function() {
          return "Gram-Schmidt process: input must not be null, undefined, or empty"
         }));
         for (var n = t[0].shape[0], r = function(e) {
           k(t[e].shape[0] === n, (function() {
            return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t[e].shape[0] + " vs. " + n + ")"
           }))
          }, i = 1; i < t.length; ++i) r(i)
        } else e = !0, t = Ln(t, t.shape[0], 0).map((function(t) {
         return yr(t, [0])
        }));
        k(t.length <= t[0].shape[0], (function() {
         return "Gram-Schmidt: Number of vectors (" + t.length + ") exceeds number of dimensions (" + t[0].shape[0] + ")."
        }));
        var o = [],
         a = t,
         s = function(t) {
          o.push(Bt.tidy((function() {
           var e = a[t];
           if (t > 0)
            for (var n = 0; n < t; ++n) {
             var r = rl(o[n].mulStrict(e)).mul(o[n]);
             e = e.sub(r)
            }
           return e.div(fl(e, "euclidean"))
          })))
         };
        for (i = 0; i < t.length; ++i) s(i);
        return e ? br(o, 0) : o
       }
      }),
      Yl = ln({
       qr_: function(t, e) {
        if (void 0 === e && (e = !1), t.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t.rank);
        if (2 === t.rank) return ql(t, e);
        var n = t.shape.slice(0, t.shape.length - 2).reduce((function(t, e) {
          return t * e
         })),
         r = Cr(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),
         i = [],
         o = [];
        return r.forEach((function(t) {
         var n = ql(t, e),
          r = n[0],
          a = n[1];
         i.push(r), o.push(a)
        })), [br(i, 0).reshape(t.shape), br(o, 0).reshape(t.shape)]
       }
      }),
      Zl = Object.freeze({
       bandPart: Kl,
       gramSchmidt: Xl,
       qr: Yl
      });
 
     function Jl(t, e, n, r, i, o) {
      null == r && (r = .5), null == i && (i = Number.NEGATIVE_INFINITY), null == o && (o = 0);
      var a = t.shape[0];
      return n = Math.min(n, a), k(0 <= r && r <= 1, (function() {
       return "iouThreshold must be in [0, 1], but was '" + r + "'"
      })), k(2 === t.rank, (function() {
       return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'"
      })), k(4 === t.shape[1], (function() {
       return "boxes must have 4 columns, but 2nd dimension was " + t.shape[1]
      })), k(1 === e.rank, (function() {
       return "scores must be a 1D tensor"
      })), k(e.shape[0] === a, (function() {
       return "scores has incompatible shape with boxes. Expected " + a + ", but was " + e.shape[0]
      })), k(0 <= o && o <= 1, (function() {
       return "softNmsSigma must be in [0, 1], but was '" + o + "'"
      })), {
       maxOutputSize: n,
       iouThreshold: r,
       scoreThreshold: i,
       softNmsSigma: o
      }
     }
     var Ql = ln({
       resizeBilinear_: function(t, e, n) {
        void 0 === n && (n = !1);
        var r = Ze(t, "images", "resizeBilinear");
        k(3 === r.rank || 4 === r.rank, (function() {
         return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + "."
        })), k(2 === e.length, (function() {
         return "Error in resizeBilinear: new shape must 2D, but got shape " + e + "."
        }));
        var i = r,
         o = !1;
        3 === r.rank && (o = !0, i = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
        var a = e[0],
         s = e[1],
         u = Bt.runKernelFunc((function(t, e) {
          return e([i]), t.resizeBilinear(i, a, s, n)
         }), {
          x: i
         }, (function(t, e) {
          return {
           x: function() {
            return Bt.runKernelFunc((function(r) {
             return r.resizeBilinearBackprop(t, e[0], n)
            }), {})
           }
          }
         }), "ResizeBilinear", {
          alignCorners: n,
          newHeight: a,
          newWidth: s
         });
        return o ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
       }
      }),
      th = ln({
       resizeNearestNeighbor_: function(t, e, n) {
        void 0 === n && (n = !1);
        var r = Ze(t, "images", "resizeNearestNeighbor");
        k(3 === r.rank || 4 === r.rank, (function() {
         return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + "."
        })), k(2 === e.length, (function() {
         return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + "."
        })), k("float32" === r.dtype || "int32" === r.dtype, (function() {
         return "`images` must have `int32` or `float32` as dtype"
        }));
        var i = r,
         o = !1;
        3 === r.rank && (o = !0, i = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
        var a = e[0],
         s = e[1],
         u = Bt.runKernelFunc((function(t, e) {
          return e([i]), t.resizeNearestNeighbor(i, a, s, n)
         }), {
          batchImages: i
         }, (function(t, e) {
          return {
           batchImages: function() {
            return Bt.runKernelFunc((function(r) {
             return r.resizeNearestNeighborBackprop(t, e[0], n)
            }), {})
           }
          }
         }));
        return o ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
       }
      }),
      eh = ln({
       nonMaxSuppression_: function(t, e, n, r, i) {
        void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY);
        var o = Ze(t, "boxes", "nonMaxSuppression"),
         a = Ze(e, "scores", "nonMaxSuppression"),
         s = Jl(o, a, n, r, i);
        n = s.maxOutputSize, r = s.iouThreshold, i = s.scoreThreshold;
        var u = {
         maxOutputSize: n,
         iouThreshold: r,
         scoreThreshold: i
        };
        return Bt.runKernelFunc((function(t) {
         return t.nonMaxSuppression(o, a, n, r, i)
        }), {
         boxes: o,
         scores: a
        }, null, "NonMaxSuppressionV3", u)
       }
      }),
      nh = function(t, e, n, r, i) {
       return void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), s(this, void 0, void 0, (function() {
        var o, a, s, c, l, h, p;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return o = Ze(t, "boxes", "nonMaxSuppressionAsync"), a = Ze(e, "scores", "nonMaxSuppressionAsync"), s = Jl(o, a, n, r, i), n = s.maxOutputSize, r = s.iouThreshold, i = s.scoreThreshold, [4, Promise.all([o.data(), a.data()])];
          case 1:
           return c = u.sent(), l = c[0], h = c[1], p = bi(l, h, n, r, i), o !== t && o.dispose(), a !== e && a.dispose(), [2, p]
         }
        }))
       }))
      },
      rh = ln({
       nonMaxSuppressionWithScore_: function(t, e, n, r, i, o) {
        void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === o && (o = 0);
        var a = Ze(t, "boxes", "nonMaxSuppression"),
         s = Ze(e, "scores", "nonMaxSuppression"),
         u = Jl(a, s, n, r, i, o),
         c = {
          maxOutputSize: n = u.maxOutputSize,
          iouThreshold: r = u.iouThreshold,
          scoreThreshold: i = u.scoreThreshold,
          softNmsSigma: o = u.softNmsSigma
         },
         l = Bt.runKernel("NonMaxSuppressionV5", {
          boxes: a,
          scores: s
         }, c);
        return {
         selectedIndices: l[0],
         selectedScores: l[1]
        }
       }
      }),
      ih = function(t, e, n, r, i, o) {
       return void 0 === r && (r = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === o && (o = 0), s(this, void 0, void 0, (function() {
        var a, s, c, l, h, p, f;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return a = Ze(t, "boxes", "nonMaxSuppressionAsync"), s = Ze(e, "scores", "nonMaxSuppressionAsync"), c = Jl(a, s, n, r, i, o), n = c.maxOutputSize, r = c.iouThreshold, i = c.scoreThreshold, o = c.softNmsSigma, [4, Promise.all([a.data(), s.data()])];
          case 1:
           return l = u.sent(), h = l[0], p = l[1], f = xi(h, p, n, r, i, o), a !== t && a.dispose(), s !== e && s.dispose(), [2, f]
         }
        }))
       }))
      },
      oh = ln({
       cropAndResize_: function(t, e, n, r, i, o) {
        var a = Ze(t, "image", "cropAndResize"),
         s = Ze(e, "boxes", "cropAndResize", "float32"),
         u = Ze(n, "boxInd", "cropAndResize", "int32");
        i = i || "bilinear", o = o || 0;
        var c = s.shape[0];
        return k(4 === a.rank, (function() {
         return "Error in cropAndResize: image must be rank 4,but got rank " + a.rank + "."
        })), k(2 === s.rank && 4 === s.shape[1], (function() {
         return "Error in cropAndResize: boxes must be have size [" + c + ",4] but had shape " + s.shape + "."
        })), k(1 === u.rank && u.shape[0] === c, (function() {
         return "Error in cropAndResize: boxInd must be have size [" + c + "] but had shape " + s.shape + "."
        })), k(2 === r.length, (function() {
         return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + "."
        })), k(r[0] >= 1 && r[1] >= 1, (function() {
         return "cropSize must be atleast [1,1], but was " + r
        })), k("bilinear" === i || "nearest" === i, (function() {
         return "method must be bilinear or nearest, but was " + i
        })), Bt.runKernelFunc((function(t, e) {
         return t.cropAndResize(a, s, u, r, i, o)
        }), {
         images: a,
         boxes: s,
         boxInd: u
        }, null, "CropAndResize", {
         method: i,
         extrapolationValue: o,
         cropSize: r
        })
       }
      }),
      ah = Object.freeze({
       resizeBilinear: Ql,
       resizeNearestNeighbor: th,
       nonMaxSuppression: eh,
       nonMaxSuppressionAsync: nh,
       nonMaxSuppressionWithScore: rh,
       nonMaxSuppressionWithScoreAsync: ih,
       cropAndResize: oh
      }),
      sh = function(t, e) {
       return !(t > 0) || "linear" === e
      },
      uh = function(t, e, n) {
       if (null == n || "linear" === n) return t;
       if ("relu" === n) return t.mul(e.step());
       throw new Error("Gradient for activation " + n + " has not been implemented yet.")
      },
      ch = function(t, e) {
       var n = e,
        r = Yr(t.shape, e.shape);
       return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape)
      },
      lh = function(t, e, n) {
       if ("linear" === e) return t;
       if ("relu" === e) return ul(t);
       if ("elu" === e) return ol(t);
       if ("relu6" === e) return cl(t);
       if ("prelu" === e) return sl(t, n);
       throw new Error("Unknown fused activation " + e + ".")
      },
      hh = ln({
       fusedMatMul_: function(t) {
        var e, n = t.a,
         r = t.b,
         i = t.transposeA,
         o = void 0 !== i && i,
         a = t.transposeB,
         s = void 0 !== a && a,
         u = t.bias,
         c = t.activation,
         l = void 0 === c ? "linear" : c,
         h = t.preluActivationWeights;
        if (!1 === sh(Bt.state.gradientDepth, l)) {
         var p = Oc(n, r, o, s);
         return null != u && (p = Au(p, u)), lh(p, l, h)
        }
        var f = Ze(n, "a", "fused matMul"),
         d = Ze(r, "b", "fused matMul");
        e = Tt(f, d), f = e[0], d = e[1];
        var v = o ? f.shape[f.rank - 2] : f.shape[f.rank - 1],
         m = s ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
         g = o ? f.shape[f.rank - 1] : f.shape[f.rank - 2],
         y = s ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
         b = f.shape.slice(0, -2),
         x = d.shape.slice(0, -2),
         w = N(b),
         C = N(x);
        k(f.rank >= 2 && d.rank >= 2 && f.rank === d.rank, (function() {
         return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + f.rank + " and " + d.rank + "."
        })), k(R(b, x), (function() {
         return "Error in fused matMul: outer dimensions (" + b + ") and (" + x + ") of Tensors with shapes " + f.shape + " and " + d.shape + " must match."
        })), k(v === m, (function() {
         return "Error in fused matMul: inner shapes (" + v + ") and (" + m + ") of Tensors with shapes " + f.shape + " and " + d.shape + " and transposeA=" + o + " and transposeB=" + s + " must match."
        }));
        var S, E, I = f.shape.slice(0, -2).concat([g, y]),
         O = o ? f.as3D(w, v, g) : f.as3D(w, g, v),
         A = s ? d.as3D(C, y, m) : d.as3D(C, m, y);
        null != u && Zr(I, (S = Tt(S = Ze(u, "bias", "fused matMul"), f)[0]).shape), null != h && (E = Ze(h, "prelu weights", "fused matMul"));
        var T = {
         $a: O,
         $b: A
        };
        return null != u && (T.$bias = S), null != h && (T.$preluActivationWeights = E), Bt.runKernelFunc((function(t, e) {
         var n = t.fusedBatchMatMul({
          a: O,
          b: A,
          transposeA: o,
          transposeB: s,
          bias: S,
          activation: l,
          preluActivationWeights: E
         });
         return e([O, A, n]), n
        }), T, (function(t, e) {
         var n = e[0],
          r = e[1],
          i = e[2],
          a = uh(t, i, l),
          c = {};
         return null != u && (c = {
          $bias: function() {
           return ch(S, a)
          }
         }), o || s ? !o && s ? Object.assign({
          $a: function() {
           return a.matMul(r, !1, !1)
          },
          $b: function() {
           return a.matMul(n, !0, !1)
          }
         }, c) : o && !s ? Object.assign({
          $a: function() {
           return r.matMul(a, !1, !0)
          },
          $b: function() {
           return n.matMul(a, !1, !1)
          }
         }, c) : Object.assign({
          $a: function() {
           return r.matMul(a, !0, !0)
          },
          $b: function() {
           return a.matMul(n, !0, !0)
          }
         }, c) : Object.assign({
          $a: function() {
           return a.matMul(r, !1, !0)
          },
          $b: function() {
           return n.matMul(a, !0, !1)
          }
         }, c)
        })).reshape(I)
       }
      }),
      ph = ln({
       fusedConv2d_: function(t) {
        var e = t.x,
         n = t.filter,
         r = t.strides,
         i = t.pad,
         o = t.dataFormat,
         a = void 0 === o ? "NHWC" : o,
         s = t.dilations,
         u = void 0 === s ? [1, 1] : s,
         c = t.dimRoundingMode,
         l = t.bias,
         h = t.activation,
         p = void 0 === h ? "linear" : h,
         f = t.preluActivationWeights;
        if (p = p || "linear", !1 === sh(Bt.state.gradientDepth, p)) {
         var d = gc(e, n, r, i, a, u, c);
         return null != l && (d = Au(d, l)), lh(d, p, f)
        }
        var v = Ze(e, "x", "conv2d"),
         m = Ze(n, "filter", "conv2d"),
         g = v,
         y = !1;
        3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), k(4 === g.rank, (function() {
         return "Error in fused conv2d: input must be rank 4, but got rank " + g.rank + "."
        })), k(4 === m.rank, (function() {
         return "Error in fused conv2d: filter must be rank 4, but got rank " + m.rank + "."
        })), null != c && k(T(i), (function() {
         return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c + " but got pad " + i + "."
        })), k(g.shape[3] === m.shape[2], (function() {
         return "Error in conv2d: depth of input (" + g.shape[3] + ") must match input depth for filter " + m.shape[2] + "."
        })), k(ui(r, u), (function() {
         return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
        })), k("NHWC" === a, (function() {
         return "Error in conv2d: got dataFormat of " + a + " but only NHWC is currently supported."
        }));
        var b, x, w = ti(g.shape, m.shape, r, u, i, c);
        null != l && (b = Tt(b = Ze(l, "bias", "fused conv2d"), v)[0], Zr(w.outShape, b.shape)), null != f && (x = Ze(f, "prelu weights", "fused conv2d"));
        var C = {
         x: g,
         filter: m
        };
        null != l && (C.bias = b), null != f && (C.preluActivationWeights = x);
        var S = [m, g],
         E = Bt.runKernelFunc((function(t, e) {
          var n = t.fusedConv2d({
           input: g,
           filter: m,
           convInfo: w,
           bias: b,
           activation: p,
           preluActivationWeights: x
          });
          return e([m, g, n]), n
         }), C, (function(t, e) {
          var n = e,
           o = n[0],
           a = n[1],
           s = n[2],
           c = uh(t, s, p);
          k(si(u), (function() {
           return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'"
          }));
          var h = {};
          return null != l && (h = {
           bias: function() {
            return ch(b, c)
           }
          }), Object.assign({
           x: function() {
            return xc(a.shape, c, o, r, i)
           },
           filter: function() {
            return bc(a, c, o.shape, r, i)
           }
          }, h)
         }), "FusedConv2D", {
          convInfo: w,
          activation: p
         }, S, [!0]);
        return y ? E.as3D(E.shape[1], E.shape[2], E.shape[3]) : E
       }
      }),
      fh = ln({
       fusedDepthwiseConv2d_: function(t) {
        var e = t.x,
         n = t.filter,
         r = t.strides,
         i = t.pad,
         o = t.dataFormat,
         a = void 0 === o ? "NHWC" : o,
         s = t.dilations,
         u = void 0 === s ? [1, 1] : s,
         c = t.dimRoundingMode,
         l = t.bias,
         h = t.activation,
         p = void 0 === h ? "linear" : h,
         f = t.preluActivationWeights;
        if (!1 === sh(Bt.state.gradientDepth, p)) {
         var d = wc(e, n, r, i, a, u, c);
         return null != l && (d = Au(d, l)), lh(d, p, f)
        }
        var v = Ze(e, "x", "depthwiseConv2d"),
         m = Ze(n, "filter", "depthwiseConv2d"),
         g = v,
         y = !1;
        3 === v.rank && (y = !0, g = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), k(4 === g.rank, (function() {
         return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + g.rank + "."
        })), k(4 === m.rank, (function() {
         return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m.rank + "."
        })), k(g.shape[3] === m.shape[2], (function() {
         return "Error in fused depthwiseConv2d: number of input channels (" + g.shape[3] + ") must match the inChannels dimension in filter " + m.shape[2] + "."
        })), null == u && (u = [1, 1]), k(ui(r, u), (function() {
         return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
        })), null != c && k(T(i), (function() {
         return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c + " but got pad " + i + "."
        }));
        var b, x, w = ti(g.shape, m.shape, r, u, i, c, !0);
        null != l && (b = Tt(b = Ze(l, "bias", "fused conv2d"), v)[0], Zr(w.outShape, b.shape)), null != f && (x = Ze(f, "prelu weights", "fused depthwiseConv2d"));
        var C = {
         x: g,
         filter: m
        };
        null != l && (C.bias = b), null != f && (C.preluActivationWeights = x);
        var S = [m, g],
         E = Bt.runKernelFunc((function(t, e) {
          var n = t.fusedDepthwiseConv2D({
           input: g,
           filter: m,
           convInfo: w,
           bias: b,
           activation: p,
           preluActivationWeights: x
          });
          return e([m, g, n]), n
         }), C, (function(t, e) {
          k(si(u), (function() {
           return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'"
          }));
          var n = e[0],
           r = e[1],
           i = e[2],
           o = uh(t, i, p),
           a = {};
          return null != l && (a = {
           bias: function() {
            return ch(b, o)
           }
          }), Object.assign({
           x: function() {
            return Cc(r.shape, o, n, w)
           },
           filter: function() {
            return Sc(r, o, n.shape, w)
           }
          }, a)
         }), "FusedDepthwiseConv2D", {
          convInfo: w,
          activation: p
         }, S, [!0]);
        return y ? E.as3D(E.shape[1], E.shape[2], E.shape[3]) : E
       }
      }),
      dh = Object.freeze({
       matMul: hh,
       conv2d: ph,
       depthwiseConv2d: fh
      }),
      vh = Object.freeze({
       image: ah,
       linalg: Zl,
       losses: Gl,
       spectral: El,
       fused: dh,
       signal: Ml,
       square: Os,
       conv1d: mc,
       conv2d: gc,
       conv3d: yc,
       depthwiseConv2d: wc,
       separableConv2d: Ec,
       conv2dTranspose: kc,
       conv3dTranspose: Ic,
       op: ln,
       batchNormalization2d: du,
       batchNormalization3d: vu,
       batchNormalization4d: mu,
       batchNormalization: gu,
       batchNorm: yu,
       batchNorm2d: bu,
       batchNorm3d: xu,
       batchNorm4d: wu,
       booleanMaskAsync: pc,
       complex: hn,
       real: pn,
       imag: fn,
       concat: Tn,
       concat1d: _n,
       concat2d: Dn,
       concat3d: Fn,
       concat4d: Mn,
       split: Ln,
       matMul: Oc,
       dot: Ac,
       outerProduct: Nc,
       reverse: Rc,
       reverse1d: Tc,
       reverse2d: _c,
       reverse3d: Dc,
       reverse4d: Fc,
       maxPool: Bc,
       avgPool: Pc,
       pool: zc,
       maxPool3d: jc,
       avgPool3d: Wc,
       slice: Vc,
       slice1d: Uc,
       slice2d: Hc,
       slice3d: $c,
       slice4d: Gc,
       abs: As,
       acos: Ns,
       acosh: Rs,
       asin: Ts,
       asinh: _s,
       atan: Ds,
       atanh: Fs,
       ceil: Ms,
       clipByValue: Ls,
       cos: Bs,
       cosh: Ps,
       erf: zs,
       exp: js,
       expm1: Ws,
       floor: Vs,
       log: Us,
       log1p: Hs,
       logSigmoid: $s,
       neg: Gs,
       reciprocal: qs,
       round: Ks,
       rsqrt: Xs,
       sigmoid: Ys,
       sign: Zs,
       isNaN: Js,
       isInf: Qs,
       isFinite: tu,
       sin: eu,
       sinh: nu,
       softplus: ru,
       sqrt: iu,
       step: ou,
       tan: au,
       tanh: su,
       all: Kc,
       any: Xc,
       argMax: Yc,
       argMin: Zc,
       logSumExp: Jc,
       max: Qc,
       mean: tl,
       min: el,
       moments: nl,
       sum: rl,
       prod: il,
       equal: Yu,
       equalStrict: Zu,
       greater: Ju,
       greaterEqual: Qu,
       greaterEqualStrict: tc,
       greaterStrict: ec,
       less: nc,
       lessEqual: rc,
       lessEqualStrict: ic,
       lessStrict: oc,
       notEqual: ac,
       notEqualStrict: sc,
       add: Au,
       addN: Nu,
       addStrict: Ru,
       atan2: Tu,
       div: _u,
       divNoNan: Du,
       divStrict: Fu,
       floorDiv: Mu,
       maximum: Lu,
       maximumStrict: Bu,
       minimum: Pu,
       minimumStrict: zu,
       mod: ju,
       modStrict: Wu,
       mul: Vu,
       mulStrict: Uu,
       pow: Hu,
       powStrict: $u,
       squaredDifference: Gu,
       squaredDifferenceStrict: qu,
       sub: Ku,
       subStrict: Xu,
       elu: ol,
       leakyRelu: al,
       prelu: sl,
       relu: ul,
       relu6: cl,
       selu: ll,
       logicalAnd: Cu,
       logicalNot: Su,
       logicalOr: Eu,
       logicalXor: ku,
       where: Iu,
       whereAsync: Ou,
       buffer: Xn,
       print: Yn,
       batchToSpaceND: Zn,
       broadcastTo: Jn,
       cast: Qn,
       clone: tr,
       cumsum: er,
       depthToSpace: nr,
       expandDims: rr,
       eye: ir,
       multinomial: or,
       oneHot: ar,
       pad: sr,
       pad1d: ur,
       pad2d: cr,
       pad3d: lr,
       pad4d: hr,
       rand: pr,
       randomNormal: fr,
       randomGamma: dr,
       randomUniform: vr,
       reshape: mr,
       spaceToBatchND: gr,
       squeeze: yr,
       stack: br,
       tile: xr,
       truncatedNormal: wr,
       unstack: Cr,
       setdiff1dAsync: Sr,
       fill: In,
       linspace: On,
       ones: En,
       range: An,
       scalar: mn,
       tensor: dn,
       tensor1d: gn,
       tensor2d: yn,
       tensor3d: bn,
       tensor4d: xn,
       tensor5d: wn,
       tensor6d: Cn,
       variable: Sn,
       zeros: kn,
       onesLike: Nn,
       zerosLike: Rn,
       transpose: hl,
       softmax: Hr,
       logSoftmax: $r,
       localResponseNormalization: pl,
       norm: fl,
       gather: lc,
       unsortedSegmentSum: hc,
       basicLSTMCell: dl,
       multiRNNCell: vl,
       movingAverage: ml,
       stridedSlice: gl,
       topk: yl,
       scatterND: bl,
       fft: xl,
       ifft: wl,
       rfft: Cl,
       irfft: Sl,
       sparseToDense: kl,
       gatherND: Il,
       diag: Ol,
       dropout: Al,
       hannWindow: Tl,
       hammingWindow: _l,
       frame: Dl,
       stft: Fl,
       inTopKAsync: Ll
      });
 
     function mh(t, e) {
      Array.isArray(t) || (t = [t]), t.forEach((function(t) {
       null != t && k("complex64" !== t.dtype, (function() {
        return e + " does not support complex64 tensors."
       }))
      }))
     }
 
     function gh(t, e, n, r) {
      if ("linear" === n) return t.linear(e);
      if ("relu" === n) return t.relu(e);
      if ("elu" === n) return t.elu(e);
      if ("relu6" === n) return t.relu6(e);
      if ("prelu" === n) return t.prelu(e, r);
      throw new Error("Activation " + n + " has not been implemented for the CPU backend.")
     }
     var yh = function(t) {
      function e() {
       var e = t.call(this) || this;
       return e.blockSize = 48, e.firstUse = !0, e.data = new Gr(e, Bt), e
      }
      return a(e, t), e.prototype.write = function(t, e, n) {
       this.firstUse && (this.firstUse = !1, h().get("IS_NODE") && Ke("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
       var r = {};
       return this.data.set(r, {
        values: t,
        dtype: n
       }), r
      }, e.prototype.move = function(t, e, n, r) {
       this.data.set(t, {
        values: e,
        dtype: r
       })
      }, e.prototype.numDataIds = function() {
       return this.data.numDataIds()
      }, e.prototype.read = function(t) {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(e) {
         return [2, this.readSync(t)]
        }))
       }))
      }, e.prototype.readSync = function(t) {
       var e = this.data.get(t),
        n = e.dtype,
        r = e.complexTensors;
       return "complex64" === n ? fi(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values
      }, e.prototype.bufferSync = function(t) {
       var e = this.readSync(t.dataId),
        n = e;
       if ("string" === t.dtype) try {
        n = e.map((function(t) {
         return st(t)
        }))
       } catch (t) {
        throw new Error("Failed to decode encoded string bytes into utf-8")
       }
       return Xn(t.shape, t.dtype, n)
      }, e.prototype.makeOutput = function(t, e, n) {
       var r = this.write(t, e, n);
       return Bt.makeTensorFromDataId(r, e, n, this)
      }, e.prototype.disposeData = function(t) {
       if (this.data.has(t)) {
        var e = this.data.get(t).complexTensors;
        null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t)
       }
      }, e.prototype.time = function(t) {
       return s(this, void 0, void 0, (function() {
        var e;
        return u(this, (function(n) {
         return e = it(), t(), [2, {
          kernelMs: it() - e
         }]
        }))
       }))
      }, e.prototype.memory = function() {
       return {
        unreliable: !0,
        reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
       }
      }, e.prototype.complex = function(t, e) {
       var n = this.makeOutput(null, t.shape, "complex64");
       return this.data.get(n.dataId).complexTensors = {
        real: Bt.keep(t.clone()),
        imag: Bt.keep(e.clone())
       }, n
      }, e.prototype.real = function(t) {
       return this.data.get(t.dataId).complexTensors.real.clone()
      }, e.prototype.imag = function(t) {
       return this.data.get(t.dataId).complexTensors.imag.clone()
      }, e.prototype.slice = function(t, e, n) {
       if (mh(t, "slice"), jr(t.shape, e, n)) {
        var r = Wr(e, t.strides),
         i = N(n);
        return dn(this.readSync(t.dataId).subarray(r, r + i), n, t.dtype)
       }
       for (var o = Xn(n, t.dtype), a = this.bufferSync(t), s = 0; s < o.size; ++s) {
        var u = o.indexToLoc(s).map((function(t, n) {
         return t + e[n]
        }));
        o.values[s] = a.get.apply(a, u)
       }
       return o.toTensor()
      }, e.prototype.stridedSlice = function(t, e, n, r) {
       mh(t, "stridedSlice");
       var i = Br(e, n, r);
       if (i.some((function(t) {
         return 0 === t
        }))) return dn([], i);
       for (var o = Xn(i, t.dtype), a = this.bufferSync(t), s = 0; s < o.size; s++) {
        for (var u = o.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++) c[l] = u[l] * r[l] + e[l];
        o.set.apply(o, [a.get.apply(a, c)].concat(u))
       }
       return o.toTensor()
      }, e.prototype.diag = function(t) {
       for (var e = this.readSync(t.dataId), n = Xn([t.size, t.size], t.dtype), r = n.values, i = 0; i < e.length; i++) r[i * t.size + i] = e[i];
       return n.toTensor()
      }, e.prototype.unstack = function(t, e) {
       for (var n = t.shape[e], r = new Array(t.rank - 1), i = 0, o = 0; o < t.rank; o++) o !== e && (r[i++] = t.shape[o]);
       var a = new Array(t.rank).fill(0),
        s = t.shape.slice();
       s[e] = 1;
       var u = new Array(n);
       for (o = 0; o < u.length; o++) a[e] = o, u[o] = this.slice(t, a, s).reshape(r);
       return u
      }, e.prototype.reverse = function(t, e) {
       mh(t, "reverse");
       for (var n = Xn(t.shape, t.dtype), r = this.bufferSync(t), i = function(i) {
         var o = n.indexToLoc(i),
          a = o.slice();
         e.forEach((function(e) {
          return a[e] = t.shape[e] - 1 - a[e]
         })), n.set.apply(n, [r.get.apply(r, a)].concat(o))
        }, o = 0; o < n.size; o++) i(o);
       return n.toTensor()
      }, e.prototype.concat = function(t, e) {
       var n = this;
       if ("complex64" === t[0].dtype) {
        var r = t.map((function(t) {
          return pn(t)
         })),
         i = t.map((function(t) {
          return fn(t)
         }));
        return hn(this.concat(r, e), this.concat(i, e))
       }
       var o = t.map((function(t) {
         var n = N(t.shape.slice(e));
         return t.as2D(-1, n)
        })),
        a = cn(o.map((function(t) {
         return t.shape
        })), 1),
        s = Xn(a, t[0].dtype).values;
       if (1 === o[0].shape[0]) {
        var u = 0;
        o.forEach((function(t) {
         s.set(n.readSync(t.dataId), u), u += t.size
        }))
       } else {
        var c = 0;
        o.forEach((function(t) {
         for (var e = n.readSync(t.dataId), r = 0, i = 0; i < t.shape[0]; ++i)
          for (var o = i * a[1] + c, u = 0; u < t.shape[1]; ++u) s[o + u] = e[r++];
         c += t.shape[1]
        }))
       }
       var l = cn(t.map((function(t) {
        return t.shape
       })), e);
       return dn(s, l, t[0].dtype)
      }, e.prototype.neg = function(t) {
       return mh(t, "neg"), this.multiply(mn(-1), t)
      }, e.prototype.add = function(t, e) {
       return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), (function(t, e, n, r) {
        return {
         real: t + n,
         imag: e + r
        }
       })) : this.broadcastedBinaryOp(t, e, Nt(t.dtype, e.dtype), (function(t, e) {
        return t + e
       }))
      }, e.prototype.addN = function(t) {
       var e = this;
       mh(t, "addN");
       for (var n = t.map((function(t) {
         return e.readSync(t.dataId)
        })), r = Xn(t[0].shape, t[0].dtype), i = r.values, o = 0; o < t.length; o++)
        for (var a = n[o], s = 0; s < i.length; s++) i[s] += a[s];
       return r.toTensor()
      }, e.prototype.subtract = function(t, e) {
       return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), (function(t, e, n, r) {
        return {
         real: t - n,
         imag: e - r
        }
       })) : this.broadcastedBinaryOp(t, e, Nt(t.dtype, e.dtype), (function(t, e) {
        return t - e
       }))
      }, e.prototype.pow = function(t, e) {
       return mh([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        return Math.pow(t, e)
       }))
      }, e.prototype.batchMatMul = function(t, e, n, r) {
       mh([t, e], "matMul");
       for (var i = n ? t.shape[1] : t.shape[2], o = n ? t.shape[2] : t.shape[1], a = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], p = l[1], f = l[2], d = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], v = d[0], m = d[1], g = d[2], y = o * a, b = Xn([s, o, a], t.dtype), x = b.values, w = this.blockSize, C = 0; C < s; C++)
        for (var S = 0; S < o; S += w)
         for (var E = 0; E < a; E += w)
          for (var k = 0; k < i; k += w)
           for (var I = Math.min(S + w, o), O = Math.min(E + w, a), A = Math.min(k + w, i), N = S; N < I; N++)
            for (var R = E; R < O; R++) {
             for (var T = 0, _ = k; _ < A; _++) T += u[C * h + N * p + _ * f] * c[_ * v + R * m + C * g];
             x[C * y + (N * a + R)] += T
            }
       return b.toTensor()
      }, e.prototype.fusedBatchMatMul = function(t) {
       var e = t.a,
        n = t.b,
        r = t.transposeA,
        i = t.transposeB,
        o = t.bias,
        a = t.activation,
        s = t.preluActivationWeights,
        u = this.batchMatMul(e, n, r, i);
       return o && (u = this.add(u, o)), a && (u = gh(this, u, a, s)), u
      }, e.prototype.multiply = function(t, e) {
       return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), (function(t, e, n, r) {
        return {
         real: t * n - e * r,
         imag: t * r + e * n
        }
       })) : this.broadcastedBinaryOp(t, e, Nt(t.dtype, e.dtype), (function(t, e) {
        return t * e
       }))
      }, e.prototype.realDivide = function(t, e) {
       return mh([t, e], "realDivide"), this.broadcastedBinaryOp(t, e, "float32", (function(t, e) {
        return t / e
       }))
      }, e.prototype.floorDiv = function(t, e) {
       return mh([t, e], "floorDiv"), this.broadcastedBinaryOp(t, e, "int32", (function(t, e) {
        return Math.floor(t / e)
       }))
      }, e.prototype.sum = function(t, e) {
       mh(t, "sum"), rn("sum", e, t.rank);
       for (var n = en(t.shape, e), r = n[0], i = n[1], o = kn(r, Nt(t.dtype, "int32")), a = N(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = 0, p = 0; p < a; ++p) h += u[l + p];
        s[c] = h
       }
       return o
      }, e.prototype.prod = function(t, e) {
       mh(t, "sum");
       for (var n = en(t.shape, e), r = n[0], i = n[1], o = kn(r, Nt(t.dtype, "int32")), a = N(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = 1, p = 0; p < a; ++p) h *= u[l + p];
        s[c] = h
       }
       return o
      }, e.prototype.unsortedSegmentSum = function(t, e, n) {
       mh(t, "unsortedSegmentSum");
       for (var r = [], i = t.rank - e.rank, o = 0; o < i; ++o) e = e.expandDims(o + 1);
       for (o = 0; o < n; ++o) {
        var a = mn(o, "int32"),
         s = Yu(a, e).asType("float32").mul(t).sum(0);
        r.push(s)
       }
       return br(r)
      }, e.prototype.argMin = function(t, e) {
       mh(t, "argMin");
       var n = [e];
       rn("argMin", n, t.rank);
       for (var r = en(t.shape, n), i = r[0], o = r[1], a = kn(i, "int32"), s = N(o), u = this.readSync(a.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
        for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {
         var v = c[h + d];
         v < p && (p = v, f = d)
        }
        u[l] = f
       }
       return a
      }, e.prototype.argMax = function(t, e) {
       mh(t, "argMax");
       var n = [e];
       rn("argMax", n, t.rank);
       for (var r = en(t.shape, n), i = r[0], o = r[1], a = kn(i, "int32"), s = N(o), u = this.readSync(a.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {
        for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {
         var v = c[h + d];
         v > p && (p = v, f = d)
        }
        u[l] = f
       }
       return a
      }, e.prototype.cumsum = function(t, e, n, r) {
       if (mh(t, "cumsum"), e !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
       for (var i = Nt(t.dtype, "int32"), o = kn(t.shape, i), a = this.readSync(o.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function(t, e) {
         return t + u - e - 1
        } : function(t, e) {
         return t + e
        }, l = 0; l < s.length; l += u)
        for (var h = 0; h < u; h++) {
         var p = c(l, h);
         if (0 === h) a[p] = n ? 0 : s[p];
         else {
          var f = c(l, h - 1);
          a[p] = n ? s[f] + a[f] : s[p] + a[f]
         }
        }
       return o
      }, e.prototype.equal = function(t, e) {
       return mh([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t === e ? 1 : 0
       }))
      }, e.prototype.notEqual = function(t, e) {
       return mh([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t !== e ? 1 : 0
       }))
      }, e.prototype.less = function(t, e) {
       return mh([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t < e ? 1 : 0
       }))
      }, e.prototype.lessEqual = function(t, e) {
       return mh([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t <= e ? 1 : 0
       }))
      }, e.prototype.greater = function(t, e) {
       return mh([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t > e ? 1 : 0
       }))
      }, e.prototype.greaterEqual = function(t, e) {
       return mh([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t >= e ? 1 : 0
       }))
      }, e.prototype.logicalNot = function(t) {
       mh(t, "logicalNot");
       for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;
       return this.makeOutput(n, t.shape, "bool")
      }, e.prototype.logicalAnd = function(t, e) {
       return mh([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t && e
       }))
      }, e.prototype.logicalOr = function(t, e) {
       return mh([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", (function(t, e) {
        return t || e
       }))
      }, e.prototype.select = function(t, e, n) {
       mh([t, e, n], "select");
       for (var r = this.readSync(t.dataId), i = this.readSync(e.dataId), o = this.readSync(n.dataId), a = kn(e.shape, Nt(e.dtype, n.dtype)), s = this.readSync(a.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : N(e.shape.slice(1)), l = 0; l < r.length; l++)
        for (var h = 0; h < c; h++) 1 === r[l] ? s[u++] = i[l] : s[u++] = o[l];
       return a
      }, e.prototype.where = function(t) {
       mh([t], "where");
       var e = this.readSync(t.dataId);
       return Ai(t.shape, e)
      }, e.prototype.topk = function(t, e, n) {
       return mh(t, "topk"), Oi(this.readSync(t.dataId), t.shape, t.dtype, e)
      }, e.prototype.min = function(t, e) {
       mh(t, "min"), rn("min", e, t.rank);
       for (var n = en(t.shape, e), r = n[0], i = n[1], o = kn(r, t.dtype), a = N(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
         var f = u[l + p];
         f < h && (h = f)
        }
        s[c] = h
       }
       return o
      }, e.prototype.minimum = function(t, e) {
       return mh([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        return Math.min(t, e)
       }))
      }, e.prototype.mod = function(t, e) {
       return mh([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        var n = t % e;
        return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e
       }))
      }, e.prototype.max = function(t, e) {
       mh(t, "max"), rn("max", e, t.rank);
       for (var n = en(t.shape, e), r = n[0], i = n[1], o = kn(r, t.dtype), a = N(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
         var f = u[l + p];
         f > h && (h = f)
        }
        s[c] = h
       }
       return o
      }, e.prototype.maximum = function(t, e) {
       return mh([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        return Math.max(t, e)
       }))
      }, e.prototype.all = function(t, e) {
       mh(t, "all"), rn("all", e, t.rank);
       for (var n = en(t.shape, e), r = n[0], i = n[1], o = kn(r, t.dtype), a = N(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
         var f = u[l + p];
         h = h && f
        }
        s[c] = h
       }
       return o
      }, e.prototype.any = function(t, e) {
       mh(t, "any"), rn("any", e, t.rank);
       for (var n = en(t.shape, e), r = n[0], i = n[1], o = kn(r, t.dtype), a = N(i), s = this.readSync(o.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {
        for (var l = c * a, h = u[l], p = 0; p < a; ++p) {
         var f = u[l + p];
         h = h || f
        }
        s[c] = h
       }
       return o
      }, e.prototype.squaredDifference = function(t, e) {
       return mh([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        var n = t - e;
        return n * n
       }))
      }, e.prototype.ceil = function(t) {
       mh(t, "ceil");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.floor = function(t) {
       mh(t, "floor");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.sign = function(t) {
       mh(t, "x");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.isNaN = function(t) {
       mh(t, "x");
       for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);
       return this.makeOutput(n, t.shape, "bool")
      }, e.prototype.isInf = function(t) {
       mh(t, "x");
       for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);
       return this.makeOutput(n, t.shape, "bool")
      }, e.prototype.isFinite = function(t) {
       mh(t, "x");
       for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);
       return this.makeOutput(n, t.shape, "bool")
      }, e.prototype.round = function(t) {
       mh(t, "round");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var i = Math.floor(e[r]);
        e[r] - i < .5 ? n[r] = Math.floor(e[r]) : e[r] - i > .5 ? n[r] = Math.ceil(e[r]) : n[r] = i % 2 == 0 ? i : i + 1
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.exp = function(t) {
       mh(t, "exp");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.expm1 = function(t) {
       mh(t, "expm1");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.log = function(t) {
       mh(t, "log");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var i = e[r];
        n[r] = Math.log(i)
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.log1p = function(t) {
       mh(t, "log1p");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var i = e[r];
        n[r] = Math.log1p(i)
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.sqrt = function(t) {
       mh(t, "sqrt");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var i = e[r];
        n[r] = Math.sqrt(i)
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.rsqrt = function(t) {
       mh(t, "rsqrt");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var i = e[r];
        n[r] = 1 / Math.sqrt(i)
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.reciprocal = function(t) {
       mh(t, "reciprocal");
       for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.linear = function(t) {
       return t
      }, e.prototype.relu = function(t) {
       mh(t, "relu");
       for (var e = kn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) n[i] = Math.max(0, r[i]);
       return e
      }, e.prototype.relu6 = function(t) {
       mh(t, "relu");
       for (var e = kn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) n[i] = Math.min(Math.max(0, r[i]), 6);
       return e
      }, e.prototype.prelu = function(t, e) {
       return mh([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        return t < 0 ? e * t : t
       }))
      }, e.prototype.elu = function(t) {
       mh(t, "elu");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
        var i = n[r];
        e[r] = i >= 0 ? i : Math.exp(i) - 1
       }
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.eluDer = function(t, e) {
       mh([t, e], "eluDer");
       for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), i = this.readSync(t.dataId), o = 0; o < r.length; ++o) {
        var a = r[o];
        n[o] = a >= 1 ? i[o] : i[o] * (a + 1)
       }
       return this.makeOutput(n, e.shape, "float32")
      }, e.prototype.selu = function(t) {
       mh(t, "selu");
       for (var e = qa, n = Ka, r = new Float32Array(t.size), i = this.readSync(t.dataId), o = 0; o < i.length; ++o) {
        var a = i[o];
        r[o] = a >= 0 ? n * a : e * (Math.exp(a) - 1)
       }
       return this.makeOutput(r, t.shape, "float32")
      }, e.prototype.clip = function(t, e, n) {
       mh(t, "clip");
       for (var r = new Float32Array(t.size), i = this.readSync(t.dataId), o = 0; o < i.length; ++o) {
        var a = i[o];
        r[o] = a > n ? n : a < e ? e : a
       }
       return this.makeOutput(r, t.shape, "float32")
      }, e.prototype.abs = function(t) {
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.complexAbs = function(t) {
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
        var i = n[2 * r],
         o = n[2 * r + 1];
        e[r] = Math.hypot(i, o)
       }
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.int = function(t) {
       mh(t, "int");
       for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];
       return this.makeOutput(e, t.shape, "int32")
      }, e.prototype.sigmoid = function(t) {
       mh(t, "sigmoid");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.softplus = function(t) {
       mh(t, "softplus");
       for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) {
        var o = r[i] > -e,
         a = r[i] < e,
         s = Math.exp(r[i]),
         u = void 0;
        u = a ? s : o ? r[i] : Math.log(1 + s), n[i] = u
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.sin = function(t) {
       mh(t, "sin");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.cos = function(t) {
       mh(t, "cos");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.tan = function(t) {
       mh(t, "tan");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.asin = function(t) {
       mh(t, "asin");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.acos = function(t) {
       mh(t, "acos");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.atan = function(t) {
       mh(t, "atan");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.atan2 = function(t, e) {
       return mh([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, (function(t, e) {
        return Math.atan2(t, e)
       }))
      }, e.prototype.sinh = function(t) {
       mh(t, "sinh");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.cosh = function(t) {
       mh(t, "cosh");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.tanh = function(t) {
       mh(t, "tanh");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = _(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.asinh = function(t) {
       mh(t, "asinh");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.acosh = function(t) {
       mh(t, "acosh");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.atanh = function(t) {
       mh(t, "atanh");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.erf = function(t) {
       mh(t, "erf");
       for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
        var i = Math.sign(n[r]),
         o = Math.abs(n[r]),
         a = 1 / (1 + .3275911 * o);
        e[r] = i * (1 - ((((1.061405429 * a - 1.453152027) * a + 1.421413741) * a - .284496736) * a + .254829592) * a * Math.exp(-o * o))
       }
       return this.makeOutput(e, t.shape, "float32")
      }, e.prototype.step = function(t, e) {
       void 0 === e && (e = 0), mh(t, "step");
       for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), i = 0; i < r.length; ++i) {
        var o = r[i];
        isNaN(o) ? n[i] = NaN : n[i] = o > 0 ? 1 : e
       }
       return this.makeOutput(n, t.shape, "float32")
      }, e.prototype.fusedConv2d = function(t) {
       var e = t.input,
        n = t.filter,
        r = t.convInfo,
        i = t.bias,
        o = t.activation,
        a = t.preluActivationWeights,
        s = this.conv2d(e, n, r);
       return i && (s = this.add(s, i)), o && (s = gh(this, s, o, a)), s
      }, e.prototype.conv2d = function(t, e, n) {
       mh([t, e], "conv2d");
       for (var r = n.filterHeight, i = n.filterWidth, o = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = "channelsLast" === n.dataFormat, l = Xn(n.outShape, t.dtype), h = t.strides[0], p = c ? t.strides[1] : t.strides[2], f = c ? t.strides[2] : 1, d = c ? 1 : t.strides[1], v = l.strides[0], m = c ? l.strides[1] : l.strides[2], g = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], b = this.readSync(t.dataId), x = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C)
        for (var S = C * h, E = C * v, k = 0; k < n.outHeight; ++k)
         for (var I = E + k * m, O = k * n.strideHeight - u, A = 0; A < r; A++) {
          var N = O + A * o;
          if (!(N < 0 || N >= n.inHeight))
           for (var R = A * e.strides[0], T = S + N * p, _ = 0; _ < n.outWidth; ++_)
            for (var D = I + _ * g, F = _ * n.strideWidth - s, M = 0; M < i; M++) {
             var L = F + M * a;
             if (!(L < 0 || L >= n.inWidth))
              for (var B = T + L * f, P = R + M * e.strides[1], z = 0; z < n.inChannels; ++z) {
               for (var j = b[B + z * d], W = 0; W < n.outChannels; ++W) w[D + W * y] += j * x[P + W];
               P += n.outChannels
              }
            }
         }
       return l.toTensor()
      }, e.prototype.conv3d = function(t, e, n) {
       for (var r = n.filterDepth, i = n.filterHeight, o = n.filterWidth, a = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, p = Xn(n.outShape, t.dtype), f = this.readSync(t.dataId), d = this.readSync(e.dataId), v = p.values, m = 0; m < n.batchSize; ++m)
        for (var g = m * t.strides[0], y = m * p.strides[0], b = 0; b < n.outDepth; ++b)
         for (var x = y + b * p.strides[1], w = b * n.strideDepth - c, C = 0; C < r; C++) {
          var S = w + C * a;
          if (!(S < 0 || S >= n.inDepth))
           for (var E = C * e.strides[0], k = g + S * t.strides[1], I = 0; I < n.outHeight; ++I)
            for (var O = x + I * p.strides[2], A = I * n.strideHeight - h, N = 0; N < i; N++) {
             var R = A + N * s;
             if (!(R < 0 || R >= n.inHeight))
              for (var T = E + N * e.strides[1], _ = k + R * t.strides[2], D = 0; D < n.outWidth; ++D)
               for (var F = O + D * n.outChannels, M = D * n.strideWidth - l, L = 0; L < o; L++) {
                var B = M + L * u;
                if (!(B < 0 || B >= n.inWidth))
                 for (var P = T + L * e.strides[2], z = _ + B * n.inChannels, j = P, W = 0; W < n.inChannels; ++W) {
                  for (var V = f[z + W], U = 0; U < n.outChannels; ++U) v[F + U] += V * d[j + U];
                  j += n.outChannels
                 }
               }
            }
         }
       return p.toTensor()
      }, e.prototype.conv2dDerInput = function(t, e, n) {
       mh([t, e], "conv2dDerInput");
       for (var r = Xn(n.inShape, "float32"), i = r.values, o = this.readSync(t.dataId), a = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, p = n.filterHeight, f = n.filterWidth, d = n.inChannels, v = n.inHeight, m = n.inWidth, g = n.outChannels, y = n.outHeight, b = n.outWidth, x = n.strideHeight, w = n.strideWidth, C = n.dataFormat, S = p - 1 - n.padInfo.top, E = f - 1 - n.padInfo.left, k = "channelsLast" === C, I = r.strides[0], O = k ? r.strides[1] : r.strides[2], A = k ? r.strides[2] : 1, N = k ? 1 : r.strides[1], R = t.strides[0], T = k ? t.strides[1] : t.strides[2], _ = k ? t.strides[2] : 1, D = k ? 1 : t.strides[1], F = 0; F < h; ++F)
        for (var M = 0; M < d; ++M)
         for (var L = 0; L < v; ++L)
          for (var B = L - S, P = Math.max(0, Math.ceil(B / x)), z = Math.min(y, (p + B) / x), j = 0; j < m; ++j) {
           for (var W = j - E, V = Math.max(0, Math.ceil(W / w)), U = Math.min(b, (f + W) / w), H = 0, $ = P; $ < z; ++$)
            for (var G = $ * x - B, q = V; q < U; ++q)
             for (var K = R * F + T * $ + _ * q, X = u * (p - 1 - G) + c * (f - 1 - (q * w - W)) + l * M, Y = 0; Y < g; ++Y) H += o[K + D * Y] * a[X + Y];
           i[I * F + O * L + A * j + N * M] = H
          }
       return r.toTensor()
      }, e.prototype.conv3dDerInput = function(t, e, n) {
       for (var r = Xn(n.inShape, "float32"), i = r.values, o = r.strides, a = o[0], s = o[1], u = o[2], c = o[3], l = this.readSync(t.dataId), h = t.strides, p = h[0], f = h[1], d = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], b = g[1], x = g[2], w = g[3], C = n.batchSize, S = n.filterDepth, E = n.filterHeight, k = n.filterWidth, I = n.inChannels, O = n.inDepth, A = n.inHeight, N = n.inWidth, R = n.outChannels, T = n.outDepth, _ = n.outHeight, D = n.outWidth, F = n.strideDepth, M = n.strideHeight, L = n.strideWidth, B = S - 1 - n.padInfo.front, P = E - 1 - n.padInfo.top, z = k - 1 - n.padInfo.left, j = 0; j < C; ++j)
        for (var W = 0; W < I; ++W)
         for (var V = 0; V < O; ++V)
          for (var U = V - B, H = Math.max(0, Math.ceil(U / F)), $ = Math.min(T, (S + U) / F), G = 0; G < A; ++G)
           for (var q = G - P, K = Math.max(0, Math.ceil(q / M)), X = Math.min(_, (E + q) / M), Y = 0; Y < N; ++Y) {
            for (var Z = Y - z, J = Math.max(0, Math.ceil(Z / L)), Q = Math.min(D, (k + Z) / L), tt = 0, et = H; et < $; ++et)
             for (var nt = et * F - U, rt = K; rt < X; ++rt)
              for (var it = rt * M - q, ot = J; ot < Q; ++ot)
               for (var at = p * j + f * et + d * rt + v * ot, st = y * (S - 1 - nt) + b * (E - 1 - it) + x * (k - 1 - (ot * L - Z)) + w * W, ut = 0; ut < R; ++ut) tt += l[at + ut] * m[st + ut];
            i[a * j + s * V + u * G + c * Y + W] = tt
           }
       return r.toTensor()
      }, e.prototype.conv2dDerFilter = function(t, e, n) {
       mh([t, e], "conv2dDerFilter");
       for (var r = n.strideHeight, i = n.strideWidth, o = n.filterHeight, a = n.filterWidth, s = "channelsLast" === n.dataFormat, u = Xn(n.filterShape, "float32"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), p = this.bufferSync(e), f = 0; f < o; ++f)
        for (var d = Math.max(0, Math.ceil((l - f) / r)), v = Math.min(n.outHeight, (n.inHeight + l - f) / r), m = 0; m < a; ++m)
         for (var g = Math.max(0, Math.ceil((c - m) / i)), y = Math.min(n.outWidth, (n.inWidth + c - m) / i), b = 0; b < n.inChannels; ++b)
          for (var x = 0; x < n.outChannels; ++x) {
           for (var w = 0, C = 0; C < n.batchSize; ++C)
            for (var S = d; S < v; ++S)
             for (var E = f + S * r - l, k = g; k < y; ++k) {
              var I = m + k * i - c;
              w += s ? h.get(C, E, I, b) * p.get(C, S, k, x) : h.get(C, b, E, I) * p.get(C, x, S, k)
             }
           u.set(w, f, m, b, x)
          }
       return u.toTensor()
      }, e.prototype.conv3dDerFilter = function(t, e, n) {
       for (var r = n.strideDepth, i = n.strideHeight, o = n.strideWidth, a = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = Xn(n.filterShape, "float32"), l = c.values, h = c.strides, p = h[0], f = h[1], d = h[2], v = h[3], m = this.readSync(e.dataId), g = e.strides, y = g[0], b = g[1], x = g[2], w = g[3], C = this.readSync(t.dataId), S = t.strides, E = S[0], k = S[1], I = S[2], O = S[3], A = n.padInfo.front, N = n.padInfo.left, R = n.padInfo.top, T = 0; T < a; ++T)
        for (var _ = Math.max(0, Math.ceil((A - T) / r)), D = Math.min(n.outDepth, (n.inDepth + A - T) / r), F = T * p, M = 0; M < s; ++M)
         for (var L = Math.max(0, Math.ceil((R - M) / i)), B = Math.min(n.outHeight, (n.inHeight + R - M) / i), P = M * f + F, z = 0; z < u; ++z)
          for (var j = Math.max(0, Math.ceil((N - z) / o)), W = Math.min(n.outWidth, (n.inWidth + N - z) / o), V = z * d + P, U = 0; U < n.inChannels; ++U)
           for (var H = U * v + V, $ = 0; $ < n.outChannels; ++$) {
            for (var G = 0, q = 0; q < n.batchSize; ++q)
             for (var K = q * E, X = q * y, Y = _; Y < D; ++Y)
              for (var Z = (T + Y * r - A) * k + K, J = Y * b + X, Q = L; Q < B; ++Q)
               for (var tt = (M + Q * i - R) * I + Z, et = Q * x + J, nt = j; nt < W; ++nt) {
                var rt = nt * w + et;
                G += C[(z + nt * o - N) * O + tt + U] * m[rt + $]
               }
            l[H + $] = G
           }
       return c.toTensor()
      }, e.prototype.fusedDepthwiseConv2D = function(t) {
       var e = t.input,
        n = t.filter,
        r = t.convInfo,
        i = t.bias,
        o = t.activation,
        a = t.preluActivationWeights,
        s = this.depthwiseConv2D(e, n, r);
       return i && (s = this.add(s, i)), o && (s = gh(this, s, o, a)), s
      }, e.prototype.depthwiseConv2D = function(t, e, n) {
       mh([t, e], "depthwiseConv2D");
       for (var r = n.filterHeight, i = n.filterWidth, o = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = Xn(n.outShape, t.dtype), h = this.readSync(t.dataId), p = this.readSync(e.dataId), f = l.values, d = 0; d < n.batchSize; ++d)
        for (var v = d * t.strides[0], m = d * l.strides[0], g = 0; g < n.outHeight; ++g)
         for (var y = m + g * l.strides[1], b = g * n.strideHeight - s, x = 0; x < r; ++x) {
          var w = b + x * o;
          if (!(w < 0 || w >= n.inHeight))
           for (var C = x * e.strides[0], S = v + w * t.strides[1], E = 0; E < n.outWidth; ++E)
            for (var k = y + E * l.strides[2], I = E * n.strideWidth - u, O = 0; O < i; ++O) {
             var A = I + O * a;
             if (!(A < 0 || A >= n.inWidth))
              for (var N = C + O * e.strides[1], R = S + A * n.inChannels, T = k, _ = N, D = 0; D < n.inChannels; ++D) {
               for (var F = h[R + D], M = 0; M < c; ++M) f[T + M] += F * p[_ + M];
               T += c, _ += c
              }
            }
         }
       return l.toTensor()
      }, e.prototype.depthwiseConv2DDerInput = function(t, e, n) {
       mh([t, e], "depthwiseConv2DDerInput");
       for (var r = Xn(n.inShape, "float32"), i = r.values, o = r.strides, a = o[0], s = o[1], u = o[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], p = l[1], f = l[2], d = this.readSync(e.dataId), v = e.strides, m = v[0], g = v[1], y = v[2], b = n.batchSize, x = n.filterHeight, w = n.filterWidth, C = n.inChannels, S = n.inHeight, E = n.inWidth, k = n.outChannels, I = n.outHeight, O = n.outWidth, A = n.strideHeight, N = n.strideWidth, R = x - 1 - n.padInfo.top, T = w - 1 - n.padInfo.left, _ = k / C, D = 0; D < b; ++D)
        for (var F = 0; F < C; ++F)
         for (var M = 0; M < S; ++M)
          for (var L = M - R, B = Math.max(0, Math.ceil(L / A)), P = Math.min(I, (x + L) / A), z = 0; z < E; ++z) {
           for (var j = z - T, W = Math.max(0, Math.ceil(j / N)), V = Math.min(O, (w + j) / N), U = 0, H = B; H < P; ++H)
            for (var $ = H * A - L, G = W; G < V; ++G)
             for (var q = h * D + p * H + f * G, K = m * (x - 1 - $) + g * (w - 1 - (G * N - j)) + y * F, X = 0; X < _; ++X) U += c[q + (F * _ + X)] * d[K + X];
           i[a * D + s * M + u * z + F] = U
          }
       return r.toTensor()
      }, e.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
       mh([t, e], "depthwiseConv2DDerFilter");
       for (var r = n.strideHeight, i = n.strideWidth, o = n.filterHeight, a = n.filterWidth, s = Xn(n.filterShape, "float32"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), p = this.bufferSync(e), f = 0; f < o; ++f)
        for (var d = Math.max(0, Math.ceil((c - f) / r)), v = Math.min(n.outHeight, (n.inHeight + c - f) / r), m = 0; m < a; ++m)
         for (var g = Math.max(0, Math.ceil((u - m) / i)), y = Math.min(n.outWidth, (n.inWidth + u - m) / i), b = 0; b < n.outChannels; ++b) {
          for (var x = Math.trunc(b / l), w = b % l, C = 0, S = 0; S < n.batchSize; ++S)
           for (var E = d; E < v; ++E)
            for (var k = f + E * r - c, I = g; I < y; ++I) {
             var O = m + I * i - u;
             C += h.get(S, k, O, x) * p.get(S, E, I, b)
            }
          s.set(C, f, m, x, w)
         }
       return s.toTensor()
      }, e.prototype.tile = function(t, e) {
       return mh(t, "tile"), Ii(this.bufferSync(t), e)
      }, e.prototype.pad = function(t, e, n) {
       mh(t, "pad");
       var r = e.map((function(e, n) {
         return e[0] + t.shape[n] + e[1]
        })),
        i = e.map((function(t) {
         return t[0]
        })),
        o = this.bufferSync(t),
        a = Xn(r, t.dtype);
       0 !== n && a.values.fill(n);
       for (var s = 0; s < t.size; s++) {
        var u = o.indexToLoc(s),
         c = u.map((function(t, e) {
          return t + i[e]
         }));
        a.set.apply(a, [o.get.apply(o, u)].concat(c))
       }
       return a.toTensor()
      }, e.prototype.transpose = function(t, e) {
       mh(t, "transpose");
       for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];
       var i = this.readSync(t.dataId),
        o = Xn(n, t.dtype),
        a = this.bufferSync(t);
       for (r = 0; r < t.size; ++r) {
        for (var s = a.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[e[c]];
        var l = o.locToIndex(u);
        o.values[l] = i[r]
       }
       return o.toTensor()
      }, e.prototype.gather = function(t, e, n) {
       mh([t, e], "gather");
       var r = t.shape.slice(),
        i = this.readSync(e.dataId);
       r[n] = i.length;
       for (var o = Xn(r, t.dtype), a = this.bufferSync(t), s = 0; s < o.size; ++s) {
        var u = o.indexToLoc(s),
         c = u.slice();
        c[n] = i[u[n]];
        var l = a.locToIndex(c);
        o.values[s] = a.values[l]
       }
       return o.toTensor()
      }, e.prototype.batchToSpaceND = function(t, e, n) {
       mh([t], "batchToSpaceND");
       var r = e.reduce((function(t, e) {
         return t * e
        })),
        i = Er(t.shape, e, r),
        o = kr(i.length, e.length),
        a = Ir(t.shape, e, r),
        s = Or(n, e.length),
        u = Ar(a, n, e.length);
       return t.reshape(i).transpose(o).reshape(a).slice(s, u)
      }, e.prototype.spaceToBatchND = function(t, e, n) {
       mh([t], "spaceToBatchND");
       var r = e.reduce((function(t, e) {
         return t * e
        })),
        i = [
         [0, 0]
        ];
       i.push.apply(i, n);
       for (var o = 1 + e.length; o < t.shape.length; ++o) i.push([0, 0]);
       var a = t.pad(i),
        s = Er(a.shape, e, r, !1),
        u = kr(s.length, e.length, !1),
        c = Ir(a.shape, e, r, !1);
       return a.reshape(s).transpose(u).reshape(c)
      }, e.prototype.pool = function(t, e, n) {
       mh(t, "pool");
       for (var r = e.strideHeight, i = e.strideWidth, o = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, p = this.readSync(t.dataId), f = Xn(e.outShape, t.dtype), d = f.values, v = e.outShape[1] * e.outShape[2] * e.outShape[3], m = e.outShape[2] * e.outShape[3], g = e.outShape[3], y = 0; y < e.batchSize; ++y)
        for (var b = y * v, x = y * t.strides[0], w = 0; w < e.inChannels; ++w)
         for (var C = 0; C < e.outHeight; ++C)
          for (var S = C * r - c, E = Math.max(0, S), k = Math.min(e.inHeight, s + S), I = b + C * m, O = 0; O < e.outWidth; ++O) {
           for (var A = O * i - l, N = Math.max(0, A), R = Math.min(e.inWidth, u + A), T = h, _ = 0, D = 0, F = E; F < k; F += o) {
            for (var M = x + F * t.strides[1], L = N; L < R; L += a) {
             var B = p[M + L * t.strides[2] + w];
             "max" === n && B > T ? T = B : "avg" === n && (_ += B, D++)
            }
            if (isNaN(T)) break
           }
           d[I + O * g + w] = "avg" === n ? _ / D : T
          }
       return f.toTensor()
      }, e.prototype.maxPool = function(t, e) {
       return this.pool(t, e, "max")
      }, e.prototype.maxPoolPositions = function(t, e) {
       for (var n = Xn(e.outShape, "int32"), r = e.strideHeight, i = e.strideWidth, o = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), p = 0; p < e.batchSize; ++p)
        for (var f = 0; f < e.inChannels; ++f)
         for (var d = 0; d < e.outHeight; ++d) {
          for (var v = d * r - c, m = v; m < 0;) m += o;
          for (var g = Math.min(e.inHeight, s + v), y = 0; y < e.outWidth; ++y) {
           for (var b = y * i - l, x = b; x < 0;) x += a;
           for (var w = Math.min(e.inWidth, u + b), C = Number.NEGATIVE_INFINITY, S = -1, E = m; E < g; E += o)
            for (var k = E - v, I = x; I < w; I += a) {
             var O = I - b,
              A = h.get(p, E, I, f);
             A > C && (C = A, S = k * u + O)
            }
           n.set(S, p, d, y, f)
          }
         }
       return n.toTensor()
      }, e.prototype.maxPoolBackprop = function(t, e, n, r) {
       mh([e, n], "maxPoolBackprop");
       for (var i = this.maxPoolPositions(e, r), o = r.strideHeight, a = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, p = c - 1 - r.padInfo.top, f = Xn(e.shape, "float32"), d = this.bufferSync(i), v = this.bufferSync(t), m = 0; m < r.batchSize; ++m)
        for (var g = 0; g < r.inChannels; ++g)
         for (var y = 0; y < r.inHeight; ++y)
          for (var b = 0; b < r.inWidth; ++b) {
           for (var x = y - p, w = b - h, C = 0, S = 0; S < c; S += s) {
            var E = (x + S) / o;
            if (!(E < 0 || E >= r.outHeight || Math.floor(E) !== E))
             for (var k = 0; k < l; k += u) {
              var I = (w + k) / a;
              if (!(I < 0 || I >= r.outWidth || Math.floor(I) !== I)) {
               var O = c * l - 1 - d.get(m, E, I, g) === S * l + k ? 1 : 0;
               0 !== O && (C += v.get(m, E, I, g) * O)
              }
             }
           }
           f.set(C, m, y, b, g)
          }
       return f.toTensor()
      }, e.prototype.avgPoolBackprop = function(t, e, n) {
       mh([t, e], "avgPoolBackprop");
       for (var r = n.strideHeight, i = n.strideWidth, o = n.filterHeight, a = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, p = c - 1 - n.padInfo.top, f = Xn(e.shape, "float32"), d = 1 / (o * a), v = this.bufferSync(t), m = 0; m < n.batchSize; ++m)
        for (var g = 0; g < n.inChannels; ++g)
         for (var y = 0; y < n.inHeight; ++y)
          for (var b = 0; b < n.inWidth; ++b) {
           for (var x = y - p, w = b - h, C = 0, S = 0; S < c; S += s) {
            var E = (x + S) / r;
            if (!(E < 0 || E >= n.outHeight || Math.floor(E) !== E))
             for (var k = 0; k < l; k += u) {
              var I = (w + k) / i;
              I < 0 || I >= n.outWidth || Math.floor(I) !== I || (C += v.get(m, E, I, g))
             }
           }
           f.set(C * d, m, y, b, g)
          }
       return f.toTensor()
      }, e.prototype.pool3d = function(t, e, n) {
       mh(t, "pool3d");
       for (var r = e.strideDepth, i = e.strideHeight, o = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, p = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, v = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = this.readSync(t.dataId), g = Xn(e.outShape, t.dtype), y = g.values, b = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], x = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], S = 0; S < e.batchSize; ++S)
        for (var E = S * b, k = S * t.strides[0], I = 0; I < e.inChannels; ++I)
         for (var O = 0; O < e.outDepth; ++O) {
          for (var A = O * r - p, N = A; N < 0;) N += a;
          for (var R = Math.min(e.inDepth, c + A), T = E + O * x, _ = 0; _ < e.outHeight; ++_) {
           for (var D = _ * i - f, F = D; F < 0;) F += s;
           for (var M = Math.min(e.inHeight, l + D), L = T + _ * w, B = 0; B < e.outWidth; ++B) {
            for (var P = B * o - d, z = P; z < 0;) z += u;
            for (var j = Math.min(e.inWidth, h + P), W = L + B * C, V = v, U = 0, H = 0, $ = N; $ < R; $ += a) {
             for (var G = k + $ * t.strides[1], q = F; q < M; q += s) {
              for (var K = G + q * t.strides[2], X = z; X < j; X += u) {
               var Y = m[K + X * t.strides[3] + I];
               if ("max" === n && Y > V ? V = Y : "avg" === n && (U += Y, H++), isNaN(V)) break
              }
              if (isNaN(V)) break
             }
             if (isNaN(V)) break
            }
            y[W + I] = "avg" === n ? U / H : V
           }
          }
         }
       return g.toTensor()
      }, e.prototype.avgPool3d = function(t, e) {
       return mh(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat()
      }, e.prototype.avgPool3dBackprop = function(t, e, n) {
       mh([t, e], "avgPool3dBackprop");
       for (var r = n.strideDepth, i = n.strideHeight, o = n.strideWidth, a = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, p = n.effectiveFilterDepth, f = n.effectiveFilterHeight, d = n.effectiveFilterWidth, v = p - 1 - n.padInfo.front, m = d - 1 - n.padInfo.left, g = f - 1 - n.padInfo.top, y = Xn(e.shape, "float32"), b = 1 / (a * s * u), x = this.bufferSync(t), w = 0; w < n.batchSize; ++w)
        for (var C = 0; C < n.inChannels; ++C)
         for (var S = 0; S < n.inDepth; ++S)
          for (var E = 0; E < n.inHeight; ++E)
           for (var k = 0; k < n.inWidth; ++k) {
            for (var I = S - v, O = E - g, A = k - m, N = 0, R = 0; R < p; R += c) {
             var T = (I + R) / r;
             if (!(T < 0 || T >= n.outDepth || Math.floor(T) !== T))
              for (var _ = 0; _ < f; _ += l) {
               var D = (O + _) / i;
               if (!(D < 0 || D >= n.outHeight || Math.floor(D) !== D))
                for (var F = 0; F < d; F += h) {
                 var M = (A + F) / o;
                 M < 0 || M >= n.outWidth || Math.floor(M) !== M || (N += x.get(w, T, D, M, C))
                }
              }
            }
            y.set(N * b, w, S, E, k, C)
           }
       return y.toTensor()
      }, e.prototype.maxPool3d = function(t, e) {
       return mh(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat()
      }, e.prototype.maxPool3dPositions = function(t, e) {
       for (var n = Xn(e.outShape, "int32"), r = e.strideDepth, i = e.strideHeight, o = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, p = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, v = this.bufferSync(t), m = 0; m < e.batchSize; ++m)
        for (var g = 0; g < e.inChannels; ++g)
         for (var y = 0; y < e.outDepth; ++y) {
          for (var b = y * r - p, x = b; x < 0;) x += a;
          for (var w = Math.min(e.inDepth, c + b), C = 0; C < e.outHeight; ++C) {
           for (var S = C * i - f, E = S; E < 0;) E += s;
           for (var k = Math.min(e.inHeight, l + S), I = 0; I < e.outWidth; ++I) {
            for (var O = I * o - d, A = O; A < 0;) A += u;
            for (var N = Math.min(e.inWidth, h + O), R = Number.NEGATIVE_INFINITY, T = -1, _ = x; _ < w; _ += a)
             for (var D = _ - b, F = E; F < k; F += s)
              for (var M = F - S, L = A; L < N; L += u) {
               var B = L - O,
                P = v.get(m, _, F, L, g);
               P >= R && (R = P, T = D * l * h + M * l + B)
              }
            n.set(T, m, y, C, I, g)
           }
          }
         }
       return n.toTensor()
      }, e.prototype.maxPool3dBackprop = function(t, e, n, r) {
       mh([e, n], "maxPool3dBackprop");
       for (var i = this.maxPool3dPositions(e, r), o = r.strideDepth, a = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, p = r.effectiveFilterHeight, f = r.effectiveFilterWidth, d = h - 1 - r.padInfo.front, v = f - 1 - r.padInfo.left, m = p - 1 - r.padInfo.top, g = Xn(e.shape, "float32"), y = this.bufferSync(i), b = this.bufferSync(t), x = 0; x < r.batchSize; ++x)
        for (var w = 0; w < r.inChannels; ++w)
         for (var C = 0; C < r.inDepth; ++C)
          for (var S = 0; S < r.inHeight; ++S)
           for (var E = 0; E < r.inWidth; ++E) {
            for (var k = C - d, I = S - m, O = E - v, A = 0, N = 0; N < h; N += u) {
             var R = (k + N) / o;
             if (!(R < 0 || R >= r.outDepth || Math.floor(R) !== R))
              for (var T = 0; T < p; T += c) {
               var _ = (I + T) / a;
               if (!(_ < 0 || _ >= r.outHeight || Math.floor(_) !== _))
                for (var D = 0; D < f; D += l) {
                 var F = (O + D) / s;
                 if (!(F < 0 || F >= r.outWidth || Math.floor(F) !== F)) {
                  var M = h * p * f - 1 - y.get(x, R, _, F, w) === N * p * f + T * f + D ? 1 : 0;
                  0 !== M && (A += b.get(x, R, _, F, w) * M)
                 }
                }
              }
            }
            g.set(A, x, C, S, E, w)
           }
       return g.toTensor()
      }, e.prototype.cast = function(t, e) {
       return li(t, e, this)
      }, e.prototype.reshape = function(t, e) {
       return hi(t, e)
      }, e.prototype.avgPool = function(t, e) {
       return mh(t, "avgPool"), this.pool(t, e, "avg").toFloat()
      }, e.prototype.resizeBilinear = function(t, e, n, r) {
       mh(t, "resizeBilinear");
       for (var i = t.shape, o = i[0], a = i[1], s = i[2], u = i[3], c = this.readSync(t.dataId), l = new Float32Array(N([o, e, n, u])), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = 0, d = h[0] / p[0], v = h[1] / p[1], m = 0; m < o; m++)
        for (var g = 0; g < e; g++)
         for (var y = d * g, b = Math.floor(y), x = y - b, w = Math.min(a - 1, Math.ceil(y)), C = m * t.strides[0] + b * t.strides[1], S = m * t.strides[0] + w * t.strides[1], E = 0; E < n; E++)
          for (var k = v * E, I = Math.floor(k), O = k - I, A = Math.min(s - 1, Math.ceil(k)), R = C + I * t.strides[2], T = S + I * t.strides[2], _ = C + A * t.strides[2], D = S + A * t.strides[2], F = 0; F < u; F++) {
           var M = c[R + F],
            L = c[T + F],
            B = M + (c[_ + F] - M) * O,
            P = B + (L + (c[D + F] - L) * O - B) * x;
           l[f++] = P
          }
       return dn(l, [o, e, n, u])
      }, e.prototype.resizeBilinearBackprop = function(t, e, n) {
       mh([t, e], "resizeBilinearBackprop");
       for (var r = e.shape, i = r[0], o = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(i * o * a * s), p = [n && c > 1 ? o - 1 : o, n && l > 1 ? a - 1 : a], f = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], d = p[0] / f[0], v = p[1] / f[1], m = this.readSync(t.dataId), g = 0, y = 0; y < i; y++)
        for (var b = y * e.strides[0], x = 0; x < c; x++)
         for (var w = x * d, C = Math.floor(w), S = Math.min(Math.ceil(w), o - 1), E = b + C * e.strides[1], k = b + S * e.strides[1], I = w - C, O = 1 - I, A = 0; A < l; A++)
          for (var N = A * v, R = Math.floor(N), T = Math.min(Math.ceil(N), a - 1), _ = N - R, D = 1 - _, F = E + R * e.strides[2], M = E + T * e.strides[2], L = k + R * e.strides[2], B = k + T * e.strides[2], P = O * D, z = O * _, j = I * D, W = I * _, V = 0; V < s; V++) {
           var U = m[g++];
           h[F + V] += U * P, h[M + V] += U * z, h[L + V] += U * j, h[B + V] += U * W
          }
       return xn(h, [i, a, o, s], e.dtype)
      }, e.prototype.resizeNearestNeighbor = function(t, e, n, r) {
       mh(t, "resizeNearestNeighbor");
       for (var i = t.shape, o = i[0], a = i[1], s = i[2], u = i[3], c = this.readSync(t.dataId), l = new Float32Array(o * e * n * u), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = h[0] / p[0], d = h[1] / p[1], v = 0, m = 0; m < o; m++)
        for (var g = m * t.strides[0], y = 0; y < e; y++)
         for (var b = f * y, x = g + Math.min(a - 1, r ? Math.round(b) : Math.floor(b)) * t.strides[1], w = 0; w < n; w++)
          for (var C = d * w, S = x + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], E = 0; E < u; E++) {
           var k = c[S + E];
           l[v++] = k
          }
       return dn(l, [o, e, n, u], t.dtype)
      }, e.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
       mh([t, e], "resizeNearestNeighborBackprop");
       for (var r = e.shape, i = r[0], o = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(i * o * a * s), p = this.readSync(t.dataId), f = [n && c > 1 ? o - 1 : o, n && l > 1 ? a - 1 : a], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], v = f[0] / d[0], m = f[1] / d[1], g = 1 / v, y = 1 / m, b = 2 * Math.ceil(g) + 2, x = 2 * Math.ceil(y) + 2, w = 0; w < i; w++)
        for (var C = w * e.strides[0], S = 0; S < o; S++)
         for (var E = C + S * e.strides[1], k = Math.floor(S * g), I = Math.floor(k - b / 2), O = 0; O < a; O++)
          for (var A = E + O * e.strides[2], N = Math.floor(O * y), R = Math.floor(N - x / 2), T = 0; T < s; T++) {
           for (var _ = 0, D = 0; D < b; D++) {
            var F = D + I;
            if (!(F < 0 || F >= c)) {
             var M = C + F * t.strides[1],
              L = F * v;
             if (S === Math.min(o - 1, n ? Math.round(L) : Math.floor(L)))
              for (var B = 0; B < x; B++) {
               var P = B + R;
               if (!(P < 0 || P >= l)) {
                var z = M + P * t.strides[2],
                 j = P * m;
                O === Math.min(a - 1, n ? Math.round(j) : Math.floor(j)) && (_ += p[z + T])
               }
              }
            }
           }
           h[A + T] = _
          }
       return xn(h, e.shape, e.dtype)
      }, e.prototype.batchNormalization = function(t, e, n, r, i, o) {
       mh([t, e, n, i, o], "batchNorm");
       for (var a = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = i ? this.readSync(i.dataId) : new Float32Array([1]), l = o ? this.readSync(o.dataId) : new Float32Array([0]), h = new Float32Array(a.length), p = l.length, f = c.length, d = u.length, v = s.length, m = 0, g = 0, y = 0, b = 0, x = 0; x < a.length; ++x) h[x] = l[m++] + (a[x] - s[g++]) * c[y++] / Math.sqrt(u[b++] + r), m >= p && (m = 0), g >= v && (g = 0), y >= f && (y = 0), b >= d && (b = 0);
       return xn(h, t.shape)
      }, e.prototype.localResponseNormalization4D = function(t, e, n, r, i) {
       mh(t, "localResponseNormalization4D");
       var o = t.shape[3],
        a = o - 1,
        s = this.readSync(t.dataId),
        u = t.size,
        c = new Float32Array(u);
 
       function l(t) {
        for (var n = t % o, r = t - n + Math.max(0, n - e), i = t - n + Math.min(n + e, a), u = 0; r <= i; r++) {
         var c = s[r];
         u += c * c
        }
        return u
       }
       for (var h = 0; h < u; h++) {
        var p = l(h),
         f = s[h] * Math.pow(n + r * p, -i);
        c[h] = f
       }
       return xn(c, t.shape)
      }, e.prototype.LRNGrad = function(t, e, n, r, i, o, a) {
       mh(t, "LRNGrad");
       for (var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), p = t.size, f = 0; f < p; f++) {
        for (var d = f % s, v = f - d + Math.max(0, d - r), m = f - d + Math.min(s, d + r + 1), g = 0, y = v; y < m; y++) g += Math.pow(c[y], 2);
        for (g = o * g + i, y = v; y < m; y++) {
         var b = -2 * o * a * c[y] * l[f] / g;
         f === y && (b += Math.pow(g, -a)), b *= u[f], h[y] += b
        }
       }
       return xn(h, t.shape)
      }, e.prototype.multinomial = function(t, e, n, r) {
       mh(t, "multinomial");
       for (var i = e ? t : Hr(t), o = i.shape[0], a = i.shape[1], s = kn([o, n], "int32"), u = this.readSync(s.dataId), c = this.readSync(i.dataId), l = 0; l < o; ++l) {
        var h = l * a,
         p = new Float32Array(a - 1);
        p[0] = c[h];
        for (var f = 1; f < p.length; ++f) p[f] = p[f - 1] + c[h + f];
        for (var d = $n(r.toString()), v = l * n, m = 0; m < n; ++m) {
         var g = d();
         u[v + m] = p.length;
         for (var y = 0; y < p.length; y++)
          if (g < p[y]) {
           u[v + m] = y;
           break
          }
        }
       }
       return s
      }, e.prototype.oneHot = function(t, e, n, r) {
       mh(t, "oneHot");
       var i = new Float32Array(t.size * e);
       i.fill(r);
       for (var o = this.readSync(t.dataId), a = 0; a < t.size; ++a) o[a] >= 0 && o[a] < e && (i[a * e + o[a]] = n);
       return yn(i, [t.size, e], "int32")
      }, e.prototype.nonMaxSuppression = function(t, e, n, r, i) {
       return mh(t, "nonMaxSuppression"), bi(this.readSync(t.dataId), this.readSync(e.dataId), n, r, i)
      }, e.prototype.fft = function(t) {
       return this.fftBatch(t, !1)
      }, e.prototype.ifft = function(t) {
       return this.fftBatch(t, !0)
      }, e.prototype.fftBatch = function(t, e) {
       for (var n = t.shape[0], r = t.shape[1], i = Xn(t.shape, "float32"), o = Xn(t.shape, "float32"), a = pn(t).as2D(n, r), s = fn(t).as2D(n, r), u = 0; u < n; u++)
        for (var c = a.slice([u, 0], [1, r]), l = s.slice([u, 0], [1, r]), h = hn(c, l), p = this.readSync(this.fftImpl(h, e).dataId), f = 0; f < r; f++) {
         var d = di(p, f);
         i.values[u * r + f] = d.real, o.values[u * r + f] = d.imag
        }
       return hn(i.toTensor(), o.toTensor()).as2D(n, r)
      }, e.prototype.fftImpl = function(t, e) {
       var n = t.as1D(),
        r = n.size;
       if (this.isExponentOf2(r)) {
        var i = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
        return e && (i = hn(pn(i).div(mn(r)), fn(i).div(mn(r)))), i
       }
       var o = this.readSync(t.dataId),
        a = function(t) {
         for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];
         return {
          real: e,
          imag: n
         }
        }(this.fourierTransformByMatmul(o, r, e));
       return hn(a.real, a.imag).as2D(t.shape[0], t.shape[1])
      }, e.prototype.isExponentOf2 = function(t) {
       return 0 == (t & t - 1)
      }, e.prototype.fftRadix2 = function(t, e, n) {
       if (1 === e) return t;
       var r = this.readSync(t.dataId),
        i = e / 2,
        o = function(t) {
         for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), i = 0; i < t.length; i += 4) n[Math.floor(i / 4)] = t[i], r[Math.floor(i / 4)] = t[i + 1];
         return {
          real: n,
          imag: r
         }
        }(r),
        a = hn(o.real, o.imag).as1D(),
        s = function(t) {
         for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), i = 2; i < t.length; i += 4) n[Math.floor(i / 4)] = t[i], r[Math.floor(i / 4)] = t[i + 1];
         return {
          real: n,
          imag: r
         }
        }(r),
        u = hn(s.real, s.imag).as1D();
       a = this.fftRadix2(a, i, n), u = this.fftRadix2(u, i, n);
       var c = function(t, e) {
         for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), i = 0; i < Math.ceil(t / 2); i++) {
          var o = (e ? 2 : -2) * Math.PI * (i / t);
          n[i] = Math.cos(o), r[i] = Math.sin(o)
         }
         return {
          real: n,
          imag: r
         }
        }(e, n),
        l = hn(c.real, c.imag).mul(u),
        h = a.add(l),
        p = a.sub(l),
        f = pn(h).concat(pn(p)),
        d = fn(h).concat(fn(p));
       return hn(f, d).as1D()
      }, e.prototype.fourierTransformByMatmul = function(t, e, n) {
       for (var r = new Float32Array(2 * e), i = 0; i < e; i++) {
        for (var o = 0, a = 0, s = 0; s < e; s++) {
         var u = mi(i * s, e, n),
          c = di(t, s);
         o += c.real * u.real - c.imag * u.imag, a += c.real * u.imag + c.imag * u.real
        }
        n && (o /= e, a /= e), vi(r, o, a, i)
       }
       return r
      }, e.prototype.depthToSpace = function(t, e, n) {
       k("NHWC" === n, (function() {
        return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n
       })), k(e > 1, (function() {
        return "blockSize should be > 1 for depthToSpace, but was: " + e
       }));
       for (var r = t.shape[0], i = t.shape[1], o = t.shape[2], a = t.shape[3], s = i * e, u = o * e, c = a / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), p = 0, f = 0; f < r; ++f)
        for (var d = 0; d < s; ++d)
         for (var v = Math.floor(d / e), m = d % e, g = 0; g < u; ++g)
          for (var y = Math.floor(g / e), b = (m * e + g % e) * c, x = 0; x < c; ++x) {
           var w = x + b + a * (y + o * (v + i * f));
           h[p++] = l[w]
          }
       return xn(h, [r, s, u, c])
      }, e.prototype.broadcastedBinaryOp = function(t, e, n, r) {
       var i = Zr(t.shape, e.shape),
        o = Xn(i, n),
        a = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = Xr(t.shape, i),
        c = Xr(e.shape, i),
        l = o.values;
       if (u.length + c.length === 0)
        for (var h = 0; h < l.length; ++h) l[h] = r(a[h % a.length], s[h % s.length]);
       else {
        var p = this.bufferSync(t),
         f = this.bufferSync(e),
         d = function(n) {
          var i = o.indexToLoc(n),
           h = i.slice(-t.rank);
          u.forEach((function(t) {
           return h[t] = 0
          }));
          var d = p.locToIndex(h),
           v = i.slice(-e.rank);
          c.forEach((function(t) {
           return v[t] = 0
          }));
          var m = f.locToIndex(v);
          l[n] = r(a[d], s[m])
         };
        for (h = 0; h < l.length; ++h) d(h)
       }
       return o.toTensor()
      }, e.prototype.broadcastedBinaryComplexOp = function(t, e, n) {
       var r = Zr(t.shape, e.shape),
        i = Xn(r, "float32"),
        o = Xn(r, "float32"),
        a = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = Xr(t.shape, r),
        c = Xr(e.shape, r),
        l = i.values,
        h = o.values;
       if (u.length + c.length === 0)
        for (var p = 0; p < l.length; p++) {
         var f = p % a.length,
          d = p % s.length,
          v = n(a[2 * f], a[2 * f + 1], s[2 * d], s[2 * d + 1]);
         l[p] = v.real, h[p] = v.imag
        } else {
         var m = this.bufferSync(this.data.get(t.dataId).complexTensors.real),
          g = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
          y = function(r) {
           var o = i.indexToLoc(r),
            p = o.slice(-t.rank);
           u.forEach((function(t) {
            return p[t] = 0
           }));
           var f = m.locToIndex(p),
            d = o.slice(-e.rank);
           c.forEach((function(t) {
            return d[t] = 0
           }));
           var v = g.locToIndex(d),
            y = n(a[2 * f], a[2 * f + 1], s[2 * v], s[2 * v + 1]);
           l[r] = y.real, h[r] = y.imag
          };
         for (p = 0; p < l.length; p++) y(p)
        }
       return this.complex(i.toTensor(), o.toTensor())
      }, e.prototype.split = function(t, e, n) {
       return ki(t, e, n)
      }, e.prototype.dispose = function() {}, e.prototype.floatPrecision = function() {
       return 32
      }, e.prototype.epsilon = function() {
       return 1e-7
      }, e.prototype.cropAndResize = function(t, e, n, r, i, o) {
       for (var a = t.shape, s = a[0], u = a[1], c = a[2], l = a[3], h = e.shape[0], p = r[0], f = r[1], d = Xn([h, p, f, l], "float32"), v = this.readSync(e.dataId), m = this.readSync(n.dataId), g = this.readSync(t.dataId), y = t.strides, b = d.strides, x = 0; x < h; x++) {
        var w = 4 * x,
         C = v[w],
         S = v[w + 1],
         E = v[w + 2],
         k = v[w + 3],
         I = m[x];
        if (!(I >= s))
         for (var O = p > 1 ? (E - C) * (u - 1) / (p - 1) : 0, A = f > 1 ? (k - S) * (c - 1) / (f - 1) : 0, N = 0; N < p; N++) {
          var R = p > 1 ? C * (u - 1) + N * O : .5 * (C + E) * (u - 1);
          if (R < 0 || R > u - 1)
           for (var T = 0; T < f; T++)
            for (var _ = 0; _ < l; _++) {
             var D = _ + T * b[2] + N * b[1] + x * b[0];
             d.values[D] = o
            } else if ("bilinear" === i) {
             var F = Math.floor(R),
              M = Math.ceil(R),
              L = R - F;
             for (T = 0; T < f; T++)
              if (($ = f > 1 ? S * (c - 1) + T * A : .5 * (S + k) * (c - 1)) < 0 || $ > c - 1)
               for (_ = 0; _ < l; _++) D = _ + T * b[2] + N * b[1] + x * b[0], d.values[D] = o;
              else {
               var B = Math.floor($),
                P = Math.ceil($),
                z = $ - B;
               for (_ = 0; _ < l; _++) {
                var j = g[D = _ + B * y[2] + F * y[1] + I * y[0]],
                 W = g[D = _ + P * y[2] + F * y[1] + I * y[0]],
                 V = g[D = _ + B * y[2] + M * y[1] + I * y[0]],
                 U = j + (W - j) * z,
                 H = V + (g[D = _ + P * y[2] + M * y[1] + I * y[0]] - V) * z;
                D = _ + T * b[2] + N * b[1] + x * b[0], d.values[D] = U + (H - U) * L
               }
              }
            } else
             for (T = 0; T < f; ++T) {
              var $;
              if (($ = f > 1 ? S * (c - 1) + T * A : .5 * (S + k) * (c - 1)) < 0 || $ > c - 1)
               for (_ = 0; _ < l; _++) D = _ + T * b[2] + N * b[1] + x * b[0], d.values[D] = o;
              else {
               var G = Math.round($),
                q = Math.round(R);
               for (_ = 0; _ < l; _++) {
                var K = _ + G * y[2] + q * y[1] + I * y[0],
                 X = _ + T * b[2] + N * b[1] + x * b[0];
                d.values[X] = g[K]
               }
              }
             }
         }
       }
       return d.toTensor()
      }, e.prototype.sparseToDense = function(t, e, n, r) {
       var i = Fr(0, t, n),
        o = i.sliceRank,
        a = i.numUpdates,
        s = i.sliceSize,
        u = i.strides,
        c = i.outputSize;
       return this.scatter(t, e, n, c, s, a, o, u, r, !1)
      }, e.prototype.gatherND = function(t, e) {
       var n = e.shape,
        r = n[n.length - 1],
        i = Nr(t, e),
        o = i[0],
        a = i[1],
        s = i[2],
        u = i[3];
       if (0 === a) return dn([], o, t.dtype);
       for (var c = new gt([a, s], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), p = 0; p < a; p++) {
        for (var f = [], d = 0, v = 0; v < r; v++) {
         var m = l[p * r + v];
         d += m * u[v], f.push(m)
        }
        if (d < 0 || d >= t.size / s) throw new Error("Invalid indices: " + f + " does not index into " + t.shape);
        for (var g = 0; g < s; g++) c.values[p * s + g] = h[d * s + g]
       }
       return c.toTensor().reshape(o)
      }, e.prototype.scatterND = function(t, e, n) {
       var r = Fr(0, t, n),
        i = r.sliceRank,
        o = r.numUpdates,
        a = r.sliceSize,
        s = r.strides,
        u = r.outputSize,
        c = mn(0);
       return this.scatter(t, e, n, u, a, o, i, s, c, !0)
      }, e.prototype.fill = function(t, e, n) {
       var r = j(n = n || Y(e), N(t));
       return r.fill(e), Bt.makeTensor(r, t, n, this)
      }, e.prototype.onesLike = function(t) {
       if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
       return this.fill(t.shape, 1, t.dtype)
      }, e.prototype.zerosLike = function(t) {
       var e = j(t.dtype, N(t.shape));
       return this.makeOutput(e, t.shape, t.dtype)
      }, e.prototype.linspace = function(t, e, n) {
       return pi(t, e, n)
      }, e.prototype.scatter = function(t, e, n, r, i, o, a, s, u, c) {
       var l = [r / i, i],
        h = this.readSync(t.dataId),
        p = this.readSync(e.dataId);
       if (0 === r) return dn([], n, e.dtype);
       var f = new gt(l, e.dtype);
       f.values.fill(this.readSync(u.dataId)[0]);
       for (var d = 0; d < o; d++) {
        for (var v = [], m = 0, g = 0; g < a; g++) {
         var y = h[d * a + g];
         v.push(y), m += y * s[g]
        }
        if (m < 0 || m >= r / i) throw new Error("Invalid indices: " + v + " does not index into " + n);
        for (var b = 0; b < i; b++) c ? f.values[m * i + b] += p[d * i + b] : f.values[m * i + b] = 0 === e.rank ? p[0] : p[d * i + b]
       }
       return f.toTensor().reshape(n)
      }, e
     }(qr);
     Bt.registerBackend("cpu", (function() {
      return new yh
     }), 1), y({
      kernelName: "Square",
      backendName: "cpu",
      kernelFunc: function(t) {
       var e = t.inputs,
        n = t.backend,
        r = e.x,
        i = n;
       mh(r, "square");
       for (var o = i.data.get(r.dataId).values, a = new Float32Array(o.length), s = 0; s < o.length; ++s) {
        var u = o[s];
        a[s] = u * u
       }
       return {
        dataId: i.write(a, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
       }
      }
     }), y({
      kernelName: "NonMaxSuppressionV5",
      backendName: "cpu",
      kernelFunc: function(t) {
       var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        i = e,
        o = i.boxes,
        a = i.scores,
        s = r,
        u = s.maxOutputSize,
        c = s.iouThreshold,
        l = s.scoreThreshold,
        h = s.softNmsSigma,
        p = n;
       mh(o, "NonMaxSuppressionWithScore");
       var f = xi(p.data.get(o.dataId).values, p.data.get(a.dataId).values, u, c, l, h);
       return [f.selectedIndices, f.selectedScores]
      }
     }), y({
      kernelName: "Square",
      backendName: "webgl",
      kernelFunc: function(t) {
       var e = t.inputs,
        n = t.backend,
        r = e.x,
        i = n,
        o = new Xa(r.shape, "return x * x;");
       return i.runWebGLProgram(o, [r], r.dtype)
      }
     });
     var bh, xh = function(t) {
       this.variableNames = ["A"];
       var e = Fi(),
        n = t[0],
        r = t[1];
       this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + e.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "
      },
      wh = function(t) {
       this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
       var e = Fi(),
        n = t[0],
        r = t[1];
       this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + e.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e.output + " = result;\n      }\n    "
      };
     y({
      kernelName: "FromPixels",
      backendName: "webgl",
      kernelFunc: function(t) {
       var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        i = e.pixels,
        o = r.numChannels,
        a = "undefined" != typeof HTMLVideoElement && i instanceof HTMLVideoElement,
        s = "undefined" != typeof HTMLImageElement && i instanceof HTMLImageElement,
        u = a ? [i.videoWidth, i.videoHeight] : [i.width, i.height],
        c = u[0],
        l = u[1],
        p = [l, c],
        f = [l, c, o];
       (s || a) && (null == bh && (bh = document.createElement("canvas").getContext("2d")), bh.canvas.width = c, bh.canvas.height = l, bh.drawImage(i, 0, 0, c, l), i = bh.canvas);
       var d = n.makeTensorInfo(p, "int32");
       n.texData.get(d.dataId).usage = Wt.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), i);
       var v = h().getBool("WEBGL_PACK") ? new wh(f) : new xh(f),
        m = n.runWebGLProgram(v, [d], "int32");
       return n.disposeData(d.dataId), m
      }
     }), y({
      kernelName: "NonMaxSuppressionV5",
      backendName: "webgl",
      kernelFunc: function(t) {
       var e = t.inputs,
        n = t.backend,
        r = t.attrs;
       Ke("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
       var i = e,
        o = i.boxes,
        a = i.scores,
        s = r,
        u = s.maxOutputSize,
        c = s.iouThreshold,
        l = s.scoreThreshold,
        h = s.softNmsSigma,
        p = n,
        f = xi(p.readSync(o.dataId), p.readSync(a.dataId), u, c, l, h);
       return [f.selectedIndices, f.selectedScores]
      }
     });
     var Ch = function() {
      function t() {}
      return t.prototype.fetch = function(t, e) {
       return fetch(t, e)
      }, t.prototype.now = function() {
       return performance.now()
      }, t.prototype.encode = function(t, e) {
       if ("utf-8" !== e && "utf8" !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e);
       return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t)
      }, t.prototype.decode = function(t, e) {
       return new TextDecoder(e).decode(t)
      }, t
     }();
     h().get("IS_BROWSER") && h().setPlatform("browser", new Ch);
     var Sh, Eh = function() {
       return n(5)
      },
      kh = function() {
       function t() {
        this.util = n(6), this.textEncoder = new this.util.TextEncoder
       }
       return t.prototype.fetch = function(t, e) {
        return null != h().global.fetch ? h().global.fetch(t, e) : (null == Sh && (Sh = Eh()), Sh(t, e))
       }, t.prototype.now = function() {
        var t = r.hrtime();
        return 1e3 * t[0] + t[1] / 1e6
       }, t.prototype.encode = function(t, e) {
        if ("utf-8" !== e && "utf8" !== e) throw new Error("Node built-in encoder only supports utf-8, but got " + e);
        return this.textEncoder.encode(t)
       }, t.prototype.decode = function(t, e) {
        return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t)
       }, t
      }();
     h().get("IS_NODE") && h().setPlatform("node", new kh);
     var Ih = {
       float32: 4,
       int32: 4,
       uint16: 2,
       uint8: 1,
       bool: 1
      },
      Oh = 4;
 
     function Ah(t, e) {
      for (var n = {}, r = 0, i = function(e) {
        var i = e.name,
         o = e.dtype,
         a = e.shape,
         s = N(a),
         u = void 0;
        if ("quantization" in e) {
         var c = e.quantization;
         if ("uint8" !== c.dtype && "uint16" !== c.dtype) throw new Error("Weight " + e.name + " has unknown quantization dtype " + c.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
         var l = Ih[c.dtype],
          h = t.slice(r, r + s * l),
          p = "uint8" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);
         if ("float32" === o) u = Float32Array.from(p, (function(t) {
          return t * c.scale + c.min
         }));
         else {
          if ("int32" !== o) throw new Error("Unsupported dtype in weight '" + i + "': " + o);
          u = Int32Array.from(p, (function(t) {
           return Math.round(t * c.scale + c.min)
          }))
         }
         r += s * l
        } else if ("string" === o) {
         var f = N(e.shape);
         u = [];
         for (var d = 0; d < f; d++) {
          var v = new Uint32Array(t.slice(r, r + Oh))[0];
          r += Oh;
          var m = new Uint8Array(t.slice(r, r + v));
          u.push(m), r += v
         }
        } else {
         var g = Ih[o];
         if (h = t.slice(r, r + s * g), "float32" === o) u = new Float32Array(h);
         else if ("int32" === o) u = new Int32Array(h);
         else {
          if ("bool" !== o) throw new Error("Unsupported dtype in weight '" + i + "': " + o);
          u = new Uint8Array(h)
         }
         r += s * g
        }
        n[i] = dn(u, a, o)
       }, o = 0, a = e; o < a.length; o++) i(a[o]);
      return n
     }
 
     function Nh(t) {
      if (null === t) throw new Error("Invalid input value: " + JSON.stringify(t));
      var e = 0,
       n = [];
      t.forEach((function(t) {
       if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t.constructor.name)
      }));
      var r = new Uint8Array(e),
       i = 0;
      return n.forEach((function(t) {
       r.set(new Uint8Array(t.buffer), i), i += t.byteLength
      })), r.buffer
     }
     var Rh = "undefined" != typeof i && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
 
     function Th(t) {
      return Rh ? i.byteLength(t) : new Blob([t]).size
     }
 
     function _h(t) {
      var e = 0;
      t.forEach((function(t) {
       e += t.byteLength
      }));
      var n = new Uint8Array(e),
       r = 0;
      return t.forEach((function(t) {
       n.set(new Uint8Array(t), r), r += t.byteLength
      })), n.buffer
     }
 
     function Dh(t) {
      for (t = t.trim(); t.endsWith("/");) t = t.slice(0, t.length - 1);
      var e = t.split("/");
      return e[e.length - 1]
     }
 
     function Fh(t) {
      if (t.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
      return {
       dateSaved: new Date,
       modelTopologyType: "JSON",
       modelTopologyBytes: null == t.modelTopology ? 0 : Th(JSON.stringify(t.modelTopology)),
       weightSpecsBytes: null == t.weightSpecs ? 0 : Th(JSON.stringify(t.weightSpecs)),
       weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength
      }
     }
     var Mh = function() {
       function t() {
        this.saveRouters = [], this.loadRouters = []
       }
       return t.getInstance = function() {
        return null == t.instance && (t.instance = new t), t.instance
       }, t.registerSaveRouter = function(e) {
        t.getInstance().saveRouters.push(e)
       }, t.registerLoadRouter = function(e) {
        t.getInstance().loadRouters.push(e)
       }, t.getSaveHandlers = function(e) {
        return t.getHandlers(e, "save")
       }, t.getLoadHandlers = function(e, n) {
        return t.getHandlers(e, "load", n)
       }, t.getHandlers = function(e, n, r) {
        var i = [];
        return ("load" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach((function(t) {
         var n = t(e, r);
         null !== n && i.push(n)
        })), i
       }, t
      }(),
      Lh = "://",
      Bh = function() {
       function t() {
        this.managers = {}
       }
       return t.getInstance = function() {
        return null == t.instance && (t.instance = new t), t.instance
       }, t.registerManager = function(e, n) {
        k(null != e, (function() {
         return "scheme must not be undefined or null."
        })), e.endsWith(Lh) && (e = e.slice(0, e.indexOf(Lh))), k(e.length > 0, (function() {
         return "scheme must not be an empty string."
        }));
        var r = t.getInstance();
        k(null == r.managers[e], (function() {
         return "A model store manager is already registered for scheme '" + e + "'."
        })), r.managers[e] = n
       }, t.getManager = function(t) {
        var e = this.getInstance().managers[t];
        if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'");
        return e
       }, t.getSchemes = function() {
        return Object.keys(this.getInstance().managers)
       }, t
      }();
 
     function Ph(t) {
      if (-1 === t.indexOf(Lh)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Bh.getSchemes().join(","));
      return {
       scheme: t.split(Lh)[0],
       path: t.split(Lh)[1]
      }
     }
 
     function zh(t, e, n) {
      return void 0 === n && (n = !1), s(this, void 0, void 0, (function() {
       var r, i, o, a, s, c, l, h, p;
       return u(this, (function(u) {
        switch (u.label) {
         case 0:
          return k(t !== e, (function() {
           return "Old path and new path are the same: '" + t + "'"
          })), k((r = Mh.getLoadHandlers(t)).length > 0, (function() {
           return "Copying failed because no load handler is found for source URL " + t + "."
          })), k(r.length < 2, (function() {
           return "Copying failed because more than one (" + r.length + ") load handlers for source URL " + t + "."
          })), i = r[0], k((o = Mh.getSaveHandlers(e)).length > 0, (function() {
           return "Copying failed because no save handler is found for destination URL " + e + "."
          })), k(o.length < 2, (function() {
           return "Copying failed because more than one (" + r.length + ") save handlers for destination URL " + e + "."
          })), a = o[0], s = Ph(t).scheme, c = Ph(t).path, l = s === Ph(t).scheme, [4, i.load()];
         case 1:
          return h = u.sent(), n && l ? [4, Bh.getManager(s).removeModel(c)] : [3, 3];
         case 2:
          u.sent(), u.label = 3;
         case 3:
          return [4, a.save(h)];
         case 4:
          return p = u.sent(), !n || l ? [3, 6] : [4, Bh.getManager(s).removeModel(c)];
         case 5:
          u.sent(), u.label = 6;
         case 6:
          return [2, p.modelArtifactsInfo]
        }
       }))
      }))
     }
     var jh = "models_store",
      Wh = "model_info_store";
 
     function Vh() {
      if (!h().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
      var t = window,
       e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
      if (null == e) throw new Error("The current browser does not appear to support IndexedDB.");
      return e
     }
 
     function Uh(t) {
      var e = t.result;
      e.createObjectStore(jh, {
       keyPath: "modelPath"
      }), e.createObjectStore(Wh, {
       keyPath: "modelPath"
      })
     }
     var Hh = function() {
       function t(t) {
        if (this.indexedDB = Vh(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        this.modelPath = t
       }
       return t.prototype.save = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
          return [2, this.databaseAction(this.modelPath, t)]
         }))
        }))
       }, t.prototype.load = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return [2, this.databaseAction(this.modelPath)]
         }))
        }))
       }, t.prototype.databaseAction = function(t, e) {
        var n = this;
        return new Promise((function(t, r) {
         var i = n.indexedDB.open("tensorflowjs", 1);
         i.onupgradeneeded = function() {
          return Uh(i)
         }, i.onsuccess = function() {
          var o = i.result;
          if (null == e) {
           var a = o.transaction(jh, "readonly"),
            s = a.objectStore(jh).get(n.modelPath);
           s.onsuccess = function() {
            if (null == s.result) return o.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
            t(s.result.modelArtifacts)
           }, s.onerror = function(t) {
            return o.close(), r(s.error)
           }, a.oncomplete = function() {
            return o.close()
           }
          } else {
           var u, c = Fh(e),
            l = o.transaction(Wh, "readwrite"),
            h = l.objectStore(Wh),
            p = h.put({
             modelPath: n.modelPath,
             modelArtifactsInfo: c
            });
           p.onsuccess = function() {
            var i = (u = o.transaction(jh, "readwrite")).objectStore(jh).put({
             modelPath: n.modelPath,
             modelArtifacts: e,
             modelArtifactsInfo: c
            });
            i.onsuccess = function() {
             return t({
              modelArtifactsInfo: c
             })
            }, i.onerror = function(t) {
             var e = (h = l.objectStore(Wh)).delete(n.modelPath);
             e.onsuccess = function() {
              return o.close(), r(i.error)
             }, e.onerror = function(t) {
              return o.close(), r(i.error)
             }
            }
           }, p.onerror = function(t) {
            return o.close(), r(p.error)
           }, l.oncomplete = function() {
            null == u ? o.close() : u.oncomplete = function() {
             return o.close()
            }
           }
          }
         }, i.onerror = function(t) {
          return r(i.error)
         }
        }))
       }, t.URL_SCHEME = "indexeddb://", t
      }(),
      $h = function(t) {
       return h().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Hh.URL_SCHEME) ? (e = t.slice(Hh.URL_SCHEME.length), new Hh(e)) : null;
       var e
      };
     Mh.registerSaveRouter($h), Mh.registerLoadRouter($h);
     var Gh = function() {
      function t() {
       this.indexedDB = Vh()
      }
      return t.prototype.listModels = function() {
       return s(this, void 0, void 0, (function() {
        var t = this;
        return u(this, (function(e) {
         return [2, new Promise((function(e, n) {
          var r = t.indexedDB.open("tensorflowjs", 1);
          r.onupgradeneeded = function() {
           return Uh(r)
          }, r.onsuccess = function() {
           var t = r.result,
            i = t.transaction(Wh, "readonly"),
            o = i.objectStore(Wh).getAll();
           o.onsuccess = function() {
            for (var t = {}, n = 0, r = o.result; n < r.length; n++) {
             var i = r[n];
             t[i.modelPath] = i.modelArtifactsInfo
            }
            e(t)
           }, o.onerror = function(e) {
            return t.close(), n(o.error)
           }, i.oncomplete = function() {
            return t.close()
           }
          }, r.onerror = function(t) {
           return n(r.error)
          }
         }))]
        }))
       }))
      }, t.prototype.removeModel = function(t) {
       return s(this, void 0, void 0, (function() {
        var e = this;
        return u(this, (function(n) {
         var r;
         return t = (r = t).startsWith(Hh.URL_SCHEME) ? r.slice(Hh.URL_SCHEME.length) : r, [2, new Promise((function(n, r) {
          var i = e.indexedDB.open("tensorflowjs", 1);
          i.onupgradeneeded = function() {
           return Uh(i)
          }, i.onsuccess = function() {
           var e, o = i.result,
            a = o.transaction(Wh, "readwrite"),
            s = a.objectStore(Wh),
            u = s.get(t);
           u.onsuccess = function() {
            if (null == u.result) return o.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));
            var i = s.delete(t),
             a = function() {
              var i = (e = o.transaction(jh, "readwrite")).objectStore(jh).delete(t);
              i.onsuccess = function() {
               return n(u.result.modelArtifactsInfo)
              }, i.onerror = function(t) {
               return r(u.error)
              }
             };
            i.onsuccess = a, i.onerror = function(t) {
             return a(), o.close(), r(u.error)
            }
           }, u.onerror = function(t) {
            return o.close(), r(u.error)
           }, a.oncomplete = function() {
            null == e ? o.close() : e.oncomplete = function() {
             return o.close()
            }
           }
          }, i.onerror = function(t) {
           return r(i.error)
          }
         }))]
        }))
       }))
      }, t
     }();
     if (h().getBool("IS_BROWSER")) try {
      Bh.registerManager(Hh.URL_SCHEME, new Gh)
     } catch (o) {}
     var qh = "/",
      Kh = "tensorflowjs_models",
      Xh = "info",
      Yh = "model_topology",
      Zh = "weight_specs",
      Jh = "weight_data",
      Qh = "model_metadata";
 
     function tp(t) {
      return {
       info: [Kh, t, Xh].join(qh),
       topology: [Kh, t, Yh].join(qh),
       weightSpecs: [Kh, t, Zh].join(qh),
       weightData: [Kh, t, Jh].join(qh),
       modelMetadata: [Kh, t, Qh].join(qh)
      }
     }
 
     function ep(t) {
      var e = t.split(qh);
      if (e.length < 3) throw new Error("Invalid key format: " + t);
      return e.slice(1, e.length - 1).join(qh)
     }
     var np = function() {
       function t(t) {
        if (!h().getBool("IS_BROWSER") || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
        if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        this.modelPath = t, this.keys = tp(this.modelPath)
       }
       return t.prototype.save = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r;
         return u(this, (function(o) {
          if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
          e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), r = Fh(t);
          try {
           return this.LS.setItem(this.keys.info, JSON.stringify(r)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function(t) {
            if (Rh) return i.from(t).toString("base64");
            for (var e = new Uint8Array(t), n = "", r = 0, o = e.length; r < o; r++) n += String.fromCharCode(e[r]);
            return btoa(n)
           }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
            format: t.format,
            generatedBy: t.generatedBy,
            convertedBy: t.convertedBy,
            userDefinedMetadata: t.userDefinedMetadata
           })), [2, {
            modelArtifactsInfo: r
           }]
          } catch (t) {
           throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + r.modelTopologyBytes + ", weightSpecsBytes=" + r.weightSpecsBytes + ", weightDataBytes=" + r.weightDataBytes + ".")
          }
          return [2]
         }))
        }))
       }, t.prototype.load = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, o, a, s;
         return u(this, (function(u) {
          if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
          if ("JSON" !== t.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
          if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
          if (e.modelTopology = n, null == (r = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
          if (e.weightSpecs = r, null != (o = this.LS.getItem(this.keys.modelMetadata)) && (a = JSON.parse(o), e.format = a.format, e.generatedBy = a.generatedBy, e.convertedBy = a.convertedBy, e.userDefinedMetadata = a.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
          return e.weightData = function(t) {
           if (Rh) {
            var e = i.from(t, "base64");
            return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
           }
           for (var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o) r.set([n.charCodeAt(o)], o);
           return r.buffer
          }(s), [2, e]
         }))
        }))
       }, t.URL_SCHEME = "localstorage://", t
      }(),
      rp = function(t) {
       return h().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(np.URL_SCHEME) ? (e = t.slice(np.URL_SCHEME.length), new np(e)) : null;
       var e
      };
     Mh.registerSaveRouter(rp), Mh.registerLoadRouter(rp);
     var ip = function() {
      function t() {
       k(h().getBool("IS_BROWSER"), (function() {
        return "Current environment is not a web browser"
       })), k(void 0 !== window.localStorage, (function() {
        return "Current browser does not appear to support localStorage"
       })), this.LS = window.localStorage
      }
      return t.prototype.listModels = function() {
       return s(this, void 0, void 0, (function() {
        var t, e, n, r, i, o;
        return u(this, (function(a) {
         for (t = {}, e = Kh + qh, n = qh + Xh, r = 0; r < this.LS.length; ++r)(i = this.LS.key(r)).startsWith(e) && i.endsWith(n) && (o = ep(i), t[o] = JSON.parse(this.LS.getItem(i)));
         return [2, t]
        }))
       }))
      }, t.prototype.removeModel = function(t) {
       return s(this, void 0, void 0, (function() {
        var e, n;
        return u(this, (function(r) {
         var i;
         if (t = (i = t).startsWith(np.URL_SCHEME) ? i.slice(np.URL_SCHEME.length) : i, e = tp(t), null == this.LS.getItem(e.info)) throw new Error("Cannot find model at path '" + t + "'");
         return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n]
        }))
       }))
      }, t
     }();
     if (h().getBool("IS_BROWSER")) try {
      Bh.registerManager(np.URL_SCHEME, new ip)
     } catch (o) {}
     var op = "model",
      ap = ".json",
      sp = ".weights.bin";
 
     function up(t) {
      return new Promise((function(t) {
       return setTimeout(t)
      })).then(t)
     }
     var cp = function() {
       function t(e) {
        if (!h().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = op), this.modelTopologyFileName = e + ap, this.weightDataFileName = e + sp
       }
       return t.prototype.save = function(t) {
        return s(this, void 0, void 0, (function() {
         var e, n, r, i, o, a;
         return u(this, (function(s) {
          switch (s.label) {
           case 0:
            if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (e = window.URL.createObjectURL(new Blob([t.weightData], {
              type: "application/octet-stream"
             })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
           case 1:
            return n = [{
             paths: ["./" + this.weightDataFileName],
             weights: t.weightSpecs
            }], r = {
             modelTopology: t.modelTopology,
             format: t.format,
             generatedBy: t.generatedBy,
             convertedBy: t.convertedBy,
             weightsManifest: n
            }, i = window.URL.createObjectURL(new Blob([JSON.stringify(r)], {
             type: "application/json"
            })), (o = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, o.href = i, [4, up((function() {
             return o.dispatchEvent(new MouseEvent("click"))
            }))];
           case 2:
            return s.sent(), null == t.weightData ? [3, 4] : ((a = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, a.href = e, [4, up((function() {
             return a.dispatchEvent(new MouseEvent("click"))
            }))]);
           case 3:
            s.sent(), s.label = 4;
           case 4:
            return [2, {
             modelArtifactsInfo: Fh(t)
            }]
          }
         }))
        }))
       }, t.URL_SCHEME = "downloads://", t
      }(),
      lp = function() {
       function t(t) {
        if (null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t);
        this.files = t
       }
       return t.prototype.load = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n = this;
         return u(this, (function(r) {
          return t = this.files[0], e = this.files.slice(1), [2, new Promise((function(r, i) {
           var o = new FileReader;
           o.onload = function(o) {
            var a = JSON.parse(o.target.result),
             s = a.modelTopology;
            if (null != s) {
             0 === e.length && r({
              modelTopology: s
             });
             var u = a.weightsManifest;
             if (null != u) {
              var c;
              try {
               c = n.checkManifestAndWeightFiles(u, e)
              } catch (t) {
               return void i(t)
              }
              var l = [],
               h = [],
               p = [];
              u.forEach((function(t) {
               t.paths.forEach((function(t) {
                h.push(t), p.push(null)
               })), l.push.apply(l, t.weights)
              })), u.forEach((function(t) {
               t.paths.forEach((function(t) {
                var e = new FileReader;
                e.onload = function(e) {
                 var n = e.target.result,
                  i = h.indexOf(t);
                 p[i] = n, -1 === p.indexOf(null) && r({
                  modelTopology: s,
                  weightSpecs: l,
                  weightData: _h(p),
                  format: a.format,
                  generatedBy: a.generatedBy,
                  convertedBy: a.convertedBy,
                  userDefinedMetadata: a.userDefinedMetadata
                 })
                }, e.onerror = function(e) {
                 return i("Failed to weights data from file of path '" + t + "'.")
                }, e.readAsArrayBuffer(c[t])
               }))
              }))
             } else i(new Error("weightManifest field is missing from file " + t.name))
            } else i(new Error("modelTopology field is missing from file " + t.name))
           }, o.onerror = function(e) {
            return i("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")
           }, o.readAsText(t)
          }))]
         }))
        }))
       }, t.prototype.checkManifestAndWeightFiles = function(t, e) {
        for (var n = [], r = e.map((function(t) {
          return Dh(t.name)
         })), i = {}, o = 0, a = t; o < a.length; o++) a[o].paths.forEach((function(t) {
         var o = Dh(t);
         if (-1 !== n.indexOf(o)) throw new Error("Duplicate file basename found in weights manifest: '" + o + "'");
         if (n.push(o), -1 === r.indexOf(o)) throw new Error("Weight file with basename '" + o + "' is not provided.");
         i[t] = e[r.indexOf(o)]
        }));
        if (n.length !== e.length) throw new Error("Mismatch in the number of files in weights manifest (" + n.length + ") and the number of weight files provided (" + e.length + ").");
        return i
       }, t
      }();
 
     function hp(t, e, n, r) {
      ! function(t) {
       k(null != t && Array.isArray(t) && t.length > 0, (function() {
        return "promises must be a none empty array"
       }))
      }(t),
      function(t, e) {
       k(t >= 0 && t <= 1, (function() {
        return "Progress fraction must be in range [0, 1], but got startFraction " + t
       })), k(e >= 0 && e <= 1, (function() {
        return "Progress fraction must be in range [0, 1], but got endFraction " + e
       })), k(e >= t, (function() {
        return "startFraction must be no more than endFraction, but got startFraction " + t + " and endFraction " + e
       }))
      }(n = null == n ? 0 : n, r = null == r ? 1 : r);
      var i = 0;
      return Promise.all(t.map((function(o) {
       return o.then((function(o) {
        var a = n + ++i / t.length * (r - n);
        return e(a), o
       })), o
      })))
     }
 
     function pp(t, e) {
      return s(this, void 0, void 0, (function() {
       var n, r, i, o, a, s, c, l, p;
       return u(this, (function(u) {
        switch (u.label) {
         case 0:
          return null == e && (e = {}), n = null == e.fetchFunc ? h().platform.fetch : e.fetchFunc, r = t.map((function(t) {
           return n(t, e.requestInit, {
            isBinary: !0
           })
          })), i = 0, o = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(r)];
         case 1:
          return a = u.sent(), [3, 4];
         case 2:
          return [4, hp(r, e.onProgress, i, o)];
         case 3:
          a = u.sent(), u.label = 4;
         case 4:
          return s = a.map((function(t) {
           return t.arrayBuffer()
          })), c = .5, l = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(s)];
         case 5:
          return p = u.sent(), [3, 8];
         case 6:
          return [4, hp(s, e.onProgress, c, l)];
         case 7:
          p = u.sent(), u.label = 8;
         case 8:
          return [2, p]
        }
       }))
      }))
     }
 
     function fp(t) {
      var e = this;
      return function(n, r, i) {
       return void 0 === r && (r = ""), s(e, void 0, void 0, (function() {
        var e, o, a, s, c, l, h, p, f, d;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           if (e = n.map((function() {
             return !1
            })), o = {}, a = null != i ? i.map((function() {
             return !1
            })) : [], s = [], n.forEach((function(t, n) {
             var r = 0;
             t.weights.forEach((function(t) {
              var u = "quantization" in t ? t.quantization.dtype : t.dtype,
               c = Ih[u] * N(t.shape),
               l = function() {
                e[n] = !0, null == o[n] && (o[n] = []), o[n].push({
                 manifestEntry: t,
                 groupOffset: r,
                 sizeBytes: c
                })
               };
              null != i ? i.forEach((function(e, n) {
               e === t.name && (l(), a[n] = !0)
              })) : l(), s.push(t.name), r += c
             }))
            })), !a.every((function(t) {
             return t
            }))) throw c = i.filter((function(t, e) {
            return !a[e]
           })), new Error("Could not find weights in manifest with names: " + c.join(", ") + ". \nManifest JSON has weights with names: " + s.join(", ") + ".");
           return l = e.reduce((function(t, e, n) {
            return e && t.push(n), t
           }), []), h = [], l.forEach((function(t) {
            n[t].paths.forEach((function(t) {
             var e = r + (r.endsWith("/") ? "" : "/") + t;
             h.push(e)
            }))
           })), [4, t(h)];
          case 1:
           return p = u.sent(), f = {}, d = 0, l.forEach((function(t) {
            for (var e = n[t].paths.length, r = 0, i = 0; i < e; i++) r += p[d + i].byteLength;
            for (var a = new ArrayBuffer(r), s = new Uint8Array(a), u = 0, c = 0; c < e; c++) {
             var l = new Uint8Array(p[d + c]);
             s.set(l, u), u += l.byteLength
            }
            o[t].forEach((function(t) {
             var e = Ah(a.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);
             for (var n in e) f[n] = e[n]
            })), d += e
           })), [2, f]
         }
        }))
       }))
      }
     }
     Mh.registerSaveRouter((function(t) {
      return h().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(cp.URL_SCHEME) ? function(t) {
       return void 0 === t && (t = "model"), new cp(t)
      }(t.slice(cp.URL_SCHEME.length)) : null
     }));
     var dp = function() {
      function t(t, e) {
       if (this.DEFAULT_METHOD = "POST", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (k("function" == typeof e.fetchFunc, (function() {
         return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"
        })), this.fetch = e.fetchFunc) : this.fetch = h().platform.fetch, k(null != t && t.length > 0, (function() {
         return "URL path for http must not be null, undefined or empty."
        })), Array.isArray(t) && k(2 === t.length, (function() {
         return "URL paths for http must have a length of 2, (actual length is " + t.length + ")."
        })), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
       this.requestInit = e.requestInit || {}
      }
      return t.prototype.save = function(t) {
       return s(this, void 0, void 0, (function() {
        var e, n, r, i;
        return u(this, (function(o) {
         switch (o.label) {
          case 0:
           if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
           return (e = Object.assign({
            method: this.DEFAULT_METHOD
           }, this.requestInit)).body = new FormData, n = [{
            paths: ["./model.weights.bin"],
            weights: t.weightSpecs
           }], r = {
            modelTopology: t.modelTopology,
            format: t.format,
            generatedBy: t.generatedBy,
            convertedBy: t.convertedBy,
            userDefinedMetadata: t.userDefinedMetadata,
            weightsManifest: n
           }, e.body.append("model.json", new Blob([JSON.stringify(r)], {
            type: "application/json"
           }), "model.json"), null != t.weightData && e.body.append("model.weights.bin", new Blob([t.weightData], {
            type: "application/octet-stream"
           }), "model.weights.bin"), [4, this.fetch(this.path, e)];
          case 1:
           if ((i = o.sent()).ok) return [2, {
            modelArtifactsInfo: Fh(t),
            responses: [i]
           }];
           throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + i.status + ".")
         }
        }))
       }))
      }, t.prototype.load = function() {
       return s(this, void 0, void 0, (function() {
        var t, e, n, r, i, o, a, s, c, l, h, p;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           return [4, this.fetch(this.path, this.requestInit)];
          case 1:
           if (!(t = u.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
           u.label = 2;
          case 2:
           return u.trys.push([2, 4, , 5]), [4, t.json()];
          case 3:
           return e = u.sent(), [3, 5];
          case 4:
           throw u.sent(), n = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n += " Please make sure the server is serving valid JSON for this request.", new Error(n);
          case 5:
           if (r = e.modelTopology, i = e.weightsManifest, o = e.generatedBy, a = e.convertedBy, s = e.format, c = e.userDefinedMetadata, null == r && null == i) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
           return null == i ? [3, 7] : [4, this.loadWeights(i)];
          case 6:
           p = u.sent(), l = p[0], h = p[1], u.label = 7;
          case 7:
           return [2, {
            modelTopology: r,
            weightSpecs: l,
            weightData: h,
            userDefinedMetadata: c,
            generatedBy: o,
            convertedBy: a,
            format: s
           }]
         }
        }))
       }))
      }, t.prototype.loadWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        var e, n, r, i, o, a, s, c, l, h, p;
        return u(this, (function(u) {
         switch (u.label) {
          case 0:
           for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function(t) {
             var e = t.lastIndexOf("/"),
              n = t.lastIndexOf("?"),
              r = t.substring(0, e),
              i = n > e ? t.substring(n) : "";
             return [r + "/", i]
            }(e), r = n[0], i = n[1], o = this.weightPathPrefix || r, a = [], s = 0, c = t; s < c.length; s++) l = c[s], a.push.apply(a, l.weights);
           return h = [], t.forEach((function(t) {
            t.paths.forEach((function(t) {
             h.push(o + t + i)
            }))
           })), [4, pp(h, {
            requestInit: this.requestInit,
            fetchFunc: this.fetch,
            onProgress: this.onProgress
           })];
          case 1:
           return p = u.sent(), [2, [a, _h(p)]]
         }
        }))
       }))
      }, t.URL_SCHEME_REGEX = /^https?:\/\//, t
     }();
 
     function vp(t) {
      return null != t.match(dp.URL_SCHEME_REGEX)
     }
     var mp = function(t, e) {
      return "undefined" == typeof fetch ? null : (Array.isArray(t) ? t.every((function(t) {
       return vp(t)
      })) : vp(t)) ? gp(t, {
       onProgress: e
      }) : null
     };
 
     function gp(t, e) {
      return new dp(t, e)
     }
     Mh.registerSaveRouter(mp), Mh.registerLoadRouter(mp);
     var yp, bp = function() {
       function t(t) {
        this.modelArtifacts = t
       }
       return t.prototype.load = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return [2, this.modelArtifacts]
         }))
        }))
       }, t
      }(),
      xp = function() {
       function t(t) {
        this.saveHandler = t
       }
       return t.prototype.save = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(e) {
          return [2, this.saveHandler(t)]
         }))
        }))
       }, t
      }(),
      wp = (Object.freeze({
       browserFiles: function(t) {
        return new lp(t)
       },
       browserHTTPRequest: function(t, e) {
        return gp(t, e)
       },
       concatenateArrayBuffers: _h,
       decodeWeights: Ah,
       encodeWeights: function(t, e) {
        return s(this, void 0, void 0, (function() {
         var n, r, i, o, a, c = this;
         return u(this, (function(l) {
          switch (l.label) {
           case 0:
            for (n = [], r = [], i = Array.isArray(t) ? t.map((function(t) {
              return t.name
             })) : Object.keys(t), o = function(o) {
              var a = i[o],
               l = Array.isArray(t) ? t[o].tensor : t[a];
              if ("float32" !== l.dtype && "int32" !== l.dtype && "bool" !== l.dtype && "string" !== l.dtype) throw new Error("Unsupported dtype in weight '" + a + "': " + l.dtype);
              var h = {
               name: a,
               shape: l.shape,
               dtype: l.dtype
              };
              if ("string" === l.dtype) {
               var p = new Promise((function(t) {
                return s(c, void 0, void 0, (function() {
                 var e, n, r, i, o, a, s;
                 return u(this, (function(u) {
                  switch (u.label) {
                   case 0:
                    return [4, l.bytes()];
                   case 1:
                    for (e = u.sent(), n = e.reduce((function(t, e) {
                      return t + e.length
                     }), 0) + Oh * e.length, r = new Uint8Array(n), i = 0, o = 0; o < e.length; o++) a = e[o], s = new Uint8Array(new Uint32Array([a.length]).buffer), r.set(s, i), i += Oh, r.set(a, i), i += a.length;
                    return t(r), [2]
                  }
                 }))
                }))
               }));
               r.push(p)
              } else r.push(l.data());
              null != e && (h.group = e), n.push(h)
             }, a = 0; a < i.length; ++a) o(a);
            return [4, Promise.all(r)];
           case 1:
            return [2, {
             data: Nh(l.sent()),
             specs: n
            }]
          }
         }))
        }))
       },
       fromMemory: function(t, e, n, r) {
        return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new bp(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new bp({
         modelTopology: t
        })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new bp({
         modelTopology: t,
         weightSpecs: e,
         weightData: n,
         trainingConfig: r
        }))
       },
       getLoadHandlers: function(t, e) {
        return Mh.getLoadHandlers(t, e)
       },
       getModelArtifactsInfoForJSON: Fh,
       getSaveHandlers: function(t) {
        return Mh.getSaveHandlers(t)
       },
       http: gp,
       isHTTPScheme: vp,
       loadWeights: function(t, e, n, r) {
        return void 0 === e && (e = ""), s(this, void 0, void 0, (function() {
         return u(this, (function(i) {
          return [2, fp((function(t) {
           return pp(t, {
            requestInit: r
           })
          }))(t, e, n)]
         }))
        }))
       },
       registerLoadRouter: function(t) {
        return Mh.registerLoadRouter(t)
       },
       registerSaveRouter: function(t) {
        return Mh.registerSaveRouter(t)
       },
       weightsLoaderFactory: fp,
       withSaveHandler: function(t) {
        return new xp(t)
       },
       copyModel: function(t, e) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(n) {
          return [2, zh(t, e, !1)]
         }))
        }))
       },
       listModels: function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r, i, o, a;
         return u(this, (function(s) {
          switch (s.label) {
           case 0:
            t = Bh.getSchemes(), e = {}, n = 0, r = t, s.label = 1;
           case 1:
            return n < r.length ? (i = r[n], [4, Bh.getManager(i).listModels()]) : [3, 4];
           case 2:
            for (a in o = s.sent()) e[i + Lh + a] = o[a];
            s.label = 3;
           case 3:
            return n++, [3, 1];
           case 4:
            return [2, e]
          }
         }))
        }))
       },
       moveModel: function(t, e) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(n) {
          return [2, zh(t, e, !0)]
         }))
        }))
       },
       removeModel: function(t) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          return e = Ph(t), [2, Bh.getManager(e.scheme).removeModel(e.path)]
         }))
        }))
       }
      }), ln({
       confusionMatrix_: function(t, e, n) {
        var r = Ze(t, "labels", "confusionMatrix"),
         i = Ze(e, "predictions", "confusionMatrix");
        k(null == n || n > 0 && Number.isInteger(n), (function() {
         return "If provided, numClasses must be a positive integer, but got " + n
        })), k(1 === r.rank, (function() {
         return "Expected the rank of labels to be 1, but got " + r.rank
        })), k(1 === i.rank, (function() {
         return "Expected the rank of predictions to be 1, but got " + i.rank
        })), k(r.shape[0] === i.shape[0], (function() {
         return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + i.shape[0] + ". Labels and predictions should have the same number of elements."
        })), k(n > 0 && Number.isInteger(n), (function() {
         return "numClasses is required to be a positive integer, but got " + n
        }));
        var o = ar(r.asType("int32"), n),
         a = ar(i.asType("int32"), n);
        return o.transpose().matMul(a).asType("int32")
       }
      })),
      Cp = (Object.freeze({
       confusionMatrix: wp
      }), ln({
       fromPixels_: function(t, e) {
        if (void 0 === e && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n = !1,
         r = !1,
         i = !1,
         o = !1,
         a = !1;
        if (t.data instanceof Uint8Array) n = !0;
        else if ("undefined" != typeof ImageData && t instanceof ImageData) r = !0;
        else if ("undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) i = !0;
        else if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) o = !0;
        else {
         if (null == t.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
         a = !0
        }
        if (i && i && t.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
        if (null != v("FromPixels", Bt.backendName)) return Bt.runKernel("FromPixels", {
         pixels: t
        }, {
         numChannels: e
        });
        var s, u, c = i ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
         l = c[0],
         h = c[1];
        if (a ? s = t.getContext("2d").getImageData(0, 0, l, h).data : r || n ? s = t.data : (o || i) && (null == yp && (yp = document.createElement("canvas").getContext("2d")), yp.canvas.width = l, yp.canvas.height = h, yp.drawImage(t, 0, 0, l, h), s = yp.getImageData(0, 0, l, h).data), 4 === e) u = new Int32Array(s);
        else {
         var p = l * h;
         u = new Int32Array(p * e);
         for (var f = 0; f < p; f++)
          for (var d = 0; d < e; ++d) u[f * e + d] = s[4 * f + d]
        }
        return bn(u, [h, l, e], "int32")
       }
      })),
      Sp = (Object.freeze({
       toPixels: function(t, e) {
        return s(this, void 0, void 0, (function() {
         var n, r, i, o, a, s, c, l, h, p, f, d, v, m, g, y, b, x, w, C, S, E, k;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            if (n = Ze(t, "img", "toPixels"), t instanceof wt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n.rank + ".");
            if (r = n.shape.slice(0, 2), i = r[0], o = r[1], (a = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === a) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + a);
            return [4, n.data()];
           case 1:
            return s = u.sent(), c = n.min(), l = n.max(), [4, Promise.all([c.data(), l.data()])];
           case 2:
            if (h = u.sent(), p = h[0], f = h[1], d = p[0], v = f[0], c.dispose(), l.dispose(), "float32" === n.dtype) {
             if (d < 0 || v > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d + " - " + v + "].")
            } else {
             if ("int32" !== n.dtype) throw new Error("Unsupported type for toPixels: " + n.dtype + ". Please use float32 or int32 tensors.");
             if (d < 0 || v > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d + " - " + v + "].")
            }
            for (m = "float32" === n.dtype ? 255 : 1, g = new Uint8ClampedArray(o * i * 4), y = 0; y < i * o; ++y) b = void 0, x = void 0, w = void 0, C = void 0, 1 === a ? (b = s[y] * m, x = s[y] * m, w = s[y] * m, C = 255) : 3 === a ? (b = s[3 * y] * m, x = s[3 * y + 1] * m, w = s[3 * y + 2] * m, C = 255) : 4 === a && (b = s[4 * y] * m, x = s[4 * y + 1] * m, w = s[4 * y + 2] * m, C = s[4 * y + 3] * m), g[0 + (S = 4 * y)] = Math.round(b), g[S + 1] = Math.round(x), g[S + 2] = Math.round(w), g[S + 3] = Math.round(C);
            return null != e && (e.width = o, e.height = i, E = e.getContext("2d"), k = new ImageData(g, o, i), E.putImageData(k, 0, 0)), n !== t && n.dispose(), [2, g]
          }
         }))
        }))
       },
       fromPixels: Cp
      }), function() {
       function t() {}
       return t.prototype.getClassName = function() {
        return this.constructor.className
       }, t.fromConfig = function(t, e) {
        return new t(e)
       }, t
      }()),
      Ep = function() {
       function t() {
        this.classNameMap = {}
       }
       return t.getMap = function() {
        return null == t.instance && (t.instance = new t), t.instance
       }, t.register = function(e) {
        t.getMap().classNameMap[e.className] = [e, e.fromConfig]
       }, t
      }();
 
     function kp(t) {
      k(null != t.className, (function() {
       return "Class being registered does not have the static className property defined."
      })), k("string" == typeof t.className, (function() {
       return "className is required to be a string, but got type " + typeof t.className
      })), k(t.className.length > 0, (function() {
       return "Class being registered has an empty-string as its className, which is disallowed."
      })), Ep.register(t)
     }
     Object.freeze({
      Serializable: Sp,
      SerializationMap: Ep,
      registerClass: kp
     });
     var Ip = .001,
      Op = .1;
 
     function Ap() {
      return 32 === Bt.backend.floatPrecision() ? Ip : Op
     }
 
     function Np(t, e, n) {
      var r = !0;
      if ((H(t) || H(e)) && (r = !1), H(t) && H(e) && (r = !0), r) {
       var i = t.constructor.name,
        o = e.constructor.name;
       if (i !== o) throw new Error("Arrays are of different type. Actual: " + i + ". Expected: " + o)
      }
      if (Array.isArray(t) && Array.isArray(e)) {
       var a = Xe(t),
        s = Xe(e);
       if (!R(a, s)) throw new Error("Arrays have different shapes. Actual: [" + a + "]. Expected: [" + s + "]")
      }
      var u = H(t) ? t : A(t),
       c = H(e) ? e : A(e);
      if (u.length !== c.length) throw new Error("Arrays have different lengths actual: " + u.length + " vs expected: " + c.length + ".\nActual:   " + u + ".\nExpected: " + c + ".");
      for (var l = 0; l < c.length; ++l) {
       var h = u[l],
        p = c[l];
       if (!n(h, p)) throw new Error("Arrays differ: actual[" + l + "] = " + h + ", expected[" + l + "] = " + p + ".\nActual:   " + u + ".\nExpected: " + c + ".")
      }
     }
 
     function Rp(t, e, n) {
      return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n)
     }
     Object.freeze({
      TEST_EPSILON_FLOAT16: Op,
      expectArraysClose: function(t, e, n) {
       return null == n && (n = Ap()), Np(t, e, (function(t, e) {
        return Rp(t, e, n)
       }))
      },
      testEpsilon: Ap,
      expectPromiseToFail: function(t, e) {
       t().then((function() {
        return e.fail()
       }), (function() {
        return e()
       }))
      },
      expectArraysEqual: function(t, e) {
       var n = "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? [e] : e;
       return q(t) || q(t[0]) || q(e) || q(e[0]) ? Np(t, n, (function(t, e) {
        return t == e
       })) : Np(t, e, (function(t, e) {
        return Rp(t, e, 0)
       }))
      },
      expectNumbersClose: function(t, e, n) {
       if (null == n && (n = Ap()), !Rp(t, e, n)) throw new Error("Numbers differ: actual === " + t + ", expected === " + e)
      },
      expectValuesInRange: function(t, e, n) {
       for (var r = 0; r < t.length; r++)
        if (t[r] < e || t[r] > n) throw new Error("Value out of range:" + t[r] + " low: " + e + ", high: " + n)
      },
      expectArrayBuffersEqual: function(t, e) {
       expect(new Float32Array(t)).toEqual(new Float32Array(e))
      }
     });
     var Tp = "1.5.2",
      _p = (Object.freeze({
       gpgpu_util: ua,
       webgl_util: Ve,
       forceHalfFloat: function() {
        h().set("WEBGL_FORCE_F16_TEXTURES", !0)
       },
       MathBackendWebGL: Is,
       setWebGLContext: $t,
       GPGPUContext: ca
      }), function(t) {
       function e() {
        return null !== t && t.apply(this, arguments) || this
       }
       return a(e, t), e.prototype.minimize = function(t, e, n) {
        void 0 === e && (e = !1);
        var r = this.computeGradients(t, n),
         i = r.value,
         o = r.grads;
        if (null != n) {
         var a = n.map((function(t) {
          return {
           name: t.name,
           tensor: o[t.name]
          }
         }));
         this.applyGradients(a)
        } else this.applyGradients(o);
        return Ge(o), e ? i : (i.dispose(), null)
       }, Object.defineProperty(e.prototype, "iterations", {
        get: function() {
         return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
        },
        enumerable: !0,
        configurable: !0
       }), e.prototype.incrementIterations = function() {
        this.iterations_ = this.iterations + 1
       }, e.prototype.computeGradients = function(t, e) {
        return Vr(t, e)
       }, e.prototype.dispose = function() {
        null != this.iterations_ && Ge(this.iterations_)
       }, e.prototype.saveIterations = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          return null == this.iterations_ && (this.iterations_ = 0), [2, {
           name: "iter",
           tensor: mn(this.iterations_, "int32")
          }]
         }))
        }))
       }, e.prototype.getWeights = function() {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          throw new Error("getWeights() is not implemented for this optimizer yet.")
         }))
        }))
       }, e.prototype.setWeights = function(t) {
        return s(this, void 0, void 0, (function() {
         return u(this, (function(t) {
          throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName())
         }))
        }))
       }, e.prototype.extractIterations = function(t) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          switch (n.label) {
           case 0:
            return e = this, [4, t[0].tensor.data()];
           case 1:
            return e.iterations_ = n.sent()[0], [2, t.slice(1)]
          }
         }))
        }))
       }, e
      }(Sp));
     Object.defineProperty(_p, Symbol.hasInstance, {
      value: function(t) {
       return null != t.minimize && null != t.computeGradients && null != t.applyGradients
      }
     });
     var Dp = function(t) {
      function e(e, n, r) {
       void 0 === r && (r = null);
       var i = t.call(this) || this;
       return i.learningRate = e, i.rho = n, i.epsilon = r, i.accumulatedGrads = [], i.accumulatedUpdates = [], null == r && (i.epsilon = Bt.backend.epsilon()), i
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this;
       (Array.isArray(t) ? t.map((function(t) {
        return t.name
       })) : Object.keys(t)).forEach((function(n, r) {
        var i = Bt.registeredVariables[n];
        null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
         originalName: n + "/accum_grad",
         variable: $e((function() {
          return Rn(i).variable(!1)
         }))
        }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {
         originalName: n + "/accum_var",
         variable: $e((function() {
          return Rn(i).variable(!1)
         }))
        });
        var o = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != o) {
         var a = e.accumulatedGrads[r].variable,
          s = e.accumulatedUpdates[r].variable;
         $e((function() {
          var t = a.mul(e.rho).add(o.square().mul(1 - e.rho)),
           n = s.add(e.epsilon).sqrt().div(a.add(e.epsilon).sqrt()).mul(o),
           r = s.mul(e.rho).add(n.square().mul(1 - e.rho));
          a.assign(t), s.assign(r);
          var u = n.mul(-e.learningRate).add(i);
          i.assign(u)
         }))
        }
       })), this.incrementIterations()
      }, e.prototype.dispose = function() {
       null != this.accumulatedUpdates && (Ge(this.accumulatedGrads.map((function(t) {
        return t.variable
       }))), Ge(this.accumulatedUpdates.map((function(t) {
        return t.variable
       }))))
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        var t;
        return u(this, (function(e) {
         switch (e.label) {
          case 0:
           return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
          case 1:
           return [2, [e.sent()].concat(t.map((function(t) {
            return {
             name: t.originalName,
             tensor: t.variable
            }
           })))]
         }
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        var e;
        return u(this, (function(n) {
         switch (n.label) {
          case 0:
           return [4, this.extractIterations(t)];
          case 1:
           return t = n.sent(), e = t.length / 2, this.accumulatedGrads = t.slice(0, e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), this.accumulatedUpdates = t.slice(e, 2 * e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), [2]
         }
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate,
        rho: this.rho,
        epsilon: this.epsilon
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate, e.rho, e.epsilon)
      }, e.className = "Adadelta", e
     }(_p);
     kp(Dp);
     var Fp = function(t) {
      function e(e, n) {
       void 0 === n && (n = .1);
       var r = t.call(this) || this;
       return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this;
       (Array.isArray(t) ? t.map((function(t) {
        return t.name
       })) : Object.keys(t)).forEach((function(n, r) {
        var i = Bt.registeredVariables[n];
        null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
         originalName: n + "/accumulator",
         variable: $e((function() {
          return In(i.shape, e.initialAccumulatorValue).variable(!1)
         }))
        });
        var o = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != o) {
         var a = e.accumulatedGrads[r].variable;
         $e((function() {
          var t = a.add(o.square());
          a.assign(t);
          var n = o.div(t.add(Bt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(i);
          i.assign(n)
         }))
        }
       })), this.incrementIterations()
      }, e.prototype.dispose = function() {
       null != this.accumulatedGrads && Ge(this.accumulatedGrads.map((function(t) {
        return t.variable
       })))
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         switch (t.label) {
          case 0:
           return [4, this.saveIterations()];
          case 1:
           return [2, [t.sent()].concat(this.accumulatedGrads.map((function(t) {
            return {
             name: t.originalName,
             tensor: t.variable
            }
           })))]
         }
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(e) {
         switch (e.label) {
          case 0:
           return [4, this.extractIterations(t)];
          case 1:
           return t = e.sent(), this.accumulatedGrads = t.map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), [2]
         }
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate,
        initialAccumulatorValue: this.initialAccumulatorValue
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate, e.initialAccumulatorValue)
      }, e.className = "Adagrad", e
     }(_p);
     kp(Fp);
     var Mp = function(t) {
      function e(e, n, r, i) {
       void 0 === i && (i = null);
       var o = t.call(this) || this;
       return o.learningRate = e, o.beta1 = n, o.beta2 = r, o.epsilon = i, o.accumulatedFirstMoment = [], o.accumulatedSecondMoment = [], $e((function() {
        o.accBeta1 = mn(n).variable(), o.accBeta2 = mn(r).variable()
       })), null == i && (o.epsilon = Bt.backend.epsilon()), o
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this,
        n = Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t);
       $e((function() {
        var r = Ku(1, e.accBeta1),
         i = Ku(1, e.accBeta2);
        n.forEach((function(n, o) {
         var a = Bt.registeredVariables[n];
         null == e.accumulatedFirstMoment[o] && (e.accumulatedFirstMoment[o] = {
          originalName: n + "/m",
          variable: $e((function() {
           return Rn(a).variable(!1)
          }))
         }), null == e.accumulatedSecondMoment[o] && (e.accumulatedSecondMoment[o] = {
          originalName: n + "/v",
          variable: $e((function() {
           return Rn(a).variable(!1)
          }))
         });
         var s = Array.isArray(t) ? t[o].tensor : t[n];
         if (null != s) {
          var u = e.accumulatedFirstMoment[o].variable,
           c = e.accumulatedSecondMoment[o].variable,
           l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
           h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)),
           p = l.div(r),
           f = h.div(i);
          u.assign(l), c.assign(h);
          var d = p.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(a);
          a.assign(d)
         }
        })), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2))
       })), this.incrementIterations()
      }, e.prototype.dispose = function() {
       this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Ge(this.accumulatedFirstMoment.map((function(t) {
        return t.variable
       }))), null != this.accumulatedSecondMoment && Ge(this.accumulatedSecondMoment.map((function(t) {
        return t.variable
       })))
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        var t;
        return u(this, (function(e) {
         switch (e.label) {
          case 0:
           return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
          case 1:
           return [2, [e.sent()].concat(t.map((function(t) {
            return {
             name: t.originalName,
             tensor: t.variable
            }
           })))]
         }
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        var e, n = this;
        return u(this, (function(r) {
         switch (r.label) {
          case 0:
           return [4, this.extractIterations(t)];
          case 1:
           return t = r.sent(), $e((function() {
            n.accBeta1.assign(Hu(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(Hu(n.beta2, n.iterations_ + 1))
           })), e = t.length / 2, this.accumulatedFirstMoment = t.slice(0, e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), this.accumulatedSecondMoment = t.slice(e, 2 * e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), [2]
         }
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate, e.beta1, e.beta2, e.epsilon)
      }, e.className = "Adam", e
     }(_p);
     kp(Mp);
     var Lp = function(t) {
      function e(e, n, r, i, o) {
       void 0 === i && (i = null), void 0 === o && (o = 0);
       var a = t.call(this) || this;
       return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = i, a.decay = o, a.accumulatedFirstMoment = [], a.accumulatedWeightedInfNorm = [], $e((function() {
        a.iteration = mn(0).variable(), a.accBeta1 = mn(n).variable()
       })), null == i && (a.epsilon = Bt.backend.epsilon()), a
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this,
        n = Array.isArray(t) ? t.map((function(t) {
         return t.name
        })) : Object.keys(t);
       $e((function() {
        var r = Ku(1, e.accBeta1),
         i = _u(-e.learningRate, e.iteration.mul(e.decay).add(1));
        n.forEach((function(n, o) {
         var a = Bt.registeredVariables[n];
         null == e.accumulatedFirstMoment[o] && (e.accumulatedFirstMoment[o] = {
          originalName: n + "/m",
          variable: Rn(a).variable(!1)
         }), null == e.accumulatedWeightedInfNorm[o] && (e.accumulatedWeightedInfNorm[o] = {
          originalName: n + "/v",
          variable: Rn(a).variable(!1)
         });
         var s = Array.isArray(t) ? t[o].tensor : t[n];
         if (null != s) {
          var u = e.accumulatedFirstMoment[o].variable,
           c = e.accumulatedWeightedInfNorm[o].variable,
           l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
           h = c.mul(e.beta2),
           p = s.abs(),
           f = h.maximum(p);
          u.assign(l), c.assign(f);
          var d = i.div(r).mul(l.div(f.add(e.epsilon))).add(a);
          a.assign(d)
         }
        })), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1))
       })), this.incrementIterations()
      }, e.prototype.dispose = function() {
       this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Ge(this.accumulatedFirstMoment.map((function(t) {
        return t.variable
       }))), null != this.accumulatedWeightedInfNorm && Ge(this.accumulatedWeightedInfNorm.map((function(t) {
        return t.variable
       })))
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         throw new Error("getWeights() is not implemented for Adamax yet.")
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         throw new Error("setWeights() is not implemented for Adamax yet.")
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon,
        decay: this.decay
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay)
      }, e.className = "Adamax", e
     }(_p);
     kp(Lp);
     var Bp = function(t) {
      function e(e) {
       var n = t.call(this) || this;
       return n.learningRate = e, n.setLearningRate(e), n
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this;
       (Array.isArray(t) ? t.map((function(t) {
        return t.name
       })) : Object.keys(t)).forEach((function(n, r) {
        var i = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != i) {
         var o = Bt.registeredVariables[n];
         $e((function() {
          var t = e.c.mul(i).add(o);
          o.assign(t)
         }))
        }
       })), this.incrementIterations()
      }, e.prototype.setLearningRate = function(t) {
       this.learningRate = t, null != this.c && this.c.dispose(), this.c = qe(mn(-t))
      }, e.prototype.dispose = function() {
       this.c.dispose()
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         switch (t.label) {
          case 0:
           return [4, this.saveIterations()];
          case 1:
           return [2, [t.sent()]]
         }
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(e) {
         switch (e.label) {
          case 0:
           return [4, this.extractIterations(t)];
          case 1:
           if (0 !== (t = e.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
           return [2]
         }
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate)
      }, e.className = "SGD", e
     }(_p);
     kp(Bp);
     var Pp = function(t) {
      function e(e, n, r) {
       void 0 === r && (r = !1);
       var i = t.call(this, e) || this;
       return i.learningRate = e, i.momentum = n, i.useNesterov = r, i.accumulations = [], i.m = mn(i.momentum), i
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this;
       (Array.isArray(t) ? t.map((function(t) {
        return t.name
       })) : Object.keys(t)).forEach((function(n, r) {
        var i = Bt.registeredVariables[n];
        null == e.accumulations[r] && (e.accumulations[r] = {
         originalName: n + "/momentum",
         variable: $e((function() {
          return Rn(i).variable(!1)
         }))
        });
        var o = e.accumulations[r].variable,
         a = Array.isArray(t) ? t[r].tensor : t[n];
        null != a && $e((function() {
         var t, n = e.m.mul(o).add(a);
         t = e.useNesterov ? e.c.mul(a.add(n.mul(e.m))).add(i) : e.c.mul(n).add(i), o.assign(n), i.assign(t)
        }))
       })), this.incrementIterations()
      }, e.prototype.dispose = function() {
       this.m.dispose(), null != this.accumulations && Ge(this.accumulations.map((function(t) {
        return t.variable
       })))
      }, e.prototype.setMomentum = function(t) {
       this.momentum = t
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(t) {
         switch (t.label) {
          case 0:
           return [4, this.saveIterations()];
          case 1:
           return [2, [t.sent()].concat(this.accumulations.map((function(t) {
            return {
             name: t.originalName,
             tensor: t.variable
            }
           })))]
         }
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        return u(this, (function(e) {
         switch (e.label) {
          case 0:
           return [4, this.extractIterations(t)];
          case 1:
           return t = e.sent(), this.accumulations = t.map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), [2]
         }
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate,
        momentum: this.momentum,
        useNesterov: this.useNesterov
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate, e.momentum, e.useNesterov)
      }, e.className = "Momentum", e
     }(Bp);
     kp(Pp);
     var zp = function(t) {
      function e(e, n, r, i, o) {
       void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === i && (i = null), void 0 === o && (o = !1);
       var a = t.call(this) || this;
       if (a.learningRate = e, a.decay = n, a.momentum = r, a.epsilon = i, a.accumulatedMeanSquares = [], a.accumulatedMoments = [], a.accumulatedMeanGrads = [], a.centered = o, null == i && (a.epsilon = Bt.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
       return a
      }
      return a(e, t), e.prototype.applyGradients = function(t) {
       var e = this;
       (Array.isArray(t) ? t.map((function(t) {
        return t.name
       })) : Object.keys(t)).forEach((function(n, r) {
        var i = Bt.registeredVariables[n];
        null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {
         originalName: n + "/rms",
         variable: $e((function() {
          return Rn(i).variable(!1)
         }))
        }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {
         originalName: n + "/momentum",
         variable: $e((function() {
          return Rn(i).variable(!1)
         }))
        }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {
         originalName: n + "/mg",
         variable: $e((function() {
          return Rn(i).variable(!1)
         }))
        });
        var o = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != o) {
         var a = e.accumulatedMeanSquares[r].variable,
          s = e.accumulatedMoments[r].variable;
         $e((function() {
          var t = a.mul(e.decay).add(o.square().mul(1 - e.decay));
          if (e.centered) {
           var n = e.accumulatedMeanGrads[r].variable,
            u = n.mul(e.decay).add(o.mul(1 - e.decay)),
            c = s.mul(e.momentum).add(o.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));
           a.assign(t), n.assign(u), s.assign(c);
           var l = i.sub(c);
           i.assign(l)
          } else {
           var h = a.mul(e.decay).add(o.square().mul(1 - e.decay));
           c = s.mul(e.momentum).add(o.mul(e.learningRate).div(h.add(e.epsilon).sqrt())), a.assign(h), s.assign(c), l = i.sub(c), i.assign(l)
          }
         }))
        }
       })), this.incrementIterations()
      }, e.prototype.dispose = function() {
       null != this.accumulatedMeanSquares && Ge(this.accumulatedMeanSquares.map((function(t) {
        return t.variable
       }))), null != this.accumulatedMeanGrads && this.centered && Ge(this.accumulatedMeanGrads.map((function(t) {
        return t.variable
       }))), null != this.accumulatedMoments && Ge(this.accumulatedMoments.map((function(t) {
        return t.variable
       })))
      }, e.prototype.getWeights = function() {
       return s(this, void 0, void 0, (function() {
        var t;
        return u(this, (function(e) {
         switch (e.label) {
          case 0:
           return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];
          case 1:
           return [2, [e.sent()].concat(t.map((function(t) {
            return {
             name: t.originalName,
             tensor: t.variable
            }
           })))]
         }
        }))
       }))
      }, e.prototype.setWeights = function(t) {
       return s(this, void 0, void 0, (function() {
        var e;
        return u(this, (function(n) {
         switch (n.label) {
          case 0:
           return [4, this.extractIterations(t)];
          case 1:
           return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), this.accumulatedMoments = t.slice(e, 2 * e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           })), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map((function(t) {
            return {
             originalName: t.name,
             variable: t.tensor.variable(!1)
            }
           }))), [2]
         }
        }))
       }))
      }, e.prototype.getConfig = function() {
       return {
        learningRate: this.learningRate,
        decay: this.decay,
        momentum: this.momentum,
        epsilon: this.epsilon,
        centered: this.centered
       }
      }, e.fromConfig = function(t, e) {
       return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered)
      }, e.className = "RMSProp", e
     }(_p);
     kp(zp);
     var jp = function() {
      function t() {}
      return t.sgd = function(t) {
       return new Bp(t)
      }, t.momentum = function(t, e, n) {
       return void 0 === n && (n = !1), new Pp(t, e, n)
      }, t.rmsprop = function(t, e, n, r, i) {
       return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === i && (i = !1), new zp(t, e, n, r, i)
      }, t.adam = function(t, e, n, r) {
       return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Mp(t, e, n, r)
      }, t.adadelta = function(t, e, n) {
       return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new Dp(t, e, n)
      }, t.adamax = function(t, e, n, r, i) {
       return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === i && (i = 0), new Lp(t, e, n, r, i)
      }, t.adagrad = function(t, e) {
       return void 0 === e && (e = .1), new Fp(t, e)
      }, t
     }();
     jp.sgd, jp.momentum, jp.adadelta, jp.adagrad, jp.rmsprop, jp.adamax, jp.adam, "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate && setImmediate;
     bt = vh
    }).call(this, n("c8ba"), n("4362"), n("b639").Buffer)
   },
   "7c73": function(t, e, n) {
    var r, i = n("825a"),
     o = n("37e8"),
     a = n("7839"),
     s = n("d012"),
     u = n("1be4"),
     c = n("cc12"),
     l = n("f772"),
     h = ">",
     p = "<",
     f = "prototype",
     d = "script",
     v = l("IE_PROTO"),
     m = function() {},
     g = function(t) {
      return p + d + h + t + p + "/" + d + h
     },
     y = function(t) {
      t.write(g("")), t.close();
      var e = t.parentWindow.Object;
      return t = null, e
     },
     b = function() {
      var t, e = c("iframe"),
       n = "java" + d + ":";
      return e.style.display = "none", u.appendChild(e), e.src = String(n), t = e.contentWindow.document, t.open(), t.write(g("document.F=Object")), t.close(), t.F
     },
     x = function() {
      try {
       r = document.domain && new ActiveXObject("htmlfile")
      } catch (e) {}
      x = r ? y(r) : b();
      var t = a.length;
      while (t--) delete x[f][a[t]];
      return x()
     };
    s[v] = !0, t.exports = Object.create || function(t, e) {
     var n;
     return null !== t ? (m[f] = i(t), n = new m, m[f] = null, n[v] = t) : n = x(), void 0 === e ? n : o(n, e)
    }
   },
   "7db0": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("b727").find,
     o = n("44d2"),
     a = n("ae40"),
     s = "find",
     u = !0,
     c = a(s);
    s in [] && Array(1)[s]((function() {
     u = !1
    })), r({
     target: "Array",
     proto: !0,
     forced: u || !c
    }, {
     find: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    }), o(s)
   },
   "7dd0": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("9ed3"),
     o = n("e163"),
     a = n("d2bb"),
     s = n("d44e"),
     u = n("9112"),
     c = n("6eeb"),
     l = n("b622"),
     h = n("c430"),
     p = n("3f8c"),
     f = n("ae93"),
     d = f.IteratorPrototype,
     v = f.BUGGY_SAFARI_ITERATORS,
     m = l("iterator"),
     g = "keys",
     y = "values",
     b = "entries",
     x = function() {
      return this
     };
    t.exports = function(t, e, n, l, f, w, C) {
     i(n, e, l);
     var S, E, k, I = function(t) {
       if (t === f && T) return T;
       if (!v && t in N) return N[t];
       switch (t) {
        case g:
         return function() {
          return new n(this, t)
         };
        case y:
         return function() {
          return new n(this, t)
         };
        case b:
         return function() {
          return new n(this, t)
         }
       }
       return function() {
        return new n(this)
       }
      },
      O = e + " Iterator",
      A = !1,
      N = t.prototype,
      R = N[m] || N["@@iterator"] || f && N[f],
      T = !v && R || I(f),
      _ = "Array" == e && N.entries || R;
     if (_ && (S = o(_.call(new t)), d !== Object.prototype && S.next && (h || o(S) === d || (a ? a(S, d) : "function" != typeof S[m] && u(S, m, x)), s(S, O, !0, !0), h && (p[O] = x))), f == y && R && R.name !== y && (A = !0, T = function() {
       return R.call(this)
      }), h && !C || N[m] === T || u(N, m, T), p[e] = T, f)
      if (E = {
        values: I(y),
        keys: w ? T : I(g),
        entries: I(b)
       }, C)
       for (k in E) !v && !A && k in N || c(N, k, E[k]);
      else r({
       target: e,
       proto: !0,
       forced: v || A
      }, E);
     return E
    }
   },
   "7e2b": function(t, e, n) {
    "use strict";
    var r = n("2b0e");
 
    function i(t) {
     return function(e, n) {
      for (var r in n) Object.prototype.hasOwnProperty.call(e, r) || this.$delete(this.$data[t], r);
      for (var i in e) this.$set(this.$data[t], i, e[i])
     }
    }
    e["a"] = r["a"].extend({
     data: function() {
      return {
       attrs$: {},
       listeners$: {}
      }
     },
     created: function() {
      this.$watch("$attrs", i("attrs$"), {
       immediate: !0
      }), this.$watch("$listeners", i("listeners$"), {
       immediate: !0
      })
     }
    })
   },
   "7f9a": function(t, e, n) {
    var r = n("da84"),
     i = n("8925"),
     o = r.WeakMap;
    t.exports = "function" === typeof o && /native code/.test(i(o))
   },
   "80d2": function(t, e, n) {
    "use strict";
    n.d(e, "g", (function() {
     return o
    })), n.d(e, "a", (function() {
     return a
    })), n.d(e, "b", (function() {
     return c
    })), n.d(e, "h", (function() {
     return h
    })), n.d(e, "k", (function() {
     return p
    })), n.d(e, "l", (function() {
     return f
    })), n.d(e, "o", (function() {
     return d
    })), n.d(e, "i", (function() {
     return m
    })), n.d(e, "j", (function() {
     return g
    })), n.d(e, "f", (function() {
     return y
    })), n.d(e, "p", (function() {
     return b
    })), n.d(e, "q", (function() {
     return w
    })), n.d(e, "u", (function() {
     return C
    })), n.d(e, "r", (function() {
     return S
    })), n.d(e, "c", (function() {
     return k
    })), n.d(e, "v", (function() {
     return I
    })), n.d(e, "w", (function() {
     return O
    })), n.d(e, "n", (function() {
     return A
    })), n.d(e, "m", (function() {
     return N
    })), n.d(e, "e", (function() {
     return R
    })), n.d(e, "t", (function() {
     return T
    })), n.d(e, "d", (function() {
     return _
    })), n.d(e, "s", (function() {
     return D
    }));
    n("99af"), n("a623"), n("4de4"), n("a630"), n("c975"), n("d81d"), n("13d5"), n("fb6a"), n("45fc"), n("b0c0"), n("a9e3"), n("b680"), n("dca8"), n("b64b"), n("d3b7"), n("ac1f"), n("25f0"), n("3ca3"), n("38cf"), n("5319"), n("1276"), n("2ca0"), n("498a"), n("3835");
    var r = n("53ca"),
     i = (n("5530"), n("2b0e"));
 
    function o(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "div",
      n = arguments.length > 2 ? arguments[2] : void 0;
     return i["a"].extend({
      name: n || t.replace(/__/g, "-"),
      functional: !0,
      render: function(n, r) {
       var i = r.data,
        o = r.children;
       return i.staticClass = "".concat(t, " ").concat(i.staticClass || "").trim(), n(e, i, o)
      }
     })
    }
 
    function a(t, e, n) {
     var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
      i = function i(o) {
       n(o), t.removeEventListener(e, i, r)
      };
     t.addEventListener(e, i, r)
    }
    var s = !1;
    try {
     if ("undefined" !== typeof window) {
      var u = Object.defineProperty({}, "passive", {
       get: function() {
        s = !0
       }
      });
      window.addEventListener("testListener", u, u), window.removeEventListener("testListener", u, u)
     }
    } catch (F) {
     console.warn(F)
    }
 
    function c(t, e, n, r) {
     t.addEventListener(e, n, !!s && r)
    }
 
    function l(t, e, n) {
     var r = e.length - 1;
     if (r < 0) return void 0 === t ? n : t;
     for (var i = 0; i < r; i++) {
      if (null == t) return n;
      t = t[e[i]]
     }
     return null == t ? n : void 0 === t[e[r]] ? n : t[e[r]]
    }
 
    function h(t, e) {
     if (t === e) return !0;
     if (t instanceof Date && e instanceof Date && t.getTime() !== e.getTime()) return !1;
     if (t !== Object(t) || e !== Object(e)) return !1;
     var n = Object.keys(t);
     return n.length === Object.keys(e).length && n.every((function(n) {
      return h(t[n], e[n])
     }))
    }
 
    function p(t, e, n) {
     return null != t && e && "string" === typeof e ? void 0 !== t[e] ? t[e] : (e = e.replace(/\[(\w+)\]/g, ".$1"), e = e.replace(/^\./, ""), l(t, e.split("."), n)) : n
    }
 
    function f(t, e, n) {
     if (null == e) return void 0 === t ? n : t;
     if (t !== Object(t)) return void 0 === n ? t : n;
     if ("string" === typeof e) return p(t, e, n);
     if (Array.isArray(e)) return l(t, e, n);
     if ("function" !== typeof e) return n;
     var r = e(t, n);
     return "undefined" === typeof r ? n : r
    }
 
    function d(t) {
     if (!t || t.nodeType !== Node.ELEMENT_NODE) return 0;
     var e = +window.getComputedStyle(t).getPropertyValue("z-index");
     return e || d(t.parentNode)
    }
    var v = {
     "&": "&amp;",
     "<": "&lt;",
     ">": "&gt;"
    };
 
    function m(t) {
     return t.replace(/[&<>]/g, (function(t) {
      return v[t] || t
     }))
    }
 
    function g(t, e) {
     for (var n = {}, r = 0; r < e.length; r++) {
      var i = e[r];
      "undefined" !== typeof t[i] && (n[i] = t[i])
     }
     return n
    }
 
    function y(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "px";
     return null == t || "" === t ? void 0 : isNaN(+t) ? String(t) : "".concat(Number(t)).concat(e)
    }
 
    function b(t) {
     return (t || "").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
    }
 
    function x(t) {
     return null !== t && "object" === Object(r["a"])(t)
    }
    var w = Object.freeze({
     enter: 13,
     tab: 9,
     delete: 46,
     esc: 27,
     space: 32,
     up: 38,
     down: 40,
     left: 37,
     right: 39,
     end: 35,
     home: 36,
     del: 46,
     backspace: 8,
     insert: 45,
     pageup: 33,
     pagedown: 34
    });
 
    function C(t, e) {
     if (!e.startsWith("$")) return e;
     var n = "$vuetify.icons.values.".concat(e.split("$").pop().split(".").pop());
     return p(t, n, e)
    }
 
    function S(t) {
     return Object.keys(t)
    }
    var E = /-(\w)/g,
     k = function(t) {
      return t.replace(E, (function(t, e) {
       return e ? e.toUpperCase() : ""
      }))
     };
 
    function I(t) {
     return t.charAt(0).toUpperCase() + t.slice(1)
    }
 
    function O(t) {
     return null != t ? Array.isArray(t) ? t : [t] : []
    }
 
    function A(t, e, n) {
     return t.$slots[e] && t.$scopedSlots[e] && t.$scopedSlots[e].name ? n ? "v-slot" : "scoped" : t.$slots[e] ? "normal" : t.$scopedSlots[e] ? "scoped" : void 0
    }
 
    function N(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default",
      n = arguments.length > 2 ? arguments[2] : void 0,
      r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
     return t.$scopedSlots[e] ? t.$scopedSlots[e](n instanceof Function ? n() : n) : !t.$slots[e] || n && !r ? void 0 : t.$slots[e]
    }
 
    function R(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
     return Math.max(e, Math.min(n, t))
    }
 
    function T(t, e) {
     var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "0";
     return t + n.repeat(Math.max(0, e - t.length))
    }
 
    function _(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
      n = [],
      r = 0;
     while (r < t.length) n.push(t.substr(r, e)), r += e;
     return n
    }
 
    function D() {
     var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
     for (var n in e) {
      var r = t[n],
       i = e[n];
      x(r) && x(i) ? t[n] = D(r, i) : t[n] = i
     }
     return t
    }
   },
   "825a": function(t, e, n) {
    var r = n("861d");
    t.exports = function(t) {
     if (!r(t)) throw TypeError(String(t) + " is not an object");
     return t
    }
   },
   8336: function(t, e, n) {
    "use strict";
    n("4160"), n("caad"), n("c7cd");
    var r = n("53ca"),
     i = n("3835"),
     o = n("5530"),
     a = (n("86cc"), n("10d2")),
     s = n("22da"),
     u = n("4e82"),
     c = n("f2e7"),
     l = n("fe6c"),
     h = n("1c87"),
     p = n("af2b"),
     f = n("58df"),
     d = n("d9bd"),
     v = Object(f["a"])(a["a"], h["a"], l["a"], p["a"], Object(u["a"])("btnToggle"), Object(c["b"])("inputValue"));
    e["a"] = v.extend().extend({
     name: "v-btn",
     props: {
      activeClass: {
       type: String,
       default: function() {
        return this.btnToggle ? this.btnToggle.activeClass : ""
       }
      },
      block: Boolean,
      depressed: Boolean,
      fab: Boolean,
      icon: Boolean,
      loading: Boolean,
      outlined: Boolean,
      retainFocusOnClick: Boolean,
      rounded: Boolean,
      tag: {
       type: String,
       default: "button"
      },
      text: Boolean,
      type: {
       type: String,
       default: "button"
      },
      value: null
     },
     data: function() {
      return {
       proxyClass: "v-btn--active"
      }
     },
     computed: {
      classes: function() {
       return Object(o["a"])({
        "v-btn": !0
       }, h["a"].options.computed.classes.call(this), {
        "v-btn--absolute": this.absolute,
        "v-btn--block": this.block,
        "v-btn--bottom": this.bottom,
        "v-btn--contained": this.contained,
        "v-btn--depressed": this.depressed || this.outlined,
        "v-btn--disabled": this.disabled,
        "v-btn--fab": this.fab,
        "v-btn--fixed": this.fixed,
        "v-btn--flat": this.isFlat,
        "v-btn--icon": this.icon,
        "v-btn--left": this.left,
        "v-btn--loading": this.loading,
        "v-btn--outlined": this.outlined,
        "v-btn--right": this.right,
        "v-btn--round": this.isRound,
        "v-btn--rounded": this.rounded,
        "v-btn--router": this.to,
        "v-btn--text": this.text,
        "v-btn--tile": this.tile,
        "v-btn--top": this.top
       }, this.themeClasses, {}, this.groupClasses, {}, this.elevationClasses, {}, this.sizeableClasses)
      },
      contained: function() {
       return Boolean(!this.isFlat && !this.depressed && !this.elevation)
      },
      computedRipple: function() {
       var t = !this.icon && !this.fab || {
        circle: !0
       };
       return !this.disabled && (null != this.ripple ? this.ripple : t)
      },
      isFlat: function() {
       return Boolean(this.icon || this.text || this.outlined)
      },
      isRound: function() {
       return Boolean(this.icon || this.fab)
      },
      styles: function() {
       return Object(o["a"])({}, this.measurableStyles)
      }
     },
     created: function() {
      var t = this,
       e = [
        ["flat", "text"],
        ["outline", "outlined"],
        ["round", "rounded"]
       ];
      e.forEach((function(e) {
       var n = Object(i["a"])(e, 2),
        r = n[0],
        o = n[1];
       t.$attrs.hasOwnProperty(r) && Object(d["a"])(r, o, t)
      }))
     },
     methods: {
      click: function(t) {
       !this.retainFocusOnClick && !this.fab && t.detail && this.$el.blur(), this.$emit("click", t), this.btnToggle && this.toggle()
      },
      genContent: function() {
       return this.$createElement("span", {
        staticClass: "v-btn__content"
       }, this.$slots.default)
      },
      genLoader: function() {
       return this.$createElement("span", {
        class: "v-btn__loader"
       }, this.$slots.loader || [this.$createElement(s["a"], {
        props: {
         indeterminate: !0,
         size: 23,
         width: 2
        }
       })])
      }
     },
     render: function(t) {
      var e = [this.genContent(), this.loading && this.genLoader()],
       n = this.isFlat ? this.setTextColor : this.setBackgroundColor,
       i = this.generateRouteLink(),
       o = i.tag,
       a = i.data;
      return "button" === o && (a.attrs.type = this.type, a.attrs.disabled = this.disabled), a.attrs.value = ["string", "number"].includes(Object(r["a"])(this.value)) ? this.value : JSON.stringify(this.value), t(o, this.disabled ? a : n(this.color, a), e)
     }
    })
   },
   "83ab": function(t, e, n) {
    var r = n("d039");
    t.exports = !r((function() {
     return 7 != Object.defineProperty({}, 1, {
      get: function() {
       return 7
      }
     })[1]
    }))
   },
   "83b9": function(t, e, n) {
    "use strict";
    var r = n("d925"),
     i = n("e683");
    t.exports = function(t, e) {
     return t && !r(e) ? i(t, e) : e
    }
   },
   8418: function(t, e, n) {
    "use strict";
    var r = n("c04e"),
     i = n("9bf2"),
     o = n("5c6c");
    t.exports = function(t, e, n) {
     var a = r(e);
     a in t ? i.f(t, a, o(0, n)) : t[a] = n
    }
   },
   "857a": function(t, e, n) {
    var r = n("1d80"),
     i = /"/g;
    t.exports = function(t, e, n, o) {
     var a = String(r(t)),
      s = "<" + e;
     return "" !== n && (s += " " + n + '="' + String(o).replace(i, "&quot;") + '"'), s + ">" + a + "</" + e + ">"
    }
   },
   "861d": function(t, e) {
    t.exports = function(t) {
     return "object" === typeof t ? null !== t : "function" === typeof t
    }
   },
   "86cc": function(t, e, n) {},
   8860: function(t, e, n) {
    "use strict";
    n("a4d3"), n("e01a"), n("d28b"), n("c740"), n("0481"), n("a434"), n("4069"), n("d3b7"), n("3ca3"), n("ddb0");
    var r = n("5530"),
     i = (n("3ad0"), n("8dd9"));
    e["a"] = i["a"].extend().extend({
     name: "v-list",
     provide: function() {
      return {
       isInList: !0,
       list: this
      }
     },
     inject: {
      isInMenu: {
       default: !1
      },
      isInNav: {
       default: !1
      }
     },
     props: {
      dense: Boolean,
      disabled: Boolean,
      expand: Boolean,
      flat: Boolean,
      nav: Boolean,
      rounded: Boolean,
      shaped: Boolean,
      subheader: Boolean,
      threeLine: Boolean,
      tile: {
       type: Boolean,
       default: !0
      },
      twoLine: Boolean
     },
     data: function() {
      return {
       groups: []
      }
     },
     computed: {
      classes: function() {
       return Object(r["a"])({}, i["a"].options.computed.classes.call(this), {
        "v-list--dense": this.dense,
        "v-list--disabled": this.disabled,
        "v-list--flat": this.flat,
        "v-list--nav": this.nav,
        "v-list--rounded": this.rounded,
        "v-list--shaped": this.shaped,
        "v-list--subheader": this.subheader,
        "v-list--two-line": this.twoLine,
        "v-list--three-line": this.threeLine
       })
      }
     },
     methods: {
      register: function(t) {
       this.groups.push(t)
      },
      unregister: function(t) {
       var e = this.groups.findIndex((function(e) {
        return e._uid === t._uid
       }));
       e > -1 && this.groups.splice(e, 1)
      },
      listClick: function(t) {
       if (!this.expand) {
        var e = !0,
         n = !1,
         r = void 0;
        try {
         for (var i, o = this.groups[Symbol.iterator](); !(e = (i = o.next()).done); e = !0) {
          var a = i.value;
          a.toggle(t)
         }
        } catch (s) {
         n = !0, r = s
        } finally {
         try {
          e || null == o.return || o.return()
         } finally {
          if (n) throw r
         }
        }
       }
      }
     },
     render: function(t) {
      var e = {
       staticClass: "v-list",
       class: this.classes,
       style: this.styles,
       attrs: Object(r["a"])({
        role: this.isInNav || this.isInMenu ? void 0 : "list"
       }, this.attrs$)
      };
      return t(this.tag, this.setBackgroundColor(this.color, e), [this.$slots.default])
     }
    })
   },
   8925: function(t, e, n) {
    var r = n("c6cd"),
     i = Function.toString;
    "function" != typeof r.inspectSource && (r.inspectSource = function(t) {
     return i.call(t)
    }), t.exports = r.inspectSource
   },
   "899c": function(t, e, n) {},
   "8aa5": function(t, e, n) {
    "use strict";
    var r = n("6547").charAt;
    t.exports = function(t, e, n) {
     return e + (n ? r(t, e).length : 1)
    }
   },
   "8adc": function(t, e, n) {},
   "8b0d": function(t, e, n) {},
   "8b37": function(t, e, n) {},
   "8c4f": function(t, e, n) {
    "use strict";
    /*!
     * vue-router v3.1.5
     * (c) 2020 Evan You
     * @license MIT
     */
    function r(t, e) {
     0
    }
 
    function i(t) {
     return Object.prototype.toString.call(t).indexOf("Error") > -1
    }
 
    function o(t, e) {
     return e instanceof t || e && (e.name === t.name || e._name === t._name)
    }
 
    function a(t, e) {
     for (var n in e) t[n] = e[n];
     return t
    }
    var s = {
     name: "RouterView",
     functional: !0,
     props: {
      name: {
       type: String,
       default: "default"
      }
     },
     render: function(t, e) {
      var n = e.props,
       r = e.children,
       i = e.parent,
       o = e.data;
      o.routerView = !0;
      var s = i.$createElement,
       c = n.name,
       l = i.$route,
       h = i._routerViewCache || (i._routerViewCache = {}),
       p = 0,
       f = !1;
      while (i && i._routerRoot !== i) {
       var d = i.$vnode ? i.$vnode.data : {};
       d.routerView && p++, d.keepAlive && i._directInactive && i._inactive && (f = !0), i = i.$parent
      }
      if (o.routerViewDepth = p, f) {
       var v = h[c],
        m = v && v.component;
       return m ? (v.configProps && u(m, o, v.route, v.configProps), s(m, o, r)) : s()
      }
      var g = l.matched[p],
       y = g && g.components[c];
      if (!g || !y) return h[c] = null, s();
      h[c] = {
       component: y
      }, o.registerRouteInstance = function(t, e) {
       var n = g.instances[c];
       (e && n !== t || !e && n === t) && (g.instances[c] = e)
      }, (o.hook || (o.hook = {})).prepatch = function(t, e) {
       g.instances[c] = e.componentInstance
      }, o.hook.init = function(t) {
       t.data.keepAlive && t.componentInstance && t.componentInstance !== g.instances[c] && (g.instances[c] = t.componentInstance)
      };
      var b = g.props && g.props[c];
      return b && (a(h[c], {
       route: l,
       configProps: b
      }), u(y, o, l, b)), s(y, o, r)
     }
    };
 
    function u(t, e, n, r) {
     var i = e.props = c(n, r);
     if (i) {
      i = e.props = a({}, i);
      var o = e.attrs = e.attrs || {};
      for (var s in i) t.props && s in t.props || (o[s] = i[s], delete i[s])
     }
    }
 
    function c(t, e) {
     switch (typeof e) {
      case "undefined":
       return;
      case "object":
       return e;
      case "function":
       return e(t);
      case "boolean":
       return e ? t.params : void 0;
      default:
       0
     }
    }
    var l = /[!'()*]/g,
     h = function(t) {
      return "%" + t.charCodeAt(0).toString(16)
     },
     p = /%2C/g,
     f = function(t) {
      return encodeURIComponent(t).replace(l, h).replace(p, ",")
     },
     d = decodeURIComponent;
 
    function v(t, e, n) {
     void 0 === e && (e = {});
     var r, i = n || m;
     try {
      r = i(t || "")
     } catch (a) {
      r = {}
     }
     for (var o in e) r[o] = e[o];
     return r
    }
 
    function m(t) {
     var e = {};
     return t = t.trim().replace(/^(\?|#|&)/, ""), t ? (t.split("&").forEach((function(t) {
      var n = t.replace(/\+/g, " ").split("="),
       r = d(n.shift()),
       i = n.length > 0 ? d(n.join("=")) : null;
      void 0 === e[r] ? e[r] = i : Array.isArray(e[r]) ? e[r].push(i) : e[r] = [e[r], i]
     })), e) : e
    }
 
    function g(t) {
     var e = t ? Object.keys(t).map((function(e) {
      var n = t[e];
      if (void 0 === n) return "";
      if (null === n) return f(e);
      if (Array.isArray(n)) {
       var r = [];
       return n.forEach((function(t) {
        void 0 !== t && (null === t ? r.push(f(e)) : r.push(f(e) + "=" + f(t)))
       })), r.join("&")
      }
      return f(e) + "=" + f(n)
     })).filter((function(t) {
      return t.length > 0
     })).join("&") : null;
     return e ? "?" + e : ""
    }
    var y = /\/?$/;
 
    function b(t, e, n, r) {
     var i = r && r.options.stringifyQuery,
      o = e.query || {};
     try {
      o = x(o)
     } catch (s) {}
     var a = {
      name: e.name || t && t.name,
      meta: t && t.meta || {},
      path: e.path || "/",
      hash: e.hash || "",
      query: o,
      params: e.params || {},
      fullPath: S(e, i),
      matched: t ? C(t) : []
     };
     return n && (a.redirectedFrom = S(n, i)), Object.freeze(a)
    }
 
    function x(t) {
     if (Array.isArray(t)) return t.map(x);
     if (t && "object" === typeof t) {
      var e = {};
      for (var n in t) e[n] = x(t[n]);
      return e
     }
     return t
    }
    var w = b(null, {
     path: "/"
    });
 
    function C(t) {
     var e = [];
     while (t) e.unshift(t), t = t.parent;
     return e
    }
 
    function S(t, e) {
     var n = t.path,
      r = t.query;
     void 0 === r && (r = {});
     var i = t.hash;
     void 0 === i && (i = "");
     var o = e || g;
     return (n || "/") + o(r) + i
    }
 
    function E(t, e) {
     return e === w ? t === e : !!e && (t.path && e.path ? t.path.replace(y, "") === e.path.replace(y, "") && t.hash === e.hash && k(t.query, e.query) : !(!t.name || !e.name) && (t.name === e.name && t.hash === e.hash && k(t.query, e.query) && k(t.params, e.params)))
    }
 
    function k(t, e) {
     if (void 0 === t && (t = {}), void 0 === e && (e = {}), !t || !e) return t === e;
     var n = Object.keys(t),
      r = Object.keys(e);
     return n.length === r.length && n.every((function(n) {
      var r = t[n],
       i = e[n];
      return "object" === typeof r && "object" === typeof i ? k(r, i) : String(r) === String(i)
     }))
    }
 
    function I(t, e) {
     return 0 === t.path.replace(y, "/").indexOf(e.path.replace(y, "/")) && (!e.hash || t.hash === e.hash) && O(t.query, e.query)
    }
 
    function O(t, e) {
     for (var n in e)
      if (!(n in t)) return !1;
     return !0
    }
 
    function A(t, e, n) {
     var r = t.charAt(0);
     if ("/" === r) return t;
     if ("?" === r || "#" === r) return e + t;
     var i = e.split("/");
     n && i[i.length - 1] || i.pop();
     for (var o = t.replace(/^\//, "").split("/"), a = 0; a < o.length; a++) {
      var s = o[a];
      ".." === s ? i.pop() : "." !== s && i.push(s)
     }
     return "" !== i[0] && i.unshift(""), i.join("/")
    }
 
    function N(t) {
     var e = "",
      n = "",
      r = t.indexOf("#");
     r >= 0 && (e = t.slice(r), t = t.slice(0, r));
     var i = t.indexOf("?");
     return i >= 0 && (n = t.slice(i + 1), t = t.slice(0, i)), {
      path: t,
      query: n,
      hash: e
     }
    }
 
    function R(t) {
     return t.replace(/\/\//g, "/")
    }
    var T = Array.isArray || function(t) {
      return "[object Array]" == Object.prototype.toString.call(t)
     },
     _ = Z,
     D = P,
     F = z,
     M = V,
     L = Y,
     B = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"), "g");
 
    function P(t, e) {
     var n, r = [],
      i = 0,
      o = 0,
      a = "",
      s = e && e.delimiter || "/";
     while (null != (n = B.exec(t))) {
      var u = n[0],
       c = n[1],
       l = n.index;
      if (a += t.slice(o, l), o = l + u.length, c) a += c[1];
      else {
       var h = t[o],
        p = n[2],
        f = n[3],
        d = n[4],
        v = n[5],
        m = n[6],
        g = n[7];
       a && (r.push(a), a = "");
       var y = null != p && null != h && h !== p,
        b = "+" === m || "*" === m,
        x = "?" === m || "*" === m,
        w = n[2] || s,
        C = d || v;
       r.push({
        name: f || i++,
        prefix: p || "",
        delimiter: w,
        optional: x,
        repeat: b,
        partial: y,
        asterisk: !!g,
        pattern: C ? H(C) : g ? ".*" : "[^" + U(w) + "]+?"
       })
      }
     }
     return o < t.length && (a += t.substr(o)), a && r.push(a), r
    }
 
    function z(t, e) {
     return V(P(t, e))
    }
 
    function j(t) {
     return encodeURI(t).replace(/[\/?#]/g, (function(t) {
      return "%" + t.charCodeAt(0).toString(16).toUpperCase()
     }))
    }
 
    function W(t) {
     return encodeURI(t).replace(/[?#]/g, (function(t) {
      return "%" + t.charCodeAt(0).toString(16).toUpperCase()
     }))
    }
 
    function V(t) {
     for (var e = new Array(t.length), n = 0; n < t.length; n++) "object" === typeof t[n] && (e[n] = new RegExp("^(?:" + t[n].pattern + ")$"));
     return function(n, r) {
      for (var i = "", o = n || {}, a = r || {}, s = a.pretty ? j : encodeURIComponent, u = 0; u < t.length; u++) {
       var c = t[u];
       if ("string" !== typeof c) {
        var l, h = o[c.name];
        if (null == h) {
         if (c.optional) {
          c.partial && (i += c.prefix);
          continue
         }
         throw new TypeError('Expected "' + c.name + '" to be defined')
        }
        if (T(h)) {
         if (!c.repeat) throw new TypeError('Expected "' + c.name + '" to not repeat, but received `' + JSON.stringify(h) + "`");
         if (0 === h.length) {
          if (c.optional) continue;
          throw new TypeError('Expected "' + c.name + '" to not be empty')
         }
         for (var p = 0; p < h.length; p++) {
          if (l = s(h[p]), !e[u].test(l)) throw new TypeError('Expected all "' + c.name + '" to match "' + c.pattern + '", but received `' + JSON.stringify(l) + "`");
          i += (0 === p ? c.prefix : c.delimiter) + l
         }
        } else {
         if (l = c.asterisk ? W(h) : s(h), !e[u].test(l)) throw new TypeError('Expected "' + c.name + '" to match "' + c.pattern + '", but received "' + l + '"');
         i += c.prefix + l
        }
       } else i += c
      }
      return i
     }
    }
 
    function U(t) {
     return t.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
    }
 
    function H(t) {
     return t.replace(/([=!:$\/()])/g, "\\$1")
    }
 
    function $(t, e) {
     return t.keys = e, t
    }
 
    function G(t) {
     return t.sensitive ? "" : "i"
    }
 
    function q(t, e) {
     var n = t.source.match(/\((?!\?)/g);
     if (n)
      for (var r = 0; r < n.length; r++) e.push({
       name: r,
       prefix: null,
       delimiter: null,
       optional: !1,
       repeat: !1,
       partial: !1,
       asterisk: !1,
       pattern: null
      });
     return $(t, e)
    }
 
    function K(t, e, n) {
     for (var r = [], i = 0; i < t.length; i++) r.push(Z(t[i], e, n).source);
     var o = new RegExp("(?:" + r.join("|") + ")", G(n));
     return $(o, e)
    }
 
    function X(t, e, n) {
     return Y(P(t, n), e, n)
    }
 
    function Y(t, e, n) {
     T(e) || (n = e || n, e = []), n = n || {};
     for (var r = n.strict, i = !1 !== n.end, o = "", a = 0; a < t.length; a++) {
      var s = t[a];
      if ("string" === typeof s) o += U(s);
      else {
       var u = U(s.prefix),
        c = "(?:" + s.pattern + ")";
       e.push(s), s.repeat && (c += "(?:" + u + c + ")*"), c = s.optional ? s.partial ? u + "(" + c + ")?" : "(?:" + u + "(" + c + "))?" : u + "(" + c + ")", o += c
      }
     }
     var l = U(n.delimiter || "/"),
      h = o.slice(-l.length) === l;
     return r || (o = (h ? o.slice(0, -l.length) : o) + "(?:" + l + "(?=$))?"), o += i ? "$" : r && h ? "" : "(?=" + l + "|$)", $(new RegExp("^" + o, G(n)), e)
    }
 
    function Z(t, e, n) {
     return T(e) || (n = e || n, e = []), n = n || {}, t instanceof RegExp ? q(t, e) : T(t) ? K(t, e, n) : X(t, e, n)
    }
    _.parse = D, _.compile = F, _.tokensToFunction = M, _.tokensToRegExp = L;
    var J = Object.create(null);
 
    function Q(t, e, n) {
     e = e || {};
     try {
      var r = J[t] || (J[t] = _.compile(t));
      return e.pathMatch && (e[0] = e.pathMatch), r(e, {
       pretty: !0
      })
     } catch (i) {
      return ""
     } finally {
      delete e[0]
     }
    }
 
    function tt(t, e, n, r) {
     var i = "string" === typeof t ? {
      path: t
     } : t;
     if (i._normalized) return i;
     if (i.name) {
      i = a({}, t);
      var o = i.params;
      return o && "object" === typeof o && (i.params = a({}, o)), i
     }
     if (!i.path && i.params && e) {
      i = a({}, i), i._normalized = !0;
      var s = a(a({}, e.params), i.params);
      if (e.name) i.name = e.name, i.params = s;
      else if (e.matched.length) {
       var u = e.matched[e.matched.length - 1].path;
       i.path = Q(u, s, "path " + e.path)
      } else 0;
      return i
     }
     var c = N(i.path || ""),
      l = e && e.path || "/",
      h = c.path ? A(c.path, l, n || i.append) : l,
      p = v(c.query, i.query, r && r.options.parseQuery),
      f = i.hash || c.hash;
     return f && "#" !== f.charAt(0) && (f = "#" + f), {
      _normalized: !0,
      path: h,
      query: p,
      hash: f
     }
    }
    var et, nt = [String, Object],
     rt = [String, Array],
     it = function() {},
     ot = {
      name: "RouterLink",
      props: {
       to: {
        type: nt,
        required: !0
       },
       tag: {
        type: String,
        default: "a"
       },
       exact: Boolean,
       append: Boolean,
       replace: Boolean,
       activeClass: String,
       exactActiveClass: String,
       event: {
        type: rt,
        default: "click"
       }
      },
      render: function(t) {
       var e = this,
        n = this.$router,
        r = this.$route,
        i = n.resolve(this.to, r, this.append),
        o = i.location,
        s = i.route,
        u = i.href,
        c = {},
        l = n.options.linkActiveClass,
        h = n.options.linkExactActiveClass,
        p = null == l ? "router-link-active" : l,
        f = null == h ? "router-link-exact-active" : h,
        d = null == this.activeClass ? p : this.activeClass,
        v = null == this.exactActiveClass ? f : this.exactActiveClass,
        m = s.redirectedFrom ? b(null, tt(s.redirectedFrom), null, n) : s;
       c[v] = E(r, m), c[d] = this.exact ? c[v] : I(r, m);
       var g = function(t) {
         at(t) && (e.replace ? n.replace(o, it) : n.push(o, it))
        },
        y = {
         click: at
        };
       Array.isArray(this.event) ? this.event.forEach((function(t) {
        y[t] = g
       })) : y[this.event] = g;
       var x = {
         class: c
        },
        w = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
         href: u,
         route: s,
         navigate: g,
         isActive: c[d],
         isExactActive: c[v]
        });
       if (w) {
        if (1 === w.length) return w[0];
        if (w.length > 1 || !w.length) return 0 === w.length ? t() : t("span", {}, w)
       }
       if ("a" === this.tag) x.on = y, x.attrs = {
        href: u
       };
       else {
        var C = st(this.$slots.default);
        if (C) {
         C.isStatic = !1;
         var S = C.data = a({}, C.data);
         for (var k in S.on = S.on || {}, S.on) {
          var O = S.on[k];
          k in y && (S.on[k] = Array.isArray(O) ? O : [O])
         }
         for (var A in y) A in S.on ? S.on[A].push(y[A]) : S.on[A] = g;
         var N = C.data.attrs = a({}, C.data.attrs);
         N.href = u
        } else x.on = y
       }
       return t(this.tag, x, this.$slots.default)
      }
     };
 
    function at(t) {
     if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && (void 0 === t.button || 0 === t.button)) {
      if (t.currentTarget && t.currentTarget.getAttribute) {
       var e = t.currentTarget.getAttribute("target");
       if (/\b_blank\b/i.test(e)) return
      }
      return t.preventDefault && t.preventDefault(), !0
     }
    }
 
    function st(t) {
     if (t)
      for (var e, n = 0; n < t.length; n++) {
       if (e = t[n], "a" === e.tag) return e;
       if (e.children && (e = st(e.children))) return e
      }
    }
 
    function ut(t) {
     if (!ut.installed || et !== t) {
      ut.installed = !0, et = t;
      var e = function(t) {
        return void 0 !== t
       },
       n = function(t, n) {
        var r = t.$options._parentVnode;
        e(r) && e(r = r.data) && e(r = r.registerRouteInstance) && r(t, n)
       };
      t.mixin({
       beforeCreate: function() {
        e(this.$options.router) ? (this._routerRoot = this, this._router = this.$options.router, this._router.init(this), t.util.defineReactive(this, "_route", this._router.history.current)) : this._routerRoot = this.$parent && this.$parent._routerRoot || this, n(this, this)
       },
       destroyed: function() {
        n(this)
       }
      }), Object.defineProperty(t.prototype, "$router", {
       get: function() {
        return this._routerRoot._router
       }
      }), Object.defineProperty(t.prototype, "$route", {
       get: function() {
        return this._routerRoot._route
       }
      }), t.component("RouterView", s), t.component("RouterLink", ot);
      var r = t.config.optionMergeStrategies;
      r.beforeRouteEnter = r.beforeRouteLeave = r.beforeRouteUpdate = r.created
     }
    }
    var ct = "undefined" !== typeof window;
 
    function lt(t, e, n, r) {
     var i = e || [],
      o = n || Object.create(null),
      a = r || Object.create(null);
     t.forEach((function(t) {
      ht(i, o, a, t)
     }));
     for (var s = 0, u = i.length; s < u; s++) "*" === i[s] && (i.push(i.splice(s, 1)[0]), u--, s--);
     return {
      pathList: i,
      pathMap: o,
      nameMap: a
     }
    }
 
    function ht(t, e, n, r, i, o) {
     var a = r.path,
      s = r.name;
     var u = r.pathToRegexpOptions || {},
      c = ft(a, i, u.strict);
     "boolean" === typeof r.caseSensitive && (u.sensitive = r.caseSensitive);
     var l = {
      path: c,
      regex: pt(c, u),
      components: r.components || {
       default: r.component
      },
      instances: {},
      name: s,
      parent: i,
      matchAs: o,
      redirect: r.redirect,
      beforeEnter: r.beforeEnter,
      meta: r.meta || {},
      props: null == r.props ? {} : r.components ? r.props : {
       default: r.props
      }
     };
     if (r.children && r.children.forEach((function(r) {
       var i = o ? R(o + "/" + r.path) : void 0;
       ht(t, e, n, r, l, i)
      })), e[l.path] || (t.push(l.path), e[l.path] = l), void 0 !== r.alias)
      for (var h = Array.isArray(r.alias) ? r.alias : [r.alias], p = 0; p < h.length; ++p) {
       var f = h[p];
       0;
       var d = {
        path: f,
        children: r.children
       };
       ht(t, e, n, d, i, l.path || "/")
      }
     s && (n[s] || (n[s] = l))
    }
 
    function pt(t, e) {
     var n = _(t, [], e);
     return n
    }
 
    function ft(t, e, n) {
     return n || (t = t.replace(/\/$/, "")), "/" === t[0] ? t : null == e ? t : R(e.path + "/" + t)
    }
 
    function dt(t, e) {
     var n = lt(t),
      r = n.pathList,
      i = n.pathMap,
      o = n.nameMap;
 
     function a(t) {
      lt(t, r, i, o)
     }
 
     function s(t, n, a) {
      var s = tt(t, n, !1, e),
       u = s.name;
      if (u) {
       var c = o[u];
       if (!c) return l(null, s);
       var h = c.regex.keys.filter((function(t) {
        return !t.optional
       })).map((function(t) {
        return t.name
       }));
       if ("object" !== typeof s.params && (s.params = {}), n && "object" === typeof n.params)
        for (var p in n.params) !(p in s.params) && h.indexOf(p) > -1 && (s.params[p] = n.params[p]);
       return s.path = Q(c.path, s.params, 'named route "' + u + '"'), l(c, s, a)
      }
      if (s.path) {
       s.params = {};
       for (var f = 0; f < r.length; f++) {
        var d = r[f],
         v = i[d];
        if (vt(v.regex, s.path, s.params)) return l(v, s, a)
       }
      }
      return l(null, s)
     }
 
     function u(t, n) {
      var r = t.redirect,
       i = "function" === typeof r ? r(b(t, n, null, e)) : r;
      if ("string" === typeof i && (i = {
        path: i
       }), !i || "object" !== typeof i) return l(null, n);
      var a = i,
       u = a.name,
       c = a.path,
       h = n.query,
       p = n.hash,
       f = n.params;
      if (h = a.hasOwnProperty("query") ? a.query : h, p = a.hasOwnProperty("hash") ? a.hash : p, f = a.hasOwnProperty("params") ? a.params : f, u) {
       o[u];
       return s({
        _normalized: !0,
        name: u,
        query: h,
        hash: p,
        params: f
       }, void 0, n)
      }
      if (c) {
       var d = mt(c, t),
        v = Q(d, f, 'redirect route with path "' + d + '"');
       return s({
        _normalized: !0,
        path: v,
        query: h,
        hash: p
       }, void 0, n)
      }
      return l(null, n)
     }
 
     function c(t, e, n) {
      var r = Q(n, e.params, 'aliased route with path "' + n + '"'),
       i = s({
        _normalized: !0,
        path: r
       });
      if (i) {
       var o = i.matched,
        a = o[o.length - 1];
       return e.params = i.params, l(a, e)
      }
      return l(null, e)
     }
 
     function l(t, n, r) {
      return t && t.redirect ? u(t, r || n) : t && t.matchAs ? c(t, n, t.matchAs) : b(t, n, r, e)
     }
     return {
      match: s,
      addRoutes: a
     }
    }
 
    function vt(t, e, n) {
     var r = e.match(t);
     if (!r) return !1;
     if (!n) return !0;
     for (var i = 1, o = r.length; i < o; ++i) {
      var a = t.keys[i - 1],
       s = "string" === typeof r[i] ? decodeURIComponent(r[i]) : r[i];
      a && (n[a.name || "pathMatch"] = s)
     }
     return !0
    }
 
    function mt(t, e) {
     return A(t, e.parent ? e.parent.path : "/", !0)
    }
    var gt = ct && window.performance && window.performance.now ? window.performance : Date;
 
    function yt() {
     return gt.now().toFixed(3)
    }
    var bt = yt();
 
    function xt() {
     return bt
    }
 
    function wt(t) {
     return bt = t
    }
    var Ct = Object.create(null);
 
    function St() {
     var t = window.location.protocol + "//" + window.location.host,
      e = window.location.href.replace(t, "");
     window.history.replaceState({
      key: xt()
     }, "", e), window.addEventListener("popstate", (function(t) {
      kt(), t.state && t.state.key && wt(t.state.key)
     }))
    }
 
    function Et(t, e, n, r) {
     if (t.app) {
      var i = t.options.scrollBehavior;
      i && t.app.$nextTick((function() {
       var o = It(),
        a = i.call(t, e, n, r ? o : null);
       a && ("function" === typeof a.then ? a.then((function(t) {
        Dt(t, o)
       })).catch((function(t) {
        0
       })) : Dt(a, o))
      }))
     }
    }
 
    function kt() {
     var t = xt();
     t && (Ct[t] = {
      x: window.pageXOffset,
      y: window.pageYOffset
     })
    }
 
    function It() {
     var t = xt();
     if (t) return Ct[t]
    }
 
    function Ot(t, e) {
     var n = document.documentElement,
      r = n.getBoundingClientRect(),
      i = t.getBoundingClientRect();
     return {
      x: i.left - r.left - e.x,
      y: i.top - r.top - e.y
     }
    }
 
    function At(t) {
     return Tt(t.x) || Tt(t.y)
    }
 
    function Nt(t) {
     return {
      x: Tt(t.x) ? t.x : window.pageXOffset,
      y: Tt(t.y) ? t.y : window.pageYOffset
     }
    }
 
    function Rt(t) {
     return {
      x: Tt(t.x) ? t.x : 0,
      y: Tt(t.y) ? t.y : 0
     }
    }
 
    function Tt(t) {
     return "number" === typeof t
    }
    var _t = /^#\d/;
 
    function Dt(t, e) {
     var n = "object" === typeof t;
     if (n && "string" === typeof t.selector) {
      var r = _t.test(t.selector) ? document.getElementById(t.selector.slice(1)) : document.querySelector(t.selector);
      if (r) {
       var i = t.offset && "object" === typeof t.offset ? t.offset : {};
       i = Rt(i), e = Ot(r, i)
      } else At(t) && (e = Nt(t))
     } else n && At(t) && (e = Nt(t));
     e && window.scrollTo(e.x, e.y)
    }
    var Ft = ct && function() {
     var t = window.navigator.userAgent;
     return (-1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone")) && (window.history && "pushState" in window.history)
    }();
 
    function Mt(t, e) {
     kt();
     var n = window.history;
     try {
      if (e) {
       var r = a({}, n.state);
       r.key = xt(), n.replaceState(r, "", t)
      } else n.pushState({
       key: wt(yt())
      }, "", t)
     } catch (i) {
      window.location[e ? "replace" : "assign"](t)
     }
    }
 
    function Lt(t) {
     Mt(t, !0)
    }
 
    function Bt(t, e, n) {
     var r = function(i) {
      i >= t.length ? n() : t[i] ? e(t[i], (function() {
       r(i + 1)
      })) : r(i + 1)
     };
     r(0)
    }
 
    function Pt(t) {
     return function(e, n, r) {
      var o = !1,
       a = 0,
       s = null;
      zt(t, (function(t, e, n, u) {
       if ("function" === typeof t && void 0 === t.cid) {
        o = !0, a++;
        var c, l = Ut((function(e) {
          Vt(e) && (e = e.default), t.resolved = "function" === typeof e ? e : et.extend(e), n.components[u] = e, a--, a <= 0 && r()
         })),
         h = Ut((function(t) {
          var e = "Failed to resolve async component " + u + ": " + t;
          s || (s = i(t) ? t : new Error(e), r(s))
         }));
        try {
         c = t(l, h)
        } catch (f) {
         h(f)
        }
        if (c)
         if ("function" === typeof c.then) c.then(l, h);
         else {
          var p = c.component;
          p && "function" === typeof p.then && p.then(l, h)
         }
       }
      })), o || r()
     }
    }
 
    function zt(t, e) {
     return jt(t.map((function(t) {
      return Object.keys(t.components).map((function(n) {
       return e(t.components[n], t.instances[n], t, n)
      }))
     })))
    }
 
    function jt(t) {
     return Array.prototype.concat.apply([], t)
    }
    var Wt = "function" === typeof Symbol && "symbol" === typeof Symbol.toStringTag;
 
    function Vt(t) {
     return t.__esModule || Wt && "Module" === t[Symbol.toStringTag]
    }
 
    function Ut(t) {
     var e = !1;
     return function() {
      var n = [],
       r = arguments.length;
      while (r--) n[r] = arguments[r];
      if (!e) return e = !0, t.apply(this, n)
     }
    }
    var Ht = function(t) {
     function e(e) {
      t.call(this), this.name = this._name = "NavigationDuplicated", this.message = 'Navigating to current location ("' + e.fullPath + '") is not allowed', Object.defineProperty(this, "stack", {
       value: (new t).stack,
       writable: !0,
       configurable: !0
      })
     }
     return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
    }(Error);
    Ht._name = "NavigationDuplicated";
    var $t = function(t, e) {
     this.router = t, this.base = Gt(e), this.current = w, this.pending = null, this.ready = !1, this.readyCbs = [], this.readyErrorCbs = [], this.errorCbs = []
    };
 
    function Gt(t) {
     if (!t)
      if (ct) {
       var e = document.querySelector("base");
       t = e && e.getAttribute("href") || "/", t = t.replace(/^https?:\/\/[^\/]+/, "")
      } else t = "/";
     return "/" !== t.charAt(0) && (t = "/" + t), t.replace(/\/$/, "")
    }
 
    function qt(t, e) {
     var n, r = Math.max(t.length, e.length);
     for (n = 0; n < r; n++)
      if (t[n] !== e[n]) break;
     return {
      updated: e.slice(0, n),
      activated: e.slice(n),
      deactivated: t.slice(n)
     }
    }
 
    function Kt(t, e, n, r) {
     var i = zt(t, (function(t, r, i, o) {
      var a = Xt(t, e);
      if (a) return Array.isArray(a) ? a.map((function(t) {
       return n(t, r, i, o)
      })) : n(a, r, i, o)
     }));
     return jt(r ? i.reverse() : i)
    }
 
    function Xt(t, e) {
     return "function" !== typeof t && (t = et.extend(t)), t.options[e]
    }
 
    function Yt(t) {
     return Kt(t, "beforeRouteLeave", Jt, !0)
    }
 
    function Zt(t) {
     return Kt(t, "beforeRouteUpdate", Jt)
    }
 
    function Jt(t, e) {
     if (e) return function() {
      return t.apply(e, arguments)
     }
    }
 
    function Qt(t, e, n) {
     return Kt(t, "beforeRouteEnter", (function(t, r, i, o) {
      return te(t, i, o, e, n)
     }))
    }
 
    function te(t, e, n, r, i) {
     return function(o, a, s) {
      return t(o, a, (function(t) {
       "function" === typeof t && r.push((function() {
        ee(t, e.instances, n, i)
       })), s(t)
      }))
     }
    }
 
    function ee(t, e, n, r) {
     e[n] && !e[n]._isBeingDestroyed ? t(e[n]) : r() && setTimeout((function() {
      ee(t, e, n, r)
     }), 16)
    }
    $t.prototype.listen = function(t) {
     this.cb = t
    }, $t.prototype.onReady = function(t, e) {
     this.ready ? t() : (this.readyCbs.push(t), e && this.readyErrorCbs.push(e))
    }, $t.prototype.onError = function(t) {
     this.errorCbs.push(t)
    }, $t.prototype.transitionTo = function(t, e, n) {
     var r = this,
      i = this.router.match(t, this.current);
     this.confirmTransition(i, (function() {
      r.updateRoute(i), e && e(i), r.ensureURL(), r.ready || (r.ready = !0, r.readyCbs.forEach((function(t) {
       t(i)
      })))
     }), (function(t) {
      n && n(t), t && !r.ready && (r.ready = !0, r.readyErrorCbs.forEach((function(e) {
       e(t)
      })))
     }))
    }, $t.prototype.confirmTransition = function(t, e, n) {
     var a = this,
      s = this.current,
      u = function(t) {
       !o(Ht, t) && i(t) && (a.errorCbs.length ? a.errorCbs.forEach((function(e) {
        e(t)
       })) : (r(!1, "uncaught error during route navigation:"), console.error(t))), n && n(t)
      };
     if (E(t, s) && t.matched.length === s.matched.length) return this.ensureURL(), u(new Ht(t));
     var c = qt(this.current.matched, t.matched),
      l = c.updated,
      h = c.deactivated,
      p = c.activated,
      f = [].concat(Yt(h), this.router.beforeHooks, Zt(l), p.map((function(t) {
       return t.beforeEnter
      })), Pt(p));
     this.pending = t;
     var d = function(e, n) {
      if (a.pending !== t) return u();
      try {
       e(t, s, (function(t) {
        !1 === t || i(t) ? (a.ensureURL(!0), u(t)) : "string" === typeof t || "object" === typeof t && ("string" === typeof t.path || "string" === typeof t.name) ? (u(), "object" === typeof t && t.replace ? a.replace(t) : a.push(t)) : n(t)
       }))
      } catch (r) {
       u(r)
      }
     };
     Bt(f, d, (function() {
      var n = [],
       r = function() {
        return a.current === t
       },
       i = Qt(p, n, r),
       o = i.concat(a.router.resolveHooks);
      Bt(o, d, (function() {
       if (a.pending !== t) return u();
       a.pending = null, e(t), a.router.app && a.router.app.$nextTick((function() {
        n.forEach((function(t) {
         t()
        }))
       }))
      }))
     }))
    }, $t.prototype.updateRoute = function(t) {
     var e = this.current;
     this.current = t, this.cb && this.cb(t), this.router.afterHooks.forEach((function(n) {
      n && n(t, e)
     }))
    };
    var ne = function(t) {
     function e(e, n) {
      var r = this;
      t.call(this, e, n);
      var i = e.options.scrollBehavior,
       o = Ft && i;
      o && St();
      var a = re(this.base);
      window.addEventListener("popstate", (function(t) {
       var n = r.current,
        i = re(r.base);
       r.current === w && i === a || r.transitionTo(i, (function(t) {
        o && Et(e, t, n, !0)
       }))
      }))
     }
     return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.go = function(t) {
      window.history.go(t)
     }, e.prototype.push = function(t, e, n) {
      var r = this,
       i = this,
       o = i.current;
      this.transitionTo(t, (function(t) {
       Mt(R(r.base + t.fullPath)), Et(r.router, t, o, !1), e && e(t)
      }), n)
     }, e.prototype.replace = function(t, e, n) {
      var r = this,
       i = this,
       o = i.current;
      this.transitionTo(t, (function(t) {
       Lt(R(r.base + t.fullPath)), Et(r.router, t, o, !1), e && e(t)
      }), n)
     }, e.prototype.ensureURL = function(t) {
      if (re(this.base) !== this.current.fullPath) {
       var e = R(this.base + this.current.fullPath);
       t ? Mt(e) : Lt(e)
      }
     }, e.prototype.getCurrentLocation = function() {
      return re(this.base)
     }, e
    }($t);
 
    function re(t) {
     var e = decodeURI(window.location.pathname);
     return t && 0 === e.indexOf(t) && (e = e.slice(t.length)), (e || "/") + window.location.search + window.location.hash
    }
    var ie = function(t) {
     function e(e, n, r) {
      t.call(this, e, n), r && oe(this.base) || ae()
     }
     return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setupListeners = function() {
      var t = this,
       e = this.router,
       n = e.options.scrollBehavior,
       r = Ft && n;
      r && St(), window.addEventListener(Ft ? "popstate" : "hashchange", (function() {
       var e = t.current;
       ae() && t.transitionTo(se(), (function(n) {
        r && Et(t.router, n, e, !0), Ft || le(n.fullPath)
       }))
      }))
     }, e.prototype.push = function(t, e, n) {
      var r = this,
       i = this,
       o = i.current;
      this.transitionTo(t, (function(t) {
       ce(t.fullPath), Et(r.router, t, o, !1), e && e(t)
      }), n)
     }, e.prototype.replace = function(t, e, n) {
      var r = this,
       i = this,
       o = i.current;
      this.transitionTo(t, (function(t) {
       le(t.fullPath), Et(r.router, t, o, !1), e && e(t)
      }), n)
     }, e.prototype.go = function(t) {
      window.history.go(t)
     }, e.prototype.ensureURL = function(t) {
      var e = this.current.fullPath;
      se() !== e && (t ? ce(e) : le(e))
     }, e.prototype.getCurrentLocation = function() {
      return se()
     }, e
    }($t);
 
    function oe(t) {
     var e = re(t);
     if (!/^\/#/.test(e)) return window.location.replace(R(t + "/#" + e)), !0
    }
 
    function ae() {
     var t = se();
     return "/" === t.charAt(0) || (le("/" + t), !1)
    }
 
    function se() {
     var t = window.location.href,
      e = t.indexOf("#");
     if (e < 0) return "";
     t = t.slice(e + 1);
     var n = t.indexOf("?");
     if (n < 0) {
      var r = t.indexOf("#");
      t = r > -1 ? decodeURI(t.slice(0, r)) + t.slice(r) : decodeURI(t)
     } else t = decodeURI(t.slice(0, n)) + t.slice(n);
     return t
    }
 
    function ue(t) {
     var e = window.location.href,
      n = e.indexOf("#"),
      r = n >= 0 ? e.slice(0, n) : e;
     return r + "#" + t
    }
 
    function ce(t) {
     Ft ? Mt(ue(t)) : window.location.hash = t
    }
 
    function le(t) {
     Ft ? Lt(ue(t)) : window.location.replace(ue(t))
    }
    var he = function(t) {
      function e(e, n) {
       t.call(this, e, n), this.stack = [], this.index = -1
      }
      return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.push = function(t, e, n) {
       var r = this;
       this.transitionTo(t, (function(t) {
        r.stack = r.stack.slice(0, r.index + 1).concat(t), r.index++, e && e(t)
       }), n)
      }, e.prototype.replace = function(t, e, n) {
       var r = this;
       this.transitionTo(t, (function(t) {
        r.stack = r.stack.slice(0, r.index).concat(t), e && e(t)
       }), n)
      }, e.prototype.go = function(t) {
       var e = this,
        n = this.index + t;
       if (!(n < 0 || n >= this.stack.length)) {
        var r = this.stack[n];
        this.confirmTransition(r, (function() {
         e.index = n, e.updateRoute(r)
        }), (function(t) {
         o(Ht, t) && (e.index = n)
        }))
       }
      }, e.prototype.getCurrentLocation = function() {
       var t = this.stack[this.stack.length - 1];
       return t ? t.fullPath : "/"
      }, e.prototype.ensureURL = function() {}, e
     }($t),
     pe = function(t) {
      void 0 === t && (t = {}), this.app = null, this.apps = [], this.options = t, this.beforeHooks = [], this.resolveHooks = [], this.afterHooks = [], this.matcher = dt(t.routes || [], this);
      var e = t.mode || "hash";
      switch (this.fallback = "history" === e && !Ft && !1 !== t.fallback, this.fallback && (e = "hash"), ct || (e = "abstract"), this.mode = e, e) {
       case "history":
        this.history = new ne(this, t.base);
        break;
       case "hash":
        this.history = new ie(this, t.base, this.fallback);
        break;
       case "abstract":
        this.history = new he(this, t.base);
        break;
       default:
        0
      }
     },
     fe = {
      currentRoute: {
       configurable: !0
      }
     };
 
    function de(t, e) {
     return t.push(e),
      function() {
       var n = t.indexOf(e);
       n > -1 && t.splice(n, 1)
      }
    }
 
    function ve(t, e, n) {
     var r = "hash" === n ? "#" + e : e;
     return t ? R(t + "/" + r) : r
    }
    pe.prototype.match = function(t, e, n) {
     return this.matcher.match(t, e, n)
    }, fe.currentRoute.get = function() {
     return this.history && this.history.current
    }, pe.prototype.init = function(t) {
     var e = this;
     if (this.apps.push(t), t.$once("hook:destroyed", (function() {
       var n = e.apps.indexOf(t);
       n > -1 && e.apps.splice(n, 1), e.app === t && (e.app = e.apps[0] || null)
      })), !this.app) {
      this.app = t;
      var n = this.history;
      if (n instanceof ne) n.transitionTo(n.getCurrentLocation());
      else if (n instanceof ie) {
       var r = function() {
        n.setupListeners()
       };
       n.transitionTo(n.getCurrentLocation(), r, r)
      }
      n.listen((function(t) {
       e.apps.forEach((function(e) {
        e._route = t
       }))
      }))
     }
    }, pe.prototype.beforeEach = function(t) {
     return de(this.beforeHooks, t)
    }, pe.prototype.beforeResolve = function(t) {
     return de(this.resolveHooks, t)
    }, pe.prototype.afterEach = function(t) {
     return de(this.afterHooks, t)
    }, pe.prototype.onReady = function(t, e) {
     this.history.onReady(t, e)
    }, pe.prototype.onError = function(t) {
     this.history.onError(t)
    }, pe.prototype.push = function(t, e, n) {
     var r = this;
     if (!e && !n && "undefined" !== typeof Promise) return new Promise((function(e, n) {
      r.history.push(t, e, n)
     }));
     this.history.push(t, e, n)
    }, pe.prototype.replace = function(t, e, n) {
     var r = this;
     if (!e && !n && "undefined" !== typeof Promise) return new Promise((function(e, n) {
      r.history.replace(t, e, n)
     }));
     this.history.replace(t, e, n)
    }, pe.prototype.go = function(t) {
     this.history.go(t)
    }, pe.prototype.back = function() {
     this.go(-1)
    }, pe.prototype.forward = function() {
     this.go(1)
    }, pe.prototype.getMatchedComponents = function(t) {
     var e = t ? t.matched ? t : this.resolve(t).route : this.currentRoute;
     return e ? [].concat.apply([], e.matched.map((function(t) {
      return Object.keys(t.components).map((function(e) {
       return t.components[e]
      }))
     }))) : []
    }, pe.prototype.resolve = function(t, e, n) {
     e = e || this.history.current;
     var r = tt(t, e, n, this),
      i = this.match(r, e),
      o = i.redirectedFrom || i.fullPath,
      a = this.history.base,
      s = ve(a, o, this.mode);
     return {
      location: r,
      route: i,
      href: s,
      normalizedTo: r,
      resolved: i
     }
    }, pe.prototype.addRoutes = function(t) {
     this.matcher.addRoutes(t), this.history.current !== w && this.history.transitionTo(this.history.getCurrentLocation())
    }, Object.defineProperties(pe.prototype, fe), pe.install = ut, pe.version = "3.1.5", ct && window.Vue && window.Vue.use(pe), e["a"] = pe
   },
   "8ce9": function(t, e, n) {},
   "8d4f": function(t, e, n) {},
   "8dd9": function(t, e, n) {
    "use strict";
    var r = n("5530"),
     i = (n("25a8"), n("7e2b")),
     o = n("a9ad"),
     a = (n("a9e3"), n("ade3")),
     s = n("2b0e"),
     u = s["a"].extend({
      name: "elevatable",
      props: {
       elevation: [Number, String]
      },
      computed: {
       computedElevation: function() {
        return this.elevation
       },
       elevationClasses: function() {
        var t = this.computedElevation;
        return null == t ? {} : isNaN(parseInt(t)) ? {} : Object(a["a"])({}, "elevation-".concat(this.elevation), !0)
       }
      }
     }),
     c = n("24b2"),
     l = n("7560"),
     h = n("58df");
    e["a"] = Object(h["a"])(i["a"], o["a"], u, c["a"], l["a"]).extend({
     name: "v-sheet",
     props: {
      tag: {
       type: String,
       default: "div"
      },
      tile: Boolean
     },
     computed: {
      classes: function() {
       return Object(r["a"])({
        "v-sheet": !0,
        "v-sheet--tile": this.tile
       }, this.themeClasses, {}, this.elevationClasses)
      },
      styles: function() {
       return this.measurableStyles
      }
     },
     render: function(t) {
      var e = {
       class: this.classes,
       style: this.styles,
       on: this.listeners$
      };
      return t(this.tag, this.setBackgroundColor(this.color, e), this.$slots.default)
     }
    })
   },
   "8df4": function(t, e, n) {
    "use strict";
    var r = n("7a77");
 
    function i(t) {
     if ("function" !== typeof t) throw new TypeError("executor must be a function.");
     var e;
     this.promise = new Promise((function(t) {
      e = t
     }));
     var n = this;
     t((function(t) {
      n.reason || (n.reason = new r(t), e(n.reason))
     }))
    }
    i.prototype.throwIfRequested = function() {
     if (this.reason) throw this.reason
    }, i.source = function() {
     var t, e = new i((function(e) {
      t = e
     }));
     return {
      token: e,
      cancel: t
     }
    }, t.exports = i
   },
   "8efc": function(t, e, n) {},
   "8ff2": function(t, e, n) {},
   "90a2": function(t, e, n) {
    "use strict";
    n("7db0");
    var r = n("53ca");
 
    function i(t, e) {
     var n = e.modifiers || {},
      i = e.value,
      a = "object" === Object(r["a"])(i),
      s = a ? i.handler : i,
      u = new IntersectionObserver((function() {
       var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
        r = arguments.length > 1 ? arguments[1] : void 0;
       if (t._observe) {
        if (s && (!n.quiet || t._observe.init)) {
         var i = Boolean(e.find((function(t) {
          return t.isIntersecting
         })));
         s(e, r, i)
        }
        t._observe.init && n.once ? o(t) : t._observe.init = !0
       }
      }), i.options || {});
     t._observe = {
      init: !1,
      observer: u
     }, u.observe(t)
    }
 
    function o(t) {
     t._observe && (t._observe.observer.unobserve(t), delete t._observe)
    }
    var a = {
     inserted: i,
     unbind: o
    };
    e["a"] = a
   },
   "90e3": function(t, e) {
    var n = 0,
     r = Math.random();
    t.exports = function(t) {
     return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++n + r).toString(36)
    }
   },
   9112: function(t, e, n) {
    var r = n("83ab"),
     i = n("9bf2"),
     o = n("5c6c");
    t.exports = r ? function(t, e, n) {
     return i.f(t, e, o(1, n))
    } : function(t, e, n) {
     return t[e] = n, t
    }
   },
   9152: function(t, e) {
    e.read = function(t, e, n, r, i) {
     var o, a, s = 8 * i - r - 1,
      u = (1 << s) - 1,
      c = u >> 1,
      l = -7,
      h = n ? i - 1 : 0,
      p = n ? -1 : 1,
      f = t[e + h];
     for (h += p, o = f & (1 << -l) - 1, f >>= -l, l += s; l > 0; o = 256 * o + t[e + h], h += p, l -= 8);
     for (a = o & (1 << -l) - 1, o >>= -l, l += r; l > 0; a = 256 * a + t[e + h], h += p, l -= 8);
     if (0 === o) o = 1 - c;
     else {
      if (o === u) return a ? NaN : 1 / 0 * (f ? -1 : 1);
      a += Math.pow(2, r), o -= c
     }
     return (f ? -1 : 1) * a * Math.pow(2, o - r)
    }, e.write = function(t, e, n, r, i, o) {
     var a, s, u, c = 8 * o - i - 1,
      l = (1 << c) - 1,
      h = l >> 1,
      p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
      f = r ? 0 : o - 1,
      d = r ? 1 : -1,
      v = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
     for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = l) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), e += a + h >= 1 ? p / u : p * Math.pow(2, 1 - h), e * u >= 2 && (a++, u /= 2), a + h >= l ? (s = 0, a = l) : a + h >= 1 ? (s = (e * u - 1) * Math.pow(2, i), a += h) : (s = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[n + f] = 255 & s, f += d, s /= 256, i -= 8);
     for (a = a << i | s, c += i; c > 0; t[n + f] = 255 & a, f += d, a /= 256, c -= 8);
     t[n + f - d] |= 128 * v
    }
   },
   9263: function(t, e, n) {
    "use strict";
    var r = n("ad6d"),
     i = n("9f7f"),
     o = RegExp.prototype.exec,
     a = String.prototype.replace,
     s = o,
     u = function() {
      var t = /a/,
       e = /b*/g;
      return o.call(t, "a"), o.call(e, "a"), 0 !== t.lastIndex || 0 !== e.lastIndex
     }(),
     c = i.UNSUPPORTED_Y || i.BROKEN_CARET,
     l = void 0 !== /()??/.exec("")[1],
     h = u || l || c;
    h && (s = function(t) {
     var e, n, i, s, h = this,
      p = c && h.sticky,
      f = r.call(h),
      d = h.source,
      v = 0,
      m = t;
     return p && (f = f.replace("y", ""), -1 === f.indexOf("g") && (f += "g"), m = String(t).slice(h.lastIndex), h.lastIndex > 0 && (!h.multiline || h.multiline && "\n" !== t[h.lastIndex - 1]) && (d = "(?: " + d + ")", m = " " + m, v++), n = new RegExp("^(?:" + d + ")", f)), l && (n = new RegExp("^" + d + "$(?!\\s)", f)), u && (e = h.lastIndex), i = o.call(p ? n : h, m), p ? i ? (i.input = i.input.slice(v), i[0] = i[0].slice(v), i.index = h.lastIndex, h.lastIndex += i[0].length) : h.lastIndex = 0 : u && i && (h.lastIndex = h.global ? i.index + i[0].length : e), l && i && i.length > 1 && a.call(i[0], n, (function() {
      for (s = 1; s < arguments.length - 2; s++) void 0 === arguments[s] && (i[s] = void 0)
     })), i
    }), t.exports = s
   },
   "94ca": function(t, e, n) {
    var r = n("d039"),
     i = /#|\.prototype\./,
     o = function(t, e) {
      var n = s[a(t)];
      return n == c || n != u && ("function" == typeof e ? r(e) : !!e)
     },
     a = o.normalize = function(t) {
      return String(t).replace(i, ".").toLowerCase()
     },
     s = o.data = {},
     u = o.NATIVE = "N",
     c = o.POLYFILL = "P";
    t.exports = o
   },
   "95ed": function(t, e, n) {},
   "96cf": function(t, e, n) {
    var r = function(t) {
     "use strict";
     var e, n = Object.prototype,
      r = n.hasOwnProperty,
      i = "function" === typeof Symbol ? Symbol : {},
      o = i.iterator || "@@iterator",
      a = i.asyncIterator || "@@asyncIterator",
      s = i.toStringTag || "@@toStringTag";
 
     function u(t, e, n, r) {
      var i = e && e.prototype instanceof v ? e : v,
       o = Object.create(i.prototype),
       a = new A(r || []);
      return o._invoke = E(t, n, a), o
     }
 
     function c(t, e, n) {
      try {
       return {
        type: "normal",
        arg: t.call(e, n)
       }
      } catch (r) {
       return {
        type: "throw",
        arg: r
       }
      }
     }
     t.wrap = u;
     var l = "suspendedStart",
      h = "suspendedYield",
      p = "executing",
      f = "completed",
      d = {};
 
     function v() {}
 
     function m() {}
 
     function g() {}
     var y = {};
     y[o] = function() {
      return this
     };
     var b = Object.getPrototypeOf,
      x = b && b(b(N([])));
     x && x !== n && r.call(x, o) && (y = x);
     var w = g.prototype = v.prototype = Object.create(y);
 
     function C(t) {
      ["next", "throw", "return"].forEach((function(e) {
       t[e] = function(t) {
        return this._invoke(e, t)
       }
      }))
     }
 
     function S(t) {
      function e(n, i, o, a) {
       var s = c(t[n], t, i);
       if ("throw" !== s.type) {
        var u = s.arg,
         l = u.value;
        return l && "object" === typeof l && r.call(l, "__await") ? Promise.resolve(l.__await).then((function(t) {
         e("next", t, o, a)
        }), (function(t) {
         e("throw", t, o, a)
        })) : Promise.resolve(l).then((function(t) {
         u.value = t, o(u)
        }), (function(t) {
         return e("throw", t, o, a)
        }))
       }
       a(s.arg)
      }
      var n;
 
      function i(t, r) {
       function i() {
        return new Promise((function(n, i) {
         e(t, r, n, i)
        }))
       }
       return n = n ? n.then(i, i) : i()
      }
      this._invoke = i
     }
 
     function E(t, e, n) {
      var r = l;
      return function(i, o) {
       if (r === p) throw new Error("Generator is already running");
       if (r === f) {
        if ("throw" === i) throw o;
        return R()
       }
       n.method = i, n.arg = o;
       while (1) {
        var a = n.delegate;
        if (a) {
         var s = k(a, n);
         if (s) {
          if (s === d) continue;
          return s
         }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;
        else if ("throw" === n.method) {
         if (r === l) throw r = f, n.arg;
         n.dispatchException(n.arg)
        } else "return" === n.method && n.abrupt("return", n.arg);
        r = p;
        var u = c(t, e, n);
        if ("normal" === u.type) {
         if (r = n.done ? f : h, u.arg === d) continue;
         return {
          value: u.arg,
          done: n.done
         }
        }
        "throw" === u.type && (r = f, n.method = "throw", n.arg = u.arg)
       }
      }
     }
 
     function k(t, n) {
      var r = t.iterator[n.method];
      if (r === e) {
       if (n.delegate = null, "throw" === n.method) {
        if (t.iterator["return"] && (n.method = "return", n.arg = e, k(t, n), "throw" === n.method)) return d;
        n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method")
       }
       return d
      }
      var i = c(r, t.iterator, n.arg);
      if ("throw" === i.type) return n.method = "throw", n.arg = i.arg, n.delegate = null, d;
      var o = i.arg;
      return o ? o.done ? (n[t.resultName] = o.value, n.next = t.nextLoc, "return" !== n.method && (n.method = "next", n.arg = e), n.delegate = null, d) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, d)
     }
 
     function I(t) {
      var e = {
       tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
     }
 
     function O(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e
     }
 
     function A(t) {
      this.tryEntries = [{
       tryLoc: "root"
      }], t.forEach(I, this), this.reset(!0)
     }
 
     function N(t) {
      if (t) {
       var n = t[o];
       if (n) return n.call(t);
       if ("function" === typeof t.next) return t;
       if (!isNaN(t.length)) {
        var i = -1,
         a = function n() {
          while (++i < t.length)
           if (r.call(t, i)) return n.value = t[i], n.done = !1, n;
          return n.value = e, n.done = !0, n
         };
        return a.next = a
       }
      }
      return {
       next: R
      }
     }
 
     function R() {
      return {
       value: e,
       done: !0
      }
     }
     return m.prototype = w.constructor = g, g.constructor = m, g[s] = m.displayName = "GeneratorFunction", t.isGeneratorFunction = function(t) {
      var e = "function" === typeof t && t.constructor;
      return !!e && (e === m || "GeneratorFunction" === (e.displayName || e.name))
     }, t.mark = function(t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, g) : (t.__proto__ = g, s in t || (t[s] = "GeneratorFunction")), t.prototype = Object.create(w), t
     }, t.awrap = function(t) {
      return {
       __await: t
      }
     }, C(S.prototype), S.prototype[a] = function() {
      return this
     }, t.AsyncIterator = S, t.async = function(e, n, r, i) {
      var o = new S(u(e, n, r, i));
      return t.isGeneratorFunction(n) ? o : o.next().then((function(t) {
       return t.done ? t.value : o.next()
      }))
     }, C(w), w[s] = "Generator", w[o] = function() {
      return this
     }, w.toString = function() {
      return "[object Generator]"
     }, t.keys = function(t) {
      var e = [];
      for (var n in t) e.push(n);
      return e.reverse(),
       function n() {
        while (e.length) {
         var r = e.pop();
         if (r in t) return n.value = r, n.done = !1, n
        }
        return n.done = !0, n
       }
     }, t.values = N, A.prototype = {
      constructor: A,
      reset: function(t) {
       if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(O), !t)
        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e)
      },
      stop: function() {
       this.done = !0;
       var t = this.tryEntries[0],
        e = t.completion;
       if ("throw" === e.type) throw e.arg;
       return this.rval
      },
      dispatchException: function(t) {
       if (this.done) throw t;
       var n = this;
 
       function i(r, i) {
        return s.type = "throw", s.arg = t, n.next = r, i && (n.method = "next", n.arg = e), !!i
       }
       for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var a = this.tryEntries[o],
         s = a.completion;
        if ("root" === a.tryLoc) return i("end");
        if (a.tryLoc <= this.prev) {
         var u = r.call(a, "catchLoc"),
          c = r.call(a, "finallyLoc");
         if (u && c) {
          if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
          if (this.prev < a.finallyLoc) return i(a.finallyLoc)
         } else if (u) {
          if (this.prev < a.catchLoc) return i(a.catchLoc, !0)
         } else {
          if (!c) throw new Error("try statement without catch or finally");
          if (this.prev < a.finallyLoc) return i(a.finallyLoc)
         }
        }
       }
      },
      abrupt: function(t, e) {
       for (var n = this.tryEntries.length - 1; n >= 0; --n) {
        var i = this.tryEntries[n];
        if (i.tryLoc <= this.prev && r.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
         var o = i;
         break
        }
       }
       o && ("break" === t || "continue" === t) && o.tryLoc <= e && e <= o.finallyLoc && (o = null);
       var a = o ? o.completion : {};
       return a.type = t, a.arg = e, o ? (this.method = "next", this.next = o.finallyLoc, d) : this.complete(a)
      },
      complete: function(t, e) {
       if ("throw" === t.type) throw t.arg;
       return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), d
      },
      finish: function(t) {
       for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), O(n), d
       }
      },
      catch: function(t) {
       for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n.tryLoc === t) {
         var r = n.completion;
         if ("throw" === r.type) {
          var i = r.arg;
          O(n)
         }
         return i
        }
       }
       throw new Error("illegal catch attempt")
      },
      delegateYield: function(t, n, r) {
       return this.delegate = {
        iterator: N(t),
        resultName: n,
        nextLoc: r
       }, "next" === this.method && (this.arg = e), d
      }
     }, t
    }(t.exports);
    try {
     regeneratorRuntime = r
    } catch (i) {
     Function("r", "regeneratorRuntime = r")(r)
    }
   },
   9911: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("857a"),
     o = n("af03");
    r({
     target: "String",
     proto: !0,
     forced: o("link")
    }, {
     link: function(t) {
      return i(this, "a", "href", t)
     }
    })
   },
   "99af": function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("d039"),
     o = n("e8b5"),
     a = n("861d"),
     s = n("7b0b"),
     u = n("50c4"),
     c = n("8418"),
     l = n("65f0"),
     h = n("1dde"),
     p = n("b622"),
     f = n("2d00"),
     d = p("isConcatSpreadable"),
     v = 9007199254740991,
     m = "Maximum allowed index exceeded",
     g = f >= 51 || !i((function() {
      var t = [];
      return t[d] = !1, t.concat()[0] !== t
     })),
     y = h("concat"),
     b = function(t) {
      if (!a(t)) return !1;
      var e = t[d];
      return void 0 !== e ? !!e : o(t)
     },
     x = !g || !y;
    r({
     target: "Array",
     proto: !0,
     forced: x
    }, {
     concat: function(t) {
      var e, n, r, i, o, a = s(this),
       h = l(a, 0),
       p = 0;
      for (e = -1, r = arguments.length; e < r; e++)
       if (o = -1 === e ? a : arguments[e], b(o)) {
        if (i = u(o.length), p + i > v) throw TypeError(m);
        for (n = 0; n < i; n++, p++) n in o && c(h, p, o[n])
       } else {
        if (p >= v) throw TypeError(m);
        c(h, p++, o)
       } return h.length = p, h
     }
    })
   },
   "9bdd": function(t, e, n) {
    var r = n("825a");
    t.exports = function(t, e, n, i) {
     try {
      return i ? e(r(n)[0], n[1]) : e(n)
     } catch (a) {
      var o = t["return"];
      throw void 0 !== o && r(o.call(t)), a
     }
    }
   },
   "9bf2": function(t, e, n) {
    var r = n("83ab"),
     i = n("0cfb"),
     o = n("825a"),
     a = n("c04e"),
     s = Object.defineProperty;
    e.f = r ? s : function(t, e, n) {
     if (o(t), e = a(e, !0), o(n), i) try {
      return s(t, e, n)
     } catch (r) {}
     if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
     return "value" in n && (t[e] = n.value), t
    }
   },
   "9d26": function(t, e, n) {
    "use strict";
    var r = n("132d");
    e["a"] = r["a"]
   },
   "9d65": function(t, e, n) {
    "use strict";
    var r = n("d9bd"),
     i = n("2b0e");
    e["a"] = i["a"].extend().extend({
     name: "bootable",
     props: {
      eager: Boolean
     },
     data: function() {
      return {
       isBooted: !1
      }
     },
     computed: {
      hasContent: function() {
       return this.isBooted || this.eager || this.isActive
      }
     },
     watch: {
      isActive: function() {
       this.isBooted = !0
      }
     },
     created: function() {
      "lazy" in this.$attrs && Object(r["d"])("lazy", this)
     },
     methods: {
      showLazyContent: function(t) {
       return this.hasContent && t ? t() : [this.$createElement()]
      }
     }
    })
   },
   "9ed3": function(t, e, n) {
    "use strict";
    var r = n("ae93").IteratorPrototype,
     i = n("7c73"),
     o = n("5c6c"),
     a = n("d44e"),
     s = n("3f8c"),
     u = function() {
      return this
     };
    t.exports = function(t, e, n) {
     var c = e + " Iterator";
     return t.prototype = i(r, {
      next: o(1, n)
     }), a(t, c, !1, !0), s[c] = u, t
    }
   },
   "9f7f": function(t, e, n) {
    "use strict";
    var r = n("d039");
 
    function i(t, e) {
     return RegExp(t, e)
    }
    e.UNSUPPORTED_Y = r((function() {
     var t = i("a", "y");
     return t.lastIndex = 2, null != t.exec("abcd")
    })), e.BROKEN_CARET = r((function() {
     var t = i("^r", "gy");
     return t.lastIndex = 2, null != t.exec("str")
    }))
   },
   a15b: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("44ad"),
     o = n("fc6a"),
     a = n("a640"),
     s = [].join,
     u = i != Object,
     c = a("join", ",");
    r({
     target: "Array",
     proto: !0,
     forced: u || !c
    }, {
     join: function(t) {
      return s.call(o(this), void 0 === t ? "," : t)
     }
    })
   },
   a293: function(t, e, n) {
    "use strict";
    n("45fc");
 
    function r() {
     return !1
    }
 
    function i(t, e, n) {
     n.args = n.args || {};
     var i = n.args.closeConditional || r;
     if (t && !1 !== i(t) && !("isTrusted" in t && !t.isTrusted || "pointerType" in t && !t.pointerType)) {
      var o = (n.args.include || function() {
       return []
      })();
      o.push(e), !o.some((function(e) {
       return e.contains(t.target)
      })) && setTimeout((function() {
       i(t) && n.value && n.value(t)
      }), 0)
     }
    }
    var o = {
     inserted: function(t, e) {
      var n = function(n) {
        return i(n, t, e)
       },
       r = document.querySelector("[data-app]") || document.body;
      r.addEventListener("click", n, !0), t._clickOutside = n
     },
     unbind: function(t) {
      if (t._clickOutside) {
       var e = document.querySelector("[data-app]") || document.body;
       e && e.removeEventListener("click", t._clickOutside, !0), delete t._clickOutside
      }
     }
    };
    e["a"] = o
   },
   a2bf: function(t, e, n) {
    "use strict";
    var r = n("e8b5"),
     i = n("50c4"),
     o = n("0366"),
     a = function(t, e, n, s, u, c, l, h) {
      var p, f = u,
       d = 0,
       v = !!l && o(l, h, 3);
      while (d < s) {
       if (d in n) {
        if (p = v ? v(n[d], d, e) : n[d], c > 0 && r(p)) f = a(t, e, p, i(p.length), f, c - 1) - 1;
        else {
         if (f >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
         t[f] = p
        }
        f++
       }
       d++
      }
      return f
     };
    t.exports = a
   },
   a434: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("23cb"),
     o = n("a691"),
     a = n("50c4"),
     s = n("7b0b"),
     u = n("65f0"),
     c = n("8418"),
     l = n("1dde"),
     h = n("ae40"),
     p = l("splice"),
     f = h("splice", {
      ACCESSORS: !0,
      0: 0,
      1: 2
     }),
     d = Math.max,
     v = Math.min,
     m = 9007199254740991,
     g = "Maximum allowed length exceeded";
    r({
     target: "Array",
     proto: !0,
     forced: !p || !f
    }, {
     splice: function(t, e) {
      var n, r, l, h, p, f, y = s(this),
       b = a(y.length),
       x = i(t, b),
       w = arguments.length;
      if (0 === w ? n = r = 0 : 1 === w ? (n = 0, r = b - x) : (n = w - 2, r = v(d(o(e), 0), b - x)), b + n - r > m) throw TypeError(g);
      for (l = u(y, r), h = 0; h < r; h++) p = x + h, p in y && c(l, h, y[p]);
      if (l.length = r, n < r) {
       for (h = x; h < b - r; h++) p = h + r, f = h + n, p in y ? y[f] = y[p] : delete y[f];
       for (h = b; h > b - r + n; h--) delete y[h - 1]
      } else if (n > r)
       for (h = b - r; h > x; h--) p = h + r - 1, f = h + n - 1, p in y ? y[f] = y[p] : delete y[f];
      for (h = 0; h < n; h++) y[h + x] = arguments[h + 2];
      return y.length = b - r + n, l
     }
    })
   },
   a452: function(t, e, n) {
    "use strict";
    var r = n("ade3"),
     i = n("2b0e");
 
    function o() {
     var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "value",
      e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "change";
     return i["a"].extend({
      name: "proxyable",
      model: {
       prop: t,
       event: e
      },
      props: Object(r["a"])({}, t, {
       required: !1
      }),
      data: function() {
       return {
        internalLazyValue: this[t]
       }
      },
      computed: {
       internalValue: {
        get: function() {
         return this.internalLazyValue
        },
        set: function(t) {
         t !== this.internalLazyValue && (this.internalLazyValue = t, this.$emit(e, t))
        }
       }
      },
      watch: Object(r["a"])({}, t, (function(t) {
       this.internalLazyValue = t
      }))
     })
    }
    var a = o();
    e["a"] = a
   },
   a4d3: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("da84"),
     o = n("d066"),
     a = n("c430"),
     s = n("83ab"),
     u = n("4930"),
     c = n("fdbf"),
     l = n("d039"),
     h = n("5135"),
     p = n("e8b5"),
     f = n("861d"),
     d = n("825a"),
     v = n("7b0b"),
     m = n("fc6a"),
     g = n("c04e"),
     y = n("5c6c"),
     b = n("7c73"),
     x = n("df75"),
     w = n("241c"),
     C = n("057f"),
     S = n("7418"),
     E = n("06cf"),
     k = n("9bf2"),
     I = n("d1e7"),
     O = n("9112"),
     A = n("6eeb"),
     N = n("5692"),
     R = n("f772"),
     T = n("d012"),
     _ = n("90e3"),
     D = n("b622"),
     F = n("e538"),
     M = n("746f"),
     L = n("d44e"),
     B = n("69f3"),
     P = n("b727").forEach,
     z = R("hidden"),
     j = "Symbol",
     W = "prototype",
     V = D("toPrimitive"),
     U = B.set,
     H = B.getterFor(j),
     $ = Object[W],
     G = i.Symbol,
     q = o("JSON", "stringify"),
     K = E.f,
     X = k.f,
     Y = C.f,
     Z = I.f,
     J = N("symbols"),
     Q = N("op-symbols"),
     tt = N("string-to-symbol-registry"),
     et = N("symbol-to-string-registry"),
     nt = N("wks"),
     rt = i.QObject,
     it = !rt || !rt[W] || !rt[W].findChild,
     ot = s && l((function() {
      return 7 != b(X({}, "a", {
       get: function() {
        return X(this, "a", {
         value: 7
        }).a
       }
      })).a
     })) ? function(t, e, n) {
      var r = K($, e);
      r && delete $[e], X(t, e, n), r && t !== $ && X($, e, r)
     } : X,
     at = function(t, e) {
      var n = J[t] = b(G[W]);
      return U(n, {
       type: j,
       tag: t,
       description: e
      }), s || (n.description = e), n
     },
     st = c ? function(t) {
      return "symbol" == typeof t
     } : function(t) {
      return Object(t) instanceof G
     },
     ut = function(t, e, n) {
      t === $ && ut(Q, e, n), d(t);
      var r = g(e, !0);
      return d(n), h(J, r) ? (n.enumerable ? (h(t, z) && t[z][r] && (t[z][r] = !1), n = b(n, {
       enumerable: y(0, !1)
      })) : (h(t, z) || X(t, z, y(1, {})), t[z][r] = !0), ot(t, r, n)) : X(t, r, n)
     },
     ct = function(t, e) {
      d(t);
      var n = m(e),
       r = x(n).concat(dt(n));
      return P(r, (function(e) {
       s && !ht.call(n, e) || ut(t, e, n[e])
      })), t
     },
     lt = function(t, e) {
      return void 0 === e ? b(t) : ct(b(t), e)
     },
     ht = function(t) {
      var e = g(t, !0),
       n = Z.call(this, e);
      return !(this === $ && h(J, e) && !h(Q, e)) && (!(n || !h(this, e) || !h(J, e) || h(this, z) && this[z][e]) || n)
     },
     pt = function(t, e) {
      var n = m(t),
       r = g(e, !0);
      if (n !== $ || !h(J, r) || h(Q, r)) {
       var i = K(n, r);
       return !i || !h(J, r) || h(n, z) && n[z][r] || (i.enumerable = !0), i
      }
     },
     ft = function(t) {
      var e = Y(m(t)),
       n = [];
      return P(e, (function(t) {
       h(J, t) || h(T, t) || n.push(t)
      })), n
     },
     dt = function(t) {
      var e = t === $,
       n = Y(e ? Q : m(t)),
       r = [];
      return P(n, (function(t) {
       !h(J, t) || e && !h($, t) || r.push(J[t])
      })), r
     };
    if (u || (G = function() {
      if (this instanceof G) throw TypeError("Symbol is not a constructor");
      var t = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0,
       e = _(t),
       n = function(t) {
        this === $ && n.call(Q, t), h(this, z) && h(this[z], e) && (this[z][e] = !1), ot(this, e, y(1, t))
       };
      return s && it && ot($, e, {
       configurable: !0,
       set: n
      }), at(e, t)
     }, A(G[W], "toString", (function() {
      return H(this).tag
     })), A(G, "withoutSetter", (function(t) {
      return at(_(t), t)
     })), I.f = ht, k.f = ut, E.f = pt, w.f = C.f = ft, S.f = dt, F.f = function(t) {
      return at(D(t), t)
     }, s && (X(G[W], "description", {
      configurable: !0,
      get: function() {
       return H(this).description
      }
     }), a || A($, "propertyIsEnumerable", ht, {
      unsafe: !0
     }))), r({
      global: !0,
      wrap: !0,
      forced: !u,
      sham: !u
     }, {
      Symbol: G
     }), P(x(nt), (function(t) {
      M(t)
     })), r({
      target: j,
      stat: !0,
      forced: !u
     }, {
      for: function(t) {
       var e = String(t);
       if (h(tt, e)) return tt[e];
       var n = G(e);
       return tt[e] = n, et[n] = e, n
      },
      keyFor: function(t) {
       if (!st(t)) throw TypeError(t + " is not a symbol");
       if (h(et, t)) return et[t]
      },
      useSetter: function() {
       it = !0
      },
      useSimple: function() {
       it = !1
      }
     }), r({
      target: "Object",
      stat: !0,
      forced: !u,
      sham: !s
     }, {
      create: lt,
      defineProperty: ut,
      defineProperties: ct,
      getOwnPropertyDescriptor: pt
     }), r({
      target: "Object",
      stat: !0,
      forced: !u
     }, {
      getOwnPropertyNames: ft,
      getOwnPropertySymbols: dt
     }), r({
      target: "Object",
      stat: !0,
      forced: l((function() {
       S.f(1)
      }))
     }, {
      getOwnPropertySymbols: function(t) {
       return S.f(v(t))
      }
     }), q) {
     var vt = !u || l((function() {
      var t = G();
      return "[null]" != q([t]) || "{}" != q({
       a: t
      }) || "{}" != q(Object(t))
     }));
     r({
      target: "JSON",
      stat: !0,
      forced: vt
     }, {
      stringify: function(t, e, n) {
       var r, i = [t],
        o = 1;
       while (arguments.length > o) i.push(arguments[o++]);
       if (r = e, (f(e) || void 0 !== t) && !st(t)) return p(e) || (e = function(t, e) {
        if ("function" == typeof r && (e = r.call(this, t, e)), !st(e)) return e
       }), i[1] = e, q.apply(null, i)
      }
     })
    }
    G[W][V] || O(G[W], V, G[W].valueOf), L(G, j), T[z] = !0
   },
   a523: function(t, e, n) {
    "use strict";
    n("99af"), n("4de4"), n("b64b"), n("2ca0"), n("20f6"), n("4b85"), n("a15b"), n("498a");
    var r = n("2b0e");
 
    function i(t) {
     return r["a"].extend({
      name: "v-".concat(t),
      functional: !0,
      props: {
       id: String,
       tag: {
        type: String,
        default: "div"
       }
      },
      render: function(e, n) {
       var r = n.props,
        i = n.data,
        o = n.children;
       i.staticClass = "".concat(t, " ").concat(i.staticClass || "").trim();
       var a = i.attrs;
       if (a) {
        i.attrs = {};
        var s = Object.keys(a).filter((function(t) {
         if ("slot" === t) return !1;
         var e = a[t];
         return t.startsWith("data-") ? (i.attrs[t] = e, !1) : e || "string" === typeof e
        }));
        s.length && (i.staticClass += " ".concat(s.join(" ")))
       }
       return r.id && (i.domProps = i.domProps || {}, i.domProps.id = r.id), e(r.tag, i, o)
      }
     })
    }
    var o = n("d9f7");
    e["a"] = i("container").extend({
     name: "v-container",
     functional: !0,
     props: {
      id: String,
      tag: {
       type: String,
       default: "div"
      },
      fluid: {
       type: Boolean,
       default: !1
      }
     },
     render: function(t, e) {
      var n, r = e.props,
       i = e.data,
       a = e.children,
       s = i.attrs;
      return s && (i.attrs = {}, n = Object.keys(s).filter((function(t) {
       if ("slot" === t) return !1;
       var e = s[t];
       return t.startsWith("data-") ? (i.attrs[t] = e, !1) : e || "string" === typeof e
      }))), r.id && (i.domProps = i.domProps || {}, i.domProps.id = r.id), t(r.tag, Object(o["a"])(i, {
       staticClass: "container",
       class: Array({
        "container--fluid": r.fluid
       }).concat(n || [])
      }), a)
     }
    })
   },
   a623: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("b727").every,
     o = n("a640"),
     a = n("ae40"),
     s = o("every"),
     u = a("every");
    r({
     target: "Array",
     proto: !0,
     forced: !s || !u
    }, {
     every: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   a630: function(t, e, n) {
    var r = n("23e7"),
     i = n("4df4"),
     o = n("1c7e"),
     a = !o((function(t) {
      Array.from(t)
     }));
    r({
     target: "Array",
     stat: !0,
     forced: a
    }, {
     from: i
    })
   },
   a640: function(t, e, n) {
    "use strict";
    var r = n("d039");
    t.exports = function(t, e) {
     var n = [][t];
     return !!n && r((function() {
      n.call(null, e || function() {
       throw 1
      }, 1)
     }))
    }
   },
   a691: function(t, e) {
    var n = Math.ceil,
     r = Math.floor;
    t.exports = function(t) {
     return isNaN(t = +t) ? 0 : (t > 0 ? r : n)(t)
    }
   },
   a75b: function(t, e, n) {
    "use strict";
    n("daaf");
    var r = n("d10f");
    e["a"] = r["a"].extend({
     name: "v-content",
     props: {
      tag: {
       type: String,
       default: "main"
      }
     },
     computed: {
      styles: function() {
       var t = this.$vuetify.application,
        e = t.bar,
        n = t.top,
        r = t.right,
        i = t.footer,
        o = t.insetFooter,
        a = t.bottom,
        s = t.left;
       return {
        paddingTop: "".concat(n + e, "px"),
        paddingRight: "".concat(r, "px"),
        paddingBottom: "".concat(i + o + a, "px"),
        paddingLeft: "".concat(s, "px")
       }
      }
     },
     render: function(t) {
      var e = {
       staticClass: "v-content",
       style: this.styles,
       ref: "content"
      };
      return t(this.tag, e, [t("div", {
       staticClass: "v-content__wrap"
      }, this.$slots.default)])
     }
    })
   },
   a79d: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("c430"),
     o = n("fea9"),
     a = n("d039"),
     s = n("d066"),
     u = n("4840"),
     c = n("cdf9"),
     l = n("6eeb"),
     h = !!o && a((function() {
      o.prototype["finally"].call({
       then: function() {}
      }, (function() {}))
     }));
    r({
     target: "Promise",
     proto: !0,
     real: !0,
     forced: h
    }, {
     finally: function(t) {
      var e = u(this, s("Promise")),
       n = "function" == typeof t;
      return this.then(n ? function(n) {
       return c(e, t()).then((function() {
        return n
       }))
      } : t, n ? function(n) {
       return c(e, t()).then((function() {
        throw n
       }))
      } : t)
     }
    }), i || "function" != typeof o || o.prototype["finally"] || l(o.prototype, "finally", s("Promise").prototype["finally"])
   },
   a9ad: function(t, e, n) {
    "use strict";
    n("d3b7"), n("ac1f"), n("25f0"), n("466d"), n("1276"), n("498a");
    var r = n("3835"),
     i = n("ade3"),
     o = n("5530"),
     a = n("2b0e"),
     s = n("d9bd");
 
    function u(t) {
     return !!t && !!t.match(/^(#|var\(--|(rgb|hsl)a?\()/)
    }
    e["a"] = a["a"].extend({
     name: "colorable",
     props: {
      color: String
     },
     methods: {
      setBackgroundColor: function(t) {
       var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
       return "string" === typeof e.style ? (Object(s["b"])("style must be an object", this), e) : "string" === typeof e.class ? (Object(s["b"])("class must be an object", this), e) : (u(t) ? e.style = Object(o["a"])({}, e.style, {
        "background-color": "".concat(t),
        "border-color": "".concat(t)
       }) : t && (e.class = Object(o["a"])({}, e.class, Object(i["a"])({}, t, !0))), e)
      },
      setTextColor: function(t) {
       var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
       if ("string" === typeof e.style) return Object(s["b"])("style must be an object", this), e;
       if ("string" === typeof e.class) return Object(s["b"])("class must be an object", this), e;
       if (u(t)) e.style = Object(o["a"])({}, e.style, {
        color: "".concat(t),
        "caret-color": "".concat(t)
       });
       else if (t) {
        var n = t.toString().trim().split(" ", 2),
         a = Object(r["a"])(n, 2),
         c = a[0],
         l = a[1];
        e.class = Object(o["a"])({}, e.class, Object(i["a"])({}, c + "--text", !0)), l && (e.class["text--" + l] = !0)
       }
       return e
      }
     }
    })
   },
   a9e3: function(t, e, n) {
    "use strict";
    var r = n("83ab"),
     i = n("da84"),
     o = n("94ca"),
     a = n("6eeb"),
     s = n("5135"),
     u = n("c6b6"),
     c = n("7156"),
     l = n("c04e"),
     h = n("d039"),
     p = n("7c73"),
     f = n("241c").f,
     d = n("06cf").f,
     v = n("9bf2").f,
     m = n("58a8").trim,
     g = "Number",
     y = i[g],
     b = y.prototype,
     x = u(p(b)) == g,
     w = function(t) {
      var e, n, r, i, o, a, s, u, c = l(t, !1);
      if ("string" == typeof c && c.length > 2)
       if (c = m(c), e = c.charCodeAt(0), 43 === e || 45 === e) {
        if (n = c.charCodeAt(2), 88 === n || 120 === n) return NaN
       } else if (48 === e) {
       switch (c.charCodeAt(1)) {
        case 66:
        case 98:
         r = 2, i = 49;
         break;
        case 79:
        case 111:
         r = 8, i = 55;
         break;
        default:
         return +c
       }
       for (o = c.slice(2), a = o.length, s = 0; s < a; s++)
        if (u = o.charCodeAt(s), u < 48 || u > i) return NaN;
       return parseInt(o, r)
      }
      return +c
     };
    if (o(g, !y(" 0o1") || !y("0b1") || y("+0x1"))) {
     for (var C, S = function(t) {
       var e = arguments.length < 1 ? 0 : t,
        n = this;
       return n instanceof S && (x ? h((function() {
        b.valueOf.call(n)
       })) : u(n) != g) ? c(new y(w(e)), n, S) : w(e)
      }, E = r ? f(y) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), k = 0; E.length > k; k++) s(y, C = E[k]) && !s(S, C) && v(S, C, d(y, C));
     S.prototype = b, b.constructor = S, a(i, g, S)
    }
   },
   ab13: function(t, e, n) {
    var r = n("b622"),
     i = r("match");
    t.exports = function(t) {
     var e = /./;
     try {
      "/./" [t](e)
     } catch (n) {
      try {
       return e[i] = !1, "/./" [t](e)
      } catch (r) {}
     }
     return !1
    }
   },
   ac1f: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("9263");
    r({
     target: "RegExp",
     proto: !0,
     forced: /./.exec !== i
    }, {
     exec: i
    })
   },
   ad6d: function(t, e, n) {
    "use strict";
    var r = n("825a");
    t.exports = function() {
     var t = r(this),
      e = "";
     return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
    }
   },
   ade3: function(t, e, n) {
    "use strict";
 
    function r(t, e, n) {
     return e in t ? Object.defineProperty(t, e, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
     }) : t[e] = n, t
    }
    n.d(e, "a", (function() {
     return r
    }))
   },
   ae40: function(t, e, n) {
    var r = n("83ab"),
     i = n("d039"),
     o = n("5135"),
     a = Object.defineProperty,
     s = {},
     u = function(t) {
      throw t
     };
    t.exports = function(t, e) {
     if (o(s, t)) return s[t];
     e || (e = {});
     var n = [][t],
      c = !!o(e, "ACCESSORS") && e.ACCESSORS,
      l = o(e, 0) ? e[0] : u,
      h = o(e, 1) ? e[1] : void 0;
     return s[t] = !!n && !i((function() {
      if (c && !r) return !0;
      var t = {
       length: -1
      };
      c ? a(t, 1, {
       enumerable: !0,
       get: u
      }) : t[1] = 1, n.call(t, l, h)
     }))
    }
   },
   ae93: function(t, e, n) {
    "use strict";
    var r, i, o, a = n("e163"),
     s = n("9112"),
     u = n("5135"),
     c = n("b622"),
     l = n("c430"),
     h = c("iterator"),
     p = !1,
     f = function() {
      return this
     };
    [].keys && (o = [].keys(), "next" in o ? (i = a(a(o)), i !== Object.prototype && (r = i)) : p = !0), void 0 == r && (r = {}), l || u(r, h) || s(r, h, f), t.exports = {
     IteratorPrototype: r,
     BUGGY_SAFARI_ITERATORS: p
    }
   },
   af03: function(t, e, n) {
    var r = n("d039");
    t.exports = function(t) {
     return r((function() {
      var e = "" [t]('"');
      return e !== e.toLowerCase() || e.split('"').length > 3
     }))
    }
   },
   af2b: function(t, e, n) {
    "use strict";
    n("c96a");
    var r = n("2b0e");
    e["a"] = r["a"].extend({
     name: "sizeable",
     props: {
      large: Boolean,
      small: Boolean,
      xLarge: Boolean,
      xSmall: Boolean
     },
     computed: {
      medium: function() {
       return Boolean(!this.xSmall && !this.small && !this.large && !this.xLarge)
      },
      sizeableClasses: function() {
       return {
        "v-size--x-small": this.xSmall,
        "v-size--small": this.small,
        "v-size--default": this.medium,
        "v-size--large": this.large,
        "v-size--x-large": this.xLarge
       }
      }
     }
    })
   },
   b041: function(t, e, n) {
    "use strict";
    var r = n("00ee"),
     i = n("f5df");
    t.exports = r ? {}.toString : function() {
     return "[object " + i(this) + "]"
    }
   },
   b0af: function(t, e, n) {
    "use strict";
    n("0481"), n("4069"), n("a9e3");
    var r = n("5530"),
     i = (n("615b"), n("10d2")),
     o = n("297c"),
     a = n("1c87"),
     s = n("58df");
    e["a"] = Object(s["a"])(o["a"], a["a"], i["a"]).extend({
     name: "v-card",
     props: {
      flat: Boolean,
      hover: Boolean,
      img: String,
      link: Boolean,
      loaderHeight: {
       type: [Number, String],
       default: 4
      },
      outlined: Boolean,
      raised: Boolean,
      shaped: Boolean
     },
     computed: {
      classes: function() {
       return Object(r["a"])({
        "v-card": !0
       }, a["a"].options.computed.classes.call(this), {
        "v-card--flat": this.flat,
        "v-card--hover": this.hover,
        "v-card--link": this.isClickable,
        "v-card--loading": this.loading,
        "v-card--disabled": this.disabled,
        "v-card--outlined": this.outlined,
        "v-card--raised": this.raised,
        "v-card--shaped": this.shaped
       }, i["a"].options.computed.classes.call(this))
      },
      styles: function() {
       var t = Object(r["a"])({}, i["a"].options.computed.styles.call(this));
       return this.img && (t.background = 'url("'.concat(this.img, '") center center / cover no-repeat')), t
      }
     },
     methods: {
      genProgress: function() {
       var t = o["a"].options.methods.genProgress.call(this);
       return t ? this.$createElement("div", {
        staticClass: "v-card__progress"
       }, [t]) : null
      }
     },
     render: function(t) {
      var e = this.generateRouteLink(),
       n = e.tag,
       r = e.data;
      return r.style = this.styles, this.isClickable && (r.attrs = r.attrs || {}, r.attrs.tabindex = 0), t(n, this.setBackgroundColor(this.color, r), [this.genProgress(), this.$slots.default])
     }
    })
   },
   b0c0: function(t, e, n) {
    var r = n("83ab"),
     i = n("9bf2").f,
     o = Function.prototype,
     a = o.toString,
     s = /^\s*function ([^ (]*)/,
     u = "name";
    !r || u in o || i(o, u, {
     configurable: !0,
     get: function() {
      try {
       return a.call(this).match(s)[1]
      } catch (t) {
       return ""
      }
     }
    })
   },
   b3cb: function(t, e, n) {
    ! function(e, n) {
     t.exports = n()
    }(window, (function() {
     return function(t) {
      var e = {};
 
      function n(r) {
       if (e[r]) return e[r].exports;
       var i = e[r] = {
        i: r,
        l: !1,
        exports: {}
       };
       return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
      }
      return n.m = t, n.c = e, n.d = function(t, e, r) {
       n.o(t, e) || Object.defineProperty(t, e, {
        enumerable: !0,
        get: r
       })
      }, n.r = function(t) {
       "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
       }), Object.defineProperty(t, "__esModule", {
        value: !0
       })
      }, n.t = function(t, e) {
       if (1 & e && (t = n(t)), 8 & e) return t;
       if (4 & e && "object" == typeof t && t && t.__esModule) return t;
       var r = Object.create(null);
       if (n.r(r), Object.defineProperty(r, "default", {
         enumerable: !0,
         value: t
        }), 2 & e && "string" != typeof t)
        for (var i in t) n.d(r, i, function(e) {
         return t[e]
        }.bind(null, i));
       return r
      }, n.n = function(t) {
       var e = t && t.__esModule ? function() {
        return t.default
       } : function() {
        return t
       };
       return n.d(e, "a", e), e
      }, n.o = function(t, e) {
       return Object.prototype.hasOwnProperty.call(t, e)
      }, n.p = "/dist/", n(n.s = 0)
     }([function(t, e, n) {
      "use strict";
      n.r(e);
      var r = function(t, e, n, r, i, o, a, s) {
       var u, c = "function" == typeof t ? t.options : t;
       if (e && (c.render = e, c.staticRenderFns = n, c._compiled = !0), r && (c.functional = !0), o && (c._scopeId = "data-v-" + o), a ? (u = function(t) {
         (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), i && i.call(this, t), t && t._registeredComponents && t._registeredComponents.add(a)
        }, c._ssrRegister = u) : i && (u = s ? function() {
         i.call(this, this.$root.$options.shadowRoot)
        } : i), u)
        if (c.functional) {
         c._injectStyles = u;
         var l = c.render;
         c.render = function(t, e) {
          return u.call(e), l(t, e)
         }
        } else {
         var h = c.beforeCreate;
         c.beforeCreate = h ? [].concat(h, u) : [u]
        } return {
        exports: t,
        options: c
       }
      }({
       name: "VueWebCam",
       props: {
        width: {
         type: [Number, String],
         default: "100%"
        },
        height: {
         type: [Number, String],
         default: 500
        },
        autoplay: {
         type: Boolean,
         default: !0
        },
        screenshotFormat: {
         type: String,
         default: "image/jpeg"
        },
        selectFirstDevice: {
         type: Boolean,
         default: !1
        },
        deviceId: {
         type: String,
         default: null
        },
        playsinline: {
         type: Boolean,
         default: !0
        },
        resolution: {
         type: Object,
         default: null,
         validator: function(t) {
          return t.height && t.width
         }
        }
       },
       data: function() {
        return {
         source: null,
         canvas: null,
         camerasListEmitted: !1,
         cameras: []
        }
       },
       watch: {
        deviceId: function(t) {
         this.changeCamera(t)
        }
       },
       mounted: function() {
        this.setupMedia()
       },
       beforeDestroy: function() {
        this.stop()
       },
       methods: {
        legacyGetUserMediaSupport: function() {
         return function(t) {
          var e = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;
          return e ? new Promise((function(n, r) {
           e.call(navigator, t, n, r)
          })) : Promise.reject(new Error("getUserMedia is not implemented in this browser"))
         }
        },
        setupMedia: function() {
         void 0 === navigator.mediaDevices && (navigator.mediaDevices = {}), void 0 === navigator.mediaDevices.getUserMedia && (navigator.mediaDevices.getUserMedia = this.legacyGetUserMediaSupport()), this.testMediaAccess()
        },
        loadCameras: function() {
         var t = this;
         navigator.mediaDevices.enumerateDevices().then((function(e) {
          for (var n = 0; n !== e.length; ++n) {
           var r = e[n];
           "videoinput" === r.kind && t.cameras.push(r)
          }
         })).then((function() {
          t.camerasListEmitted || (t.selectFirstDevice && t.cameras.length > 0 && (t.deviceId = t.cameras[0].deviceId), t.$emit("cameras", t.cameras), t.camerasListEmitted = !0)
         })).catch((function(e) {
          return t.$emit("notsupported", e)
         }))
        },
        changeCamera: function(t) {
         this.stop(), this.$emit("camera-change", t), this.loadCamera(t)
        },
        loadSrcStream: function(t) {
         var e = this;
         "srcObject" in this.$refs.video ? this.$refs.video.srcObject = t : this.source = window.HTMLMediaElement.srcObject(t), this.$refs.video.onloadedmetadata = function() {
          e.$emit("video-live", t)
         }, this.$emit("started", t)
        },
        stopStreamedVideo: function(t) {
         var e = this,
          n = t.srcObject;
         n.getTracks().forEach((function(t) {
          t.stop(), e.$emit("stopped", n), e.$refs.video.srcObject = null, e.source = null
         }))
        },
        stop: function() {
         null !== this.$refs.video && this.$refs.video.srcObject && this.stopStreamedVideo(this.$refs.video)
        },
        start: function() {
         this.deviceId && this.loadCamera(this.deviceId)
        },
        pause: function() {
         null !== this.$refs.video && this.$refs.video.srcObject && this.$refs.video.pause()
        },
        resume: function() {
         null !== this.$refs.video && this.$refs.video.srcObject && this.$refs.video.play()
        },
        testMediaAccess: function() {
         var t = this,
          e = {
           video: !0
          };
         this.resolution && (e.video = {}, e.video.height = this.resolution.height, e.video.width = this.resolution.width), navigator.mediaDevices.getUserMedia(e).then((function(e) {
          e.getTracks().forEach((function(t) {
           t.stop()
          })), t.loadCameras()
         })).catch((function(e) {
          return t.$emit("error", e)
         }))
        },
        loadCamera: function(t) {
         var e = this,
          n = {
           video: {
            deviceId: {
             exact: t
            }
           }
          };
         this.resolution && (n.video.height = this.resolution.height, n.video.width = this.resolution.width), navigator.mediaDevices.getUserMedia(n).then((function(t) {
          return e.loadSrcStream(t)
         })).catch((function(t) {
          return e.$emit("error", t)
         }))
        },
        capture: function() {
         return this.getCanvas().toDataURL(this.screenshotFormat)
        },
        getCanvas: function() {
         var t = this.$refs.video;
         if (!this.ctx) {
          var e = document.createElement("canvas");
          e.height = t.videoHeight, e.width = t.videoWidth, this.canvas = e, this.ctx = e.getContext("2d")
         }
         var n = this.ctx,
          r = this.canvas;
         return n.drawImage(t, 0, 0, r.width, r.height), r
        }
       }
      }, (function() {
       var t = this.$createElement;
       return (this._self._c || t)("video", {
        ref: "video",
        attrs: {
         width: this.width,
         height: this.height,
         src: this.source,
         autoplay: this.autoplay,
         playsinline: this.playsinline
        }
       })
      }), [], !1, null, null, null).exports;
 
      function i(t) {
       t.component("vue-web-cam", r)
      }
      n.d(e, "version", (function() {
       return o
      })), n.d(e, "WebCam", (function() {
       return r
      })), "undefined" != typeof window && window.Vue && window.Vue.use(i), e.default = i;
      var o = "__VERSION__"
     }])
    }))
   },
   b50d: function(t, e, n) {
    "use strict";
    var r = n("c532"),
     i = n("467f"),
     o = n("30b5"),
     a = n("83b9"),
     s = n("c345"),
     u = n("3934"),
     c = n("2d83");
    t.exports = function(t) {
     return new Promise((function(e, l) {
      var h = t.data,
       p = t.headers;
      r.isFormData(h) && delete p["Content-Type"];
      var f = new XMLHttpRequest;
      if (t.auth) {
       var d = t.auth.username || "",
        v = t.auth.password || "";
       p.Authorization = "Basic " + btoa(d + ":" + v)
      }
      var m = a(t.baseURL, t.url);
      if (f.open(t.method.toUpperCase(), o(m, t.params, t.paramsSerializer), !0), f.timeout = t.timeout, f.onreadystatechange = function() {
        if (f && 4 === f.readyState && (0 !== f.status || f.responseURL && 0 === f.responseURL.indexOf("file:"))) {
         var n = "getAllResponseHeaders" in f ? s(f.getAllResponseHeaders()) : null,
          r = t.responseType && "text" !== t.responseType ? f.response : f.responseText,
          o = {
           data: r,
           status: f.status,
           statusText: f.statusText,
           headers: n,
           config: t,
           request: f
          };
         i(e, l, o), f = null
        }
       }, f.onabort = function() {
        f && (l(c("Request aborted", t, "ECONNABORTED", f)), f = null)
       }, f.onerror = function() {
        l(c("Network Error", t, null, f)), f = null
       }, f.ontimeout = function() {
        var e = "timeout of " + t.timeout + "ms exceeded";
        t.timeoutErrorMessage && (e = t.timeoutErrorMessage), l(c(e, t, "ECONNABORTED", f)), f = null
       }, r.isStandardBrowserEnv()) {
       var g = n("7aac"),
        y = (t.withCredentials || u(m)) && t.xsrfCookieName ? g.read(t.xsrfCookieName) : void 0;
       y && (p[t.xsrfHeaderName] = y)
      }
      if ("setRequestHeader" in f && r.forEach(p, (function(t, e) {
        "undefined" === typeof h && "content-type" === e.toLowerCase() ? delete p[e] : f.setRequestHeader(e, t)
       })), r.isUndefined(t.withCredentials) || (f.withCredentials = !!t.withCredentials), t.responseType) try {
       f.responseType = t.responseType
      } catch (b) {
       if ("json" !== t.responseType) throw b
      }
      "function" === typeof t.onDownloadProgress && f.addEventListener("progress", t.onDownloadProgress), "function" === typeof t.onUploadProgress && f.upload && f.upload.addEventListener("progress", t.onUploadProgress), t.cancelToken && t.cancelToken.promise.then((function(t) {
       f && (f.abort(), l(t), f = null)
      })), void 0 === h && (h = null), f.send(h)
     }))
    }
   },
   b575: function(t, e, n) {
    var r, i, o, a, s, u, c, l, h = n("da84"),
     p = n("06cf").f,
     f = n("c6b6"),
     d = n("2cf4").set,
     v = n("1cdc"),
     m = h.MutationObserver || h.WebKitMutationObserver,
     g = h.process,
     y = h.Promise,
     b = "process" == f(g),
     x = p(h, "queueMicrotask"),
     w = x && x.value;
    w || (r = function() {
     var t, e;
     b && (t = g.domain) && t.exit();
     while (i) {
      e = i.fn, i = i.next;
      try {
       e()
      } catch (n) {
       throw i ? a() : o = void 0, n
      }
     }
     o = void 0, t && t.enter()
    }, b ? a = function() {
     g.nextTick(r)
    } : m && !v ? (s = !0, u = document.createTextNode(""), new m(r).observe(u, {
     characterData: !0
    }), a = function() {
     u.data = s = !s
    }) : y && y.resolve ? (c = y.resolve(void 0), l = c.then, a = function() {
     l.call(c, r)
    }) : a = function() {
     d.call(h, r)
    }), t.exports = w || function(t) {
     var e = {
      fn: t,
      next: void 0
     };
     o && (o.next = e), i || (i = e, a()), o = e
    }
   },
   b605: function(t, e, n) {
    "use strict";
    (function(t) {
     n.d(e, "a", (function() {
      return Wt
     })), n.d(e, "b", (function() {
      return Vt
     }));
     var r, i, o = n("45ef"),
      a = function() {
       return (a = Object.assign || function(t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
         for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
        return t
       }).apply(this, arguments)
      };
     /**
      * @license
      * Copyright 2020 Google LLC. All Rights Reserved.
      * Licensed under the Apache License, Version 2.0 (the "License");
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      * http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      * =============================================================================
      */
     function s(t, e, n, r) {
      return new(n || (n = Promise))((function(i, o) {
       function a(t) {
        try {
         u(r.next(t))
        } catch (t) {
         o(t)
        }
       }
 
       function s(t) {
        try {
         u(r.throw(t))
        } catch (t) {
         o(t)
        }
       }
 
       function u(t) {
        t.done ? i(t.value) : new n((function(e) {
         e(t.value)
        })).then(a, s)
       }
       u((r = r.apply(t, e || [])).next())
      }))
     }
 
     function u(t, e) {
      var n, r, i, o, a = {
       label: 0,
       sent: function() {
        if (1 & i[0]) throw i[1];
        return i[1]
       },
       trys: [],
       ops: []
      };
      return o = {
       next: s(0),
       throw: s(1),
       return: s(2)
      }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
       return this
      }), o;
 
      function s(o) {
       return function(s) {
        return function(o) {
         if (n) throw new TypeError("Generator is already executing.");
         for (; a;) try {
          if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
          switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
           case 0:
           case 1:
            i = o;
            break;
           case 4:
            return a.label++, {
             value: o[1],
             done: !1
            };
           case 5:
            a.label++, r = o[1], o = [0];
            continue;
           case 7:
            o = a.ops.pop(), a.trys.pop();
            continue;
           default:
            if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
             a = 0;
             continue
            }
            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
             a.label = o[1];
             break
            }
            if (6 === o[0] && a.label < i[1]) {
             a.label = i[1], i = o;
             break
            }
            if (i && a.label < i[2]) {
             a.label = i[2], a.ops.push(o);
             break
            }
            i[2] && a.ops.pop(), a.trys.pop();
            continue
          }
          o = e.call(t, a)
         } catch (t) {
          o = [6, t], r = 0
         } finally {
          n = i = 0
         }
         if (5 & o[0]) throw o[1];
         return {
          value: o[0] ? o[1] : void 0,
          done: !0
         }
        }([o, s])
       }
      }
     }! function(t) {
      t[t.DT_INVALID = 0] = "DT_INVALID", t[t.DT_FLOAT = 1] = "DT_FLOAT", t[t.DT_DOUBLE = 2] = "DT_DOUBLE", t[t.DT_INT32 = 3] = "DT_INT32", t[t.DT_UINT8 = 4] = "DT_UINT8", t[t.DT_INT16 = 5] = "DT_INT16", t[t.DT_INT8 = 6] = "DT_INT8", t[t.DT_STRING = 7] = "DT_STRING", t[t.DT_COMPLEX64 = 8] = "DT_COMPLEX64", t[t.DT_INT64 = 9] = "DT_INT64", t[t.DT_BOOL = 10] = "DT_BOOL", t[t.DT_QINT8 = 11] = "DT_QINT8", t[t.DT_QUINT8 = 12] = "DT_QUINT8", t[t.DT_QINT32 = 13] = "DT_QINT32", t[t.DT_BFLOAT16 = 14] = "DT_BFLOAT16", t[t.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", t[t.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", t[t.DT_INT32_REF = 103] = "DT_INT32_REF", t[t.DT_UINT8_REF = 104] = "DT_UINT8_REF", t[t.DT_INT16_REF = 105] = "DT_INT16_REF", t[t.DT_INT8_REF = 106] = "DT_INT8_REF", t[t.DT_STRING_REF = 107] = "DT_STRING_REF", t[t.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", t[t.DT_INT64_REF = 109] = "DT_INT64_REF", t[t.DT_BOOL_REF = 110] = "DT_BOOL_REF", t[t.DT_QINT8_REF = 111] = "DT_QINT8_REF", t[t.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", t[t.DT_QINT32_REF = 113] = "DT_QINT32_REF", t[t.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF"
     }(r || (r = {})),
     function(t) {
      ! function(t) {
       t[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2"
      }(t.CheckpointFormatVersion || (t.CheckpointFormatVersion = {}))
     }(i || (i = {}));
     var c = {};
 
     function l(t) {
      return c[t]
     }
 
     function h(t, e, n, r) {
      var i = e.inputParams[t];
      if (i && void 0 !== i.inputIndexStart) {
       var o = i.inputIndexStart,
        a = 0 === i.inputIndexEnd ? void 0 : void 0 === i.inputIndexEnd ? o + 1 : i.inputIndexEnd;
       if ("tensor" === i.type) return p(e.inputNames[i.inputIndexStart], n, r);
       if ("tensors" === i.type) return e.inputNames.slice(o, a).map((function(t) {
        return p(t, n, r)
       }));
       var s = Array.prototype.slice.call(p(e.inputNames.slice(o)[0], n, r).dataSync());
       return "number" === i.type ? s[0] : s
      }
      var u = e.attrParams[t];
      return u && u.value
     }
 
     function p(t, e, n) {
      var r = m(t),
       i = r[0],
       o = r[1],
       a = n.currentContextIds.find((function(t) {
        return !!e[v(i, t)]
       }));
      return void 0 !== a ? e[v(i, a)][o] : void 0
     }
 
     function f(t, e, n) {
      return e[v(t, n.currentContextId)]
     }
 
     function d(t, e) {
      var n = m(t),
       r = n[0],
       i = n[1];
      return [v(r, e && e.currentContextId), i]
     }
 
     function v(t, e) {
      return e ? t + "-" + e : t
     }
 
     function m(t) {
      var e = t.lastIndexOf(":");
      return -1 === e ? [t, 0] : [t.substring(0, e), Number(t.substring(e + 1))]
     }
 
     function g(t, e) {
      for (var n = [], r = 0; r < t.length; r += e) n.push(t.slice(r, r + e));
      return n
     }
     var y = [{
       tfOpName: "Add",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "AddV2",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "AddN",
       category: "arithmetic",
       inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
       }]
      }, {
       tfOpName: "BiasAdd",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Sub",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "RealDiv",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Div",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "DivNoNan",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "FloorDiv",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Mul",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Maximum",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }]
      }, {
       tfOpName: "Minimum",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }]
      }, {
       tfOpName: "Pow",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "SquaredDifference",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Mod",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "FloorMod",
       category: "arithmetic",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }],
      b = Object.freeze({
       json: y
      }),
      x = [{
       tfOpName: "Abs",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Acos",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Asin",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Atan",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Atan2",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "y",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Ceil",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "ClipByValue",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "clip_value_min",
        name: "clipValueMin",
        type: "number"
       }, {
        tfName: "clip_value_max",
        name: "clipValueMax",
        type: "number"
       }]
      }, {
       tfOpName: "Complex",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "real",
        type: "tensor"
       }, {
        start: 1,
        name: "imag",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "ComplexAbs",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Cos",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Cosh",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Elu",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Exp",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Floor",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Log",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Imag",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Neg",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Real",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Prelu",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "alpha",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Relu",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Relu6",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "clipValueMin",
        name: "clipValueMin",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "clipValueMax",
        name: "clipValueMax",
        type: "number",
        defaultValue: 6
       }]
      }, {
       tfOpName: "Selu",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Sigmoid",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Sin",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Sinh",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Sqrt",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Rsqrt",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Square",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Tan",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Tanh",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Sign",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Round",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Expm1",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Log1p",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Reciprocal",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Softplus",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Asinh",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Acosh",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Atanh",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Erf",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Prod",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axes",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        notSupported: !0
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "LeakyRelu",
       category: "basic_math",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: .2
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }],
      w = Object.freeze({
       json: x
      }),
      C = [{
       tfOpName: "LoopCond",
       category: "control",
       inputs: [{
        start: 0,
        name: "pred",
        type: "tensor"
       }]
      }, {
       tfOpName: "Switch",
       category: "control",
       inputs: [{
        start: 0,
        name: "data",
        type: "tensor"
       }, {
        start: 1,
        name: "pred",
        type: "tensor"
       }]
      }, {
       tfOpName: "Merge",
       category: "control",
       inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
       }]
      }, {
       tfOpName: "Enter",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "frame_name",
        name: "frameName",
        type: "string"
       }, {
        tfName: "is_constant",
        name: "isConstant",
        type: "bool"
       }]
      }, {
       tfOpName: "Exit",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "NextIteration",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "TensorArrayV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "size",
        type: "number"
       }],
       attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }, {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
       }, {
        tfName: "dynamic_size",
        name: "dynamicSize",
        type: "bool"
       }, {
        tfName: "clear_after_read",
        name: "clearAfterRead",
        type: "bool"
       }, {
        tfName: "identical_element_shapes",
        name: "identicalElementShapes",
        type: "bool"
       }, {
        tfName: "tensor_array_name",
        name: "name",
        type: "string"
       }]
      }, {
       tfOpName: "TensorArrayWriteV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "index",
        type: "number"
       }, {
        start: 2,
        name: "tensor",
        type: "tensor"
       }, {
        start: 3,
        name: "flowIn",
        type: "number"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "TensorArrayReadV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "index",
        type: "number"
       }, {
        start: 2,
        name: "flowIn",
        type: "number"
       }],
       attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "TensorArrayGatherV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "indices",
        type: "number[]"
       }, {
        start: 2,
        name: "flowIn",
        type: "number"
       }],
       attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }, {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
       }]
      }, {
       tfOpName: "TensorArrayScatterV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "indices",
        type: "number[]"
       }, {
        start: 2,
        name: "tensor",
        type: "tensor"
       }, {
        start: 3,
        name: "flowIn",
        type: "number"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "TensorArrayConcatV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "flowIn",
        type: "number"
       }],
       attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }, {
        tfName: "element_shape_except0",
        name: "elementShapeExcept0",
        type: "shape",
        notSupported: !0
       }]
      }, {
       tfOpName: "TensorArraySplitV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "tensor",
        type: "tensor"
       }, {
        start: 2,
        name: "lengths",
        type: "number[]"
       }, {
        start: 3,
        name: "flowIn",
        type: "number"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "TensorArraySizeV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }, {
        start: 1,
        name: "flowIn",
        type: "number"
       }]
      }, {
       tfOpName: "TensorArrayCloseV3",
       category: "control",
       inputs: [{
        start: 0,
        name: "tensorArrayId",
        type: "number"
       }]
      }],
      S = Object.freeze({
       json: C
      }),
      E = [{
       tfOpName: "AvgPool",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "MaxPool",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "AvgPool3D",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "MaxPool3D",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Conv1D",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }],
       attrs: [{
        tfName: "stride",
        name: "stride",
        type: "number"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NWC"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "dilation",
        name: "dilation",
        type: "number",
        defaultValue: 1
       }]
      }, {
       tfOpName: "Conv2D",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "useCudnnOnGpu",
        name: "useCudnnOnGpu",
        type: "bool"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
       }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
       }]
      }, {
       tfOpName: "_FusedConv2D",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
       }],
       attrs: [{
        tfName: "num_args",
        name: "numArgs",
        type: "number"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
       }, {
        tfName: "use_cudnn_on_gpu",
        name: "useCudnnOnGpu",
        type: "bool",
        defaultValue: !0
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
       }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [1, 1, 1, 1]
       }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
       }, {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
       }]
      }, {
       tfOpName: "Conv2DBackpropInput",
       category: "convolution",
       inputs: [{
        start: 2,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }, {
        start: 0,
        name: "outputShape",
        type: "number[]"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }]
      }, {
       tfOpName: "DepthwiseConv2d",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
       }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
       }]
      }, {
       tfOpName: "DepthwiseConv2dNative",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "input",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
       }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
       }]
      }, {
       tfOpName: "FusedDepthwiseConv2dNative",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
       }],
       attrs: [{
        tfName: "num_args",
        name: "numArgs",
        type: "number"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
       }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [1, 1, 1, 1]
       }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
       }]
      }, {
       tfOpName: "Conv3D",
       category: "convolution",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "filter",
        type: "tensor"
       }],
       attrs: [{
        tfName: "strides",
        name: "strides",
        type: "number[]"
       }, {
        tfName: "padding",
        name: "pad",
        type: "string"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
       }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
       }]
      }],
      k = Object.freeze({
       json: E
      }),
      I = [{
       tfOpName: "Fill",
       category: "creation",
       inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
       }, {
        start: 1,
        name: "value",
        type: "number"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "LinSpace",
       category: "creation",
       inputs: [{
        start: 0,
        name: "start",
        type: "number"
       }, {
        start: 1,
        name: "stop",
        type: "number"
       }, {
        start: 2,
        name: "num",
        type: "number"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "OneHot",
       category: "creation",
       inputs: [{
        start: 0,
        name: "indices",
        type: "tensor"
       }, {
        start: 1,
        name: "depth",
        type: "number"
       }, {
        start: 2,
        name: "onValue",
        type: "number",
        defaultValue: 1
       }, {
        start: 3,
        name: "offValue",
        type: "number",
        defaultValue: 0
       }],
       attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        notSupported: !0
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Ones",
       category: "creation",
       inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "OnesLike",
       category: "creation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "RandomUniform",
       category: "creation",
       inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
       }],
       attrs: [{
        tfName: "minval",
        name: "minval",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "maxval",
        name: "maxval",
        type: "number",
        defaultValue: 1
       }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }, {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
       }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
       }]
      }, {
       tfOpName: "Range",
       category: "creation",
       inputs: [{
        start: 0,
        name: "start",
        type: "number"
       }, {
        start: 1,
        name: "stop",
        type: "number"
       }, {
        start: 2,
        name: "step",
        type: "number",
        defaultValue: 0
       }],
       attrs: [{
        tfName: "Tidx",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "TruncatedNormal",
       category: "creation",
       inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
       }],
       attrs: [{
        tfName: "means",
        name: "mean",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "stddev",
        name: "stdDev",
        type: "number",
        defaultValue: 1
       }, {
        tfName: "seed",
        name: "seed",
        type: "number"
       }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
       }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
       }]
      }, {
       tfOpName: "Zeros",
       category: "creation",
       inputs: [{
        start: 0,
        name: "shape",
        type: "number[]"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "ZerosLike",
       category: "creation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "Multinomial",
       category: "creation",
       inputs: [{
        start: 0,
        name: "logits",
        type: "tensor"
       }, {
        start: 1,
        name: "numSamples",
        type: "number"
       }],
       attrs: [{
        tfName: "seed",
        name: "seed",
        type: "number"
       }, {
        tfName: "seed2",
        name: "seed2",
        type: "number"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
       }, {
        tfName: "output_dtype",
        name: "output_dtype",
        type: "dtype"
       }]
      }],
      O = Object.freeze({
       json: I
      }),
      A = [{
       tfOpName: "NonMaxSuppressionV2",
       category: "dynamic",
       inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
       }, {
        start: 1,
        name: "scores",
        type: "tensor"
       }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
       }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
       }]
      }, {
       tfOpName: "NonMaxSuppressionV3",
       category: "dynamic",
       inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
       }, {
        start: 1,
        name: "scores",
        type: "tensor"
       }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
       }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
       }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
       }]
      }, {
       tfOpName: "NonMaxSuppressionV5",
       category: "dynamic",
       inputs: [{
        start: 0,
        name: "boxes",
        type: "tensor"
       }, {
        start: 1,
        name: "scores",
        type: "tensor"
       }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
       }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
       }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
       }, {
        start: 5,
        name: "softNmsSigma",
        type: "number"
       }]
      }, {
       tfOpName: "Where",
       category: "dynamic",
       inputs: [{
        start: 0,
        name: "condition",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "ListDiff",
       category: "dynamic",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "y",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }],
      N = Object.freeze({
       json: A
      }),
      R = [{
       tfOpName: "TopKV2",
       category: "evaluation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "k",
        type: "number"
       }],
       attrs: [{
        tfName: "sorted",
        name: "sorted",
        type: "bool"
       }]
      }],
      T = Object.freeze({
       json: R
      }),
      _ = [{
       tfOpName: "PlaceholderWithDefault",
       category: "graph",
       inputs: [{
        start: 0,
        name: "default",
        type: "tensor"
       }],
       attrs: [{
        tfName: "shape",
        name: "shape",
        type: "shape"
       }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "Placeholder",
       category: "graph",
       attrs: [{
        tfName: "shape",
        name: "shape",
        type: "shape"
       }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "Const",
       category: "graph"
      }, {
       tfOpName: "Identity",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "IdentityN",
       category: "graph",
       inputs: [{
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
       }]
      }, {
       tfOpName: "Snapshot",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "Rank",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "Size",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "Shape",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "ShapeN",
       category: "graph",
       inputs: [{
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
       }]
      }, {
       tfOpName: "Print",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "data",
        type: "tensors"
       }],
       attrs: [{
        tfName: "message",
        name: "message",
        type: "string"
       }, {
        tfName: "first_n",
        name: "firstN",
        type: "number",
        notSupported: !0
       }, {
        tfName: "summarize",
        name: "summarize",
        type: "number",
        defaultValue: 3
       }]
      }, {
       tfOpName: "NoOp",
       category: "graph",
       inputs: []
      }, {
       tfOpName: "StopGradient",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "FakeQuantWithMinMaxVars",
       category: "graph",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "min",
        name: "min",
        type: "number"
       }, {
        tfName: "max",
        name: "max",
        type: "number"
       }]
      }],
      D = Object.freeze({
       json: _
      }),
      F = [{
       tfOpName: "ResizeBilinear",
       category: "image",
       inputs: [{
        start: 0,
        name: "images",
        type: "tensor"
       }, {
        start: 1,
        name: "size",
        type: "number[]"
       }],
       attrs: [{
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "ResizeNearestNeighbor",
       category: "image",
       inputs: [{
        start: 0,
        name: "images",
        type: "tensor"
       }, {
        start: 1,
        name: "size",
        type: "number[]"
       }],
       attrs: [{
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "CropAndResize",
       category: "image",
       inputs: [{
        start: 0,
        name: "image",
        type: "tensor"
       }, {
        start: 1,
        name: "boxes",
        type: "tensor"
       }, {
        start: 2,
        name: "boxInd",
        type: "tensor"
       }, {
        start: 3,
        name: "cropSize",
        type: "number[]"
       }],
       attrs: [{
        tfName: "method",
        name: "method",
        type: "string"
       }, {
        tfName: "extrapolation_value",
        name: "extrapolationValue",
        type: "number"
       }]
      }],
      M = Object.freeze({
       json: F
      }),
      L = [{
       tfOpName: "Equal",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "NotEqual",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Greater",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "GreaterEqual",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Less",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "LessEqual",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "LogicalAnd",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "LogicalNot",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "LogicalOr",
       category: "logical",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Select",
       category: "logical",
       inputs: [{
        start: 0,
        name: "condition",
        type: "tensor"
       }, {
        start: 1,
        name: "a",
        type: "tensor"
       }, {
        start: 2,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }],
      B = Object.freeze({
       json: L
      }),
      P = [{
       tfOpName: "_FusedMatMul",
       category: "matrices",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
       }],
       attrs: [{
        tfName: "num_args",
        name: "numArgs",
        type: "number"
       }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
       }, {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
       }, {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "MatMul",
       category: "matrices",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "BatchMatMul",
       category: "matrices",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "BatchMatMulV2",
       category: "matrices",
       inputs: [{
        start: 0,
        name: "a",
        type: "tensor"
       }, {
        start: 1,
        name: "b",
        type: "tensor"
       }],
       attrs: [{
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
       }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }, {
       tfOpName: "Transpose",
       category: "matrices",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "perm",
        type: "number[]"
       }],
       attrs: [{
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
       }]
      }],
      z = Object.freeze({
       json: P
      }),
      j = [{
       tfOpName: "FusedBatchNorm",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "scale",
        type: "tensor"
       }, {
        start: 2,
        name: "offset",
        type: "tensor"
       }, {
        start: 3,
        name: "mean",
        type: "tensor"
       }, {
        start: 4,
        name: "variance",
        type: "tensor"
       }],
       attrs: [{
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: .001
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }]
      }, {
       tfOpName: "FusedBatchNormV2",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "scale",
        type: "tensor"
       }, {
        start: 2,
        name: "offset",
        type: "tensor"
       }, {
        start: 3,
        name: "mean",
        type: "tensor"
       }, {
        start: 4,
        name: "variance",
        type: "tensor"
       }],
       attrs: [{
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: .001
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }]
      }, {
       tfOpName: "FusedBatchNormV3",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "scale",
        type: "tensor"
       }, {
        start: 2,
        name: "offset",
        type: "tensor"
       }, {
        start: 3,
        name: "mean",
        type: "tensor"
       }, {
        start: 4,
        name: "variance",
        type: "tensor"
       }],
       attrs: [{
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: .001
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
       }]
      }, {
       tfOpName: "LRN",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "depth_radius",
        name: "radius",
        type: "number",
        defaultValue: 5
       }, {
        tfName: "bias",
        name: "bias",
        type: "number",
        defaultValue: 1
       }, {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 1
       }, {
        tfName: "beta",
        name: "beta",
        type: "number",
        defaultValue: .5
       }]
      }, {
       tfOpName: "Softmax",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "LogSoftmax",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "SparseToDense",
       category: "normalization",
       inputs: [{
        start: 0,
        name: "sparseIndices",
        type: "tensor"
       }, {
        start: 1,
        name: "outputShape",
        type: "number[]"
       }, {
        start: 2,
        name: "sparseValues",
        type: "tensor"
       }, {
        start: 3,
        name: "defaultValue",
        type: "tensor"
       }],
       attrs: [{
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: !0,
        notSupported: !0
       }]
      }],
      W = Object.freeze({
       json: j
      }),
      V = [{
       tfOpName: "Max",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }, {
       tfOpName: "Mean",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }, {
       tfOpName: "Min",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }, {
       tfOpName: "Sum",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }, {
       tfOpName: "All",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }, {
       tfOpName: "Any",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }, {
       tfOpName: "ArgMax",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number"
       }]
      }, {
       tfOpName: "ArgMin",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number"
       }]
      }, {
       tfOpName: "Prod",
       category: "reduction",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }],
       attrs: [{
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
       }]
      }],
      U = Object.freeze({
       json: V
      }),
      H = [{
       tfOpName: "ConcatV2",
       category: "slice_join",
       inputs: [{
        start: 0,
        end: -1,
        name: "tensors",
        type: "tensors"
       }, {
        start: -1,
        name: "axis",
        type: "number"
       }],
       attrs: [{
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
       }]
      }, {
       tfOpName: "Concat",
       category: "slice_join",
       inputs: [{
        start: 1,
        end: 0,
        name: "tensors",
        type: "tensors"
       }, {
        start: 0,
        name: "axis",
        type: "number"
       }],
       attrs: [{
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
       }]
      }, {
       tfOpName: "GatherV2",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "indices",
        type: "tensor"
       }, {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
       }]
      }, {
       tfOpName: "Gather",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "indices",
        type: "tensor"
       }],
       attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        notSupported: !0
       }]
      }, {
       tfOpName: "Reverse",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "dims",
        type: "bool",
        notSupported: !0
       }]
      }, {
       tfOpName: "ReverseV2",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number[]"
       }]
      }, {
       tfOpName: "Slice",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "begin",
        type: "number[]"
       }, {
        start: 2,
        name: "size",
        type: "number[]"
       }]
      }, {
       tfOpName: "StridedSlice",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "begin",
        type: "number[]"
       }, {
        start: 2,
        name: "end",
        type: "number[]"
       }, {
        start: 3,
        name: "strides",
        type: "number[]"
       }],
       attrs: [{
        tfName: "begin_mask",
        name: "beginMask",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "end_mask",
        name: "endMask",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "new_axis_mask",
        name: "newAxisMask",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "ellipsis_mask",
        name: "ellipsisMask",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "shrink_axis_mask",
        name: "shrinkAxisMask",
        type: "number",
        defaultValue: 0
       }]
      }, {
       tfOpName: "Pack",
       category: "slice_join",
       inputs: [{
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
       }],
       attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
       }]
      }, {
       tfOpName: "Unpack",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "tensor",
        type: "tensor"
       }],
       attrs: [{
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
       }, {
        tfName: "num",
        name: "num",
        type: "number",
        defaultValue: 0,
        notSupported: !0
       }]
      }, {
       tfOpName: "Tile",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "reps",
        type: "number[]"
       }]
      }, {
       tfOpName: "Split",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "axis",
        type: "number",
        defaultValue: 0
       }, {
        start: 1,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "num_split",
        name: "numOrSizeSplits",
        type: "number",
        defaultValue: 1
       }]
      }, {
       tfOpName: "SplitV",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "numOrSizeSplits",
        type: "number[]"
       }, {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
       }]
      }, {
       tfOpName: "ScatterNd",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "indices",
        type: "tensor"
       }, {
        start: 1,
        name: "values",
        type: "tensor"
       }, {
        start: 2,
        name: "shape",
        type: "number[]"
       }]
      }, {
       tfOpName: "GatherNd",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "indices",
        type: "tensor"
       }]
      }, {
       tfOpName: "SparseToDense",
       category: "slice_join",
       inputs: [{
        start: 0,
        name: "sparseIndices",
        type: "tensor"
       }, {
        start: 1,
        name: "outputShape",
        type: "number[]"
       }, {
        start: 2,
        name: "sparseValues",
        type: "tensor"
       }, {
        start: 3,
        name: "defaultValue",
        type: "tensor"
       }],
       attrs: [{
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: !1,
        notSupported: !0
       }]
      }],
      $ = Object.freeze({
       json: H
      }),
      G = [{
       tfOpName: "FFT",
       category: "spectral",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "IFFT",
       category: "spectral",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }]
      }, {
       tfOpName: "RFFT",
       category: "spectral",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
       }]
      }, {
       tfOpName: "IRFFT",
       category: "spectral",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
       }]
      }],
      q = Object.freeze({
       json: G
      }),
      K = [{
       tfOpName: "Cast",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "SrcT",
        name: "sdtype",
        type: "dtype",
        notSupported: !0
       }, {
        tfName: "DstT",
        name: "dtype",
        type: "dtype"
       }]
      }, {
       tfOpName: "ExpandDims",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "axis",
        type: "number"
       }]
      }, {
       tfOpName: "Pad",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "padding",
        type: "number[]"
       }],
       attrs: [{
        tfName: "constant_value",
        name: "constantValue",
        type: "number",
        defaultValue: 0
       }]
      }, {
       tfOpName: "PadV2",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "padding",
        type: "number[]"
       }, {
        start: 2,
        name: "constantValue",
        type: "number",
        defaultValue: 0
       }]
      }, {
       tfOpName: "Reshape",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "shape",
        type: "number[]"
       }]
      }, {
       tfOpName: "Squeeze",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "axis",
        tfDeprecatedName: "squeeze_dims",
        name: "axis",
        type: "number[]"
       }]
      }, {
       tfOpName: "SpaceToBatchND",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "blockShape",
        type: "number[]"
       }, {
        start: 2,
        name: "paddings",
        type: "number[]"
       }]
      }, {
       tfOpName: "BatchToSpaceND",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }, {
        start: 1,
        name: "blockShape",
        type: "number[]"
       }, {
        start: 2,
        name: "crops",
        type: "number[]"
       }]
      }, {
       tfOpName: "DepthToSpace",
       category: "transformation",
       inputs: [{
        start: 0,
        name: "x",
        type: "tensor"
       }],
       attrs: [{
        tfName: "block_size",
        name: "blockSize",
        type: "number"
       }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string"
       }]
      }],
      X = Object.freeze({
       json: K
      }),
      Y = function() {
       function t() {
        var t = [b, w, S, k, O, N, T, B, M, D, z, W, U, $, q, X],
         e = [].concat.apply([], t.map((function(t) {
          return t.json
         })));
        this.opMappers = e.reduce((function(t, e) {
         return t[e.tfOpName] = e, t
        }), {})
       }
       return Object.defineProperty(t, "Instance", {
        get: function() {
         return this._instance || (this._instance = new this)
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.transformGraph = function(t, e) {
        var n = this;
        void 0 === e && (e = {});
        var r = [],
         i = [],
         o = t.node.reduce((function(t, e) {
          return t[e.name] = n.mapNode(e), e.op.startsWith("Placeholder") && r.push(t[e.name]), "Const" === e.op && i.push(t[e.name]), t
         }), {}),
         a = [],
         s = [],
         u = {},
         c = {};
        null != e && (u = this.mapSignatureEntries(e.inputs), c = this.mapSignatureEntries(e.outputs));
        var l = Object.keys(o);
        return l.forEach((function(t) {
         var e = o[t];
         e.inputNames.forEach((function(t) {
          var n = d(t)[0];
          e.inputs.push(o[n]), o[n].children.push(e)
         }))
        })), 0 === Object.keys(c).length ? l.forEach((function(t) {
         var e = o[t];
         0 === e.children.length && s.push(e)
        })) : Object.keys(c).forEach((function(t) {
         var e = d(t)[0],
          n = o[e];
         null != n && (n.signatureKey = c[t], s.push(n))
        })), Object.keys(u).length > 0 ? Object.keys(u).forEach((function(t) {
         var e = d(t)[0],
          n = o[e];
         n && (n.signatureKey = u[t], a.push(n))
        })) : a = r, {
         nodes: o,
         inputs: a,
         outputs: s,
         weights: i,
         placeholders: r,
         signature: e
        }
       }, t.prototype.mapSignatureEntries = function(t) {
        return Object.keys(t || {}).reduce((function(e, n) {
         return e[t[n].name] = n, e
        }), {})
       }, t.prototype.mapNode = function(t) {
        var e = l(t.op) || this.opMappers[t.op] || {};
        null == t.attr && (t.attr = {});
        var n = {
         name: t.name,
         op: t.op,
         category: e.category,
         inputNames: (t.input || []).map((function(t) {
          return t.startsWith("^") ? t.substr(1) : t
         })),
         inputs: [],
         children: [],
         inputParams: {},
         attrParams: {},
         rawAttrs: t.attr
        };
        return null != e.inputs && (n.inputParams = e.inputs.reduce((function(t, e) {
         return t[e.name] = {
          type: e.type,
          inputIndexStart: e.start,
          inputIndexEnd: e.end
         }, t
        }), {})), null != e.attrs && (n.attrParams = e.attrs.reduce((function(e, n) {
         var r = n.type,
          i = void 0;
         switch (n.type) {
          case "string":
           void 0 === (i = Q(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = Q(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "string[]":
           void 0 === (i = ut(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = ut(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "number":
           void 0 === (i = et(t.attr, n.tfName, n.defaultValue || 0)) && n.tfDeprecatedName && (i = et(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "number[]":
           void 0 === (i = st(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = st(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "bool":
           void 0 === (i = tt(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = tt(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "bool[]":
           void 0 === (i = lt(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = lt(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "shape":
           void 0 === (i = at(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = at(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "shape[]":
           void 0 === (i = ct(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = ct(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "dtype":
           void 0 === (i = rt(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = rt(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "dtype[]":
           void 0 === (i = it(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (i = it(t.attr, n.tfDeprecatedName, n.defaultValue));
           break;
          case "tensor":
          case "tensors":
           break;
          default:
           throw new Error("Unsupported param type: " + n.type + " for op: " + t.op)
         }
         return e[n.name] = {
          value: i,
          type: r
         }, e
        }), {})), n
       }, t
      }();
 
     function Z(e) {
      var n = Object(o["env"])().global;
      if (void 0 !== n.atob) return n.atob(e);
      if ("undefined" != typeof t) return new t(e, "base64").toString();
      throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")
     }
 
     function J(t, e) {
      var n = Array.isArray(t) ? String.fromCharCode.apply(null, t) : Z(t);
      return e ? n : n.toLowerCase()
     }
 
     function Q(t, e, n, r) {
      void 0 === r && (r = !1);
      var i = t[e];
      return null != i ? J(i.s, r) : n
     }
 
     function tt(t, e, n) {
      var r = t[e];
      return r ? r.b : n
     }
 
     function et(t, e, n) {
      var r = t[e] || {},
       i = null != r.i ? r.i : null != r.f ? r.f : n;
      return "number" == typeof i ? i : parseInt(i, 10)
     }
 
     function nt(t) {
      switch ("string" == typeof t && (t = r[t]), t) {
       case r.DT_FLOAT:
        return "float32";
       case r.DT_INT32:
       case r.DT_INT64:
        return "int32";
       case r.DT_BOOL:
        return "bool";
       case r.DT_DOUBLE:
        return "float32";
       case r.DT_STRING:
        return "string";
       default:
        return null
      }
     }
 
     function rt(t, e, n) {
      var r = t[e];
      return r && r.type ? nt(r.type) : n
     }
 
     function it(t, e, n) {
      var r = t[e];
      return r && r.list && r.list.type ? r.list.type.map((function(t) {
       return nt(t)
      })) : n
     }
 
     function ot(t) {
      if (!t.unknownRank) return null != t.dim ? t.dim.map((function(t) {
       return "number" == typeof t.size ? t.size : parseInt(t.size, 10)
      })) : []
     }
 
     function at(t, e, n) {
      var r = t[e];
      return r && r.shape ? ot(r.shape) : n
     }
 
     function st(t, e, n) {
      var r = t[e];
      return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map((function(t) {
       return "number" == typeof t ? t : parseInt(t, 10)
      })) : n
     }
 
     function ut(t, e, n, r) {
      void 0 === r && (r = !1);
      var i = t[e];
      return i && i.list && i.list.s ? i.list.s.map((function(t) {
       return J(t, r)
      })) : n
     }
 
     function ct(t, e, n) {
      var r = t[e];
      return r && r.list && r.list.shape ? r.list.shape.map((function(t) {
       return ot(t)
      })) : n
     }
 
     function lt(t, e, n) {
      var r = t[e];
      return r && r.list && r.list.b ? r.list.b : n
     }
     var ht = function() {
       function t(t, e, n) {
        var r = this;
        this.node = t, this.tensorMap = e, this.context = n, this.inputs = [], this.attrs = {}, this.inputs = t.inputNames.map((function(t) {
         return r.getInput(t)
        })), null != t.rawAttrs && (this.attrs = Object.keys(t.rawAttrs).reduce((function(t, e) {
         return t[e] = r.getAttr(e), t
        }), {}))
       }
       return t.prototype.getInput = function(t) {
        return p(t, this.tensorMap, this.context)
       }, t.prototype.getAttr = function(t, e) {
        var n = this.node.rawAttrs[t];
        if (null != n.tensor) return p(t, this.tensorMap, this.context);
        if (null != n.i || null != n.f) return et(this.node.rawAttrs, t, e);
        if (null != n.s) return Q(this.node.rawAttrs, t, e);
        if (null != n.b) return tt(this.node.rawAttrs, t, e);
        if (null != n.shape) return at(this.node.rawAttrs, t, e);
        if (null != n.type) return rt(this.node.rawAttrs, t, e);
        if (null != n.list) {
         if (null != n.list.i || null != n.list.f) return st(this.node.rawAttrs, t, e);
         if (null != n.list.s) return ut(this.node.rawAttrs, t, e);
         if (null != n.list.shape) return ct(this.node.rawAttrs, t, e);
         if (null != n.list.b) return lt(this.node.rawAttrs, t, e);
         if (null != n.list.type) return it(this.node.rawAttrs, t, e)
        }
        return e
       }, t
      }(),
      pt = function(t, e, n) {
       switch (t.op) {
        case "BiasAdd":
        case "AddV2":
        case "Add":
         return [Object(o["add"])(h("a", t, e, n), h("b", t, e, n))];
        case "AddN":
         return [Object(o["addN"])(h("tensors", t, e, n))];
        case "FloorMod":
        case "Mod":
         return [Object(o["mod"])(h("a", t, e, n), h("b", t, e, n))];
        case "Mul":
         return [Object(o["mul"])(h("a", t, e, n), h("b", t, e, n))];
        case "RealDiv":
        case "Div":
         return [Object(o["div"])(h("a", t, e, n), h("b", t, e, n))];
        case "DivNoNan":
         return [Object(o["divNoNan"])(h("a", t, e, n), h("b", t, e, n))];
        case "FloorDiv":
         return [Object(o["floorDiv"])(h("a", t, e, n), h("b", t, e, n))];
        case "Sub":
         return [Object(o["sub"])(h("a", t, e, n), h("b", t, e, n))];
        case "Minimum":
         return [Object(o["minimum"])(h("a", t, e, n), h("b", t, e, n))];
        case "Maximum":
         return [Object(o["maximum"])(h("a", t, e, n), h("b", t, e, n))];
        case "Pow":
         return [Object(o["pow"])(h("a", t, e, n), h("b", t, e, n))];
        case "SquaredDifference":
         return [Object(o["squaredDifference"])(h("a", t, e, n), h("b", t, e, n))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      ft = function(t, e, n) {
       switch (t.op) {
        case "Abs":
        case "ComplexAbs":
         return [Object(o["abs"])(h("x", t, e, n))];
        case "Acos":
         return [Object(o["acos"])(h("x", t, e, n))];
        case "Acosh":
         return [Object(o["acosh"])(h("x", t, e, n))];
        case "Asin":
         return [Object(o["asin"])(h("x", t, e, n))];
        case "Asinh":
         return [Object(o["asinh"])(h("x", t, e, n))];
        case "Atan":
         return [Object(o["atan"])(h("x", t, e, n))];
        case "Atan2":
         return [Object(o["atan2"])(h("x", t, e, n), h("y", t, e, n))];
        case "Atanh":
         return [Object(o["atanh"])(h("x", t, e, n))];
        case "Ceil":
         return [Object(o["ceil"])(h("x", t, e, n))];
        case "Complex":
         return [Object(o["complex"])(h("real", t, e, n), h("imag", t, e, n))];
        case "Cos":
         return [Object(o["cos"])(h("x", t, e, n))];
        case "Cosh":
         return [Object(o["cosh"])(h("x", t, e, n))];
        case "Elu":
         return [Object(o["elu"])(h("x", t, e, n))];
        case "Erf":
         return [Object(o["erf"])(h("x", t, e, n))];
        case "Exp":
         return [Object(o["exp"])(h("x", t, e, n))];
        case "Expm1":
         return [Object(o["expm1"])(h("x", t, e, n))];
        case "Floor":
         return [Object(o["floor"])(h("x", t, e, n))];
        case "Log":
         return [Object(o["log"])(h("x", t, e, n))];
        case "Log1p":
         return [Object(o["log1p"])(h("x", t, e, n))];
        case "Imag":
         return [Object(o["imag"])(h("x", t, e, n))];
        case "Neg":
         return [Object(o["neg"])(h("x", t, e, n))];
        case "Reciprocal":
         return [Object(o["reciprocal"])(h("x", t, e, n))];
        case "Real":
         return [Object(o["real"])(h("x", t, e, n))];
        case "Relu":
         return [Object(o["relu"])(h("x", t, e, n))];
        case "Round":
         return [Object(o["round"])(h("x", t, e, n))];
        case "Selu":
         return [Object(o["selu"])(h("x", t, e, n))];
        case "Sigmoid":
         return [Object(o["sigmoid"])(h("x", t, e, n))];
        case "Sin":
         return [Object(o["sin"])(h("x", t, e, n))];
        case "Sign":
         return [Object(o["sign"])(h("x", t, e, n))];
        case "Sinh":
         return [Object(o["sinh"])(h("x", t, e, n))];
        case "Softplus":
         return [Object(o["softplus"])(h("x", t, e, n))];
        case "Sqrt":
         return [Object(o["sqrt"])(h("x", t, e, n))];
        case "Square":
         return [Object(o["square"])(h("x", t, e, n))];
        case "Tanh":
         return [Object(o["tanh"])(h("x", t, e, n))];
        case "Tan":
         return [Object(o["tan"])(h("x", t, e, n))];
        case "Relu6":
        case "ClipByValue":
         return [Object(o["clipByValue"])(h("x", t, e, n), h("clipValueMin", t, e, n), h("clipValueMax", t, e, n))];
        case "Rsqrt":
         return [Object(o["rsqrt"])(p(t.inputNames[0], e, n))];
        case "Prod":
         return [Object(o["prod"])(h("x", t, e, n), h("axes", t, e, n))];
        case "LeakyRelu":
         return [Object(o["leakyRelu"])(h("x", t, e, n), h("alpha", t, e, n))];
        case "Prelu":
         return [Object(o["prelu"])(h("x", t, e, n), h("alpha", t, e, n))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      dt = function() {
       function t(e, n, r, i, o, a, s) {
        this.name = e, this.dtype = n, this.maxSize = r, this.elementShape = i, this.identicalElementShapes = o, this.dynamicSize = a, this.clearAfterRead = s, this.tensors = [], this.closed_ = !1, this.id = t.nextId++
       }
       return Object.defineProperty(t.prototype, "closed", {
        get: function() {
         return this.closed_
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.clearAndClose = function() {
        this.tensors.forEach((function(t) {
         return t.tensor.dispose()
        })), this.tensors = [], this.closed_ = !0
       }, t.prototype.size = function() {
        return this.tensors.length
       }, t.prototype.read = function(t) {
        if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
        if (t < 0 || t >= this.tensors.length) throw new Error("Tried to read from index " + t + ", but array size is: " + this.tensors.length);
        var e = this.tensors[t];
        if (e.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + t + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
        return this.clearAfterRead && (e.cleared = !0), e.read = !0, e.tensor
       }, t.prototype.readMany = function(t) {
        var e = this;
        return t.map((function(t) {
         return e.read(t)
        }))
       }, t.prototype.write = function(t, e) {
        if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
        if (t < 0 || !this.dynamicSize && t >= this.maxSize) throw new Error("Tried to write to index " + t + ", but array is not resizeable and size is: " + this.maxSize);
        var n = this.tensors[t] || {};
        if (e.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + t + ",\n          because the value dtype is " + e.dtype + ", but TensorArray dtype is " + this.dtype + ".");
        if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = e.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, e.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + t + "."), n && n.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + t + ", because it has already been read.");
        if (n && n.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + t + ", because it has already been written.");
        n.tensor = e, n.written = !0, this.tensors[t] = n
       }, t.prototype.writeMany = function(t, e) {
        var n = this;
        if (t.length !== e.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + t.length + " is not the same as tensors size: " + e.length + ".");
        t.forEach((function(t, r) {
         return n.write(t, e[r])
        }))
       }, t.prototype.gather = function(t, e) {
        if (e && e !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + e);
        if (!t) {
         t = [];
         for (var n = 0; n < this.size(); n++) t.push(n)
        }
        if (0 === t.length) return Object(o["tensor"])([], [0].concat(this.elementShape));
        var r = this.readMany(t);
        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), Object(o["stack"])(r, 0)
       }, t.prototype.concat = function(t) {
        if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + t);
        if (0 === this.size()) return Object(o["tensor"])([], [0].concat(this.elementShape));
        for (var e = [], n = 0; n < this.size(); n++) e.push(n);
        var r = this.readMany(e);
        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r[0].shape + ")"), Object(o["concat"])(r, 0)
       }, t.prototype.scatter = function(t, e) {
        if (e.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + e.dtype);
        if (t.length !== e.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + t.length + " vs. " + e.shape[0]);
        var n = Math.max.apply(Math, t);
        if (!this.dynamicSize && n >= this.maxSize) throw new Error("Max index must be < array size (" + n + "  vs. " + this.maxSize + ")");
        this.writeMany(t, Object(o["unstack"])(e, 0))
       }, t.prototype.split = function(t, e) {
        var n = this;
        if (e.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + e.dtype);
        var r = 0,
         i = t.map((function(t) {
          return r += t
         }));
        if (r !== e.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + e.shape);
        if (!this.dynamicSize && t.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + t.length + "), and the TensorArray is not marked as dynamically resizeable");
        var a = 0 === r ? 0 : e.size / r,
         s = [];
        Object(o["tidy"])((function() {
         e = e.reshape([1, r, a]);
         for (var u = 0; u < t.length; ++u) {
          var c = [0, 0 === u ? 0 : i[u - 1], 0],
           l = [1, t[u], a];
          s[u] = Object(o["slice"])(e, c, l).reshape(n.elementShape)
         }
         return s
        }));
        for (var u = [], c = 0; c < t.length; c++) u[c] = c;
        this.writeMany(u, s)
       }, t.prototype.assertShapesMatchAllowUndefinedSize = function(t, e, n) {
        void 0 === n && (n = ""), o["util"].assert(this.shapesEqualAllowUndefinedSize(t, e), (function() {
         return n + " Shapes " + t + " and " + e + " must match"
        }))
       }, t.prototype.shapesEqualAllowUndefinedSize = function(t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0; n < t.length; n++)
         if (-1 !== t[n] && -1 !== e[n] && t[n] !== e[n]) return !1;
        return !0
       }, t.nextId = 0, t
      }();
 
     function vt(t, e, n) {
      return s(this, void 0, void 0, (function() {
       var r, i, a, s, c, l, f, d, v, m, g, y, b, x, w, C, S, E, k, I, O, A, N, R, T, _, D, F, M, L, B, P, z, j, W;
       return u(this, (function(u) {
        switch (u.label) {
         case 0:
          switch (t.op) {
           case "LoopCond":
            return [3, 1];
           case "Switch":
            return [3, 2];
           case "Merge":
            return [3, 4];
           case "Enter":
            return [3, 5];
           case "Exit":
            return [3, 6];
           case "NextIteration":
            return [3, 7];
           case "TensorArrayV3":
            return [3, 8];
           case "TensorArrayWriteV3":
            return [3, 9];
           case "TensorArrayReadV3":
            return [3, 10];
           case "TensorArrayGatherV3":
            return [3, 11];
           case "TensorArrayScatterV3":
            return [3, 12];
           case "TensorArrayConcatV3":
            return [3, 13];
           case "TensorArraySplitV3":
            return [3, 14];
           case "TensorArraySizeV3":
            return [3, 15];
           case "TensorArrayCloseV3":
            return [3, 16]
          }
          return [3, 17];
         case 1:
          return [2, [h("pred", t, e, n).clone()]];
         case 2:
          return r = h("pred", t, e, n), i = h("data", t, e, n), [4, r.data()];
         case 3:
          return [2, u.sent()[0] ? [void 0, i.clone()] : [i.clone(), void 0]];
         case 4:
          return [2, (a = t.inputNames.find((function(t) {
           return void 0 !== p(t, e, n)
          }))) ? [p(a, e, n).clone()] : void 0];
         case 5:
          return s = h("frameName", t, e, n), c = h("tensor", t, e, n), n.enterFrame(s), [2, [c.clone()]];
         case 6:
          return l = h("tensor", t, e, n), n.exitFrame(), [2, [l.clone()]];
         case 7:
          return f = h("tensor", t, e, n), n.nextIteration(), [2, [f.clone()]];
         case 8:
          return d = h("size", t, e, n), v = h("dtype", t, e, n), m = h("elementShape", t, e, n), g = h("dynamicSize", t, e, n), y = h("clearAfterRead", t, e, n), b = h("identicalElementShapes", t, e, n), x = h("name", t, e, n), w = new dt(x, v, d, m, b, g, y), n.addTensorArray(w), [2, [Object(o["scalar"])(w.id), Object(o["scalar"])(1)]];
         case 9:
          return C = h("tensorArrayId", t, e, n), S = h("index", t, e, n), E = h("tensor", t, e, n), n.getTensorArray(C).write(S, E), [2, [Object(o["scalar"])(1)]];
         case 10:
          return k = h("tensorArrayId", t, e, n), I = h("index", t, e, n), [2, [n.getTensorArray(k).read(I)]];
         case 11:
          return O = h("tensorArrayId", t, e, n), A = h("indices", t, e, n), N = h("dtype", t, e, n), [2, [n.getTensorArray(O).gather(A, N)]];
         case 12:
          return R = h("tensorArrayId", t, e, n), T = h("indices", t, e, n), _ = h("tensor", t, e, n), n.getTensorArray(R).scatter(T, _), [2, [Object(o["scalar"])(1)]];
         case 13:
          return D = h("tensorArrayId", t, e, n), F = n.getTensorArray(D), M = h("dtype", t, e, n), [2, [F.concat(M)]];
         case 14:
          return L = h("tensorArrayId", t, e, n), B = h("tensor", t, e, n), P = h("lengths", t, e, n), n.getTensorArray(L).split(P, B), [2, [Object(o["scalar"])(1)]];
         case 15:
          return z = h("tensorArrayId", t, e, n), j = n.getTensorArray(z), [2, [Object(o["scalar"])(j.size(), "int32")]];
         case 16:
          return W = h("tensorArrayId", t, e, n), n.getTensorArray(W).clearAndClose(), [2, [Object(o["scalar"])(0)]];
         case 17:
          throw TypeError("Node type " + t.op + " is not implemented")
        }
       }))
      }))
     }
     var mt = function(t, e, n) {
       switch (t.op) {
        case "Conv1D":
         var r = h("stride", t, e, n),
          i = h("pad", t, e, n),
          a = h("dataFormat", t, e, n).toUpperCase(),
          s = h("dilation", t, e, n);
         return [Object(o["conv1d"])(h("x", t, e, n), h("filter", t, e, n), r, i, a, s)];
        case "Conv2D":
         r = h("strides", t, e, n), i = h("pad", t, e, n), a = h("dataFormat", t, e, n).toUpperCase();
         var u = h("dilations", t, e, n);
         return [Object(o["conv2d"])(h("x", t, e, n), h("filter", t, e, n), [r[1], r[2]], i, a, [u[1], u[2]])];
        case "_FusedConv2D":
        case "FusedDepthwiseConv2dNative":
         var c = h("fusedOps", t, e, n),
          l = c[0],
          p = c[1],
          f = "biasadd" === l,
          d = "prelu" === p,
          v = "fusedbatchnorm" === l,
          m = h("numArgs", t, e, n);
         if (f) {
          if (d && 2 !== m) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          if (!d && 1 !== m) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")
         }
         if (v) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
         r = h("strides", t, e, n), i = h("pad", t, e, n), a = h("dataFormat", t, e, n).toUpperCase(), u = h("dilations", t, e, n);
         var g = h("args", t, e, n),
          y = g[0],
          b = g[1];
         return [("_FusedConv2D" === t.op ? o["fused"].conv2d : o["fused"].depthwiseConv2d)({
          x: h("x", t, e, n),
          filter: h("filter", t, e, n),
          strides: [r[1], r[2]],
          pad: i,
          dataFormat: a,
          dilations: [u[1], u[2]],
          bias: y,
          activation: p,
          preluActivationWeights: b
         })];
        case "Conv2DBackpropInput":
        case "Conv2dTranspose":
         var x = h("outputShape", t, e, n);
         return r = h("strides", t, e, n), i = h("pad", t, e, n), [Object(o["conv2dTranspose"])(h("x", t, e, n), h("filter", t, e, n), x, [r[1], r[2]], i)];
        case "DepthwiseConv2dNative":
        case "DepthwiseConv2d":
         return r = h("strides", t, e, n), i = h("pad", t, e, n), u = h("dilations", t, e, n), a = h("dataFormat", t, e, n).toUpperCase(), [Object(o["depthwiseConv2d"])(h("input", t, e, n), h("filter", t, e, n), [r[1], r[2]], i, a, [u[1], u[2]])];
        case "Conv3D":
         return r = h("strides", t, e, n), i = h("pad", t, e, n), a = h("dataFormat", t, e, n).toUpperCase(), u = h("dilations", t, e, n), [Object(o["conv3d"])(h("x", t, e, n), h("filter", t, e, n), [r[1], r[2], r[3]], i, a, [u[1], u[2], u[3]])];
        case "AvgPool":
         r = h("strides", t, e, n), i = h("pad", t, e, n);
         var w = h("kernelSize", t, e, n);
         return [Object(o["avgPool"])(h("x", t, e, n), [w[1], w[2]], [r[1], r[2]], i)];
        case "MaxPool":
         return r = h("strides", t, e, n), i = h("pad", t, e, n), w = h("kernelSize", t, e, n), [Object(o["maxPool"])(h("x", t, e, n), [w[1], w[2]], [r[1], r[2]], i)];
        case "AvgPool3D":
         return r = h("strides", t, e, n), i = h("pad", t, e, n), w = h("kernelSize", t, e, n), [Object(o["avgPool3d"])(h("x", t, e, n), [w[1], w[2], w[3]], [r[1], r[2], r[3]], i)];
        case "MaxPool3D":
         return r = h("strides", t, e, n), i = h("pad", t, e, n), w = h("kernelSize", t, e, n), [Object(o["maxPool3d"])(h("x", t, e, n), [w[1], w[2], w[3]], [r[1], r[2], r[3]], i)];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      gt = function(t, e, n) {
       switch (t.op) {
        case "Fill":
         var r = h("shape", t, e, n),
          i = h("dtype", t, e, n),
          a = h("value", t, e, n);
         return [Object(o["fill"])(r, a, i)];
        case "LinSpace":
         var s = h("start", t, e, n),
          u = h("stop", t, e, n),
          c = h("num", t, e, n);
         return [Object(o["linspace"])(s, u, c)];
        case "Multinomial":
         var l = h("logits", t, e, n),
          p = h("numSamples", t, e, n),
          f = h("seed", t, e, n);
         return [Object(o["multinomial"])(l, p, f)];
        case "OneHot":
         var d = h("indices", t, e, n),
          v = h("depth", t, e, n),
          m = h("onValue", t, e, n),
          g = h("offValue", t, e, n);
         return [Object(o["oneHot"])(d, v, m, g)];
        case "Ones":
         return [Object(o["ones"])(h("shape", t, e, n), h("dtype", t, e, n))];
        case "OnesLike":
         return [Object(o["onesLike"])(h("x", t, e, n))];
        case "RandomUniform":
         return [Object(o["randomUniform"])(h("shape", t, e, n), h("minval", t, e, n), h("maxval", t, e, n), h("dtype", t, e, n))];
        case "Range":
         s = h("start", t, e, n);
         var y = h("stop", t, e, n),
          b = h("step", t, e, n);
         return [Object(o["range"])(s, y, b, h("dtype", t, e, n))];
        case "TruncatedNormal":
         r = h("shape", t, e, n);
         var x = h("mean", t, e, n),
          w = h("stdDev", t, e, n);
         return f = h("seed", t, e, n), [Object(o["truncatedNormal"])(r, x, w, h("dtype", t, e, n), f)];
        case "Zeros":
         return [Object(o["zeros"])(h("shape", t, e, n), h("dtype", t, e, n))];
        case "ZerosLike":
         return [Object(o["zerosLike"])(h("x", t, e, n))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      };
 
     function yt(t, e, n) {
      return s(this, void 0, void 0, (function() {
       var r, i, a, s, c, l, p;
       return u(this, (function(u) {
        switch (u.label) {
         case 0:
          switch (t.op) {
           case "NonMaxSuppressionV5":
           case "NonMaxSuppressionV3":
           case "NonMaxSuppressionV2":
            return [3, 1];
           case "Where":
            return [3, 5];
           case "ListDiff":
            return [3, 7]
          }
          return [3, 8];
         case 1:
          return r = h("boxes", t, e, n), i = h("scores", t, e, n), a = h("maxOutputSize", t, e, n), s = h("iouThreshold", t, e, n), c = h("scoreThreshold", t, e, n), "NonMaxSuppressionV5" !== t.op ? [3, 3] : (l = h("softNmsSigma", t, e, n), [4, o["image"].nonMaxSuppressionWithScoreAsync(r, i, a, s, c, l)]);
         case 2:
          return [2, [(p = u.sent()).selectedIndices, p.selectedScores]];
         case 3:
          return [4, o["image"].nonMaxSuppressionAsync(r, i, a, s, c)];
         case 4:
          return [2, [u.sent()]];
         case 5:
          return [4, Object(o["whereAsync"])(h("condition", t, e, n).asType("bool"))];
         case 6:
          return [2, [u.sent()]];
         case 7:
          return [2, Object(o["setdiff1dAsync"])(h("x", t, e, n), h("y", t, e, n))];
         case 8:
          throw TypeError("Node type " + t.op + " is not implemented")
        }
       }))
      }))
     }
     var bt = function(t, e, n) {
       switch (t.op) {
        case "TopKV2":
         var r = h("x", t, e, n),
          i = h("k", t, e, n),
          a = h("sorted", t, e, n),
          s = Object(o["topk"])(r, i, a);
         return [s.values, s.indices];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      xt = function(t, e, n) {
       switch (t.op) {
        case "Const":
         return e[t.name];
        case "PlaceholderWithDefault":
         var r = h("default", t, e, n);
         return [p(t.name, e, n) || r];
        case "Placeholder":
         return [p(t.name, e, n)];
        case "Identity":
        case "StopGradient":
        case "FakeQuantWithMinMaxVars":
         return [h("x", t, e, n).clone()];
        case "IdentityN":
         return h("x", t, e, n).map((function(t) {
          return t.clone()
         }));
        case "Snapshot":
         return [h("x", t, e, n).clone()];
        case "Shape":
         return [Object(o["tensor1d"])(h("x", t, e, n).shape, "int32")];
        case "ShapeN":
         return h("x", t, e, n).map((function(t) {
          return Object(o["tensor1d"])(t.shape)
         }));
        case "Size":
         return [Object(o["scalar"])(h("x", t, e, n).size, "int32")];
        case "Rank":
         return [Object(o["scalar"])(h("x", t, e, n).rank, "int32")];
        case "NoOp":
         return [Object(o["scalar"])(1)];
        case "Print":
         var i = h("x", t, e, n),
          a = h("data", t, e, n),
          s = h("message", t, e, n),
          u = h("summarize", t, e, n);
         console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(s);
         for (var c = 0; c < a.length; c++) console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0, u));
         return [i];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      wt = function(t, e, n) {
       switch (t.op) {
        case "ResizeBilinear":
         var r = h("images", t, e, n),
          i = h("size", t, e, n),
          a = h("alignCorners", t, e, n);
         return [o["image"].resizeBilinear(r, [i[0], i[1]], a)];
        case "ResizeNearestNeighbor":
         return r = h("images", t, e, n), i = h("size", t, e, n), a = h("alignCorners", t, e, n), [o["image"].resizeNearestNeighbor(r, [i[0], i[1]], a)];
        case "CropAndResize":
         var s = h("image", t, e, n),
          u = h("boxes", t, e, n),
          c = h("boxInd", t, e, n),
          l = h("cropSize", t, e, n),
          p = h("method", t, e, n),
          f = h("extrapolationValue", t, e, n);
         return [o["image"].cropAndResize(s, u, c, l, p, f)];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      Ct = function(t, e, n) {
       switch (t.op) {
        case "Equal":
         return [Object(o["equal"])(h("a", t, e, n), h("b", t, e, n))];
        case "NotEqual":
         return [Object(o["notEqual"])(h("a", t, e, n), h("b", t, e, n))];
        case "Greater":
         return [Object(o["greater"])(h("a", t, e, n), h("b", t, e, n))];
        case "GreaterEqual":
         return [Object(o["greaterEqual"])(h("a", t, e, n), h("b", t, e, n))];
        case "Less":
         return [Object(o["less"])(h("a", t, e, n), h("b", t, e, n))];
        case "LessEqual":
         return [Object(o["lessEqual"])(h("a", t, e, n), h("b", t, e, n))];
        case "LogicalAnd":
         return [Object(o["logicalAnd"])(h("a", t, e, n), h("b", t, e, n))];
        case "LogicalNot":
         return [Object(o["logicalNot"])(h("a", t, e, n))];
        case "LogicalOr":
         return [Object(o["logicalOr"])(h("a", t, e, n), h("b", t, e, n))];
        case "Select":
         return [Object(o["where"])(h("condition", t, e, n), h("a", t, e, n), h("b", t, e, n))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      St = function(t, e, n) {
       switch (t.op) {
        case "BatchMatMul":
        case "BatchMatMulV2":
        case "MatMul":
         return [Object(o["matMul"])(h("a", t, e, n), h("b", t, e, n), h("transposeA", t, e, n), h("transposeB", t, e, n))];
        case "Transpose":
         return [Object(o["transpose"])(h("x", t, e, n), h("perm", t, e, n))];
        case "_FusedMatMul":
         var r = h("fusedOps", t, e, n),
          i = r[0],
          a = r[1],
          s = "biasadd" === i,
          u = "prelu" === a,
          c = h("numArgs", t, e, n);
         if (s) {
          if (u && 2 !== c) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
          if (!u && 1 !== c) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")
         }
         var l = h("args", t, e, n),
          p = l[0],
          f = l[1];
         return [o["fused"].matMul({
          a: h("a", t, e, n),
          b: h("b", t, e, n),
          transposeA: h("transposeA", t, e, n),
          transposeB: h("transposeB", t, e, n),
          bias: p,
          activation: a,
          preluActivationWeights: f
         })];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      Et = function(t, e, n) {
       switch (t.op) {
        case "FusedBatchNorm":
        case "FusedBatchNormV2":
        case "FusedBatchNormV3":
         return [Object(o["batchNorm"])(h("x", t, e, n), h("mean", t, e, n), h("variance", t, e, n), h("offset", t, e, n), h("scale", t, e, n), h("epsilon", t, e, n))];
        case "LRN":
         return [Object(o["localResponseNormalization"])(h("x", t, e, n), h("radius", t, e, n), h("bias", t, e, n), h("alpha", t, e, n), h("beta", t, e, n))];
        case "Softmax":
         return [Object(o["softmax"])(h("x", t, e, n))];
        case "LogSoftmax":
         return [Object(o["logSoftmax"])(h("x", t, e, n))];
        case "SparseToDense":
         return [Object(o["sparseToDense"])(h("sparseIndices", t, e, n), h("outputShape", t, e, n), h("sparseValues", t, e, n), h("defaultValue", t, e, n))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      kt = function(t, e, n) {
       switch (t.op) {
        case "Max":
         var r = h("axis", t, e, n),
          i = h("keepDims", t, e, n);
         return [Object(o["max"])(h("x", t, e, n), r, i)];
        case "Mean":
         return r = h("axis", t, e, n), i = h("keepDims", t, e, n), [Object(o["mean"])(h("x", t, e, n), r, i)];
        case "Min":
         return r = h("axis", t, e, n), i = h("keepDims", t, e, n), [Object(o["min"])(h("x", t, e, n), r, i)];
        case "Sum":
         return r = h("axis", t, e, n), i = h("keepDims", t, e, n), [Object(o["sum"])(h("x", t, e, n), r, i)];
        case "All":
         return r = h("axis", t, e, n), i = h("keepDims", t, e, n), [Object(o["all"])(h("x", t, e, n), r, i)];
        case "Any":
         return r = h("axis", t, e, n), i = h("keepDims", t, e, n), [Object(o["any"])(h("x", t, e, n), r, i)];
        case "ArgMax":
         return r = h("axis", t, e, n), [Object(o["argMax"])(h("x", t, e, n), r)];
        case "ArgMin":
         return r = h("axis", t, e, n), [Object(o["argMin"])(h("x", t, e, n), r)];
        case "Prod":
         return r = h("axis", t, e, n), i = h("keepDims", t, e, n), [Object(o["prod"])(h("x", t, e, n), r, i)];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      It = function(t, e, n) {
       switch (t.op) {
        case "ConcatV2":
        case "Concat":
         var r = h("n", t, e, n),
          i = h("axis", t, e, n),
          a = h("tensors", t, e, n);
         return a = a.slice(0, r), [Object(o["concat"])(a, i)];
        case "GatherV2":
        case "Gather":
         i = h("axis", t, e, n);
         var s = h("x", t, e, n),
          u = h("indices", t, e, n);
         return [Object(o["gather"])(s, u.asType("int32"), i)];
        case "ReverseV2":
        case "Reverse":
         return i = h("axis", t, e, n), s = h("x", t, e, n), [Object(o["reverse"])(s, i)];
        case "Slice":
         var c = h("begin", t, e, n),
          l = h("size", t, e, n);
         return [Object(o["slice"])(h("x", t, e, n), c, l)];
        case "StridedSlice":
         c = h("begin", t, e, n);
         var p = h("end", t, e, n),
          f = h("strides", t, e, n),
          d = h("beginMask", t, e, n),
          v = h("endMask", t, e, n),
          m = h("ellipsisMask", t, e, n),
          g = h("newAxisMask", t, e, n),
          y = h("shrinkAxisMask", t, e, n),
          b = h("x", t, e, n);
         if (1 === c.length && b.shape.length > 1)
          for (var x = 1; x < b.shape.length; x++) c.push(0), p.push(b.shape[x]), f.push(f[0]);
         return [Object(o["stridedSlice"])(b, c, p, f, d, v, m, g, y)];
        case "Pack":
         return Object(o["tidy"])((function() {
          var r = h("axis", t, e, n),
           i = h("tensors", t, e, n),
           a = i[0].shape,
           s = i[0].squeeze().shape,
           u = i.map((function(t) {
            var e = o["util"].arraysEqual(t.shape, a);
            if (!e && !o["util"].arraysEqual(t.squeeze().shape, s)) throw new Error("the input tensors shape does not match");
            return e ? t : t.reshape(a)
           }));
          return [Object(o["stack"])(u, r)]
         }));
        case "Unpack":
         return Object(o["tidy"])((function() {
          var r = h("axis", t, e, n),
           i = h("tensor", t, e, n);
          return Object(o["unstack"])(i, r)
         }));
        case "Tile":
         var w = h("reps", t, e, n);
         return [Object(o["tile"])(h("x", t, e, n), w)];
        case "Split":
        case "SplitV":
         i = h("axis", t, e, n);
         var C = h("numOrSizeSplits", t, e, n);
         return Object(o["split"])(h("x", t, e, n), C, i);
        case "ScatterNd":
         u = h("indices", t, e, n);
         var S = h("values", t, e, n),
          E = h("shape", t, e, n);
         return [Object(o["scatterND"])(u, S, E)];
        case "GatherNd":
         var k = h("x", t, e, n);
         return u = h("indices", t, e, n), [Object(o["gatherND"])(k, u)];
        case "SparseToDense":
         u = h("sparseIndices", t, e, n), E = h("outputShape", t, e, n);
         var I = h("sparseValues", t, e, n),
          O = h("defaultValue", t, e, n);
         return [Object(o["sparseToDense"])(u, I, E, I.dtype === O.dtype ? O : O.asType(I.dtype))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      Ot = function(t, e, n) {
       switch (t.op) {
        case "FFT":
         return [Object(o["fft"])(h("x", t, e, n))];
        case "IFFT":
         return [Object(o["ifft"])(h("x", t, e, n))];
        case "RFFT":
         return [Object(o["rfft"])(h("x", t, e, n))];
        case "IRFFT":
         return [Object(o["irfft"])(h("x", t, e, n))];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      },
      At = function(t, e, n) {
       switch (t.op) {
        case "Cast":
         return [Object(o["cast"])(h("x", t, e, n), h("dtype", t, e, n))];
        case "ExpandDims":
         var r = h("axis", t, e, n);
         return [Object(o["expandDims"])(h("x", t, e, n), r)];
        case "Squeeze":
         return r = h("axis", t, e, n), [Object(o["squeeze"])(h("x", t, e, n), r)];
        case "Reshape":
         return [Object(o["reshape"])(h("x", t, e, n), h("shape", t, e, n))];
        case "PadV2":
        case "Pad":
         return [Object(o["pad"])(h("x", t, e, n), g(h("padding", t, e, n), 2), h("constantValue", t, e, n))];
        case "SpaceToBatchND":
         var i = h("blockShape", t, e, n),
          a = g(h("paddings", t, e, n), 2);
         return [Object(o["spaceToBatchND"])(h("x", t, e, n), i, a)];
        case "BatchToSpaceND":
         i = h("blockShape", t, e, n);
         var s = g(h("crops", t, e, n), 2);
         return [Object(o["batchToSpaceND"])(h("x", t, e, n), i, s)];
        case "DepthToSpace":
         var u = h("blockSize", t, e, n),
          c = h("dataFormat", t, e, n).toUpperCase();
         return [Object(o["depthToSpace"])(h("x", t, e, n), u, c)];
        default:
         throw TypeError("Node type " + t.op + " is not implemented")
       }
      };
 
     function Nt(t, e, n) {
      var r = function(t, e, n) {
       switch (t.category) {
        case "arithmetic":
         return pt(t, e, n);
        case "basic_math":
         return ft(t, e, n);
        case "control":
         return vt(t, e, n);
        case "convolution":
         return mt(t, e, n);
        case "creation":
         return gt(t, e, n);
        case "dynamic":
         return yt(t, e, n);
        case "evaluation":
         return bt(t, e, n);
        case "image":
         return wt(t, e, n);
        case "graph":
         return xt(t, e, n);
        case "logical":
         return Ct(t, e, n);
        case "matrices":
         return St(t, e, n);
        case "normalization":
         return Et(t, e, n);
        case "reduction":
         return kt(t, e, n);
        case "slice_join":
         return It(t, e, n);
        case "spectral":
         return Ot(t, e, n);
        case "transformation":
         return At(t, e, n);
        case "custom":
         var r = l(t.op);
         if (r && r.customExecutor) return r.customExecutor(new ht(t, e, n));
         throw TypeError("Custom op " + t.op + " is not registered.");
        default:
         throw TypeError("Unknown op '" + t.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")
       }
      }(t, e, n);
      return r instanceof Promise ? r.then((function(t) {
       return [].concat(t)
      })) : [].concat(r)
     }
     var Rt = function() {
      function t(t, e) {
       this.weightMap = t, this.tensorArrayMap = e, this.rootContext = {
        id: 0,
        frameName: "",
        iterationId: 0
       }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds()
      }
      return t.prototype.newFrame = function(t, e) {
       return {
        id: t,
        frameName: e,
        iterationId: 0
       }
      }, Object.defineProperty(t.prototype, "currentContext", {
       get: function() {
        return this.contexts
       },
       set: function(t) {
        this.contexts !== t && (this.contexts = t, this.generateCurrentContextIds())
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(t.prototype, "currentContextId", {
       get: function() {
        return this._currentContextIds[0]
       },
       enumerable: !0,
       configurable: !0
      }), Object.defineProperty(t.prototype, "currentContextIds", {
       get: function() {
        return this._currentContextIds
       },
       enumerable: !0,
       configurable: !0
      }), t.prototype.generateCurrentContextIds = function() {
       for (var t = [], e = 0; e < this.contexts.length - 1; e++) {
        var n = this.contexts.slice(0, this.contexts.length - e);
        t.push(this.contextIdforContexts(n))
       }
       t.push(""), this._currentContextIds = t
      }, t.prototype.contextIdforContexts = function(t) {
       return t ? t.map((function(t) {
        return 0 === t.id && 0 === t.iterationId ? "" : t.frameName + "-" + t.iterationId
       })).join("/") : ""
      }, t.prototype.enterFrame = function(t) {
       this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, t)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))
      }, t.prototype.exitFrame = function() {
       if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
       this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift()
      }, t.prototype.nextIteration = function() {
       if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
       this.contexts = this.contexts.slice(), this.lastId++;
       var t = Object.assign({}, this.contexts[this.contexts.length - 1]);
       t.iterationId += 1, t.id = this.lastId, this.contexts.splice(-1, 1, t), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
      }, t.prototype.getWeight = function(t) {
       return this.weightMap[t]
      }, t.prototype.addTensorArray = function(t) {
       this.tensorArrayMap[t.id] = t
      }, t.prototype.getTensorArray = function(t) {
       return this.tensorArrayMap[t]
      }, t
     }();
 
     function Tt(t, e, n) {
      for (var r = new Set, i = [], o = null, a = null, s = new Set, u = Object.keys(t).map((function(t) {
        return m(t)[0]
       })), c = e.slice(); c.length > 0;) {
       var l = c.pop();
       (Mt(l) || Lt(l)) && null == o && (a = (o = l).children.map((function(t) {
        return t.name
       })).filter((function(t) {
        return r.has(t)
       }))), r.add(l.name), null == n[l.name] && -1 === u.indexOf(l.name) && (0 !== l.inputs.length ? l.inputs.forEach((function(t) {
        s.has(t.name) || (s.add(t.name), c.push(t))
       })) : i.push(l.name))
      }
      return {
       inputs: t,
       outputs: e,
       usedNodes: r,
       missingInputs: i,
       dynamicNode: o,
       syncInputs: a
      }
     }
 
     function _t(t, e, n) {
      var r = n.usedNodes,
       i = n.inputs,
       o = [];
      Object.keys(i).map((function(t) {
       return m(t)[0]
      })).map((function(e) {
       return t.nodes[e]
      })).forEach((function(t) {
       r.has(t.name) && o.push(t)
      })), t.weights.forEach((function(t) {
       r.has(t.name) && o.push(t)
      }));
      for (var a = new Set, s = []; o.length > 0;) {
       var u = o.pop();
       a.add(u.name), e[u.name] || s.push(u), u.children.forEach((function(t) {
        !a.has(t.name) && r.has(t.name) && t.inputs.every((function(t) {
         return a.has(t.name)
        })) && o.push(t)
       }))
      }
      return s
     }
     var Dt = ["Switch", "Merge", "Enter", "Exit", "NextIteration"],
      Ft = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"];
 
     function Mt(t) {
      return Dt.indexOf(t.op) >= 0
     }
 
     function Lt(t) {
      return Ft.indexOf(t.op) >= 0
     }
     var Bt = function() {
       function t(t) {
        this.graph = t, this.compiledMap = new Map, this._weightMap = {}, this.SEPERATOR = ",", this._outputs = t.outputs, this._inputs = t.inputs, this._signature = t.signature
       }
       return Object.defineProperty(t.prototype, "weightMap", {
        get: function() {
         return this._weightMap
        },
        set: function(t) {
         var e = Object.keys(t).map((function(e) {
          return t[e].map((function(t) {
           return t.id
          }))
         }));
         this.weightIds = [].concat.apply([], e), this._weightMap = t
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "inputs", {
        get: function() {
         return this._inputs.map((function(t) {
          return {
           name: t.name,
           shape: t.attrParams.shape ? t.attrParams.shape.value : void 0,
           dtype: t.attrParams.dtype ? t.attrParams.dtype.value : void 0
          }
         }))
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "outputs", {
        get: function() {
         return this._outputs.map((function(t) {
          return {
           name: t.name,
           shape: t.attrParams.shape ? t.attrParams.shape.value : void 0,
           dtype: t.attrParams.dtype ? t.attrParams.dtype.value : void 0
          }
         }))
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "inputNodes", {
        get: function() {
         return this._inputs.map((function(t) {
          return t.signatureKey || t.name
         }))
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "outputNodes", {
        get: function() {
         return this._outputs.map((function(t) {
          return t.signatureKey || t.name
         }))
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.getCompilationKey = function(t, e) {
        var n = t.map((function(t) {
          return t.name
         })).sort(),
         r = e.map((function(t) {
          return t.name
         })).sort();
        return n.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR)
       }, t.prototype.compile = function(t, e) {
        var n = Tt(t, e, this.weightMap),
         r = n.missingInputs,
         i = n.dynamicNode,
         o = n.syncInputs;
        if (null != i) throw new Error("This execution contains the node '" + i.name + "', which has the dynamic op '" + i.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + o + "]");
        if (r.length > 0) {
         var a = e.map((function(t) {
           return t.name
          })),
          s = Object.keys(t);
         throw new Error("Cannot compute the outputs [" + a + "] from the provided inputs [" + s + "]. Missing the following inputs: [" + r + "]")
        }
        return _t(this.graph, this.weightMap, n)
       }, t.prototype.execute = function(t, e) {
        var n = this;
        t = this.mapInputs(t);
        var r = Object.keys(t).sort();
        this.checkInputs(t), this.checkInputShapeAndType(t), e = this.mapOutputs(e), this.checkOutputs(e);
        var i = r.map((function(t) {
          return n.graph.nodes[m(t)[0]]
         })),
         s = e.map((function(t) {
          return n.graph.nodes[m(t)[0]]
         })),
         u = this.getCompilationKey(i, s),
         c = this.compiledMap.get(u);
        null == c && (c = this.compile(t, s), this.compiledMap.set(u, c));
        var l = {};
        return Object(o["tidy"])((function() {
         var r = new Rt(n._weightMap, l),
          i = a({}, n.weightMap);
         Object.keys(t).forEach((function(e) {
          var n = m(e),
           r = n[0],
           o = [];
          o[n[1]] = t[e], i[r] = o
         }));
         for (var o = n.getFrozenTensorIds(i), s = {}, u = 0; u < c.length; u++) {
          var h = c[u];
          if (!i[h.name]) {
           var f = Nt(h, i, r);
           if (f instanceof Promise) throw new Error("The execution of the op '" + h.op + "' returned a promise. Please use model.executeAsync() instead.");
           i[h.name] = f, n.checkTensorForDisposal(h.name, h, i, r, o, e, s)
          }
         }
         return e.map((function(t) {
          return p(t, i, r)
         }))
        }))
       }, t.prototype.getFrozenTensorIds = function(t) {
        var e = [].concat.apply([], Object.keys(t).map((function(e) {
         return t[e]
        })).map((function(t) {
         return t.map((function(t) {
          return t.id
         }))
        })));
        return new Set(e)
       }, t.prototype.checkTensorForDisposal = function(t, e, n, r, i, o, a) {
        "control" !== e.category && -1 === o.indexOf(t) && (n[t].forEach((function(t) {
         null != t && (a[t.id] = (a[t.id] || 0) + e.children.length)
        })), e.inputs.forEach((function(t) {
         if ("control" !== t.category) {
          var e = f(t.name, n, r);
          null != e && e.forEach((function(t) {
           if (t && !i.has(t.id)) {
            var e = a[t.id];
            1 === e ? (t.dispose(), delete a[t.id]) : null != e && a[t.id]--
           }
          }))
         }
        })))
       }, t.prototype.executeAsync = function(t, e) {
        return s(this, void 0, void 0, (function() {
         var n, r, i, o, a, s, c = this;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            return t = this.mapInputs(t), this.checkInputs(t), this.checkInputShapeAndType(t), e = this.mapOutputs(e), this.checkOutputs(e), n = {}, r = new Rt(this._weightMap, n), [4, this.executeWithControlFlow(t, r, e)];
           case 1:
            return i = u.sent(), o = e.map((function(t) {
             return p(t, i, r)
            })), a = new Set(o.map((function(t) {
             return t.id
            }))), s = new Set(Object.keys(t).map((function(e) {
             return t[e].id
            }))), Object.keys(i).forEach((function(t) {
             i[t].forEach((function(t) {
              !t || t.isDisposed || a.has(t.id) || s.has(t.id) || -1 !== c.weightIds.indexOf(t.id) || t.dispose()
             }))
            })), [2, o]
          }
         }))
        }))
       }, t.prototype.executeWithControlFlow = function(t, e, n) {
        return s(this, void 0, void 0, (function() {
         var r, i, o, s, c, l, h, f, d, v, g, y, b, x, w, C, S = this;
         return u(this, (function(u) {
          switch (u.label) {
           case 0:
            r = Object.keys(t), i = r.map((function(t) {
             return S.graph.nodes[m(t)[0]]
            })), o = n.map((function(t) {
             return S.graph.nodes[m(t)[0]]
            })), s = Tt(t, o, this.weightMap), c = s.usedNodes, l = s.missingInputs, h = s.dynamicNode, f = s.syncInputs, d = i.concat(this.graph.weights).map((function(t) {
             return {
              node: t,
              contexts: e.currentContext
             }
            })), v = a({}, this.weightMap), Object.keys(t).forEach((function(e) {
             var n = m(e),
              r = n[0],
              i = [];
             i[n[1]] = t[e], v[r] = i
            })), g = {}, y = this.getFrozenTensorIds(v), b = {}, u.label = 1;
           case 1:
            return d.length > 0 ? (x = this.processStack(i, d, e, v, b, y, n, g, c), [4, Promise.all(x)]) : [3, 3];
           case 2:
            return u.sent(), [3, 1];
           case 3:
            if (null == h && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (w = o.filter((function(t) {
              return !Mt(t) && !p(t.name, v, e)
             })).map((function(t) {
              return t.name
             }))).length > 0) throw C = "", null != h && (C = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + f + "]"), new Error("Cannot compute the outputs [" + w + "] from the provided inputs [" + r + "]. Consider providing the following inputs: [" + l + "]. " + C);
            return [2, v]
          }
         }))
        }))
       }, t.prototype.processStack = function(t, e, n, r, i, o, a, s, u) {
        for (var c = this, l = [], p = function() {
          var p = e.pop();
          n.currentContext = p.contexts;
          var v = "";
          if ("Enter" === p.node.op && h("isConstant", p.node, r, n) && (v = d(p.node.name, n)[0]), -1 === t.indexOf(p.node)) {
           var m = Nt(p.node, r, n);
           v || (v = d(p.node.name, n)[0]);
           var g = n.currentContext;
           m instanceof Promise ? l.push(m.then((function(t) {
            return r[v] = t, n.currentContext = g, c.checkTensorForDisposal(v, p.node, r, n, o, a, s), c.processChildNodes(p.node, e, n, r, i, u), t
           }))) : (r[v] = m, f.checkTensorForDisposal(v, p.node, r, n, o, a, s), f.processChildNodes(p.node, e, n, r, i, u))
          } else f.processChildNodes(p.node, e, n, r, i, u)
         }, f = this; e.length > 0;) p();
        return l
       }, t.prototype.processChildNodes = function(t, e, n, r, i, o) {
        t.children.forEach((function(t) {
         var a = d(t.name, n)[0];
         !i[a] && o.has(t.name) && ("Merge" === t.op ? t.inputNames.some((function(t) {
          return !!p(t, r, n)
         })) && (i[a] = !0, e.push({
          contexts: n.currentContext,
          node: t
         })) : t.inputNames.every((function(t) {
          return !!p(t, r, n)
         })) && (i[a] = !0, e.push({
          contexts: n.currentContext,
          node: t
         })))
        }))
       }, t.prototype.dispose = function() {
        var t = this;
        Object.keys(this.weightMap).forEach((function(e) {
         return t.weightMap[e].forEach((function(t) {
          return t.dispose()
         }))
        }))
       }, t.prototype.checkInputShapeAndType = function(t) {
        var e = this;
        Object.keys(t).forEach((function(n) {
         var r = t[n],
          i = m(n)[0],
          a = e.graph.nodes[i];
         if (a.attrParams.shape && a.attrParams.shape.value) {
          var s = a.attrParams.shape.value,
           u = s.length === r.shape.length && r.shape.every((function(t, e) {
            return -1 === s[e] || s[e] === t
           }));
          o["util"].assert(u, (function() {
           return "The shape of dict['" + a.name + "'] provided in model.execute(dict) must be [" + s + "], but was [" + r.shape + "]"
          }))
         }
         a.attrParams.dtype && a.attrParams.dtype.value && o["util"].assert(r.dtype === a.attrParams.dtype.value, (function() {
          return "The dtype of dict['" + a.name + "'] provided in model.execute(dict) must be " + a.attrParams.dtype.value + ", but was " + r.dtype
         }))
        }))
       }, t.prototype.mapInputs = function(t) {
        var e = {};
        for (var n in t) null != this._signature && null != this._signature.inputs && null != this._signature.inputs[n] ? e[this._signature.inputs[n].name] = t[n] : e[n] = t[n];
        return e
       }, t.prototype.checkInputs = function(t) {
        var e = this,
         n = Object.keys(t).filter((function(t) {
          var n = m(t)[0];
          return null == e.graph.nodes[n]
         }));
        if (n.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + n + "] that are not part of graph")
       }, t.prototype.mapOutputs = function(t) {
        var e = this;
        return t.map((function(t) {
         return null != e._signature && null != e._signature.outputs && null != e._signature.outputs[t] ? e._signature.outputs[t].name : t
        }), {})
       }, t.prototype.checkOutputs = function(t) {
        var e = this;
        t.forEach((function(t) {
         var n = m(t)[0];
         if (!e.graph.nodes[n]) throw new Error("The output '" + t + "' is not found in the graph")
        }))
       }, t
      }(),
      Pt = "?tfjs-format=file",
      zt = "model.json",
      jt = function() {
       function t(t, e) {
        void 0 === e && (e = {}), this.modelUrl = t, this.loadOptions = e, this.version = "n/a", null == e && (this.loadOptions = {})
       }
       return Object.defineProperty(t.prototype, "modelVersion", {
        get: function() {
         return this.version
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "inputNodes", {
        get: function() {
         return this.executor.inputNodes
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "outputNodes", {
        get: function() {
         return this.executor.outputNodes
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "inputs", {
        get: function() {
         return this.executor.inputs
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "outputs", {
        get: function() {
         return this.executor.outputs
        },
        enumerable: !0,
        configurable: !0
       }), Object.defineProperty(t.prototype, "weights", {
        get: function() {
         return this.executor.weightMap
        },
        enumerable: !0,
        configurable: !0
       }), t.prototype.findIOHandler = function() {
        var t = this.modelUrl;
        if (null != t.load) this.handler = t;
        else if (null != this.loadOptions.requestInit) this.handler = o["io"].browserHTTPRequest(t, this.loadOptions);
        else {
         var e = o["io"].getLoadHandlers(t, this.loadOptions.onProgress);
         if (0 === e.length) e.push(o["io"].browserHTTPRequest(t, this.loadOptions));
         else if (e.length > 1) throw new Error("Found more than one (" + e.length + ") load handlers for URL '" + [t] + "'");
         this.handler = e[0]
        }
       }, t.prototype.load = function() {
        return s(this, void 0, void 0, (function() {
         var t, e, n, r;
         return u(this, (function(i) {
          switch (i.label) {
           case 0:
            if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return t = this, [4, this.handler.load()];
           case 1:
            return t.artifacts = i.sent(), e = this.artifacts.modelTopology, n = {}, null != this.artifacts.userDefinedMetadata && (n = this.artifacts.userDefinedMetadata.signature), this.version = e.versions.producer + "." + e.versions.minConsumer, r = o["io"].decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs), this.executor = new Bt(Y.Instance.transformGraph(e, n)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), [2, !0]
          }
         }))
        }))
       }, t.prototype.save = function(t, e) {
        return s(this, void 0, void 0, (function() {
         var e;
         return u(this, (function(n) {
          if ("string" == typeof t) {
           if (0 === (e = o["io"].getSaveHandlers(t)).length) throw new Error("Cannot find any save handlers for URL '" + t + "'");
           if (e.length > 1) throw new Error("Found more than one (" + e.length + ") save handlers for URL '" + t + "'");
           t = e[0]
          }
          if (null == t.save) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
          return [2, t.save(this.artifacts)]
         }))
        }))
       }, t.prototype.predict = function(t, e) {
        return this.execute(t, this.outputNodes)
       }, t.prototype.normalizeInputs = function(t) {
        if (!(t instanceof o["Tensor"] || Array.isArray(t))) return t;
        if ((t = Array.isArray(t) ? t : [t]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + t.length + " input tensors.");
        return this.inputNodes.reduce((function(e, n, r) {
         return e[n] = t[r], e
        }), {})
       }, t.prototype.normalizeOutputs = function(t) {
        return t = t || this.outputNodes, Array.isArray(t) ? t : [t]
       }, t.prototype.execute = function(t, e) {
        t = this.normalizeInputs(t), e = this.normalizeOutputs(e);
        var n = this.executor.execute(t, e);
        return n.length > 1 ? n : n[0]
       }, t.prototype.executeAsync = function(t, e) {
        return s(this, void 0, void 0, (function() {
         var n;
         return u(this, (function(r) {
          switch (r.label) {
           case 0:
            return t = this.normalizeInputs(t), e = this.normalizeOutputs(e), [4, this.executor.executeAsync(t, e)];
           case 1:
            return [2, (n = r.sent()).length > 1 ? n : n[0]]
          }
         }))
        }))
       }, t.prototype.convertTensorMapToTensorsMap = function(t) {
        return Object.keys(t).reduce((function(e, n) {
         return e[n] = [t[n]], e
        }), {})
       }, t.prototype.dispose = function() {
        this.executor.dispose()
       }, t
      }();
 
     function Wt(t, e) {
      return void 0 === e && (e = {}), s(this, void 0, void 0, (function() {
       var n;
       return u(this, (function(r) {
        switch (r.label) {
         case 0:
          if (null == t) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
          return null == e && (e = {}), e.fromTFHub && null == t.load && (t.endsWith("/") || (t += "/"), t = "" + t + zt + Pt), [4, (n = new jt(t, e)).load()];
         case 1:
          return r.sent(), [2, n]
        }
       }))
      }))
     }
     var Vt = "1.5.2"
    }).call(this, n("b639").Buffer)
   },
   b622: function(t, e, n) {
    var r = n("da84"),
     i = n("5692"),
     o = n("5135"),
     a = n("90e3"),
     s = n("4930"),
     u = n("fdbf"),
     c = i("wks"),
     l = r.Symbol,
     h = u ? l : l && l.withoutSetter || a;
    t.exports = function(t) {
     return o(c, t) || (s && o(l, t) ? c[t] = l[t] : c[t] = h("Symbol." + t)), c[t]
    }
   },
   b639: function(t, e, n) {
    "use strict";
    (function(t) {
     /*!
      * The buffer module from node.js, for the browser.
      *
      * @author   Feross Aboukhadijeh <http://feross.org>
      * @license  MIT
      */
     var r = n("1fb5"),
      i = n("9152"),
      o = n("e3db");
 
     function a() {
      try {
       var t = new Uint8Array(1);
       return t.__proto__ = {
        __proto__: Uint8Array.prototype,
        foo: function() {
         return 42
        }
       }, 42 === t.foo() && "function" === typeof t.subarray && 0 === t.subarray(1, 1).byteLength
      } catch (e) {
       return !1
      }
     }
 
     function s() {
      return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
     }
 
     function u(t, e) {
      if (s() < e) throw new RangeError("Invalid typed array length");
      return c.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e), t.__proto__ = c.prototype) : (null === t && (t = new c(e)), t.length = e), t
     }
 
     function c(t, e, n) {
      if (!c.TYPED_ARRAY_SUPPORT && !(this instanceof c)) return new c(t, e, n);
      if ("number" === typeof t) {
       if ("string" === typeof e) throw new Error("If encoding is specified then the first argument must be a string");
       return f(this, t)
      }
      return l(this, t, e, n)
     }
 
     function l(t, e, n, r) {
      if ("number" === typeof e) throw new TypeError('"value" argument must not be a number');
      return "undefined" !== typeof ArrayBuffer && e instanceof ArrayBuffer ? m(t, e, n, r) : "string" === typeof e ? d(t, e, n) : g(t, e)
     }
 
     function h(t) {
      if ("number" !== typeof t) throw new TypeError('"size" argument must be a number');
      if (t < 0) throw new RangeError('"size" argument must not be negative')
     }
 
     function p(t, e, n, r) {
      return h(e), e <= 0 ? u(t, e) : void 0 !== n ? "string" === typeof r ? u(t, e).fill(n, r) : u(t, e).fill(n) : u(t, e)
     }
 
     function f(t, e) {
      if (h(e), t = u(t, e < 0 ? 0 : 0 | y(e)), !c.TYPED_ARRAY_SUPPORT)
       for (var n = 0; n < e; ++n) t[n] = 0;
      return t
     }
 
     function d(t, e, n) {
      if ("string" === typeof n && "" !== n || (n = "utf8"), !c.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
      var r = 0 | x(e, n);
      t = u(t, r);
      var i = t.write(e, n);
      return i !== r && (t = t.slice(0, i)), t
     }
 
     function v(t, e) {
      var n = e.length < 0 ? 0 : 0 | y(e.length);
      t = u(t, n);
      for (var r = 0; r < n; r += 1) t[r] = 255 & e[r];
      return t
     }
 
     function m(t, e, n, r) {
      if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds");
      if (e.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds");
      return e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, n) : new Uint8Array(e, n, r), c.TYPED_ARRAY_SUPPORT ? (t = e, t.__proto__ = c.prototype) : t = v(t, e), t
     }
 
     function g(t, e) {
      if (c.isBuffer(e)) {
       var n = 0 | y(e.length);
       return t = u(t, n), 0 === t.length ? t : (e.copy(t, 0, 0, n), t)
      }
      if (e) {
       if ("undefined" !== typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" !== typeof e.length || et(e.length) ? u(t, 0) : v(t, e);
       if ("Buffer" === e.type && o(e.data)) return v(t, e.data)
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
     }
 
     function y(t) {
      if (t >= s()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
      return 0 | t
     }
 
     function b(t) {
      return +t != t && (t = 0), c.alloc(+t)
     }
 
     function x(t, e) {
      if (c.isBuffer(t)) return t.length;
      if ("undefined" !== typeof ArrayBuffer && "function" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
      "string" !== typeof t && (t = "" + t);
      var n = t.length;
      if (0 === n) return 0;
      for (var r = !1;;) switch (e) {
       case "ascii":
       case "latin1":
       case "binary":
        return n;
       case "utf8":
       case "utf-8":
       case void 0:
        return Y(t).length;
       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return 2 * n;
       case "hex":
        return n >>> 1;
       case "base64":
        return Q(t).length;
       default:
        if (r) return Y(t).length;
        e = ("" + e).toLowerCase(), r = !0
      }
     }
 
     function w(t, e, n) {
      var r = !1;
      if ((void 0 === e || e < 0) && (e = 0), e > this.length) return "";
      if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
      if (n >>>= 0, e >>>= 0, n <= e) return "";
      t || (t = "utf8");
      while (1) switch (t) {
       case "hex":
        return B(this, e, n);
       case "utf8":
       case "utf-8":
        return _(this, e, n);
       case "ascii":
        return M(this, e, n);
       case "latin1":
       case "binary":
        return L(this, e, n);
       case "base64":
        return T(this, e, n);
       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return P(this, e, n);
       default:
        if (r) throw new TypeError("Unknown encoding: " + t);
        t = (t + "").toLowerCase(), r = !0
      }
     }
 
     function C(t, e, n) {
      var r = t[e];
      t[e] = t[n], t[n] = r
     }
 
     function S(t, e, n, r, i) {
      if (0 === t.length) return -1;
      if ("string" === typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
       if (i) return -1;
       n = t.length - 1
      } else if (n < 0) {
       if (!i) return -1;
       n = 0
      }
      if ("string" === typeof e && (e = c.from(e, r)), c.isBuffer(e)) return 0 === e.length ? -1 : E(t, e, n, r, i);
      if ("number" === typeof e) return e &= 255, c.TYPED_ARRAY_SUPPORT && "function" === typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : E(t, [e], n, r, i);
      throw new TypeError("val must be string, number or Buffer")
     }
 
     function E(t, e, n, r, i) {
      var o, a = 1,
       s = t.length,
       u = e.length;
      if (void 0 !== r && (r = String(r).toLowerCase(), "ucs2" === r || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
       if (t.length < 2 || e.length < 2) return -1;
       a = 2, s /= 2, u /= 2, n /= 2
      }
 
      function c(t, e) {
       return 1 === a ? t[e] : t.readUInt16BE(e * a)
      }
      if (i) {
       var l = -1;
       for (o = n; o < s; o++)
        if (c(t, o) === c(e, -1 === l ? 0 : o - l)) {
         if (-1 === l && (l = o), o - l + 1 === u) return l * a
        } else -1 !== l && (o -= o - l), l = -1
      } else
       for (n + u > s && (n = s - u), o = n; o >= 0; o--) {
        for (var h = !0, p = 0; p < u; p++)
         if (c(t, o + p) !== c(e, p)) {
          h = !1;
          break
         } if (h) return o
       }
      return -1
     }
 
     function k(t, e, n, r) {
      n = Number(n) || 0;
      var i = t.length - n;
      r ? (r = Number(r), r > i && (r = i)) : r = i;
      var o = e.length;
      if (o % 2 !== 0) throw new TypeError("Invalid hex string");
      r > o / 2 && (r = o / 2);
      for (var a = 0; a < r; ++a) {
       var s = parseInt(e.substr(2 * a, 2), 16);
       if (isNaN(s)) return a;
       t[n + a] = s
      }
      return a
     }
 
     function I(t, e, n, r) {
      return tt(Y(e, t.length - n), t, n, r)
     }
 
     function O(t, e, n, r) {
      return tt(Z(e), t, n, r)
     }
 
     function A(t, e, n, r) {
      return O(t, e, n, r)
     }
 
     function N(t, e, n, r) {
      return tt(Q(e), t, n, r)
     }
 
     function R(t, e, n, r) {
      return tt(J(e, t.length - n), t, n, r)
     }
 
     function T(t, e, n) {
      return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n))
     }
 
     function _(t, e, n) {
      n = Math.min(t.length, n);
      var r = [],
       i = e;
      while (i < n) {
       var o, a, s, u, c = t[i],
        l = null,
        h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
       if (i + h <= n) switch (h) {
        case 1:
         c < 128 && (l = c);
         break;
        case 2:
         o = t[i + 1], 128 === (192 & o) && (u = (31 & c) << 6 | 63 & o, u > 127 && (l = u));
         break;
        case 3:
         o = t[i + 1], a = t[i + 2], 128 === (192 & o) && 128 === (192 & a) && (u = (15 & c) << 12 | (63 & o) << 6 | 63 & a, u > 2047 && (u < 55296 || u > 57343) && (l = u));
         break;
        case 4:
         o = t[i + 1], a = t[i + 2], s = t[i + 3], 128 === (192 & o) && 128 === (192 & a) && 128 === (192 & s) && (u = (15 & c) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s, u > 65535 && u < 1114112 && (l = u))
       }
       null === l ? (l = 65533, h = 1) : l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), i += h
      }
      return F(r)
     }
     e.Buffer = c, e.SlowBuffer = b, e.INSPECT_MAX_BYTES = 50, c.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : a(), e.kMaxLength = s(), c.poolSize = 8192, c._augment = function(t) {
      return t.__proto__ = c.prototype, t
     }, c.from = function(t, e, n) {
      return l(null, t, e, n)
     }, c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, "undefined" !== typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
      value: null,
      configurable: !0
     })), c.alloc = function(t, e, n) {
      return p(null, t, e, n)
     }, c.allocUnsafe = function(t) {
      return f(null, t)
     }, c.allocUnsafeSlow = function(t) {
      return f(null, t)
     }, c.isBuffer = function(t) {
      return !(null == t || !t._isBuffer)
     }, c.compare = function(t, e) {
      if (!c.isBuffer(t) || !c.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
      if (t === e) return 0;
      for (var n = t.length, r = e.length, i = 0, o = Math.min(n, r); i < o; ++i)
       if (t[i] !== e[i]) {
        n = t[i], r = e[i];
        break
       } return n < r ? -1 : r < n ? 1 : 0
     }, c.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
       case "hex":
       case "utf8":
       case "utf-8":
       case "ascii":
       case "latin1":
       case "binary":
       case "base64":
       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return !0;
       default:
        return !1
      }
     }, c.concat = function(t, e) {
      if (!o(t)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t.length) return c.alloc(0);
      var n;
      if (void 0 === e)
       for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
      var r = c.allocUnsafe(e),
       i = 0;
      for (n = 0; n < t.length; ++n) {
       var a = t[n];
       if (!c.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
       a.copy(r, i), i += a.length
      }
      return r
     }, c.byteLength = x, c.prototype._isBuffer = !0, c.prototype.swap16 = function() {
      var t = this.length;
      if (t % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var e = 0; e < t; e += 2) C(this, e, e + 1);
      return this
     }, c.prototype.swap32 = function() {
      var t = this.length;
      if (t % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var e = 0; e < t; e += 4) C(this, e, e + 3), C(this, e + 1, e + 2);
      return this
     }, c.prototype.swap64 = function() {
      var t = this.length;
      if (t % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var e = 0; e < t; e += 8) C(this, e, e + 7), C(this, e + 1, e + 6), C(this, e + 2, e + 5), C(this, e + 3, e + 4);
      return this
     }, c.prototype.toString = function() {
      var t = 0 | this.length;
      return 0 === t ? "" : 0 === arguments.length ? _(this, 0, t) : w.apply(this, arguments)
     }, c.prototype.equals = function(t) {
      if (!c.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
      return this === t || 0 === c.compare(this, t)
     }, c.prototype.inspect = function() {
      var t = "",
       n = e.INSPECT_MAX_BYTES;
      return this.length > 0 && (t = this.toString("hex", 0, n).match(/.{2}/g).join(" "), this.length > n && (t += " ... ")), "<Buffer " + t + ">"
     }, c.prototype.compare = function(t, e, n, r, i) {
      if (!c.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
      if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), e < 0 || n > t.length || r < 0 || i > this.length) throw new RangeError("out of range index");
      if (r >= i && e >= n) return 0;
      if (r >= i) return -1;
      if (e >= n) return 1;
      if (e >>>= 0, n >>>= 0, r >>>= 0, i >>>= 0, this === t) return 0;
      for (var o = i - r, a = n - e, s = Math.min(o, a), u = this.slice(r, i), l = t.slice(e, n), h = 0; h < s; ++h)
       if (u[h] !== l[h]) {
        o = u[h], a = l[h];
        break
       } return o < a ? -1 : a < o ? 1 : 0
     }, c.prototype.includes = function(t, e, n) {
      return -1 !== this.indexOf(t, e, n)
     }, c.prototype.indexOf = function(t, e, n) {
      return S(this, t, e, n, !0)
     }, c.prototype.lastIndexOf = function(t, e, n) {
      return S(this, t, e, n, !1)
     }, c.prototype.write = function(t, e, n, r) {
      if (void 0 === e) r = "utf8", n = this.length, e = 0;
      else if (void 0 === n && "string" === typeof e) r = e, n = this.length, e = 0;
      else {
       if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
       e |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0)
      }
      var i = this.length - e;
      if ((void 0 === n || n > i) && (n = i), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      r || (r = "utf8");
      for (var o = !1;;) switch (r) {
       case "hex":
        return k(this, t, e, n);
       case "utf8":
       case "utf-8":
        return I(this, t, e, n);
       case "ascii":
        return O(this, t, e, n);
       case "latin1":
       case "binary":
        return A(this, t, e, n);
       case "base64":
        return N(this, t, e, n);
       case "ucs2":
       case "ucs-2":
       case "utf16le":
       case "utf-16le":
        return R(this, t, e, n);
       default:
        if (o) throw new TypeError("Unknown encoding: " + r);
        r = ("" + r).toLowerCase(), o = !0
      }
     }, c.prototype.toJSON = function() {
      return {
       type: "Buffer",
       data: Array.prototype.slice.call(this._arr || this, 0)
      }
     };
     var D = 4096;
 
     function F(t) {
      var e = t.length;
      if (e <= D) return String.fromCharCode.apply(String, t);
      var n = "",
       r = 0;
      while (r < e) n += String.fromCharCode.apply(String, t.slice(r, r += D));
      return n
     }
 
     function M(t, e, n) {
      var r = "";
      n = Math.min(t.length, n);
      for (var i = e; i < n; ++i) r += String.fromCharCode(127 & t[i]);
      return r
     }
 
     function L(t, e, n) {
      var r = "";
      n = Math.min(t.length, n);
      for (var i = e; i < n; ++i) r += String.fromCharCode(t[i]);
      return r
     }
 
     function B(t, e, n) {
      var r = t.length;
      (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
      for (var i = "", o = e; o < n; ++o) i += X(t[o]);
      return i
     }
 
     function P(t, e, n) {
      for (var r = t.slice(e, n), i = "", o = 0; o < r.length; o += 2) i += String.fromCharCode(r[o] + 256 * r[o + 1]);
      return i
     }
 
     function z(t, e, n) {
      if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint");
      if (t + e > n) throw new RangeError("Trying to access beyond buffer length")
     }
 
     function j(t, e, n, r, i, o) {
      if (!c.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
      if (n + r > t.length) throw new RangeError("Index out of range")
     }
 
     function W(t, e, n, r) {
      e < 0 && (e = 65535 + e + 1);
      for (var i = 0, o = Math.min(t.length - n, 2); i < o; ++i) t[n + i] = (e & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i)
     }
 
     function V(t, e, n, r) {
      e < 0 && (e = 4294967295 + e + 1);
      for (var i = 0, o = Math.min(t.length - n, 4); i < o; ++i) t[n + i] = e >>> 8 * (r ? i : 3 - i) & 255
     }
 
     function U(t, e, n, r, i, o) {
      if (n + r > t.length) throw new RangeError("Index out of range");
      if (n < 0) throw new RangeError("Index out of range")
     }
 
     function H(t, e, n, r, o) {
      return o || U(t, e, n, 4, 34028234663852886e22, -34028234663852886e22), i.write(t, e, n, r, 23, 4), n + 4
     }
 
     function $(t, e, n, r, o) {
      return o || U(t, e, n, 8, 17976931348623157e292, -17976931348623157e292), i.write(t, e, n, r, 52, 8), n + 8
     }
     c.prototype.slice = function(t, e) {
      var n, r = this.length;
      if (t = ~~t, e = void 0 === e ? r : ~~e, t < 0 ? (t += r, t < 0 && (t = 0)) : t > r && (t = r), e < 0 ? (e += r, e < 0 && (e = 0)) : e > r && (e = r), e < t && (e = t), c.TYPED_ARRAY_SUPPORT) n = this.subarray(t, e), n.__proto__ = c.prototype;
      else {
       var i = e - t;
       n = new c(i, void 0);
       for (var o = 0; o < i; ++o) n[o] = this[o + t]
      }
      return n
     }, c.prototype.readUIntLE = function(t, e, n) {
      t |= 0, e |= 0, n || z(t, e, this.length);
      var r = this[t],
       i = 1,
       o = 0;
      while (++o < e && (i *= 256)) r += this[t + o] * i;
      return r
     }, c.prototype.readUIntBE = function(t, e, n) {
      t |= 0, e |= 0, n || z(t, e, this.length);
      var r = this[t + --e],
       i = 1;
      while (e > 0 && (i *= 256)) r += this[t + --e] * i;
      return r
     }, c.prototype.readUInt8 = function(t, e) {
      return e || z(t, 1, this.length), this[t]
     }, c.prototype.readUInt16LE = function(t, e) {
      return e || z(t, 2, this.length), this[t] | this[t + 1] << 8
     }, c.prototype.readUInt16BE = function(t, e) {
      return e || z(t, 2, this.length), this[t] << 8 | this[t + 1]
     }, c.prototype.readUInt32LE = function(t, e) {
      return e || z(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
     }, c.prototype.readUInt32BE = function(t, e) {
      return e || z(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
     }, c.prototype.readIntLE = function(t, e, n) {
      t |= 0, e |= 0, n || z(t, e, this.length);
      var r = this[t],
       i = 1,
       o = 0;
      while (++o < e && (i *= 256)) r += this[t + o] * i;
      return i *= 128, r >= i && (r -= Math.pow(2, 8 * e)), r
     }, c.prototype.readIntBE = function(t, e, n) {
      t |= 0, e |= 0, n || z(t, e, this.length);
      var r = e,
       i = 1,
       o = this[t + --r];
      while (r > 0 && (i *= 256)) o += this[t + --r] * i;
      return i *= 128, o >= i && (o -= Math.pow(2, 8 * e)), o
     }, c.prototype.readInt8 = function(t, e) {
      return e || z(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
     }, c.prototype.readInt16LE = function(t, e) {
      e || z(t, 2, this.length);
      var n = this[t] | this[t + 1] << 8;
      return 32768 & n ? 4294901760 | n : n
     }, c.prototype.readInt16BE = function(t, e) {
      e || z(t, 2, this.length);
      var n = this[t + 1] | this[t] << 8;
      return 32768 & n ? 4294901760 | n : n
     }, c.prototype.readInt32LE = function(t, e) {
      return e || z(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
     }, c.prototype.readInt32BE = function(t, e) {
      return e || z(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
     }, c.prototype.readFloatLE = function(t, e) {
      return e || z(t, 4, this.length), i.read(this, t, !0, 23, 4)
     }, c.prototype.readFloatBE = function(t, e) {
      return e || z(t, 4, this.length), i.read(this, t, !1, 23, 4)
     }, c.prototype.readDoubleLE = function(t, e) {
      return e || z(t, 8, this.length), i.read(this, t, !0, 52, 8)
     }, c.prototype.readDoubleBE = function(t, e) {
      return e || z(t, 8, this.length), i.read(this, t, !1, 52, 8)
     }, c.prototype.writeUIntLE = function(t, e, n, r) {
      if (t = +t, e |= 0, n |= 0, !r) {
       var i = Math.pow(2, 8 * n) - 1;
       j(this, t, e, n, i, 0)
      }
      var o = 1,
       a = 0;
      this[e] = 255 & t;
      while (++a < n && (o *= 256)) this[e + a] = t / o & 255;
      return e + n
     }, c.prototype.writeUIntBE = function(t, e, n, r) {
      if (t = +t, e |= 0, n |= 0, !r) {
       var i = Math.pow(2, 8 * n) - 1;
       j(this, t, e, n, i, 0)
      }
      var o = n - 1,
       a = 1;
      this[e + o] = 255 & t;
      while (--o >= 0 && (a *= 256)) this[e + o] = t / a & 255;
      return e + n
     }, c.prototype.writeUInt8 = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 1, 255, 0), c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1
     }, c.prototype.writeUInt16LE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : W(this, t, e, !0), e + 2
     }, c.prototype.writeUInt16BE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : W(this, t, e, !1), e + 2
     }, c.prototype.writeUInt32LE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : V(this, t, e, !0), e + 4
     }, c.prototype.writeUInt32BE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : V(this, t, e, !1), e + 4
     }, c.prototype.writeIntLE = function(t, e, n, r) {
      if (t = +t, e |= 0, !r) {
       var i = Math.pow(2, 8 * n - 1);
       j(this, t, e, n, i - 1, -i)
      }
      var o = 0,
       a = 1,
       s = 0;
      this[e] = 255 & t;
      while (++o < n && (a *= 256)) t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1), this[e + o] = (t / a >> 0) - s & 255;
      return e + n
     }, c.prototype.writeIntBE = function(t, e, n, r) {
      if (t = +t, e |= 0, !r) {
       var i = Math.pow(2, 8 * n - 1);
       j(this, t, e, n, i - 1, -i)
      }
      var o = n - 1,
       a = 1,
       s = 0;
      this[e + o] = 255 & t;
      while (--o >= 0 && (a *= 256)) t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1), this[e + o] = (t / a >> 0) - s & 255;
      return e + n
     }, c.prototype.writeInt8 = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 1, 127, -128), c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1
     }, c.prototype.writeInt16LE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : W(this, t, e, !0), e + 2
     }, c.prototype.writeInt16BE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : W(this, t, e, !1), e + 2
     }, c.prototype.writeInt32LE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 4, 2147483647, -2147483648), c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : V(this, t, e, !0), e + 4
     }, c.prototype.writeInt32BE = function(t, e, n) {
      return t = +t, e |= 0, n || j(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : V(this, t, e, !1), e + 4
     }, c.prototype.writeFloatLE = function(t, e, n) {
      return H(this, t, e, !0, n)
     }, c.prototype.writeFloatBE = function(t, e, n) {
      return H(this, t, e, !1, n)
     }, c.prototype.writeDoubleLE = function(t, e, n) {
      return $(this, t, e, !0, n)
     }, c.prototype.writeDoubleBE = function(t, e, n) {
      return $(this, t, e, !1, n)
     }, c.prototype.copy = function(t, e, n, r) {
      if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < n && (r = n), r === n) return 0;
      if (0 === t.length || 0 === this.length) return 0;
      if (e < 0) throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
      if (r < 0) throw new RangeError("sourceEnd out of bounds");
      r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n);
      var i, o = r - n;
      if (this === t && n < e && e < r)
       for (i = o - 1; i >= 0; --i) t[i + e] = this[i + n];
      else if (o < 1e3 || !c.TYPED_ARRAY_SUPPORT)
       for (i = 0; i < o; ++i) t[i + e] = this[i + n];
      else Uint8Array.prototype.set.call(t, this.subarray(n, n + o), e);
      return o
     }, c.prototype.fill = function(t, e, n, r) {
      if ("string" === typeof t) {
       if ("string" === typeof e ? (r = e, e = 0, n = this.length) : "string" === typeof n && (r = n, n = this.length), 1 === t.length) {
        var i = t.charCodeAt(0);
        i < 256 && (t = i)
       }
       if (void 0 !== r && "string" !== typeof r) throw new TypeError("encoding must be a string");
       if ("string" === typeof r && !c.isEncoding(r)) throw new TypeError("Unknown encoding: " + r)
      } else "number" === typeof t && (t &= 255);
      if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index");
      if (n <= e) return this;
      var o;
      if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" === typeof t)
       for (o = e; o < n; ++o) this[o] = t;
      else {
       var a = c.isBuffer(t) ? t : Y(new c(t, r).toString()),
        s = a.length;
       for (o = 0; o < n - e; ++o) this[o + e] = a[o % s]
      }
      return this
     };
     var G = /[^+\/0-9A-Za-z-_]/g;
 
     function q(t) {
      if (t = K(t).replace(G, ""), t.length < 2) return "";
      while (t.length % 4 !== 0) t += "=";
      return t
     }
 
     function K(t) {
      return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
     }
 
     function X(t) {
      return t < 16 ? "0" + t.toString(16) : t.toString(16)
     }
 
     function Y(t, e) {
      var n;
      e = e || 1 / 0;
      for (var r = t.length, i = null, o = [], a = 0; a < r; ++a) {
       if (n = t.charCodeAt(a), n > 55295 && n < 57344) {
        if (!i) {
         if (n > 56319) {
          (e -= 3) > -1 && o.push(239, 191, 189);
          continue
         }
         if (a + 1 === r) {
          (e -= 3) > -1 && o.push(239, 191, 189);
          continue
         }
         i = n;
         continue
        }
        if (n < 56320) {
         (e -= 3) > -1 && o.push(239, 191, 189), i = n;
         continue
        }
        n = 65536 + (i - 55296 << 10 | n - 56320)
       } else i && (e -= 3) > -1 && o.push(239, 191, 189);
       if (i = null, n < 128) {
        if ((e -= 1) < 0) break;
        o.push(n)
       } else if (n < 2048) {
        if ((e -= 2) < 0) break;
        o.push(n >> 6 | 192, 63 & n | 128)
       } else if (n < 65536) {
        if ((e -= 3) < 0) break;
        o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
       } else {
        if (!(n < 1114112)) throw new Error("Invalid code point");
        if ((e -= 4) < 0) break;
        o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
       }
      }
      return o
     }
 
     function Z(t) {
      for (var e = [], n = 0; n < t.length; ++n) e.push(255 & t.charCodeAt(n));
      return e
     }
 
     function J(t, e) {
      for (var n, r, i, o = [], a = 0; a < t.length; ++a) {
       if ((e -= 2) < 0) break;
       n = t.charCodeAt(a), r = n >> 8, i = n % 256, o.push(i), o.push(r)
      }
      return o
     }
 
     function Q(t) {
      return r.toByteArray(q(t))
     }
 
     function tt(t, e, n, r) {
      for (var i = 0; i < r; ++i) {
       if (i + n >= e.length || i >= t.length) break;
       e[i + n] = t[i]
      }
      return i
     }
 
     function et(t) {
      return t !== t
     }
    }).call(this, n("c8ba"))
   },
   b64b: function(t, e, n) {
    var r = n("23e7"),
     i = n("7b0b"),
     o = n("df75"),
     a = n("d039"),
     s = a((function() {
      o(1)
     }));
    r({
     target: "Object",
     stat: !0,
     forced: s
    }, {
     keys: function(t) {
      return o(i(t))
     }
    })
   },
   b680: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("a691"),
     o = n("408a"),
     a = n("1148"),
     s = n("d039"),
     u = 1..toFixed,
     c = Math.floor,
     l = function(t, e, n) {
      return 0 === e ? n : e % 2 === 1 ? l(t, e - 1, n * t) : l(t * t, e / 2, n)
     },
     h = function(t) {
      var e = 0,
       n = t;
      while (n >= 4096) e += 12, n /= 4096;
      while (n >= 2) e += 1, n /= 2;
      return e
     },
     p = u && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !s((function() {
      u.call({})
     }));
    r({
     target: "Number",
     proto: !0,
     forced: p
    }, {
     toFixed: function(t) {
      var e, n, r, s, u = o(this),
       p = i(t),
       f = [0, 0, 0, 0, 0, 0],
       d = "",
       v = "0",
       m = function(t, e) {
        var n = -1,
         r = e;
        while (++n < 6) r += t * f[n], f[n] = r % 1e7, r = c(r / 1e7)
       },
       g = function(t) {
        var e = 6,
         n = 0;
        while (--e >= 0) n += f[e], f[e] = c(n / t), n = n % t * 1e7
       },
       y = function() {
        var t = 6,
         e = "";
        while (--t >= 0)
         if ("" !== e || 0 === t || 0 !== f[t]) {
          var n = String(f[t]);
          e = "" === e ? n : e + a.call("0", 7 - n.length) + n
         } return e
       };
      if (p < 0 || p > 20) throw RangeError("Incorrect fraction digits");
      if (u != u) return "NaN";
      if (u <= -1e21 || u >= 1e21) return String(u);
      if (u < 0 && (d = "-", u = -u), u > 1e-21)
       if (e = h(u * l(2, 69, 1)) - 69, n = e < 0 ? u * l(2, -e, 1) : u / l(2, e, 1), n *= 4503599627370496, e = 52 - e, e > 0) {
        m(0, n), r = p;
        while (r >= 7) m(1e7, 0), r -= 7;
        m(l(10, r, 1), 0), r = e - 1;
        while (r >= 23) g(1 << 23), r -= 23;
        g(1 << r), m(1, 1), g(2), v = y()
       } else m(0, n), m(1 << -e, 0), v = y() + a.call("0", p);
      return p > 0 ? (s = v.length, v = d + (s <= p ? "0." + a.call("0", p - s) + v : v.slice(0, s - p) + "." + v.slice(s - p))) : v = d + v, v
     }
    })
   },
   b727: function(t, e, n) {
    var r = n("0366"),
     i = n("44ad"),
     o = n("7b0b"),
     a = n("50c4"),
     s = n("65f0"),
     u = [].push,
     c = function(t) {
      var e = 1 == t,
       n = 2 == t,
       c = 3 == t,
       l = 4 == t,
       h = 6 == t,
       p = 5 == t || h;
      return function(f, d, v, m) {
       for (var g, y, b = o(f), x = i(b), w = r(d, v, 3), C = a(x.length), S = 0, E = m || s, k = e ? E(f, C) : n ? E(f, 0) : void 0; C > S; S++)
        if ((p || S in x) && (g = x[S], y = w(g, S, b), t))
         if (e) k[S] = y;
         else if (y) switch (t) {
        case 3:
         return !0;
        case 5:
         return g;
        case 6:
         return S;
        case 2:
         u.call(k, g)
       } else if (l) return !1;
       return h ? -1 : c || l ? l : k
      }
     };
    t.exports = {
     forEach: c(0),
     map: c(1),
     filter: c(2),
     some: c(3),
     every: c(4),
     find: c(5),
     findIndex: c(6)
    }
   },
   b810: function(t, e, n) {
    "use strict";
    var r = n("ce7e");
    e["a"] = r["a"]
   },
   b848: function(t, e, n) {
    "use strict";
    var r = n("2909"),
     i = n("58df");
 
    function o(t) {
     for (var e = [], n = 0; n < t.length; n++) {
      var i = t[n];
      i.isActive && i.isDependent ? e.push(i) : e.push.apply(e, Object(r["a"])(o(i.$children)))
     }
     return e
    }
    e["a"] = Object(i["a"])().extend({
     name: "dependent",
     data: function() {
      return {
       closeDependents: !0,
       isActive: !1,
       isDependent: !0
      }
     },
     watch: {
      isActive: function(t) {
       if (!t)
        for (var e = this.getOpenDependents(), n = 0; n < e.length; n++) e[n].isActive = !1
      }
     },
     methods: {
      getOpenDependents: function() {
       return this.closeDependents ? o(this.$children) : []
      },
      getOpenDependentElements: function() {
       for (var t = [], e = this.getOpenDependents(), n = 0; n < e.length; n++) t.push.apply(t, Object(r["a"])(e[n].getClickableDependentElements()));
       return t
      },
      getClickableDependentElements: function() {
       var t = [this.$el];
       return this.$refs.content && t.push(this.$refs.content), this.overlay && t.push(this.overlay.$el), t.push.apply(t, Object(r["a"])(this.getOpenDependentElements())), t
      }
     }
    })
   },
   b974: function(t, e, n) {
    "use strict";
    n("a4d3"), n("e01a"), n("d28b"), n("99af"), n("4de4"), n("c740"), n("a630"), n("caad"), n("d81d"), n("13d5"), n("fb6a"), n("a434"), n("b0c0"), n("4ec9"), n("d3b7"), n("ac1f"), n("25f0"), n("2532"), n("3ca3"), n("1276"), n("2ca0"), n("498a"), n("ddb0");
    var r = n("ade3"),
     i = n("5530"),
     o = (n("4ff9"), n("68dd"), n("4160"), n("3835")),
     a = (n("8adc"), n("58df")),
     s = n("0789"),
     u = n("9d26"),
     c = n("a9ad"),
     l = n("4e82"),
     h = n("7560"),
     p = n("f2e7"),
     f = n("1c87"),
     d = n("af2b"),
     v = n("d9bd"),
     m = Object(a["a"])(c["a"], d["a"], f["a"], h["a"], Object(l["a"])("chipGroup"), Object(p["b"])("inputValue")).extend({
      name: "v-chip",
      props: {
       active: {
        type: Boolean,
        default: !0
       },
       activeClass: {
        type: String,
        default: function() {
         return this.chipGroup ? this.chipGroup.activeClass : ""
        }
       },
       close: Boolean,
       closeIcon: {
        type: String,
        default: "$delete"
       },
       disabled: Boolean,
       draggable: Boolean,
       filter: Boolean,
       filterIcon: {
        type: String,
        default: "$complete"
       },
       label: Boolean,
       link: Boolean,
       outlined: Boolean,
       pill: Boolean,
       tag: {
        type: String,
        default: "span"
       },
       textColor: String,
       value: null
      },
      data: function() {
       return {
        proxyClass: "v-chip--active"
       }
      },
      computed: {
       classes: function() {
        return Object(i["a"])({
         "v-chip": !0
        }, f["a"].options.computed.classes.call(this), {
         "v-chip--clickable": this.isClickable,
         "v-chip--disabled": this.disabled,
         "v-chip--draggable": this.draggable,
         "v-chip--label": this.label,
         "v-chip--link": this.isLink,
         "v-chip--no-color": !this.color,
         "v-chip--outlined": this.outlined,
         "v-chip--pill": this.pill,
         "v-chip--removable": this.hasClose
        }, this.themeClasses, {}, this.sizeableClasses, {}, this.groupClasses)
       },
       hasClose: function() {
        return Boolean(this.close)
       },
       isClickable: function() {
        return Boolean(f["a"].options.computed.isClickable.call(this) || this.chipGroup)
       }
      },
      created: function() {
       var t = this,
        e = [
         ["outline", "outlined"],
         ["selected", "input-value"],
         ["value", "active"],
         ["@input", "@active.sync"]
        ];
       e.forEach((function(e) {
        var n = Object(o["a"])(e, 2),
         r = n[0],
         i = n[1];
        t.$attrs.hasOwnProperty(r) && Object(v["a"])(r, i, t)
       }))
      },
      methods: {
       click: function(t) {
        this.$emit("click", t), this.chipGroup && this.toggle()
       },
       genFilter: function() {
        var t = [];
        return this.isActive && t.push(this.$createElement(u["a"], {
         staticClass: "v-chip__filter",
         props: {
          left: !0
         }
        }, this.filterIcon)), this.$createElement(s["b"], t)
       },
       genClose: function() {
        var t = this;
        return this.$createElement(u["a"], {
         staticClass: "v-chip__close",
         props: {
          right: !0
         },
         on: {
          click: function(e) {
           e.stopPropagation(), e.preventDefault(), t.$emit("click:close"), t.$emit("update:active", !1)
          }
         }
        }, this.closeIcon)
       },
       genContent: function() {
        return this.$createElement("span", {
         staticClass: "v-chip__content"
        }, [this.filter && this.genFilter(), this.$slots.default, this.hasClose && this.genClose()])
       }
      },
      render: function(t) {
       var e = [this.genContent()],
        n = this.generateRouteLink(),
        r = n.tag,
        o = n.data;
       o.attrs = Object(i["a"])({}, o.attrs, {
        draggable: this.draggable ? "true" : void 0,
        tabindex: this.chipGroup && !this.disabled ? 0 : o.attrs.tabindex
       }), o.directives.push({
        name: "show",
        value: this.active
       }), o = this.setBackgroundColor(this.color, o);
       var a = this.textColor || this.outlined && this.color;
       return t(r, this.setTextColor(a, o), e)
      }
     }),
     g = m,
     y = (n("7db0"), n("c975"), n("a9e3"), n("2909")),
     b = (n("ee6f"), n("480e")),
     x = n("4ad4"),
     w = n("16b7"),
     C = n("b848"),
     S = n("75eb"),
     E = n("fe6c"),
     k = n("21be"),
     I = n("80d2"),
     O = Object(a["a"])(k["a"], E["a"], x["a"]),
     A = O.extend().extend({
      name: "menuable",
      props: {
       allowOverflow: Boolean,
       light: Boolean,
       dark: Boolean,
       maxWidth: {
        type: [Number, String],
        default: "auto"
       },
       minWidth: [Number, String],
       nudgeBottom: {
        type: [Number, String],
        default: 0
       },
       nudgeLeft: {
        type: [Number, String],
        default: 0
       },
       nudgeRight: {
        type: [Number, String],
        default: 0
       },
       nudgeTop: {
        type: [Number, String],
        default: 0
       },
       nudgeWidth: {
        type: [Number, String],
        default: 0
       },
       offsetOverflow: Boolean,
       openOnClick: Boolean,
       positionX: {
        type: Number,
        default: null
       },
       positionY: {
        type: Number,
        default: null
       },
       zIndex: {
        type: [Number, String],
        default: null
       }
      },
      data: function() {
       return {
        absoluteX: 0,
        absoluteY: 0,
        activatedBy: null,
        activatorFixed: !1,
        dimensions: {
         activator: {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0,
          offsetTop: 0,
          scrollHeight: 0,
          offsetLeft: 0
         },
         content: {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0,
          offsetTop: 0,
          scrollHeight: 0
         }
        },
        hasJustFocused: !1,
        hasWindow: !1,
        inputActivator: !1,
        isContentActive: !1,
        pageWidth: 0,
        pageYOffset: 0,
        stackClass: "v-menu__content--active",
        stackMinZIndex: 6
       }
      },
      computed: {
       computedLeft: function() {
        var t = this.dimensions.activator,
         e = this.dimensions.content,
         n = (!1 !== this.attach ? t.offsetLeft : t.left) || 0,
         r = Math.max(t.width, e.width),
         i = 0;
        if (i += this.left ? n - (r - t.width) : n, this.offsetX) {
         var o = isNaN(Number(this.maxWidth)) ? t.width : Math.min(t.width, Number(this.maxWidth));
         i += this.left ? -o : t.width
        }
        return this.nudgeLeft && (i -= parseInt(this.nudgeLeft)), this.nudgeRight && (i += parseInt(this.nudgeRight)), i
       },
       computedTop: function() {
        var t = this.dimensions.activator,
         e = this.dimensions.content,
         n = 0;
        return this.top && (n += t.height - e.height), !1 !== this.attach ? n += t.offsetTop : n += t.top + this.pageYOffset, this.offsetY && (n += this.top ? -t.height : t.height), this.nudgeTop && (n -= parseInt(this.nudgeTop)), this.nudgeBottom && (n += parseInt(this.nudgeBottom)), n
       },
       hasActivator: function() {
        return !!this.$slots.activator || !!this.$scopedSlots.activator || !!this.activator || !!this.inputActivator
       }
      },
      watch: {
       disabled: function(t) {
        t && this.callDeactivate()
       },
       isActive: function(t) {
        this.disabled || (t ? this.callActivate() : this.callDeactivate())
       },
       positionX: "updateDimensions",
       positionY: "updateDimensions"
      },
      beforeMount: function() {
       this.hasWindow = "undefined" !== typeof window
      },
      methods: {
       absolutePosition: function() {
        return {
         offsetTop: 0,
         offsetLeft: 0,
         scrollHeight: 0,
         top: this.positionY || this.absoluteY,
         bottom: this.positionY || this.absoluteY,
         left: this.positionX || this.absoluteX,
         right: this.positionX || this.absoluteX,
         height: 0,
         width: 0
        }
       },
       activate: function() {},
       calcLeft: function(t) {
        return Object(I["f"])(!1 !== this.attach ? this.computedLeft : this.calcXOverflow(this.computedLeft, t))
       },
       calcTop: function() {
        return Object(I["f"])(!1 !== this.attach ? this.computedTop : this.calcYOverflow(this.computedTop))
       },
       calcXOverflow: function(t, e) {
        var n = t + e - this.pageWidth + 12;
        return t = (!this.left || this.right) && n > 0 ? Math.max(t - n, 0) : Math.max(t, 12), t + this.getOffsetLeft()
       },
       calcYOverflow: function(t) {
        var e = this.getInnerHeight(),
         n = this.pageYOffset + e,
         r = this.dimensions.activator,
         i = this.dimensions.content.height,
         o = t + i,
         a = n < o;
        return a && this.offsetOverflow && r.top > i ? t = this.pageYOffset + (r.top - i) : a && !this.allowOverflow ? t = n - i - 12 : t < this.pageYOffset && !this.allowOverflow && (t = this.pageYOffset + 12), t < 12 ? 12 : t
       },
       callActivate: function() {
        this.hasWindow && this.activate()
       },
       callDeactivate: function() {
        this.isContentActive = !1, this.deactivate()
       },
       checkForPageYOffset: function() {
        this.hasWindow && (this.pageYOffset = this.activatorFixed ? 0 : this.getOffsetTop())
       },
       checkActivatorFixed: function() {
        if (!1 === this.attach) {
         var t = this.getActivator();
         while (t) {
          if ("fixed" === window.getComputedStyle(t).position) return void(this.activatorFixed = !0);
          t = t.offsetParent
         }
         this.activatorFixed = !1
        }
       },
       deactivate: function() {},
       genActivatorListeners: function() {
        var t = this,
         e = x["a"].options.methods.genActivatorListeners.call(this),
         n = e.click;
        return e.click = function(e) {
         t.openOnClick && n && n(e), t.absoluteX = e.clientX, t.absoluteY = e.clientY
        }, e
       },
       getInnerHeight: function() {
        return this.hasWindow ? window.innerHeight || document.documentElement.clientHeight : 0
       },
       getOffsetLeft: function() {
        return this.hasWindow ? window.pageXOffset || document.documentElement.scrollLeft : 0
       },
       getOffsetTop: function() {
        return this.hasWindow ? window.pageYOffset || document.documentElement.scrollTop : 0
       },
       getRoundedBoundedClientRect: function(t) {
        var e = t.getBoundingClientRect();
        return {
         top: Math.round(e.top),
         left: Math.round(e.left),
         bottom: Math.round(e.bottom),
         right: Math.round(e.right),
         width: Math.round(e.width),
         height: Math.round(e.height)
        }
       },
       measure: function(t) {
        if (!t || !this.hasWindow) return null;
        var e = this.getRoundedBoundedClientRect(t);
        if (!1 !== this.attach) {
         var n = window.getComputedStyle(t);
         e.left = parseInt(n.marginLeft), e.top = parseInt(n.marginTop)
        }
        return e
       },
       sneakPeek: function(t) {
        var e = this;
        requestAnimationFrame((function() {
         var n = e.$refs.content;
         n && "none" === n.style.display ? (n.style.display = "inline-block", t(), n.style.display = "none") : t()
        }))
       },
       startTransition: function() {
        var t = this;
        return new Promise((function(e) {
         return requestAnimationFrame((function() {
          t.isContentActive = t.hasJustFocused = t.isActive, e()
         }))
        }))
       },
       updateDimensions: function() {
        var t = this;
        this.hasWindow = "undefined" !== typeof window, this.checkActivatorFixed(), this.checkForPageYOffset(), this.pageWidth = document.documentElement.clientWidth;
        var e = {};
        if (!this.hasActivator || this.absolute) e.activator = this.absolutePosition();
        else {
         var n = this.getActivator();
         if (!n) return;
         e.activator = this.measure(n), e.activator.offsetLeft = n.offsetLeft, !1 !== this.attach ? e.activator.offsetTop = n.offsetTop : e.activator.offsetTop = 0
        }
        this.sneakPeek((function() {
         e.content = t.measure(t.$refs.content), t.dimensions = e
        }))
       }
      }
     }),
     N = n("e4d3"),
     R = n("a293"),
     T = n("dc22"),
     _ = Object(a["a"])(C["a"], w["a"], S["a"], A, N["a"], p["a"], h["a"]),
     D = _.extend({
      name: "v-menu",
      provide: function() {
       return {
        isInMenu: !0,
        theme: this.theme
       }
      },
      directives: {
       ClickOutside: R["a"],
       Resize: T["a"]
      },
      props: {
       auto: Boolean,
       closeOnClick: {
        type: Boolean,
        default: !0
       },
       closeOnContentClick: {
        type: Boolean,
        default: !0
       },
       disabled: Boolean,
       disableKeys: Boolean,
       maxHeight: {
        type: [Number, String],
        default: "auto"
       },
       offsetX: Boolean,
       offsetY: Boolean,
       openOnClick: {
        type: Boolean,
        default: !0
       },
       openOnHover: Boolean,
       origin: {
        type: String,
        default: "top left"
       },
       transition: {
        type: [Boolean, String],
        default: "v-menu-transition"
       }
      },
      data: function() {
       return {
        calculatedTopAuto: 0,
        defaultOffset: 8,
        hasJustFocused: !1,
        listIndex: -1,
        resizeTimeout: 0,
        selectedIndex: null,
        tiles: []
       }
      },
      computed: {
       activeTile: function() {
        return this.tiles[this.listIndex]
       },
       calculatedLeft: function() {
        var t = Math.max(this.dimensions.content.width, parseFloat(this.calculatedMinWidth));
        return this.auto ? Object(I["f"])(this.calcXOverflow(this.calcLeftAuto(), t)) || "0" : this.calcLeft(t) || "0"
       },
       calculatedMaxHeight: function() {
        var t = this.auto ? "200px" : Object(I["f"])(this.maxHeight);
        return t || "0"
       },
       calculatedMaxWidth: function() {
        return Object(I["f"])(this.maxWidth) || "0"
       },
       calculatedMinWidth: function() {
        if (this.minWidth) return Object(I["f"])(this.minWidth) || "0";
        var t = Math.min(this.dimensions.activator.width + Number(this.nudgeWidth) + (this.auto ? 16 : 0), Math.max(this.pageWidth - 24, 0)),
         e = isNaN(parseInt(this.calculatedMaxWidth)) ? t : parseInt(this.calculatedMaxWidth);
        return Object(I["f"])(Math.min(e, t)) || "0"
       },
       calculatedTop: function() {
        var t = this.auto ? Object(I["f"])(this.calcYOverflow(this.calculatedTopAuto)) : this.calcTop();
        return t || "0"
       },
       hasClickableTiles: function() {
        return Boolean(this.tiles.find((function(t) {
         return t.tabIndex > -1
        })))
       },
       styles: function() {
        return {
         maxHeight: this.calculatedMaxHeight,
         minWidth: this.calculatedMinWidth,
         maxWidth: this.calculatedMaxWidth,
         top: this.calculatedTop,
         left: this.calculatedLeft,
         transformOrigin: this.origin,
         zIndex: this.zIndex || this.activeZIndex
        }
       }
      },
      watch: {
       isActive: function(t) {
        t || (this.listIndex = -1)
       },
       isContentActive: function(t) {
        this.hasJustFocused = t
       },
       listIndex: function(t, e) {
        if (t in this.tiles) {
         var n = this.tiles[t];
         n.classList.add("v-list-item--highlighted"), this.$refs.content.scrollTop = n.offsetTop - n.clientHeight
        }
        e in this.tiles && this.tiles[e].classList.remove("v-list-item--highlighted")
       }
      },
      created: function() {
       this.$attrs.hasOwnProperty("full-width") && Object(v["d"])("full-width", this)
      },
      mounted: function() {
       this.isActive && this.callActivate()
      },
      methods: {
       activate: function() {
        var t = this;
        this.updateDimensions(), requestAnimationFrame((function() {
         t.startTransition().then((function() {
          t.$refs.content && (t.calculatedTopAuto = t.calcTopAuto(), t.auto && (t.$refs.content.scrollTop = t.calcScrollPosition()))
         }))
        }))
       },
       calcScrollPosition: function() {
        var t = this.$refs.content,
         e = t.querySelector(".v-list-item--active"),
         n = t.scrollHeight - t.offsetHeight;
        return e ? Math.min(n, Math.max(0, e.offsetTop - t.offsetHeight / 2 + e.offsetHeight / 2)) : t.scrollTop
       },
       calcLeftAuto: function() {
        return parseInt(this.dimensions.activator.left - 2 * this.defaultOffset)
       },
       calcTopAuto: function() {
        var t = this.$refs.content,
         e = t.querySelector(".v-list-item--active");
        if (e || (this.selectedIndex = null), this.offsetY || !e) return this.computedTop;
        this.selectedIndex = Array.from(this.tiles).indexOf(e);
        var n = e.offsetTop - this.calcScrollPosition(),
         r = t.querySelector(".v-list-item").offsetTop;
        return this.computedTop - n - r - 1
       },
       changeListIndex: function(t) {
        if (this.getTiles(), this.isActive && this.hasClickableTiles)
         if (t.keyCode !== I["q"].tab) {
          if (t.keyCode === I["q"].down) this.nextTile();
          else if (t.keyCode === I["q"].up) this.prevTile();
          else {
           if (t.keyCode !== I["q"].enter || -1 === this.listIndex) return;
           this.tiles[this.listIndex].click()
          }
          t.preventDefault()
         } else this.isActive = !1
       },
       closeConditional: function(t) {
        var e = t.target;
        return this.isActive && !this._isDestroyed && this.closeOnClick && !this.$refs.content.contains(e)
       },
       genActivatorAttributes: function() {
        var t = x["a"].options.methods.genActivatorAttributes.call(this);
        return this.activeTile && this.activeTile.id ? Object(i["a"])({}, t, {
         "aria-activedescendant": this.activeTile.id
        }) : t
       },
       genActivatorListeners: function() {
        var t = A.options.methods.genActivatorListeners.call(this);
        return this.disableKeys || (t.keydown = this.onKeyDown), t
       },
       genTransition: function() {
        var t = this.genContent();
        return this.transition ? this.$createElement("transition", {
         props: {
          name: this.transition
         }
        }, this.showLazyContent((function() {
         return [t]
        }))) : t
       },
       genDirectives: function() {
        var t = this,
         e = [{
          name: "show",
          value: this.isContentActive
         }];
        return !this.openOnHover && this.closeOnClick && e.push({
         name: "click-outside",
         value: function() {
          t.isActive = !1
         },
         args: {
          closeConditional: this.closeConditional,
          include: function() {
           return [t.$el].concat(Object(y["a"])(t.getOpenDependentElements()))
          }
         }
        }), e
       },
       genContent: function() {
        var t = this,
         e = {
          attrs: Object(i["a"])({}, this.getScopeIdAttrs(), {
           role: "role" in this.$attrs ? this.$attrs.role : "menu"
          }),
          staticClass: "v-menu__content",
          class: Object(i["a"])({}, this.rootThemeClasses, Object(r["a"])({
           "v-menu__content--auto": this.auto,
           "v-menu__content--fixed": this.activatorFixed,
           menuable__content__active: this.isActive
          }, this.contentClass.trim(), !0)),
          style: this.styles,
          directives: this.genDirectives(),
          ref: "content",
          on: {
           click: function(e) {
            var n = e.target;
            n.getAttribute("disabled") || t.closeOnContentClick && (t.isActive = !1)
           },
           keydown: this.onKeyDown
          }
         };
        return !this.disabled && this.openOnHover && (e.on = e.on || {}, e.on.mouseenter = this.mouseEnterHandler), this.openOnHover && (e.on = e.on || {}, e.on.mouseleave = this.mouseLeaveHandler), this.$createElement("div", e, [this.$createElement(b["a"], {
         props: {
          root: !0,
          light: this.light,
          dark: this.dark
         }
        }, this.getContentSlot())])
       },
       getTiles: function() {
        this.$refs.content && (this.tiles = Array.from(this.$refs.content.querySelectorAll(".v-list-item")))
       },
       mouseEnterHandler: function() {
        var t = this;
        this.runDelay("open", (function() {
         t.hasJustFocused || (t.hasJustFocused = !0, t.isActive = !0)
        }))
       },
       mouseLeaveHandler: function(t) {
        var e = this;
        this.runDelay("close", (function() {
         e.$refs.content.contains(t.relatedTarget) || requestAnimationFrame((function() {
          e.isActive = !1, e.callDeactivate()
         }))
        }))
       },
       nextTile: function() {
        var t = this.tiles[this.listIndex + 1];
        if (!t) {
         if (!this.tiles.length) return;
         return this.listIndex = -1, void this.nextTile()
        }
        this.listIndex++, -1 === t.tabIndex && this.nextTile()
       },
       prevTile: function() {
        var t = this.tiles[this.listIndex - 1];
        if (!t) {
         if (!this.tiles.length) return;
         return this.listIndex = this.tiles.length, void this.prevTile()
        }
        this.listIndex--, -1 === t.tabIndex && this.prevTile()
       },
       onKeyDown: function(t) {
        var e = this;
        if (t.keyCode === I["q"].esc) {
         setTimeout((function() {
          e.isActive = !1
         }));
         var n = this.getActivator();
         this.$nextTick((function() {
          return n && n.focus()
         }))
        } else !this.isActive && [I["q"].up, I["q"].down].includes(t.keyCode) && (this.isActive = !0);
        this.$nextTick((function() {
         return e.changeListIndex(t)
        }))
       },
       onResize: function() {
        this.isActive && (this.$refs.content.offsetWidth, this.updateDimensions(), clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.updateDimensions, 100))
       }
      },
      render: function(t) {
       var e = {
        staticClass: "v-menu",
        class: {
         "v-menu--attached": "" === this.attach || !0 === this.attach || "attach" === this.attach
        },
        directives: [{
         arg: "500",
         name: "resize",
         value: this.onResize
        }]
       };
       return t("div", e, [!this.activator && this.genActivator(), this.genTransition()])
      }
     }),
     F = D,
     M = (n("a15b"), n("b64b"), n("159b"), n("cf36"), n("5607")),
     L = n("2b0e"),
     B = n("132d"),
     P = L["a"].extend({
      name: "v-simple-checkbox",
      functional: !0,
      directives: {
       ripple: M["a"]
      },
      props: Object(i["a"])({}, c["a"].options.props, {}, h["a"].options.props, {
       disabled: Boolean,
       ripple: {
        type: Boolean,
        default: !0
       },
       value: Boolean,
       indeterminate: Boolean,
       indeterminateIcon: {
        type: String,
        default: "$checkboxIndeterminate"
       },
       onIcon: {
        type: String,
        default: "$checkboxOn"
       },
       offIcon: {
        type: String,
        default: "$checkboxOff"
       }
      }),
      render: function(t, e) {
       var n = e.props,
        r = e.data,
        o = [];
       if (n.ripple && !n.disabled) {
        var a = t("div", c["a"].options.methods.setTextColor(n.color, {
         staticClass: "v-input--selection-controls__ripple",
         directives: [{
          name: "ripple",
          value: {
           center: !0
          }
         }]
        }));
        o.push(a)
       }
       var s = n.offIcon;
       n.indeterminate ? s = n.indeterminateIcon : n.value && (s = n.onIcon), o.push(t(B["a"], c["a"].options.methods.setTextColor(n.value && n.color, {
        props: {
         disabled: n.disabled,
         dark: n.dark,
         light: n.light
        }
       }), s));
       var u = {
        "v-simple-checkbox": !0,
        "v-simple-checkbox--disabled": n.disabled
       };
       return t("div", Object(i["a"])({}, r, {
        class: u,
        on: {
         click: function(t) {
          t.stopPropagation(), r.on && r.on.input && !n.disabled && Object(I["w"])(r.on.input).forEach((function(t) {
           return t(!n.value)
          }))
         }
        }
       }), o)
      }
     }),
     z = n("b810"),
     j = n("24e2"),
     W = n("da13"),
     V = n("1800"),
     U = n("5d23"),
     H = n("8860"),
     $ = Object(a["a"])(c["a"], h["a"]).extend({
      name: "v-select-list",
      directives: {
       ripple: M["a"]
      },
      props: {
       action: Boolean,
       dense: Boolean,
       hideSelected: Boolean,
       items: {
        type: Array,
        default: function() {
         return []
        }
       },
       itemDisabled: {
        type: [String, Array, Function],
        default: "disabled"
       },
       itemText: {
        type: [String, Array, Function],
        default: "text"
       },
       itemValue: {
        type: [String, Array, Function],
        default: "value"
       },
       noDataText: String,
       noFilter: Boolean,
       searchInput: null,
       selectedItems: {
        type: Array,
        default: function() {
         return []
        }
       }
      },
      computed: {
       parsedItems: function() {
        var t = this;
        return this.selectedItems.map((function(e) {
         return t.getValue(e)
        }))
       },
       tileActiveClass: function() {
        return Object.keys(this.setTextColor(this.color).class || {}).join(" ")
       },
       staticNoDataTile: function() {
        var t = {
         attrs: {
          role: void 0
         },
         on: {
          mousedown: function(t) {
           return t.preventDefault()
          }
         }
        };
        return this.$createElement(W["a"], t, [this.genTileContent(this.noDataText)])
       }
      },
      methods: {
       genAction: function(t, e) {
        var n = this;
        return this.$createElement(V["a"], [this.$createElement(P, {
         props: {
          color: this.color,
          value: e
         },
         on: {
          input: function() {
           return n.$emit("select", t)
          }
         }
        })])
       },
       genDivider: function(t) {
        return this.$createElement(z["a"], {
         props: t
        })
       },
       genFilteredText: function(t) {
        if (t = t || "", !this.searchInput || this.noFilter) return Object(I["i"])(t);
        var e = this.getMaskedCharacters(t),
         n = e.start,
         r = e.middle,
         i = e.end;
        return "".concat(Object(I["i"])(n)).concat(this.genHighlight(r)).concat(Object(I["i"])(i))
       },
       genHeader: function(t) {
        return this.$createElement(j["a"], {
         props: t
        }, t.header)
       },
       genHighlight: function(t) {
        return '<span class="v-list-item__mask">'.concat(Object(I["i"])(t), "</span>")
       },
       getMaskedCharacters: function(t) {
        var e = (this.searchInput || "").toString().toLocaleLowerCase(),
         n = t.toLocaleLowerCase().indexOf(e);
        if (n < 0) return {
         start: "",
         middle: t,
         end: ""
        };
        var r = t.slice(0, n),
         i = t.slice(n, n + e.length),
         o = t.slice(n + e.length);
        return {
         start: r,
         middle: i,
         end: o
        }
       },
       genTile: function(t) {
        var e = this,
         n = t.item,
         r = t.index,
         o = t.disabled,
         a = void 0 === o ? null : o,
         s = t.value,
         u = void 0 !== s && s;
        u || (u = this.hasItem(n)), n === Object(n) && (a = null !== a ? a : this.getDisabled(n));
        var c = {
         attrs: {
          "aria-selected": String(u),
          id: "list-item-".concat(this._uid, "-").concat(r),
          role: "option"
         },
         on: {
          mousedown: function(t) {
           t.preventDefault()
          },
          click: function() {
           return a || e.$emit("select", n)
          }
         },
         props: {
          activeClass: this.tileActiveClass,
          disabled: a,
          ripple: !0,
          inputValue: u
         }
        };
        if (!this.$scopedSlots.item) return this.$createElement(W["a"], c, [this.action && !this.hideSelected && this.items.length > 0 ? this.genAction(n, u) : null, this.genTileContent(n, r)]);
        var l = this,
         h = this.$scopedSlots.item({
          parent: l,
          item: n,
          attrs: Object(i["a"])({}, c.attrs, {}, c.props),
          on: c.on
         });
        return this.needsTile(h) ? this.$createElement(W["a"], c, h) : h
       },
       genTileContent: function(t) {
        arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        var e = this.genFilteredText(this.getText(t));
        return this.$createElement(U["a"], [this.$createElement(U["b"], {
         domProps: {
          innerHTML: e
         }
        })])
       },
       hasItem: function(t) {
        return this.parsedItems.indexOf(this.getValue(t)) > -1
       },
       needsTile: function(t) {
        return 1 !== t.length || null == t[0].componentOptions || "v-list-item" !== t[0].componentOptions.Ctor.options.name
       },
       getDisabled: function(t) {
        return Boolean(Object(I["l"])(t, this.itemDisabled, !1))
       },
       getText: function(t) {
        return String(Object(I["l"])(t, this.itemText, t))
       },
       getValue: function(t) {
        return Object(I["l"])(t, this.itemValue, this.getText(t))
       }
      },
      render: function() {
       for (var t = [], e = this.items.length, n = 0; n < e; n++) {
        var r = this.items[n];
        this.hideSelected && this.hasItem(r) || (null == r ? t.push(this.genTile({
         item: r,
         index: n
        })) : r.header ? t.push(this.genHeader(r)) : r.divider ? t.push(this.genDivider(r)) : t.push(this.genTile({
         item: r,
         index: n
        })))
       }
       return t.length || t.push(this.$slots["no-data"] || this.staticNoDataTile), this.$slots["prepend-item"] && t.unshift(this.$slots["prepend-item"]), this.$slots["append-item"] && t.push(this.$slots["append-item"]), this.$createElement(H["a"], {
        staticClass: "v-select-list",
        class: this.themeClasses,
        attrs: {
         role: "listbox",
         tabindex: -1
        },
        props: {
         dense: this.dense
        }
       }, t)
      }
     }),
     G = (n("d191"), n("1b2c"), Object(a["a"])(h["a"]).extend({
      name: "v-label",
      functional: !0,
      props: {
       absolute: Boolean,
       color: {
        type: String,
        default: "primary"
       },
       disabled: Boolean,
       focused: Boolean,
       for: String,
       left: {
        type: [Number, String],
        default: 0
       },
       right: {
        type: [Number, String],
        default: "auto"
       },
       value: Boolean
      },
      render: function(t, e) {
       var n = e.children,
        r = e.listeners,
        o = e.props,
        a = {
         staticClass: "v-label",
         class: Object(i["a"])({
          "v-label--active": o.value,
          "v-label--is-disabled": o.disabled
         }, Object(h["b"])(e)),
         attrs: {
          for: o.for,
          "aria-hidden": !o.for
         },
         on: r,
         style: {
          left: Object(I["f"])(o.left),
          right: Object(I["f"])(o.right),
          position: o.absolute ? "absolute" : "relative"
         },
         ref: "label"
        };
       return t("label", c["a"].options.methods.setTextColor(o.focused && o.color, a), n)
      }
     })),
     q = G,
     K = (n("8ff2"), Object(a["a"])(c["a"], h["a"]).extend({
      name: "v-messages",
      props: {
       value: {
        type: Array,
        default: function() {
         return []
        }
       }
      },
      methods: {
       genChildren: function() {
        return this.$createElement("transition-group", {
         staticClass: "v-messages__wrapper",
         attrs: {
          name: "message-transition",
          tag: "div"
         }
        }, this.value.map(this.genMessage))
       },
       genMessage: function(t, e) {
        return this.$createElement("div", {
         staticClass: "v-messages__message",
         key: e
        }, Object(I["m"])(this, "default", {
         message: t,
         key: e
        }) || [t])
       }
      },
      render: function(t) {
       return t("div", this.setTextColor(this.color, {
        staticClass: "v-messages",
        class: this.themeClasses
       }), [this.genChildren()])
      }
     })),
     X = K,
     Y = n("7e2b"),
     Z = n("53ca"),
     J = n("3206"),
     Q = Object(a["a"])(c["a"], Object(J["a"])("form"), h["a"]).extend({
      name: "validatable",
      props: {
       disabled: Boolean,
       error: Boolean,
       errorCount: {
        type: [Number, String],
        default: 1
       },
       errorMessages: {
        type: [String, Array],
        default: function() {
         return []
        }
       },
       messages: {
        type: [String, Array],
        default: function() {
         return []
        }
       },
       readonly: Boolean,
       rules: {
        type: Array,
        default: function() {
         return []
        }
       },
       success: Boolean,
       successMessages: {
        type: [String, Array],
        default: function() {
         return []
        }
       },
       validateOnBlur: Boolean,
       value: {
        required: !1
       }
      },
      data: function() {
       return {
        errorBucket: [],
        hasColor: !1,
        hasFocused: !1,
        hasInput: !1,
        isFocused: !1,
        isResetting: !1,
        lazyValue: this.value,
        valid: !1
       }
      },
      computed: {
       computedColor: function() {
        if (!this.disabled) return this.color ? this.color : this.isDark && !this.appIsDark ? "white" : "primary"
       },
       hasError: function() {
        return this.internalErrorMessages.length > 0 || this.errorBucket.length > 0 || this.error
       },
       hasSuccess: function() {
        return this.internalSuccessMessages.length > 0 || this.success
       },
       externalError: function() {
        return this.internalErrorMessages.length > 0 || this.error
       },
       hasMessages: function() {
        return this.validationTarget.length > 0
       },
       hasState: function() {
        return !this.disabled && (this.hasSuccess || this.shouldValidate && this.hasError)
       },
       internalErrorMessages: function() {
        return this.genInternalMessages(this.errorMessages)
       },
       internalMessages: function() {
        return this.genInternalMessages(this.messages)
       },
       internalSuccessMessages: function() {
        return this.genInternalMessages(this.successMessages)
       },
       internalValue: {
        get: function() {
         return this.lazyValue
        },
        set: function(t) {
         this.lazyValue = t, this.$emit("input", t)
        }
       },
       shouldValidate: function() {
        return !!this.externalError || !this.isResetting && (this.validateOnBlur ? this.hasFocused && !this.isFocused : this.hasInput || this.hasFocused)
       },
       validations: function() {
        return this.validationTarget.slice(0, Number(this.errorCount))
       },
       validationState: function() {
        if (!this.disabled) return this.hasError && this.shouldValidate ? "error" : this.hasSuccess ? "success" : this.hasColor ? this.computedColor : void 0
       },
       validationTarget: function() {
        return this.internalErrorMessages.length > 0 ? this.internalErrorMessages : this.successMessages.length > 0 ? this.internalSuccessMessages : this.messages.length > 0 ? this.internalMessages : this.shouldValidate ? this.errorBucket : []
       }
      },
      watch: {
       rules: {
        handler: function(t, e) {
         Object(I["h"])(t, e) || this.validate()
        },
        deep: !0
       },
       internalValue: function() {
        this.hasInput = !0, this.validateOnBlur || this.$nextTick(this.validate)
       },
       isFocused: function(t) {
        t || this.disabled || (this.hasFocused = !0, this.validateOnBlur && this.$nextTick(this.validate))
       },
       isResetting: function() {
        var t = this;
        setTimeout((function() {
         t.hasInput = !1, t.hasFocused = !1, t.isResetting = !1, t.validate()
        }), 0)
       },
       hasError: function(t) {
        this.shouldValidate && this.$emit("update:error", t)
       },
       value: function(t) {
        this.lazyValue = t
       }
      },
      beforeMount: function() {
       this.validate()
      },
      created: function() {
       this.form && this.form.register(this)
      },
      beforeDestroy: function() {
       this.form && this.form.unregister(this)
      },
      methods: {
       genInternalMessages: function(t) {
        return t ? Array.isArray(t) ? t : [t] : []
       },
       reset: function() {
        this.isResetting = !0, this.internalValue = Array.isArray(this.internalValue) ? [] : void 0
       },
       resetValidation: function() {
        this.isResetting = !0
       },
       validate: function() {
        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
         e = arguments.length > 1 ? arguments[1] : void 0,
         n = [];
        e = e || this.internalValue, t && (this.hasInput = this.hasFocused = !0);
        for (var r = 0; r < this.rules.length; r++) {
         var i = this.rules[r],
          o = "function" === typeof i ? i(e) : i;
         !1 === o || "string" === typeof o ? n.push(o || "") : "boolean" !== typeof o && Object(v["b"])("Rules should return a string or boolean, received '".concat(Object(Z["a"])(o), "' instead"), this)
        }
        return this.errorBucket = n, this.valid = 0 === n.length, this.valid
       }
      }
     }),
     tt = n("d9f7"),
     et = Object(a["a"])(Y["a"], Q),
     nt = et.extend().extend({
      name: "v-input",
      inheritAttrs: !1,
      props: {
       appendIcon: String,
       backgroundColor: {
        type: String,
        default: ""
       },
       dense: Boolean,
       height: [Number, String],
       hideDetails: [Boolean, String],
       hint: String,
       id: String,
       label: String,
       loading: Boolean,
       persistentHint: Boolean,
       prependIcon: String,
       value: null
      },
      data: function() {
       return {
        lazyValue: this.value,
        hasMouseDown: !1
       }
      },
      computed: {
       classes: function() {
        return Object(i["a"])({
         "v-input--has-state": this.hasState,
         "v-input--hide-details": !this.showDetails,
         "v-input--is-label-active": this.isLabelActive,
         "v-input--is-dirty": this.isDirty,
         "v-input--is-disabled": this.disabled,
         "v-input--is-focused": this.isFocused,
         "v-input--is-loading": !1 !== this.loading && void 0 !== this.loading,
         "v-input--is-readonly": this.readonly,
         "v-input--dense": this.dense
        }, this.themeClasses)
       },
       computedId: function() {
        return this.id || "input-".concat(this._uid)
       },
       hasHint: function() {
        return !this.hasMessages && !!this.hint && (this.persistentHint || this.isFocused)
       },
       hasLabel: function() {
        return !(!this.$slots.label && !this.label)
       },
       internalValue: {
        get: function() {
         return this.lazyValue
        },
        set: function(t) {
         this.lazyValue = t, this.$emit(this.$_modelEvent, t)
        }
       },
       isDirty: function() {
        return !!this.lazyValue
       },
       isDisabled: function() {
        return this.disabled || this.readonly
       },
       isLabelActive: function() {
        return this.isDirty
       },
       messagesToDisplay: function() {
        var t = this;
        return this.hasHint ? [this.hint] : this.hasMessages ? this.validations.map((function(e) {
         if ("string" === typeof e) return e;
         var n = e(t.internalValue);
         return "string" === typeof n ? n : ""
        })).filter((function(t) {
         return "" !== t
        })) : []
       },
       showDetails: function() {
        return !1 === this.hideDetails || "auto" === this.hideDetails && this.messagesToDisplay.length > 0
       }
      },
      watch: {
       value: function(t) {
        this.lazyValue = t
       }
      },
      beforeCreate: function() {
       this.$_modelEvent = this.$options.model && this.$options.model.event || "input"
      },
      methods: {
       genContent: function() {
        return [this.genPrependSlot(), this.genControl(), this.genAppendSlot()]
       },
       genControl: function() {
        return this.$createElement("div", {
         staticClass: "v-input__control"
        }, [this.genInputSlot(), this.genMessages()])
       },
       genDefaultSlot: function() {
        return [this.genLabel(), this.$slots.default]
       },
       genIcon: function(t, e) {
        var n = this,
         r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
         i = this["".concat(t, "Icon")],
         o = "click:".concat(Object(I["p"])(t)),
         a = !(!this.listeners$[o] && !e),
         s = Object(tt["a"])({
          attrs: {
           "aria-label": a ? Object(I["p"])(t).split("-")[0] + " icon" : void 0,
           color: this.validationState,
           dark: this.dark,
           disabled: this.disabled,
           light: this.light
          },
          on: a ? {
           click: function(t) {
            t.preventDefault(), t.stopPropagation(), n.$emit(o, t), e && e(t)
           },
           mouseup: function(t) {
            t.preventDefault(), t.stopPropagation()
           }
          } : void 0
         }, r);
        return this.$createElement("div", {
         staticClass: "v-input__icon",
         class: t ? "v-input__icon--".concat(Object(I["p"])(t)) : void 0
        }, [this.$createElement(u["a"], s, i)])
       },
       genInputSlot: function() {
        return this.$createElement("div", this.setBackgroundColor(this.backgroundColor, {
         staticClass: "v-input__slot",
         style: {
          height: Object(I["f"])(this.height)
         },
         on: {
          click: this.onClick,
          mousedown: this.onMouseDown,
          mouseup: this.onMouseUp
         },
         ref: "input-slot"
        }), [this.genDefaultSlot()])
       },
       genLabel: function() {
        return this.hasLabel ? this.$createElement(q, {
         props: {
          color: this.validationState,
          dark: this.dark,
          disabled: this.disabled,
          focused: this.hasState,
          for: this.computedId,
          light: this.light
         }
        }, this.$slots.label || this.label) : null
       },
       genMessages: function() {
        var t = this;
        return this.showDetails ? this.$createElement(X, {
         props: {
          color: this.hasHint ? "" : this.validationState,
          dark: this.dark,
          light: this.light,
          value: this.messagesToDisplay
         },
         attrs: {
          role: this.hasMessages ? "alert" : null
         },
         scopedSlots: {
          default: function(e) {
           return Object(I["m"])(t, "message", e)
          }
         }
        }) : null
       },
       genSlot: function(t, e, n) {
        if (!n.length) return null;
        var r = "".concat(t, "-").concat(e);
        return this.$createElement("div", {
         staticClass: "v-input__".concat(r),
         ref: r
        }, n)
       },
       genPrependSlot: function() {
        var t = [];
        return this.$slots.prepend ? t.push(this.$slots.prepend) : this.prependIcon && t.push(this.genIcon("prepend")), this.genSlot("prepend", "outer", t)
       },
       genAppendSlot: function() {
        var t = [];
        return this.$slots.append ? t.push(this.$slots.append) : this.appendIcon && t.push(this.genIcon("append")), this.genSlot("append", "outer", t)
       },
       onClick: function(t) {
        this.$emit("click", t)
       },
       onMouseDown: function(t) {
        this.hasMouseDown = !0, this.$emit("mousedown", t)
       },
       onMouseUp: function(t) {
        this.hasMouseDown = !1, this.$emit("mouseup", t)
       }
      },
      render: function(t) {
       return t("div", this.setTextColor(this.validationState, {
        staticClass: "v-input",
        class: this.classes
       }), this.genContent())
      }
     }),
     rt = nt,
     it = (n("0481"), n("4069"), n("e9b1"), Object(a["a"])(h["a"]).extend({
      name: "v-counter",
      functional: !0,
      props: {
       value: {
        type: [Number, String],
        default: ""
       },
       max: [Number, String]
      },
      render: function(t, e) {
       var n = e.props,
        r = parseInt(n.max, 10),
        o = parseInt(n.value, 10),
        a = r ? "".concat(o, " / ").concat(r) : String(n.value),
        s = r && o > r;
       return t("div", {
        staticClass: "v-counter",
        class: Object(i["a"])({
         "error--text": s
        }, Object(h["b"])(e))
       }, a)
      }
     })),
     ot = it,
     at = n("90a2");
 
    function st(t) {
     return "undefined" !== typeof window && "IntersectionObserver" in window ? L["a"].extend({
      name: "intersectable",
      mounted: function() {
       at["a"].inserted(this.$el, {
        name: "intersect",
        value: {
         handler: this.onObserve
        }
       })
      },
      destroyed: function() {
       at["a"].unbind(this.$el)
      },
      methods: {
       onObserve: function(e, n, r) {
        if (r)
         for (var i = 0, o = t.onVisible.length; i < o; i++) {
          var a = this[t.onVisible[i]];
          "function" !== typeof a ? Object(v["c"])(t.onVisible[i] + " method is not available on the instance but referenced in intersectable mixin options") : a()
         }
       }
      }
     }) : L["a"].extend({
      name: "intersectable"
     })
    }
    var ut = n("297c"),
     ct = Object(a["a"])(rt, st({
      onVisible: ["setLabelWidth", "setPrefixWidth", "setPrependWidth", "tryAutofocus"]
     }), ut["a"]),
     lt = ["color", "file", "time", "date", "datetime-local", "week", "month"],
     ht = ct.extend().extend({
      name: "v-text-field",
      directives: {
       ripple: M["a"]
      },
      inheritAttrs: !1,
      props: {
       appendOuterIcon: String,
       autofocus: Boolean,
       clearable: Boolean,
       clearIcon: {
        type: String,
        default: "$clear"
       },
       counter: [Boolean, Number, String],
       counterValue: Function,
       filled: Boolean,
       flat: Boolean,
       fullWidth: Boolean,
       label: String,
       outlined: Boolean,
       placeholder: String,
       prefix: String,
       prependInnerIcon: String,
       reverse: Boolean,
       rounded: Boolean,
       shaped: Boolean,
       singleLine: Boolean,
       solo: Boolean,
       soloInverted: Boolean,
       suffix: String,
       type: {
        type: String,
        default: "text"
       }
      },
      data: function() {
       return {
        badInput: !1,
        labelWidth: 0,
        prefixWidth: 0,
        prependWidth: 0,
        initialValue: null,
        isBooted: !1,
        isClearing: !1
       }
      },
      computed: {
       classes: function() {
        return Object(i["a"])({}, rt.options.computed.classes.call(this), {
         "v-text-field": !0,
         "v-text-field--full-width": this.fullWidth,
         "v-text-field--prefix": this.prefix,
         "v-text-field--single-line": this.isSingle,
         "v-text-field--solo": this.isSolo,
         "v-text-field--solo-inverted": this.soloInverted,
         "v-text-field--solo-flat": this.flat,
         "v-text-field--filled": this.filled,
         "v-text-field--is-booted": this.isBooted,
         "v-text-field--enclosed": this.isEnclosed,
         "v-text-field--reverse": this.reverse,
         "v-text-field--outlined": this.outlined,
         "v-text-field--placeholder": this.placeholder,
         "v-text-field--rounded": this.rounded,
         "v-text-field--shaped": this.shaped
        })
       },
       computedColor: function() {
        var t = Q.options.computed.computedColor.call(this);
        return this.soloInverted && this.isFocused ? this.color || "primary" : t
       },
       computedCounterValue: function() {
        return "function" === typeof this.counterValue ? this.counterValue(this.internalValue) : (this.internalValue || "").toString().length
       },
       internalValue: {
        get: function() {
         return this.lazyValue
        },
        set: function(t) {
         this.lazyValue = t, this.$emit("input", this.lazyValue)
        }
       },
       isDirty: function() {
        return null != this.lazyValue && this.lazyValue.toString().length > 0 || this.badInput
       },
       isEnclosed: function() {
        return this.filled || this.isSolo || this.outlined
       },
       isLabelActive: function() {
        return this.isDirty || lt.includes(this.type)
       },
       isSingle: function() {
        return this.isSolo || this.singleLine || this.fullWidth || this.filled && !this.hasLabel
       },
       isSolo: function() {
        return this.solo || this.soloInverted
       },
       labelPosition: function() {
        var t = this.prefix && !this.labelValue ? this.prefixWidth : 0;
        return this.labelValue && this.prependWidth && (t -= this.prependWidth), this.$vuetify.rtl === this.reverse ? {
         left: t,
         right: "auto"
        } : {
         left: "auto",
         right: t
        }
       },
       showLabel: function() {
        return this.hasLabel && (!this.isSingle || !this.isLabelActive && !this.placeholder)
       },
       labelValue: function() {
        return !this.isSingle && Boolean(this.isFocused || this.isLabelActive || this.placeholder)
       }
      },
      watch: {
       labelValue: "setLabelWidth",
       outlined: "setLabelWidth",
       label: function() {
        this.$nextTick(this.setLabelWidth)
       },
       prefix: function() {
        this.$nextTick(this.setPrefixWidth)
       },
       isFocused: "updateValue",
       value: function(t) {
        this.lazyValue = t
       }
      },
      created: function() {
       this.$attrs.hasOwnProperty("box") && Object(v["a"])("box", "filled", this), this.$attrs.hasOwnProperty("browser-autocomplete") && Object(v["a"])("browser-autocomplete", "autocomplete", this), this.shaped && !(this.filled || this.outlined || this.isSolo) && Object(v["c"])("shaped should be used with either filled or outlined", this)
      },
      mounted: function() {
       var t = this;
       this.autofocus && this.tryAutofocus(), this.setLabelWidth(), this.setPrefixWidth(), this.setPrependWidth(), requestAnimationFrame((function() {
        return t.isBooted = !0
       }))
      },
      methods: {
       focus: function() {
        this.onFocus()
       },
       blur: function(t) {
        var e = this;
        window.requestAnimationFrame((function() {
         e.$refs.input && e.$refs.input.blur()
        }))
       },
       clearableCallback: function() {
        var t = this;
        this.$refs.input && this.$refs.input.focus(), this.$nextTick((function() {
         return t.internalValue = null
        }))
       },
       genAppendSlot: function() {
        var t = [];
        return this.$slots["append-outer"] ? t.push(this.$slots["append-outer"]) : this.appendOuterIcon && t.push(this.genIcon("appendOuter")), this.genSlot("append", "outer", t)
       },
       genPrependInnerSlot: function() {
        var t = [];
        return this.$slots["prepend-inner"] ? t.push(this.$slots["prepend-inner"]) : this.prependInnerIcon && t.push(this.genIcon("prependInner")), this.genSlot("prepend", "inner", t)
       },
       genIconSlot: function() {
        var t = [];
        return this.$slots["append"] ? t.push(this.$slots["append"]) : this.appendIcon && t.push(this.genIcon("append")), this.genSlot("append", "inner", t)
       },
       genInputSlot: function() {
        var t = rt.options.methods.genInputSlot.call(this),
         e = this.genPrependInnerSlot();
        return e && (t.children = t.children || [], t.children.unshift(e)), t
       },
       genClearIcon: function() {
        if (!this.clearable) return null;
        var t = this.isDirty ? void 0 : {
         attrs: {
          disabled: !0
         }
        };
        return this.genSlot("append", "inner", [this.genIcon("clear", this.clearableCallback, t)])
       },
       genCounter: function() {
        if (!1 === this.counter || null == this.counter) return null;
        var t = !0 === this.counter ? this.attrs$.maxlength : this.counter;
        return this.$createElement(ot, {
         props: {
          dark: this.dark,
          light: this.light,
          max: t,
          value: this.computedCounterValue
         }
        })
       },
       genDefaultSlot: function() {
        return [this.genFieldset(), this.genTextFieldSlot(), this.genClearIcon(), this.genIconSlot(), this.genProgress()]
       },
       genFieldset: function() {
        return this.outlined ? this.$createElement("fieldset", {
         attrs: {
          "aria-hidden": !0
         }
        }, [this.genLegend()]) : null
       },
       genLabel: function() {
        if (!this.showLabel) return null;
        var t = {
         props: {
          absolute: !0,
          color: this.validationState,
          dark: this.dark,
          disabled: this.disabled,
          focused: !this.isSingle && (this.isFocused || !!this.validationState),
          for: this.computedId,
          left: this.labelPosition.left,
          light: this.light,
          right: this.labelPosition.right,
          value: this.labelValue
         }
        };
        return this.$createElement(q, t, this.$slots.label || this.label)
       },
       genLegend: function() {
        var t = this.singleLine || !this.labelValue && !this.isDirty ? 0 : this.labelWidth,
         e = this.$createElement("span", {
          domProps: {
           innerHTML: "&#8203;"
          }
         });
        return this.$createElement("legend", {
         style: {
          width: this.isSingle ? void 0 : Object(I["f"])(t)
         }
        }, [e])
       },
       genInput: function() {
        var t = Object.assign({}, this.listeners$);
        return delete t["change"], this.$createElement("input", {
         style: {},
         domProps: {
          value: this.lazyValue
         },
         attrs: Object(i["a"])({}, this.attrs$, {
          autofocus: this.autofocus,
          disabled: this.disabled,
          id: this.computedId,
          placeholder: this.placeholder,
          readonly: this.readonly,
          type: this.type
         }),
         on: Object.assign(t, {
          blur: this.onBlur,
          input: this.onInput,
          focus: this.onFocus,
          keydown: this.onKeyDown
         }),
         ref: "input"
        })
       },
       genMessages: function() {
        if (!0 === this.hideDetails) return null;
        var t = rt.options.methods.genMessages.call(this),
         e = this.genCounter();
        return "auto" !== this.hideDetails || t || e ? this.$createElement("div", {
         staticClass: "v-text-field__details"
        }, [t, e]) : null
       },
       genTextFieldSlot: function() {
        return this.$createElement("div", {
         staticClass: "v-text-field__slot"
        }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, this.genInput(), this.suffix ? this.genAffix("suffix") : null])
       },
       genAffix: function(t) {
        return this.$createElement("div", {
         class: "v-text-field__".concat(t),
         ref: t
        }, this[t])
       },
       onBlur: function(t) {
        var e = this;
        this.isFocused = !1, t && this.$nextTick((function() {
         return e.$emit("blur", t)
        }))
       },
       onClick: function() {
        this.isFocused || this.disabled || !this.$refs.input || this.$refs.input.focus()
       },
       onFocus: function(t) {
        if (this.$refs.input) return document.activeElement !== this.$refs.input ? this.$refs.input.focus() : void(this.isFocused || (this.isFocused = !0, t && this.$emit("focus", t)))
       },
       onInput: function(t) {
        var e = t.target;
        this.internalValue = e.value, this.badInput = e.validity && e.validity.badInput
       },
       onKeyDown: function(t) {
        t.keyCode === I["q"].enter && this.$emit("change", this.internalValue), this.$emit("keydown", t)
       },
       onMouseDown: function(t) {
        t.target !== this.$refs.input && (t.preventDefault(), t.stopPropagation()), rt.options.methods.onMouseDown.call(this, t)
       },
       onMouseUp: function(t) {
        this.hasMouseDown && this.focus(), rt.options.methods.onMouseUp.call(this, t)
       },
       setLabelWidth: function() {
        this.outlined && this.$refs.label && (this.labelWidth = Math.min(.75 * this.$refs.label.scrollWidth + 6, this.$el.offsetWidth - 24))
       },
       setPrefixWidth: function() {
        this.$refs.prefix && (this.prefixWidth = this.$refs.prefix.offsetWidth)
       },
       setPrependWidth: function() {
        this.outlined && this.$refs["prepend-inner"] && (this.prependWidth = this.$refs["prepend-inner"].offsetWidth)
       },
       tryAutofocus: function() {
        return !(!this.autofocus || "undefined" === typeof document || !this.$refs.input || document.activeElement === this.$refs.input) && (this.$refs.input.focus(), !0)
       },
       updateValue: function(t) {
        this.hasColor = t, t ? this.initialValue = this.lazyValue : this.initialValue !== this.lazyValue && this.$emit("change", this.lazyValue)
       }
      }
     }),
     pt = L["a"].extend({
      name: "comparable",
      props: {
       valueComparator: {
        type: Function,
        default: I["h"]
       }
      }
     }),
     ft = L["a"].extend({
      name: "filterable",
      props: {
       noDataText: {
        type: String,
        default: "$vuetify.noDataText"
       }
      }
     }),
     dt = {
      closeOnClick: !1,
      closeOnContentClick: !1,
      disableKeys: !0,
      openOnClick: !1,
      maxHeight: 304
     },
     vt = Object(a["a"])(ht, pt, ft);
    e["a"] = vt.extend().extend({
     name: "v-select",
     directives: {
      ClickOutside: R["a"]
     },
     props: {
      appendIcon: {
       type: String,
       default: "$dropdown"
      },
      attach: {
       type: null,
       default: !1
      },
      cacheItems: Boolean,
      chips: Boolean,
      clearable: Boolean,
      deletableChips: Boolean,
      disableLookup: Boolean,
      eager: Boolean,
      hideSelected: Boolean,
      items: {
       type: Array,
       default: function() {
        return []
       }
      },
      itemColor: {
       type: String,
       default: "primary"
      },
      itemDisabled: {
       type: [String, Array, Function],
       default: "disabled"
      },
      itemText: {
       type: [String, Array, Function],
       default: "text"
      },
      itemValue: {
       type: [String, Array, Function],
       default: "value"
      },
      menuProps: {
       type: [String, Array, Object],
       default: function() {
        return dt
       }
      },
      multiple: Boolean,
      openOnClear: Boolean,
      returnObject: Boolean,
      smallChips: Boolean
     },
     data: function() {
      return {
       cachedItems: this.cacheItems ? this.items : [],
       menuIsBooted: !1,
       isMenuActive: !1,
       lastItem: 20,
       lazyValue: void 0 !== this.value ? this.value : this.multiple ? [] : void 0,
       selectedIndex: -1,
       selectedItems: [],
       keyboardLookupPrefix: "",
       keyboardLookupLastTime: 0
      }
     },
     computed: {
      allItems: function() {
       return this.filterDuplicates(this.cachedItems.concat(this.items))
      },
      classes: function() {
       return Object(i["a"])({}, ht.options.computed.classes.call(this), {
        "v-select": !0,
        "v-select--chips": this.hasChips,
        "v-select--chips--small": this.smallChips,
        "v-select--is-menu-active": this.isMenuActive,
        "v-select--is-multi": this.multiple
       })
      },
      computedItems: function() {
       return this.allItems
      },
      computedOwns: function() {
       return "list-".concat(this._uid)
      },
      computedCounterValue: function() {
       return this.multiple ? this.selectedItems.length : (this.getText(this.selectedItems[0]) || "").toString().length
      },
      directives: function() {
       return this.isFocused ? [{
        name: "click-outside",
        value: this.blur,
        args: {
         closeConditional: this.closeConditional
        }
       }] : void 0
      },
      dynamicHeight: function() {
       return "auto"
      },
      hasChips: function() {
       return this.chips || this.smallChips
      },
      hasSlot: function() {
       return Boolean(this.hasChips || this.$scopedSlots.selection)
      },
      isDirty: function() {
       return this.selectedItems.length > 0
      },
      listData: function() {
       var t = this.$vnode && this.$vnode.context.$options._scopeId,
        e = t ? Object(r["a"])({}, t, !0) : {};
       return {
        attrs: Object(i["a"])({}, e, {
         id: this.computedOwns
        }),
        props: {
         action: this.multiple,
         color: this.itemColor,
         dense: this.dense,
         hideSelected: this.hideSelected,
         items: this.virtualizedItems,
         itemDisabled: this.itemDisabled,
         itemText: this.itemText,
         itemValue: this.itemValue,
         noDataText: this.$vuetify.lang.t(this.noDataText),
         selectedItems: this.selectedItems
        },
        on: {
         select: this.selectItem
        },
        scopedSlots: {
         item: this.$scopedSlots.item
        }
       }
      },
      staticList: function() {
       return (this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"]) && Object(v["b"])("assert: staticList should not be called if slots are used"), this.$createElement($, this.listData)
      },
      virtualizedItems: function() {
       return this.$_menuProps.auto ? this.computedItems : this.computedItems.slice(0, this.lastItem)
      },
      menuCanShow: function() {
       return !0
      },
      $_menuProps: function() {
       var t = "string" === typeof this.menuProps ? this.menuProps.split(",") : this.menuProps;
       return Array.isArray(t) && (t = t.reduce((function(t, e) {
        return t[e.trim()] = !0, t
       }), {})), Object(i["a"])({}, dt, {
        eager: this.eager,
        value: this.menuCanShow && this.isMenuActive,
        nudgeBottom: t.offsetY ? 1 : 0
       }, t)
      }
     },
     watch: {
      internalValue: function(t) {
       this.initialValue = t, this.setSelectedItems()
      },
      menuIsBooted: function() {
       var t = this;
       window.setTimeout((function() {
        t.getContent() && t.getContent().addEventListener && t.getContent().addEventListener("scroll", t.onScroll, !1)
       }))
      },
      isMenuActive: function(t) {
       var e = this;
       window.setTimeout((function() {
        return e.onMenuActiveChange(t)
       })), t && (this.menuIsBooted = !0)
      },
      items: {
       immediate: !0,
       handler: function(t) {
        var e = this;
        this.cacheItems && this.$nextTick((function() {
         e.cachedItems = e.filterDuplicates(e.cachedItems.concat(t))
        })), this.setSelectedItems()
       }
      }
     },
     methods: {
      blur: function(t) {
       ht.options.methods.blur.call(this, t), this.isMenuActive = !1, this.isFocused = !1, this.selectedIndex = -1
      },
      activateMenu: function() {
       this.disabled || this.readonly || this.isMenuActive || (this.isMenuActive = !0)
      },
      clearableCallback: function() {
       var t = this;
       this.setValue(this.multiple ? [] : void 0), this.setMenuIndex(-1), this.$nextTick((function() {
        return t.$refs.input && t.$refs.input.focus()
       })), this.openOnClear && (this.isMenuActive = !0)
      },
      closeConditional: function(t) {
       return !this.isMenuActive || !this._isDestroyed && this.getContent() && !this.getContent().contains(t.target) && this.$el && !this.$el.contains(t.target) && t.target !== this.$el
      },
      filterDuplicates: function(t) {
       for (var e = new Map, n = 0; n < t.length; ++n) {
        var r = t[n],
         i = this.getValue(r);
        !e.has(i) && e.set(i, r)
       }
       return Array.from(e.values())
      },
      findExistingIndex: function(t) {
       var e = this,
        n = this.getValue(t);
       return (this.internalValue || []).findIndex((function(t) {
        return e.valueComparator(e.getValue(t), n)
       }))
      },
      getContent: function() {
       return this.$refs.menu && this.$refs.menu.$refs.content
      },
      genChipSelection: function(t, e) {
       var n = this,
        r = this.disabled || this.readonly || this.getDisabled(t);
       return this.$createElement(g, {
        staticClass: "v-chip--select",
        attrs: {
         tabindex: -1
        },
        props: {
         close: this.deletableChips && !r,
         disabled: r,
         inputValue: e === this.selectedIndex,
         small: this.smallChips
        },
        on: {
         click: function(t) {
          r || (t.stopPropagation(), n.selectedIndex = e)
         },
         "click:close": function() {
          return n.onChipInput(t)
         }
        },
        key: JSON.stringify(this.getValue(t))
       }, this.getText(t))
      },
      genCommaSelection: function(t, e, n) {
       var r = e === this.selectedIndex && this.computedColor,
        i = this.disabled || this.getDisabled(t);
       return this.$createElement("div", this.setTextColor(r, {
        staticClass: "v-select__selection v-select__selection--comma",
        class: {
         "v-select__selection--disabled": i
        },
        key: JSON.stringify(this.getValue(t))
       }), "".concat(this.getText(t)).concat(n ? "" : ", "))
      },
      genDefaultSlot: function() {
       var t = this.genSelections(),
        e = this.genInput();
       return Array.isArray(t) ? t.push(e) : (t.children = t.children || [], t.children.push(e)), [this.genFieldset(), this.$createElement("div", {
        staticClass: "v-select__slot",
        directives: this.directives
       }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, t, this.suffix ? this.genAffix("suffix") : null, this.genClearIcon(), this.genIconSlot(), this.genHiddenInput()]), this.genMenu(), this.genProgress()]
      },
      genIcon: function(t, e, n) {
       var r = rt.options.methods.genIcon.call(this, t, e, n);
       return "append" === t && (r.children[0].data = Object(tt["a"])(r.children[0].data, {
        attrs: {
         tabindex: r.children[0].componentOptions.listeners && "-1",
         "aria-hidden": "true",
         "aria-label": void 0
        }
       })), r
      },
      genInput: function() {
       var t = ht.options.methods.genInput.call(this);
       return delete t.data.attrs.name, t.data = Object(tt["a"])(t.data, {
        domProps: {
         value: null
        },
        attrs: {
         readonly: !0,
         type: "text",
         "aria-readonly": String(this.readonly),
         "aria-activedescendant": Object(I["k"])(this.$refs.menu, "activeTile.id"),
         autocomplete: Object(I["k"])(t.data, "attrs.autocomplete", "off")
        },
        on: {
         keypress: this.onKeyPress
        }
       }), t
      },
      genHiddenInput: function() {
       return this.$createElement("input", {
        domProps: {
         value: this.lazyValue
        },
        attrs: {
         type: "hidden",
         name: this.attrs$.name
        }
       })
      },
      genInputSlot: function() {
       var t = ht.options.methods.genInputSlot.call(this);
       return t.data.attrs = Object(i["a"])({}, t.data.attrs, {
        role: "button",
        "aria-haspopup": "listbox",
        "aria-expanded": String(this.isMenuActive),
        "aria-owns": this.computedOwns
       }), t
      },
      genList: function() {
       return this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"] ? this.genListWithSlot() : this.staticList
      },
      genListWithSlot: function() {
       var t = this,
        e = ["prepend-item", "no-data", "append-item"].filter((function(e) {
         return t.$slots[e]
        })).map((function(e) {
         return t.$createElement("template", {
          slot: e
         }, t.$slots[e])
        }));
       return this.$createElement($, Object(i["a"])({}, this.listData), e)
      },
      genMenu: function() {
       var t = this,
        e = this.$_menuProps;
       return e.activator = this.$refs["input-slot"], "" === this.attach || !0 === this.attach || "attach" === this.attach ? e.attach = this.$el : e.attach = this.attach, this.$createElement(F, {
        attrs: {
         role: void 0
        },
        props: e,
        on: {
         input: function(e) {
          t.isMenuActive = e, t.isFocused = e
         }
        },
        ref: "menu"
       }, [this.genList()])
      },
      genSelections: function() {
       var t, e = this.selectedItems.length,
        n = new Array(e);
       t = this.$scopedSlots.selection ? this.genSlotSelection : this.hasChips ? this.genChipSelection : this.genCommaSelection;
       while (e--) n[e] = t(this.selectedItems[e], e, e === n.length - 1);
       return this.$createElement("div", {
        staticClass: "v-select__selections"
       }, n)
      },
      genSlotSelection: function(t, e) {
       var n = this;
       return this.$scopedSlots.selection({
        attrs: {
         class: "v-chip--select"
        },
        parent: this,
        item: t,
        index: e,
        select: function(t) {
         t.stopPropagation(), n.selectedIndex = e
        },
        selected: e === this.selectedIndex,
        disabled: this.disabled || this.readonly
       })
      },
      getMenuIndex: function() {
       return this.$refs.menu ? this.$refs.menu.listIndex : -1
      },
      getDisabled: function(t) {
       return Object(I["l"])(t, this.itemDisabled, !1)
      },
      getText: function(t) {
       return Object(I["l"])(t, this.itemText, t)
      },
      getValue: function(t) {
       return Object(I["l"])(t, this.itemValue, this.getText(t))
      },
      onBlur: function(t) {
       t && this.$emit("blur", t)
      },
      onChipInput: function(t) {
       this.multiple ? this.selectItem(t) : this.setValue(null), 0 === this.selectedItems.length ? this.isMenuActive = !0 : this.isMenuActive = !1, this.selectedIndex = -1
      },
      onClick: function(t) {
       this.isDisabled || (this.isAppendInner(t.target) || (this.isMenuActive = !0), this.isFocused || (this.isFocused = !0, this.$emit("focus")))
      },
      onEscDown: function(t) {
       t.preventDefault(), this.isMenuActive && (t.stopPropagation(), this.isMenuActive = !1)
      },
      onKeyPress: function(t) {
       var e = this;
       if (!(this.multiple || this.readonly || this.disableLookup)) {
        var n = 1e3,
         r = performance.now();
        r - this.keyboardLookupLastTime > n && (this.keyboardLookupPrefix = ""), this.keyboardLookupPrefix += t.key.toLowerCase(), this.keyboardLookupLastTime = r;
        var i = this.allItems.findIndex((function(t) {
          var n = (e.getText(t) || "").toString();
          return n.toLowerCase().startsWith(e.keyboardLookupPrefix)
         })),
         o = this.allItems[i]; - 1 !== i && (this.setValue(this.returnObject ? o : this.getValue(o)), setTimeout((function() {
         return e.setMenuIndex(i)
        })))
       }
      },
      onKeyDown: function(t) {
       var e = this,
        n = t.keyCode,
        r = this.$refs.menu;
       if ([I["q"].enter, I["q"].space].includes(n) && this.activateMenu(), this.$emit("keydown", t), r) return this.isMenuActive && n !== I["q"].tab && this.$nextTick((function() {
        r.changeListIndex(t), e.$emit("update:list-index", r.listIndex)
       })), !this.isMenuActive && [I["q"].up, I["q"].down].includes(n) ? this.onUpDown(t) : n === I["q"].esc ? this.onEscDown(t) : n === I["q"].tab ? this.onTabDown(t) : n === I["q"].space ? this.onSpaceDown(t) : void 0
      },
      onMenuActiveChange: function(t) {
       if (!(this.multiple && !t || this.getMenuIndex() > -1)) {
        var e = this.$refs.menu;
        if (e && this.isDirty)
         for (var n = 0; n < e.tiles.length; n++)
          if ("true" === e.tiles[n].getAttribute("aria-selected")) {
           this.setMenuIndex(n);
           break
          }
       }
      },
      onMouseUp: function(t) {
       var e = this;
       this.hasMouseDown && 3 !== t.which && !this.isDisabled && (this.isAppendInner(t.target) ? this.$nextTick((function() {
        return e.isMenuActive = !e.isMenuActive
       })) : this.isEnclosed && (this.isMenuActive = !0)), ht.options.methods.onMouseUp.call(this, t)
      },
      onScroll: function() {
       var t = this;
       if (this.isMenuActive) {
        if (this.lastItem >= this.computedItems.length) return;
        var e = this.getContent().scrollHeight - (this.getContent().scrollTop + this.getContent().clientHeight) < 200;
        e && (this.lastItem += 20)
       } else requestAnimationFrame((function() {
        return t.getContent().scrollTop = 0
       }))
      },
      onSpaceDown: function(t) {
       t.preventDefault()
      },
      onTabDown: function(t) {
       var e = this.$refs.menu;
       if (e) {
        var n = e.activeTile;
        !this.multiple && n && this.isMenuActive ? (t.preventDefault(), t.stopPropagation(), n.click()) : this.blur(t)
       }
      },
      onUpDown: function(t) {
       var e = this.$refs.menu;
       if (e) {
        if (t.preventDefault(), this.multiple) return this.activateMenu();
        var n = t.keyCode;
        e.isBooted = !0, window.requestAnimationFrame((function() {
         e.getTiles(), I["q"].up === n ? e.prevTile() : e.nextTile(), e.activeTile && e.activeTile.click()
        }))
       }
      },
      selectItem: function(t) {
       var e = this;
       if (this.multiple) {
        var n = (this.internalValue || []).slice(),
         r = this.findExistingIndex(t);
        if (-1 !== r ? n.splice(r, 1) : n.push(t), this.setValue(n.map((function(t) {
          return e.returnObject ? t : e.getValue(t)
         }))), this.$nextTick((function() {
          e.$refs.menu && e.$refs.menu.updateDimensions()
         })), !this.multiple) return;
        var i = this.getMenuIndex();
        if (this.setMenuIndex(-1), this.hideSelected) return;
        this.$nextTick((function() {
         return e.setMenuIndex(i)
        }))
       } else this.setValue(this.returnObject ? t : this.getValue(t)), this.isMenuActive = !1
      },
      setMenuIndex: function(t) {
       this.$refs.menu && (this.$refs.menu.listIndex = t)
      },
      setSelectedItems: function() {
       var t = this,
        e = [],
        n = this.multiple && Array.isArray(this.internalValue) ? this.internalValue : [this.internalValue],
        r = !0,
        i = !1,
        o = void 0;
       try {
        for (var a, s = function() {
          var n = a.value,
           r = t.allItems.findIndex((function(e) {
            return t.valueComparator(t.getValue(e), t.getValue(n))
           }));
          r > -1 && e.push(t.allItems[r])
         }, u = n[Symbol.iterator](); !(r = (a = u.next()).done); r = !0) s()
       } catch (c) {
        i = !0, o = c
       } finally {
        try {
         r || null == u.return || u.return()
        } finally {
         if (i) throw o
        }
       }
       this.selectedItems = e
      },
      setValue: function(t) {
       var e = this.internalValue;
       this.internalValue = t, t !== e && this.$emit("change", t)
      },
      isAppendInner: function(t) {
       var e = this.$refs["append-inner"];
       return e && (e === t || e.contains(t))
      }
     }
    })
   },
   bb2f: function(t, e, n) {
    var r = n("d039");
    t.exports = !r((function() {
     return Object.isExtensible(Object.preventExtensions({}))
    }))
   },
   bc3a: function(t, e, n) {
    t.exports = n("cee4")
   },
   c04e: function(t, e, n) {
    var r = n("861d");
    t.exports = function(t, e) {
     if (!r(t)) return t;
     var n, i;
     if (e && "function" == typeof(n = t.toString) && !r(i = n.call(t))) return i;
     if ("function" == typeof(n = t.valueOf) && !r(i = n.call(t))) return i;
     if (!e && "function" == typeof(n = t.toString) && !r(i = n.call(t))) return i;
     throw TypeError("Can't convert object to primitive value")
    }
   },
   c317: function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return l
    }));
    var r = n("b605"),
     i = n("45ef");
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function o(t, e, n, r) {
     return new(n || (n = Promise))((function(i, o) {
      function a(t) {
       try {
        u(r.next(t))
       } catch (t) {
        o(t)
       }
      }
 
      function s(t) {
       try {
        u(r.throw(t))
       } catch (t) {
        o(t)
       }
      }
 
      function u(t) {
       t.done ? i(t.value) : new n((function(e) {
        e(t.value)
       })).then(a, s)
      }
      u((r = r.apply(t, e || [])).next())
     }))
    }
 
    function a(t, e) {
     var n, r, i, o, a = {
      label: 0,
      sent: function() {
       if (1 & i[0]) throw i[1];
       return i[1]
      },
      trys: [],
      ops: []
     };
     return o = {
      next: s(0),
      throw: s(1),
      return: s(2)
     }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
      return this
     }), o;
 
     function s(o) {
      return function(s) {
       return function(o) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; a;) try {
         if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
         switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
          case 0:
          case 1:
           i = o;
           break;
          case 4:
           return a.label++, {
            value: o[1],
            done: !1
           };
          case 5:
           a.label++, r = o[1], o = [0];
           continue;
          case 7:
           o = a.ops.pop(), a.trys.pop();
           continue;
          default:
           if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
            a = 0;
            continue
           }
           if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
            a.label = o[1];
            break
           }
           if (6 === o[0] && a.label < i[1]) {
            a.label = i[1], i = o;
            break
           }
           if (i && a.label < i[2]) {
            a.label = i[2], a.ops.push(o);
            break
           }
           i[2] && a.ops.pop(), a.trys.pop();
           continue
         }
         o = e.call(t, a)
        } catch (t) {
         o = [6, t], r = 0
        } finally {
         n = i = 0
        }
        if (5 & o[0]) throw o[1];
        return {
         value: o[0] ? o[1] : void 0,
         done: !0
        }
       }([o, s])
      }
     }
    }
 
    function s(t, e) {
     var n = "function" == typeof Symbol && t[Symbol.iterator];
     if (!n) return t;
     var r, i, o = n.call(t),
      a = [];
     try {
      for (;
       (void 0 === e || e-- > 0) && !(r = o.next()).done;) a.push(r.value)
     } catch (t) {
      i = {
       error: t
      }
     } finally {
      try {
       r && !r.done && (n = o.return) && n.call(o)
      } finally {
       if (i) throw i.error
      }
     }
     return a
    }
    var u = {
      1: {
       name: "/m/01g317",
       id: 1,
       displayName: "person"
      },
      2: {
       name: "/m/0199g",
       id: 2,
       displayName: "bicycle"
      },
      3: {
       name: "/m/0k4j",
       id: 3,
       displayName: "car"
      },
      4: {
       name: "/m/04_sv",
       id: 4,
       displayName: "motorcycle"
      },
      5: {
       name: "/m/05czz6l",
       id: 5,
       displayName: "airplane"
      },
      6: {
       name: "/m/01bjv",
       id: 6,
       displayName: "bus"
      },
      7: {
       name: "/m/07jdr",
       id: 7,
       displayName: "train"
      },
      8: {
       name: "/m/07r04",
       id: 8,
       displayName: "truck"
      },
      9: {
       name: "/m/019jd",
       id: 9,
       displayName: "boat"
      },
      10: {
       name: "/m/015qff",
       id: 10,
       displayName: "traffic light"
      },
      11: {
       name: "/m/01pns0",
       id: 11,
       displayName: "fire hydrant"
      },
      13: {
       name: "/m/02pv19",
       id: 13,
       displayName: "stop sign"
      },
      14: {
       name: "/m/015qbp",
       id: 14,
       displayName: "parking meter"
      },
      15: {
       name: "/m/0cvnqh",
       id: 15,
       displayName: "bench"
      },
      16: {
       name: "/m/015p6",
       id: 16,
       displayName: "bird"
      },
      17: {
       name: "/m/01yrx",
       id: 17,
       displayName: "cat"
      },
      18: {
       name: "/m/0bt9lr",
       id: 18,
       displayName: "dog"
      },
      19: {
       name: "/m/03k3r",
       id: 19,
       displayName: "horse"
      },
      20: {
       name: "/m/07bgp",
       id: 20,
       displayName: "sheep"
      },
      21: {
       name: "/m/01xq0k1",
       id: 21,
       displayName: "cow"
      },
      22: {
       name: "/m/0bwd_0j",
       id: 22,
       displayName: "elephant"
      },
      23: {
       name: "/m/01dws",
       id: 23,
       displayName: "bear"
      },
      24: {
       name: "/m/0898b",
       id: 24,
       displayName: "zebra"
      },
      25: {
       name: "/m/03bk1",
       id: 25,
       displayName: "giraffe"
      },
      27: {
       name: "/m/01940j",
       id: 27,
       displayName: "backpack"
      },
      28: {
       name: "/m/0hnnb",
       id: 28,
       displayName: "umbrella"
      },
      31: {
       name: "/m/080hkjn",
       id: 31,
       displayName: "handbag"
      },
      32: {
       name: "/m/01rkbr",
       id: 32,
       displayName: "tie"
      },
      33: {
       name: "/m/01s55n",
       id: 33,
       displayName: "suitcase"
      },
      34: {
       name: "/m/02wmf",
       id: 34,
       displayName: "frisbee"
      },
      35: {
       name: "/m/071p9",
       id: 35,
       displayName: "skis"
      },
      36: {
       name: "/m/06__v",
       id: 36,
       displayName: "snowboard"
      },
      37: {
       name: "/m/018xm",
       id: 37,
       displayName: "sports ball"
      },
      38: {
       name: "/m/02zt3",
       id: 38,
       displayName: "kite"
      },
      39: {
       name: "/m/03g8mr",
       id: 39,
       displayName: "baseball bat"
      },
      40: {
       name: "/m/03grzl",
       id: 40,
       displayName: "baseball glove"
      },
      41: {
       name: "/m/06_fw",
       id: 41,
       displayName: "skateboard"
      },
      42: {
       name: "/m/019w40",
       id: 42,
       displayName: "surfboard"
      },
      43: {
       name: "/m/0dv9c",
       id: 43,
       displayName: "tennis racket"
      },
      44: {
       name: "/m/04dr76w",
       id: 44,
       displayName: "bottle"
      },
      46: {
       name: "/m/09tvcd",
       id: 46,
       displayName: "wine glass"
      },
      47: {
       name: "/m/08gqpm",
       id: 47,
       displayName: "cup"
      },
      48: {
       name: "/m/0dt3t",
       id: 48,
       displayName: "fork"
      },
      49: {
       name: "/m/04ctx",
       id: 49,
       displayName: "knife"
      },
      50: {
       name: "/m/0cmx8",
       id: 50,
       displayName: "spoon"
      },
      51: {
       name: "/m/04kkgm",
       id: 51,
       displayName: "bowl"
      },
      52: {
       name: "/m/09qck",
       id: 52,
       displayName: "banana"
      },
      53: {
       name: "/m/014j1m",
       id: 53,
       displayName: "apple"
      },
      54: {
       name: "/m/0l515",
       id: 54,
       displayName: "sandwich"
      },
      55: {
       name: "/m/0cyhj_",
       id: 55,
       displayName: "orange"
      },
      56: {
       name: "/m/0hkxq",
       id: 56,
       displayName: "broccoli"
      },
      57: {
       name: "/m/0fj52s",
       id: 57,
       displayName: "carrot"
      },
      58: {
       name: "/m/01b9xk",
       id: 58,
       displayName: "hot dog"
      },
      59: {
       name: "/m/0663v",
       id: 59,
       displayName: "pizza"
      },
      60: {
       name: "/m/0jy4k",
       id: 60,
       displayName: "donut"
      },
      61: {
       name: "/m/0fszt",
       id: 61,
       displayName: "cake"
      },
      62: {
       name: "/m/01mzpv",
       id: 62,
       displayName: "chair"
      },
      63: {
       name: "/m/02crq1",
       id: 63,
       displayName: "couch"
      },
      64: {
       name: "/m/03fp41",
       id: 64,
       displayName: "potted plant"
      },
      65: {
       name: "/m/03ssj5",
       id: 65,
       displayName: "bed"
      },
      67: {
       name: "/m/04bcr3",
       id: 67,
       displayName: "dining table"
      },
      70: {
       name: "/m/09g1w",
       id: 70,
       displayName: "toilet"
      },
      72: {
       name: "/m/07c52",
       id: 72,
       displayName: "tv"
      },
      73: {
       name: "/m/01c648",
       id: 73,
       displayName: "laptop"
      },
      74: {
       name: "/m/020lf",
       id: 74,
       displayName: "mouse"
      },
      75: {
       name: "/m/0qjjc",
       id: 75,
       displayName: "remote"
      },
      76: {
       name: "/m/01m2v",
       id: 76,
       displayName: "keyboard"
      },
      77: {
       name: "/m/050k8",
       id: 77,
       displayName: "cell phone"
      },
      78: {
       name: "/m/0fx9l",
       id: 78,
       displayName: "microwave"
      },
      79: {
       name: "/m/029bxz",
       id: 79,
       displayName: "oven"
      },
      80: {
       name: "/m/01k6s3",
       id: 80,
       displayName: "toaster"
      },
      81: {
       name: "/m/0130jx",
       id: 81,
       displayName: "sink"
      },
      82: {
       name: "/m/040b_t",
       id: 82,
       displayName: "refrigerator"
      },
      84: {
       name: "/m/0bt_c3",
       id: 84,
       displayName: "book"
      },
      85: {
       name: "/m/01x3z",
       id: 85,
       displayName: "clock"
      },
      86: {
       name: "/m/02s195",
       id: 86,
       displayName: "vase"
      },
      87: {
       name: "/m/01lsmm",
       id: 87,
       displayName: "scissors"
      },
      88: {
       name: "/m/0kmg4",
       id: 88,
       displayName: "teddy bear"
      },
      89: {
       name: "/m/03wvsk",
       id: 89,
       displayName: "hair drier"
      },
      90: {
       name: "/m/012xff",
       id: 90,
       displayName: "toothbrush"
      }
     },
     c = "https://storage.googleapis.com/tfjs-models/savedmodel/";
 
    function l(t) {
     return void 0 === t && (t = {}), o(this, void 0, void 0, (function() {
      var e, n, r;
      return a(this, (function(o) {
       switch (o.label) {
        case 0:
         if (null == i) throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");
         if (e = t.base || "lite_mobilenet_v2", n = t.modelUrl, -1 === ["mobilenet_v1", "mobilenet_v2", "lite_mobilenet_v2"].indexOf(e)) throw new Error("ObjectDetection constructed with invalid base model " + e + ". Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.");
         return [4, (r = new h(e, n)).load()];
        case 1:
         return o.sent(), [2, r]
       }
      }))
     }))
    }
    var h = function() {
     function t(t, e) {
      this.modelPath = e || "" + c + this.getPrefix(t) + "/model.json"
     }
     return t.prototype.getPrefix = function(t) {
      return "lite_mobilenet_v2" === t ? "ssd" + t : "ssd_" + t
     }, t.prototype.load = function() {
      return o(this, void 0, void 0, (function() {
       var t, e;
       return a(this, (function(n) {
        switch (n.label) {
         case 0:
          return t = this, [4, Object(r["a"])(this.modelPath)];
         case 1:
          return t.model = n.sent(), [4, this.model.executeAsync(Object(i["zeros"])([1, 300, 300, 3]))];
         case 2:
          return e = n.sent(), [4, Promise.all(e.map((function(t) {
           return t.data()
          })))];
         case 3:
          return n.sent(), e.map((function(t) {
           return t.dispose()
          })), [2]
        }
       }))
      }))
     }, t.prototype.infer = function(t, e) {
      return o(this, void 0, void 0, (function() {
       var n, r, o, u, c, l, h, p, f, d, v, m;
       return a(this, (function(a) {
        switch (a.label) {
         case 0:
          return n = Object(i["tidy"])((function() {
           return t instanceof i["Tensor"] || (t = i["browser"].fromPixels(t)), t.expandDims(0)
          })), r = n.shape[1], o = n.shape[2], [4, this.model.executeAsync(n)];
         case 1:
          return u = a.sent(), c = u[0].dataSync(), l = u[1].dataSync(), n.dispose(), Object(i["dispose"])(u), h = s(this.calculateMaxScores(c, u[0].shape[1], u[0].shape[2]), 2), p = h[0], f = h[1], d = Object(i["getBackend"])(), Object(i["setBackend"])("cpu"), v = Object(i["tidy"])((function() {
           var t = Object(i["tensor2d"])(l, [u[1].shape[1], u[1].shape[3]]);
           return i["image"].nonMaxSuppression(t, p, e, .5, .5)
          })), m = v.dataSync(), v.dispose(), Object(i["setBackend"])(d), [2, this.buildDetectedObjects(o, r, l, p, m, f)]
        }
       }))
      }))
     }, t.prototype.buildDetectedObjects = function(t, e, n, r, i, o) {
      for (var a = i.length, s = [], c = 0; c < a; c++) {
       for (var l = [], h = 0; h < 4; h++) l[h] = n[4 * i[c] + h];
       var p = l[0] * e,
        f = l[1] * t,
        d = l[2] * e,
        v = l[3] * t;
       l[0] = f, l[1] = p, l[2] = v - f, l[3] = d - p, s.push({
        bbox: l,
        class: u[o[i[c]] + 1].displayName,
        score: r[i[c]]
       })
      }
      return s
     }, t.prototype.calculateMaxScores = function(t, e, n) {
      for (var r = [], i = [], o = 0; o < e; o++) {
       for (var a = Number.MIN_VALUE, s = -1, u = 0; u < n; u++) t[o * n + u] > a && (a = t[o * n + u], s = u);
       r[o] = a, i[o] = s
      }
      return [r, i]
     }, t.prototype.detect = function(t, e) {
      return void 0 === e && (e = 20), o(this, void 0, void 0, (function() {
       return a(this, (function(n) {
        return [2, this.infer(t, e)]
       }))
      }))
     }, t.prototype.dispose = function() {
      this.model && this.model.dispose()
     }, t
    }()
   },
   c345: function(t, e, n) {
    "use strict";
    var r = n("c532"),
     i = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
    t.exports = function(t) {
     var e, n, o, a = {};
     return t ? (r.forEach(t.split("\n"), (function(t) {
      if (o = t.indexOf(":"), e = r.trim(t.substr(0, o)).toLowerCase(), n = r.trim(t.substr(o + 1)), e) {
       if (a[e] && i.indexOf(e) >= 0) return;
       a[e] = "set-cookie" === e ? (a[e] ? a[e] : []).concat([n]) : a[e] ? a[e] + ", " + n : n
      }
     })), a) : a
    }
   },
   c401: function(t, e, n) {
    "use strict";
    var r = n("c532");
    t.exports = function(t, e, n) {
     return r.forEach(n, (function(n) {
      t = n(t, e)
     })), t
    }
   },
   c430: function(t, e) {
    t.exports = !1
   },
   c532: function(t, e, n) {
    "use strict";
    var r = n("1d2b"),
     i = Object.prototype.toString;
 
    function o(t) {
     return "[object Array]" === i.call(t)
    }
 
    function a(t) {
     return "undefined" === typeof t
    }
 
    function s(t) {
     return null !== t && !a(t) && null !== t.constructor && !a(t.constructor) && "function" === typeof t.constructor.isBuffer && t.constructor.isBuffer(t)
    }
 
    function u(t) {
     return "[object ArrayBuffer]" === i.call(t)
    }
 
    function c(t) {
     return "undefined" !== typeof FormData && t instanceof FormData
    }
 
    function l(t) {
     var e;
     return e = "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && t.buffer instanceof ArrayBuffer, e
    }
 
    function h(t) {
     return "string" === typeof t
    }
 
    function p(t) {
     return "number" === typeof t
    }
 
    function f(t) {
     return null !== t && "object" === typeof t
    }
 
    function d(t) {
     return "[object Date]" === i.call(t)
    }
 
    function v(t) {
     return "[object File]" === i.call(t)
    }
 
    function m(t) {
     return "[object Blob]" === i.call(t)
    }
 
    function g(t) {
     return "[object Function]" === i.call(t)
    }
 
    function y(t) {
     return f(t) && g(t.pipe)
    }
 
    function b(t) {
     return "undefined" !== typeof URLSearchParams && t instanceof URLSearchParams
    }
 
    function x(t) {
     return t.replace(/^\s*/, "").replace(/\s*$/, "")
    }
 
    function w() {
     return ("undefined" === typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" !== typeof window && "undefined" !== typeof document)
    }
 
    function C(t, e) {
     if (null !== t && "undefined" !== typeof t)
      if ("object" !== typeof t && (t = [t]), o(t))
       for (var n = 0, r = t.length; n < r; n++) e.call(null, t[n], n, t);
      else
       for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.call(null, t[i], i, t)
    }
 
    function S() {
     var t = {};
 
     function e(e, n) {
      "object" === typeof t[n] && "object" === typeof e ? t[n] = S(t[n], e) : t[n] = e
     }
     for (var n = 0, r = arguments.length; n < r; n++) C(arguments[n], e);
     return t
    }
 
    function E() {
     var t = {};
 
     function e(e, n) {
      "object" === typeof t[n] && "object" === typeof e ? t[n] = E(t[n], e) : t[n] = "object" === typeof e ? E({}, e) : e
     }
     for (var n = 0, r = arguments.length; n < r; n++) C(arguments[n], e);
     return t
    }
 
    function k(t, e, n) {
     return C(e, (function(e, i) {
      t[i] = n && "function" === typeof e ? r(e, n) : e
     })), t
    }
    t.exports = {
     isArray: o,
     isArrayBuffer: u,
     isBuffer: s,
     isFormData: c,
     isArrayBufferView: l,
     isString: h,
     isNumber: p,
     isObject: f,
     isUndefined: a,
     isDate: d,
     isFile: v,
     isBlob: m,
     isFunction: g,
     isStream: y,
     isURLSearchParams: b,
     isStandardBrowserEnv: w,
     forEach: C,
     merge: S,
     deepMerge: E,
     extend: k,
     trim: x
    }
   },
   c6b6: function(t, e) {
    var n = {}.toString;
    t.exports = function(t) {
     return n.call(t).slice(8, -1)
    }
   },
   c6cd: function(t, e, n) {
    var r = n("da84"),
     i = n("ce4e"),
     o = "__core-js_shared__",
     a = r[o] || i(o, {});
    t.exports = a
   },
   c740: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("b727").findIndex,
     o = n("44d2"),
     a = n("ae40"),
     s = "findIndex",
     u = !0,
     c = a(s);
    s in [] && Array(1)[s]((function() {
     u = !1
    })), r({
     target: "Array",
     proto: !0,
     forced: u || !c
    }, {
     findIndex: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    }), o(s)
   },
   c7cd: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("857a"),
     o = n("af03");
    r({
     target: "String",
     proto: !0,
     forced: o("fixed")
    }, {
     fixed: function() {
      return i(this, "tt", "", "")
     }
    })
   },
   c832: function(t, e, n) {
    (function(e) {
     var n = "Expected a function",
      r = "__lodash_hash_undefined__",
      i = 1 / 0,
      o = "[object Function]",
      a = "[object GeneratorFunction]",
      s = "[object Symbol]",
      u = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      c = /^\w*$/,
      l = /^\./,
      h = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      p = /[\\^$.*+?()[\]{}|]/g,
      f = /\\(\\)?/g,
      d = /^\[object .+?Constructor\]$/,
      v = "object" == typeof e && e && e.Object === Object && e,
      m = "object" == typeof self && self && self.Object === Object && self,
      g = v || m || Function("return this")();
 
     function y(t, e) {
      return null == t ? void 0 : t[e]
     }
 
     function b(t) {
      var e = !1;
      if (null != t && "function" != typeof t.toString) try {
       e = !!(t + "")
      } catch (n) {}
      return e
     }
     var x = Array.prototype,
      w = Function.prototype,
      C = Object.prototype,
      S = g["__core-js_shared__"],
      E = function() {
       var t = /[^.]+$/.exec(S && S.keys && S.keys.IE_PROTO || "");
       return t ? "Symbol(src)_1." + t : ""
      }(),
      k = w.toString,
      I = C.hasOwnProperty,
      O = C.toString,
      A = RegExp("^" + k.call(I).replace(p, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
      N = g.Symbol,
      R = x.splice,
      T = ot(g, "Map"),
      _ = ot(Object, "create"),
      D = N ? N.prototype : void 0,
      F = D ? D.toString : void 0;
 
     function M(t) {
      var e = -1,
       n = t ? t.length : 0;
      this.clear();
      while (++e < n) {
       var r = t[e];
       this.set(r[0], r[1])
      }
     }
 
     function L() {
      this.__data__ = _ ? _(null) : {}
     }
 
     function B(t) {
      return this.has(t) && delete this.__data__[t]
     }
 
     function P(t) {
      var e = this.__data__;
      if (_) {
       var n = e[t];
       return n === r ? void 0 : n
      }
      return I.call(e, t) ? e[t] : void 0
     }
 
     function z(t) {
      var e = this.__data__;
      return _ ? void 0 !== e[t] : I.call(e, t)
     }
 
     function j(t, e) {
      var n = this.__data__;
      return n[t] = _ && void 0 === e ? r : e, this
     }
 
     function W(t) {
      var e = -1,
       n = t ? t.length : 0;
      this.clear();
      while (++e < n) {
       var r = t[e];
       this.set(r[0], r[1])
      }
     }
 
     function V() {
      this.__data__ = []
     }
 
     function U(t) {
      var e = this.__data__,
       n = Q(e, t);
      if (n < 0) return !1;
      var r = e.length - 1;
      return n == r ? e.pop() : R.call(e, n, 1), !0
     }
 
     function H(t) {
      var e = this.__data__,
       n = Q(e, t);
      return n < 0 ? void 0 : e[n][1]
     }
 
     function $(t) {
      return Q(this.__data__, t) > -1
     }
 
     function G(t, e) {
      var n = this.__data__,
       r = Q(n, t);
      return r < 0 ? n.push([t, e]) : n[r][1] = e, this
     }
 
     function q(t) {
      var e = -1,
       n = t ? t.length : 0;
      this.clear();
      while (++e < n) {
       var r = t[e];
       this.set(r[0], r[1])
      }
     }
 
     function K() {
      this.__data__ = {
       hash: new M,
       map: new(T || W),
       string: new M
      }
     }
 
     function X(t) {
      return it(this, t)["delete"](t)
     }
 
     function Y(t) {
      return it(this, t).get(t)
     }
 
     function Z(t) {
      return it(this, t).has(t)
     }
 
     function J(t, e) {
      return it(this, t).set(t, e), this
     }
 
     function Q(t, e) {
      var n = t.length;
      while (n--)
       if (ft(t[n][0], e)) return n;
      return -1
     }
 
     function tt(t, e) {
      e = at(e, t) ? [e] : rt(e);
      var n = 0,
       r = e.length;
      while (null != t && n < r) t = t[lt(e[n++])];
      return n && n == r ? t : void 0
     }
 
     function et(t) {
      if (!mt(t) || ut(t)) return !1;
      var e = vt(t) || b(t) ? A : d;
      return e.test(ht(t))
     }
 
     function nt(t) {
      if ("string" == typeof t) return t;
      if (yt(t)) return F ? F.call(t) : "";
      var e = t + "";
      return "0" == e && 1 / t == -i ? "-0" : e
     }
 
     function rt(t) {
      return dt(t) ? t : ct(t)
     }
 
     function it(t, e) {
      var n = t.__data__;
      return st(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
     }
 
     function ot(t, e) {
      var n = y(t, e);
      return et(n) ? n : void 0
     }
 
     function at(t, e) {
      if (dt(t)) return !1;
      var n = typeof t;
      return !("number" != n && "symbol" != n && "boolean" != n && null != t && !yt(t)) || (c.test(t) || !u.test(t) || null != e && t in Object(e))
     }
 
     function st(t) {
      var e = typeof t;
      return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
     }
 
     function ut(t) {
      return !!E && E in t
     }
     M.prototype.clear = L, M.prototype["delete"] = B, M.prototype.get = P, M.prototype.has = z, M.prototype.set = j, W.prototype.clear = V, W.prototype["delete"] = U, W.prototype.get = H, W.prototype.has = $, W.prototype.set = G, q.prototype.clear = K, q.prototype["delete"] = X, q.prototype.get = Y, q.prototype.has = Z, q.prototype.set = J;
     var ct = pt((function(t) {
      t = bt(t);
      var e = [];
      return l.test(t) && e.push(""), t.replace(h, (function(t, n, r, i) {
       e.push(r ? i.replace(f, "$1") : n || t)
      })), e
     }));
 
     function lt(t) {
      if ("string" == typeof t || yt(t)) return t;
      var e = t + "";
      return "0" == e && 1 / t == -i ? "-0" : e
     }
 
     function ht(t) {
      if (null != t) {
       try {
        return k.call(t)
       } catch (e) {}
       try {
        return t + ""
       } catch (e) {}
      }
      return ""
     }
 
     function pt(t, e) {
      if ("function" != typeof t || e && "function" != typeof e) throw new TypeError(n);
      var r = function() {
       var n = arguments,
        i = e ? e.apply(this, n) : n[0],
        o = r.cache;
       if (o.has(i)) return o.get(i);
       var a = t.apply(this, n);
       return r.cache = o.set(i, a), a
      };
      return r.cache = new(pt.Cache || q), r
     }
 
     function ft(t, e) {
      return t === e || t !== t && e !== e
     }
     pt.Cache = q;
     var dt = Array.isArray;
 
     function vt(t) {
      var e = mt(t) ? O.call(t) : "";
      return e == o || e == a
     }
 
     function mt(t) {
      var e = typeof t;
      return !!t && ("object" == e || "function" == e)
     }
 
     function gt(t) {
      return !!t && "object" == typeof t
     }
 
     function yt(t) {
      return "symbol" == typeof t || gt(t) && O.call(t) == s
     }
 
     function bt(t) {
      return null == t ? "" : nt(t)
     }
 
     function xt(t, e, n) {
      var r = null == t ? void 0 : tt(t, e);
      return void 0 === r ? n : r
     }
     t.exports = xt
    }).call(this, n("c8ba"))
   },
   c8af: function(t, e, n) {
    "use strict";
    var r = n("c532");
    t.exports = function(t, e) {
     r.forEach(t, (function(n, r) {
      r !== e && r.toUpperCase() === e.toUpperCase() && (t[e] = n, delete t[r])
     }))
    }
   },
   c8ba: function(t, e) {
    var n;
    n = function() {
     return this
    }();
    try {
     n = n || new Function("return this")()
    } catch (r) {
     "object" === typeof window && (n = window)
    }
    t.exports = n
   },
   c8d2: function(t, e, n) {
    var r = n("d039"),
     i = n("5899"),
     o = "";
    t.exports = function(t) {
     return r((function() {
      return !!i[t]() || o[t]() != o || i[t].name !== t
     }))
    }
   },
   c96a: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("857a"),
     o = n("af03");
    r({
     target: "String",
     proto: !0,
     forced: o("small")
    }, {
     small: function() {
      return i(this, "small", "", "")
     }
    })
   },
   c975: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("4d64").indexOf,
     o = n("a640"),
     a = n("ae40"),
     s = [].indexOf,
     u = !!s && 1 / [1].indexOf(1, -0) < 0,
     c = o("indexOf"),
     l = a("indexOf", {
      ACCESSORS: !0,
      1: 0
     });
    r({
     target: "Array",
     proto: !0,
     forced: u || !c || !l
    }, {
     indexOf: function(t) {
      return u ? s.apply(this, arguments) || 0 : i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   ca84: function(t, e, n) {
    var r = n("5135"),
     i = n("fc6a"),
     o = n("4d64").indexOf,
     a = n("d012");
    t.exports = function(t, e) {
     var n, s = i(t),
      u = 0,
      c = [];
     for (n in s) !r(a, n) && r(s, n) && c.push(n);
     while (e.length > u) r(s, n = e[u++]) && (~o(c, n) || c.push(n));
     return c
    }
   },
   caad: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("4d64").includes,
     o = n("44d2"),
     a = n("ae40"),
     s = a("indexOf", {
      ACCESSORS: !0,
      1: 0
     });
    r({
     target: "Array",
     proto: !0,
     forced: !s
    }, {
     includes: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    }), o("includes")
   },
   cc12: function(t, e, n) {
    var r = n("da84"),
     i = n("861d"),
     o = r.document,
     a = i(o) && i(o.createElement);
    t.exports = function(t) {
     return a ? o.createElement(t) : {}
    }
   },
   cca6: function(t, e, n) {
    var r = n("23e7"),
     i = n("60da");
    r({
     target: "Object",
     stat: !0,
     forced: Object.assign !== i
    }, {
     assign: i
    })
   },
   cdf9: function(t, e, n) {
    var r = n("825a"),
     i = n("861d"),
     o = n("f069");
    t.exports = function(t, e) {
     if (r(t), i(e) && e.constructor === t) return e;
     var n = o.f(t),
      a = n.resolve;
     return a(e), n.promise
    }
   },
   ce4e: function(t, e, n) {
    var r = n("da84"),
     i = n("9112");
    t.exports = function(t, e) {
     try {
      i(r, t, e)
     } catch (n) {
      r[t] = e
     }
     return e
    }
   },
   ce7e: function(t, e, n) {
    "use strict";
    var r = n("5530"),
     i = (n("8ce9"), n("7560"));
    e["a"] = i["a"].extend({
     name: "v-divider",
     props: {
      inset: Boolean,
      vertical: Boolean
     },
     render: function(t) {
      var e;
      return this.$attrs.role && "separator" !== this.$attrs.role || (e = this.vertical ? "vertical" : "horizontal"), t("hr", {
       class: Object(r["a"])({
        "v-divider": !0,
        "v-divider--inset": this.inset,
        "v-divider--vertical": this.vertical
       }, this.themeClasses),
       attrs: Object(r["a"])({
        role: "separator",
        "aria-orientation": e
       }, this.$attrs),
       on: this.$listeners
      })
     }
    })
   },
   cee4: function(t, e, n) {
    "use strict";
    var r = n("c532"),
     i = n("1d2b"),
     o = n("0a06"),
     a = n("4a7b"),
     s = n("2444");
 
    function u(t) {
     var e = new o(t),
      n = i(o.prototype.request, e);
     return r.extend(n, o.prototype, e), r.extend(n, e), n
    }
    var c = u(s);
    c.Axios = o, c.create = function(t) {
     return u(a(c.defaults, t))
    }, c.Cancel = n("7a77"), c.CancelToken = n("8df4"), c.isCancel = n("2e67"), c.all = function(t) {
     return Promise.all(t)
    }, c.spread = n("0df6"), t.exports = c, t.exports.default = c
   },
   cf36: function(t, e, n) {},
   d012: function(t, e) {
    t.exports = {}
   },
   d039: function(t, e) {
    t.exports = function(t) {
     try {
      return !!t()
     } catch (e) {
      return !0
     }
    }
   },
   d066: function(t, e, n) {
    var r = n("428f"),
     i = n("da84"),
     o = function(t) {
      return "function" == typeof t ? t : void 0
     };
    t.exports = function(t, e) {
     return arguments.length < 2 ? o(r[t]) || o(i[t]) : r[t] && r[t][e] || i[t] && i[t][e]
    }
   },
   d10f: function(t, e, n) {
    "use strict";
    var r = n("2b0e");
    e["a"] = r["a"].extend({
     name: "ssr-bootable",
     data: function() {
      return {
       isBooted: !1
      }
     },
     mounted: function() {
      var t = this;
      window.requestAnimationFrame((function() {
       t.$el.setAttribute("data-booted", "true"), t.isBooted = !0
      }))
     }
    })
   },
   d191: function(t, e, n) {},
   d1e7: function(t, e, n) {
    "use strict";
    var r = {}.propertyIsEnumerable,
     i = Object.getOwnPropertyDescriptor,
     o = i && !r.call({
      1: 2
     }, 1);
    e.f = o ? function(t) {
     var e = i(this, t);
     return !!e && e.enumerable
    } : r
   },
   d28b: function(t, e, n) {
    var r = n("746f");
    r("iterator")
   },
   d2bb: function(t, e, n) {
    var r = n("825a"),
     i = n("3bbe");
    t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
     var t, e = !1,
      n = {};
     try {
      t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, t.call(n, []), e = n instanceof Array
     } catch (o) {}
     return function(n, o) {
      return r(n), i(o), e ? t.call(n, o) : n.__proto__ = o, n
     }
    }() : void 0)
   },
   d3b7: function(t, e, n) {
    var r = n("00ee"),
     i = n("6eeb"),
     o = n("b041");
    r || i(Object.prototype, "toString", o, {
     unsafe: !0
    })
   },
   d44e: function(t, e, n) {
    var r = n("9bf2").f,
     i = n("5135"),
     o = n("b622"),
     a = o("toStringTag");
    t.exports = function(t, e, n) {
     t && !i(t = n ? t : t.prototype, a) && r(t, a, {
      configurable: !0,
      value: e
     })
    }
   },
   d58f: function(t, e, n) {
    var r = n("1c0b"),
     i = n("7b0b"),
     o = n("44ad"),
     a = n("50c4"),
     s = function(t) {
      return function(e, n, s, u) {
       r(n);
       var c = i(e),
        l = o(c),
        h = a(c.length),
        p = t ? h - 1 : 0,
        f = t ? -1 : 1;
       if (s < 2)
        while (1) {
         if (p in l) {
          u = l[p], p += f;
          break
         }
         if (p += f, t ? p < 0 : h <= p) throw TypeError("Reduce of empty array with no initial value")
        }
       for (; t ? p >= 0 : h > p; p += f) p in l && (u = n(u, l[p], p, c));
       return u
      }
     };
    t.exports = {
     left: s(!1),
     right: s(!0)
    }
   },
   d5e8: function(t, e, n) {},
   d784: function(t, e, n) {
    "use strict";
    n("ac1f");
    var r = n("6eeb"),
     i = n("d039"),
     o = n("b622"),
     a = n("9263"),
     s = n("9112"),
     u = o("species"),
     c = !i((function() {
      var t = /./;
      return t.exec = function() {
       var t = [];
       return t.groups = {
        a: "7"
       }, t
      }, "7" !== "".replace(t, "$<a>")
     })),
     l = function() {
      return "$0" === "a".replace(/./, "$0")
     }(),
     h = o("replace"),
     p = function() {
      return !!/./ [h] && "" === /./ [h]("a", "$0")
     }(),
     f = !i((function() {
      var t = /(?:)/,
       e = t.exec;
      t.exec = function() {
       return e.apply(this, arguments)
      };
      var n = "ab".split(t);
      return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
     }));
    t.exports = function(t, e, n, h) {
     var d = o(t),
      v = !i((function() {
       var e = {};
       return e[d] = function() {
        return 7
       }, 7 != "" [t](e)
      })),
      m = v && !i((function() {
       var e = !1,
        n = /a/;
       return "split" === t && (n = {}, n.constructor = {}, n.constructor[u] = function() {
        return n
       }, n.flags = "", n[d] = /./ [d]), n.exec = function() {
        return e = !0, null
       }, n[d](""), !e
      }));
     if (!v || !m || "replace" === t && (!c || !l || p) || "split" === t && !f) {
      var g = /./ [d],
       y = n(d, "" [t], (function(t, e, n, r, i) {
        return e.exec === a ? v && !i ? {
         done: !0,
         value: g.call(e, n, r)
        } : {
         done: !0,
         value: t.call(n, e, r)
        } : {
         done: !1
        }
       }), {
        REPLACE_KEEPS_$0: l,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: p
       }),
       b = y[0],
       x = y[1];
      r(String.prototype, t, b), r(RegExp.prototype, d, 2 == e ? function(t, e) {
       return x.call(t, this, e)
      } : function(t) {
       return x.call(t, this)
      })
     }
     h && s(RegExp.prototype[d], "sham", !0)
    }
   },
   d81d: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("b727").map,
     o = n("1dde"),
     a = n("ae40"),
     s = o("map"),
     u = a("map");
    r({
     target: "Array",
     proto: !0,
     forced: !s || !u
    }, {
     map: function(t) {
      return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
     }
    })
   },
   d925: function(t, e, n) {
    "use strict";
    t.exports = function(t) {
     return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t)
    }
   },
   d9bd: function(t, e, n) {
    "use strict";
    n.d(e, "c", (function() {
     return i
    })), n.d(e, "b", (function() {
     return o
    })), n.d(e, "a", (function() {
     return a
    })), n.d(e, "d", (function() {
     return s
    }));
    n("99af"), n("caad"), n("a15b"), n("d81d"), n("b0c0"), n("ac1f"), n("2532"), n("466d"), n("38cf"), n("5319");
 
    function r(t, e, n) {
     if (n && (e = {
       _isVue: !0,
       $parent: n,
       $options: e
      }), e) {
      if (e.$_alreadyWarned = e.$_alreadyWarned || [], e.$_alreadyWarned.includes(t)) return;
      e.$_alreadyWarned.push(t)
     }
     return "[Vuetify] ".concat(t) + (e ? h(e) : "")
    }
 
    function i(t, e, n) {
     var i = r(t, e, n);
     null != i && console.warn(i)
    }
 
    function o(t, e, n) {
     var i = r(t, e, n);
     null != i && console.error(i)
    }
 
    function a(t, e, n, r) {
     o("[BREAKING] '".concat(t, "' has been removed, use '").concat(e, "' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide"), n, r)
    }
 
    function s(t, e, n) {
     i("[REMOVED] '".concat(t, "' has been removed. You can safely omit it."), e, n)
    }
    var u = /(?:^|[-_])(\w)/g,
     c = function(t) {
      return t.replace(u, (function(t) {
       return t.toUpperCase()
      })).replace(/[-_]/g, "")
     };
 
    function l(t, e) {
     if (t.$root === t) return "<Root>";
     var n = "function" === typeof t && null != t.cid ? t.options : t._isVue ? t.$options || t.constructor.options : t || {},
      r = n.name || n._componentTag,
      i = n.__file;
     if (!r && i) {
      var o = i.match(/([^/\\]+)\.vue$/);
      r = o && o[1]
     }
     return (r ? "<".concat(c(r), ">") : "<Anonymous>") + (i && !1 !== e ? " at ".concat(i) : "")
    }
 
    function h(t) {
     if (t._isVue && t.$parent) {
      var e = [],
       n = 0;
      while (t) {
       if (e.length > 0) {
        var r = e[e.length - 1];
        if (r.constructor === t.constructor) {
         n++, t = t.$parent;
         continue
        }
        n > 0 && (e[e.length - 1] = [r, n], n = 0)
       }
       e.push(t), t = t.$parent
      }
      return "\n\nfound in\n\n" + e.map((function(t, e) {
       return "".concat(0 === e ? "---\x3e " : " ".repeat(5 + 2 * e)).concat(Array.isArray(t) ? "".concat(l(t[0]), "... (").concat(t[1], " recursive calls)") : l(t))
      })).join("\n")
     }
     return "\n\n(found in ".concat(l(t), ")")
    }
   },
   d9f7: function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return u
    }));
    n("a4d3"), n("e01a"), n("d28b"), n("99af"), n("b64b"), n("d3b7"), n("ac1f"), n("3ca3"), n("1276"), n("498a"), n("ddb0");
    var r = n("5530"),
     i = n("3835"),
     o = n("80d2"),
     a = {
      styleList: /;(?![^(]*\))/g,
      styleProp: /:(.*)/
     };
 
    function s(t) {
     var e = {},
      n = !0,
      r = !1,
      s = void 0;
     try {
      for (var u, c = t.split(a.styleList)[Symbol.iterator](); !(n = (u = c.next()).done); n = !0) {
       var l = u.value,
        h = l.split(a.styleProp),
        p = Object(i["a"])(h, 2),
        f = p[0],
        d = p[1];
       f = f.trim(), f && ("string" === typeof d && (d = d.trim()), e[Object(o["c"])(f)] = d)
      }
     } catch (v) {
      r = !0, s = v
     } finally {
      try {
       n || null == c.return || c.return()
      } finally {
       if (r) throw s
      }
     }
     return e
    }
 
    function u() {
     var t, e, n = {},
      i = arguments.length;
     while (i--)
      for (var o = 0, a = Object.keys(arguments[i]); o < a.length; o++) switch (t = a[o], t) {
       case "class":
       case "style":
       case "directives":
        if (!arguments[i][t]) break;
        if (Array.isArray(n[t]) || (n[t] = []), "style" === t) {
         var u = void 0;
         u = Array.isArray(arguments[i].style) ? arguments[i].style : [arguments[i].style];
         for (var c = 0; c < u.length; c++) {
          var l = u[c];
          "string" === typeof l && (u[c] = s(l))
         }
         arguments[i].style = u
        }
        n[t] = n[t].concat(arguments[i][t]);
        break;
       case "staticClass":
        if (!arguments[i][t]) break;
        void 0 === n[t] && (n[t] = ""), n[t] && (n[t] += " "), n[t] += arguments[i][t].trim();
        break;
       case "on":
       case "nativeOn":
        if (!arguments[i][t]) break;
        n[t] || (n[t] = {});
        for (var h = n[t], p = 0, f = Object.keys(arguments[i][t] || {}); p < f.length; p++) e = f[p], h[e] ? h[e] = Array().concat(h[e], arguments[i][t][e]) : h[e] = arguments[i][t][e];
        break;
       case "attrs":
       case "props":
       case "domProps":
       case "scopedSlots":
       case "staticStyle":
       case "hook":
       case "transition":
        if (!arguments[i][t]) break;
        n[t] || (n[t] = {}), n[t] = Object(r["a"])({}, arguments[i][t], {}, n[t]);
        break;
       case "slot":
       case "key":
       case "ref":
       case "tag":
       case "show":
       case "keepAlive":
       default:
        n[t] || (n[t] = arguments[i][t])
      }
     return n
    }
   },
   da13: function(t, e, n) {
    "use strict";
    var r = n("5530"),
     i = (n("61d2"), n("a9ad")),
     o = n("1c87"),
     a = n("4e82"),
     s = n("7560"),
     u = n("f2e7"),
     c = n("5607"),
     l = n("80d2"),
     h = n("d9bd"),
     p = n("58df"),
     f = Object(p["a"])(i["a"], o["a"], s["a"], Object(a["a"])("listItemGroup"), Object(u["b"])("inputValue"));
    e["a"] = f.extend().extend({
     name: "v-list-item",
     directives: {
      Ripple: c["a"]
     },
     inheritAttrs: !1,
     inject: {
      isInGroup: {
       default: !1
      },
      isInList: {
       default: !1
      },
      isInMenu: {
       default: !1
      },
      isInNav: {
       default: !1
      }
     },
     props: {
      activeClass: {
       type: String,
       default: function() {
        return this.listItemGroup ? this.listItemGroup.activeClass : ""
       }
      },
      dense: Boolean,
      inactive: Boolean,
      link: Boolean,
      selectable: {
       type: Boolean
      },
      tag: {
       type: String,
       default: "div"
      },
      threeLine: Boolean,
      twoLine: Boolean,
      value: null
     },
     data: function() {
      return {
       proxyClass: "v-list-item--active"
      }
     },
     computed: {
      classes: function() {
       return Object(r["a"])({
        "v-list-item": !0
       }, o["a"].options.computed.classes.call(this), {
        "v-list-item--dense": this.dense,
        "v-list-item--disabled": this.disabled,
        "v-list-item--link": this.isClickable && !this.inactive,
        "v-list-item--selectable": this.selectable,
        "v-list-item--three-line": this.threeLine,
        "v-list-item--two-line": this.twoLine
       }, this.themeClasses)
      },
      isClickable: function() {
       return Boolean(o["a"].options.computed.isClickable.call(this) || this.listItemGroup)
      }
     },
     created: function() {
      this.$attrs.hasOwnProperty("avatar") && Object(h["d"])("avatar", this)
     },
     methods: {
      click: function(t) {
       t.detail && this.$el.blur(), this.$emit("click", t), this.to || this.toggle()
      },
      genAttrs: function() {
       var t = Object(r["a"])({
        "aria-disabled": !!this.disabled || void 0,
        tabindex: this.isClickable && !this.disabled ? 0 : -1
       }, this.$attrs);
       return this.$attrs.hasOwnProperty("role") || this.isInNav || (this.isInGroup ? (t.role = "listitem", t["aria-selected"] = String(this.isActive)) : this.isInMenu ? (t.role = this.isClickable ? "menuitem" : void 0, t.id = t.id || "list-item-".concat(this._uid)) : this.isInList && (t.role = "listitem")), t
      }
     },
     render: function(t) {
      var e = this,
       n = this.generateRouteLink(),
       i = n.tag,
       o = n.data;
      o.attrs = Object(r["a"])({}, o.attrs, {}, this.genAttrs()), o.on = Object(r["a"])({}, o.on, {
       click: this.click,
       keydown: function(t) {
        t.keyCode === l["q"].enter && e.click(t), e.$emit("keydown", t)
       }
      });
      var a = this.$scopedSlots.default ? this.$scopedSlots.default({
       active: this.isActive,
       toggle: this.toggle
      }) : this.$slots.default;
      return i = this.inactive ? "div" : i, t(i, this.setTextColor(this.color, o), a)
     }
    })
   },
   da84: function(t, e, n) {
    (function(e) {
     var n = function(t) {
      return t && t.Math == Math && t
     };
     t.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || Function("return this")()
    }).call(this, n("c8ba"))
   },
   daaf: function(t, e, n) {},
   db42: function(t, e, n) {},
   db90: function(t, e, n) {
    "use strict";
    n.d(e, "a", (function() {
     return r
    }));
    n("a4d3"), n("e01a"), n("d28b"), n("a630"), n("e260"), n("d3b7"), n("25f0"), n("3ca3"), n("ddb0");
 
    function r(t) {
     if (Symbol.iterator in Object(t) || "[object Arguments]" === Object.prototype.toString.call(t)) return Array.from(t)
    }
   },
   dbb4: function(t, e, n) {
    var r = n("23e7"),
     i = n("83ab"),
     o = n("56ef"),
     a = n("fc6a"),
     s = n("06cf"),
     u = n("8418");
    r({
     target: "Object",
     stat: !0,
     sham: !i
    }, {
     getOwnPropertyDescriptors: function(t) {
      var e, n, r = a(t),
       i = s.f,
       c = o(r),
       l = {},
       h = 0;
      while (c.length > h) n = i(r, e = c[h++]), void 0 !== n && u(l, e, n);
      return l
     }
    })
   },
   dc22: function(t, e, n) {
    "use strict";
 
    function r(t, e) {
     var n = e.value,
      r = e.options || {
       passive: !0
      };
     window.addEventListener("resize", n, r), t._onResize = {
      callback: n,
      options: r
     }, e.modifiers && e.modifiers.quiet || n()
    }
 
    function i(t) {
     if (t._onResize) {
      var e = t._onResize,
       n = e.callback,
       r = e.options;
      window.removeEventListener("resize", n, r), delete t._onResize
     }
    }
    var o = {
     inserted: r,
     unbind: i
    };
    e["a"] = o
   },
   dca8: function(t, e, n) {
    var r = n("23e7"),
     i = n("bb2f"),
     o = n("d039"),
     a = n("861d"),
     s = n("f183").onFreeze,
     u = Object.freeze,
     c = o((function() {
      u(1)
     }));
    r({
     target: "Object",
     stat: !0,
     forced: c,
     sham: !i
    }, {
     freeze: function(t) {
      return u && a(t) ? u(s(t)) : t
     }
    })
   },
   ddb0: function(t, e, n) {
    var r = n("da84"),
     i = n("fdbc"),
     o = n("e260"),
     a = n("9112"),
     s = n("b622"),
     u = s("iterator"),
     c = s("toStringTag"),
     l = o.values;
    for (var h in i) {
     var p = r[h],
      f = p && p.prototype;
     if (f) {
      if (f[u] !== l) try {
       a(f, u, l)
      } catch (v) {
       f[u] = l
      }
      if (f[c] || a(f, c, h), i[h])
       for (var d in o)
        if (f[d] !== o[d]) try {
         a(f, d, o[d])
        } catch (v) {
         f[d] = o[d]
        }
     }
    }
   },
   df75: function(t, e, n) {
    var r = n("ca84"),
     i = n("7839");
    t.exports = Object.keys || function(t) {
     return r(t, i)
    }
   },
   df7c: function(t, e, n) {
    (function(t) {
     function n(t, e) {
      for (var n = 0, r = t.length - 1; r >= 0; r--) {
       var i = t[r];
       "." === i ? t.splice(r, 1) : ".." === i ? (t.splice(r, 1), n++) : n && (t.splice(r, 1), n--)
      }
      if (e)
       for (; n--; n) t.unshift("..");
      return t
     }
 
     function r(t) {
      "string" !== typeof t && (t += "");
      var e, n = 0,
       r = -1,
       i = !0;
      for (e = t.length - 1; e >= 0; --e)
       if (47 === t.charCodeAt(e)) {
        if (!i) {
         n = e + 1;
         break
        }
       } else -1 === r && (i = !1, r = e + 1);
      return -1 === r ? "" : t.slice(n, r)
     }
 
     function i(t, e) {
      if (t.filter) return t.filter(e);
      for (var n = [], r = 0; r < t.length; r++) e(t[r], r, t) && n.push(t[r]);
      return n
     }
     e.resolve = function() {
      for (var e = "", r = !1, o = arguments.length - 1; o >= -1 && !r; o--) {
       var a = o >= 0 ? arguments[o] : t.cwd();
       if ("string" !== typeof a) throw new TypeError("Arguments to path.resolve must be strings");
       a && (e = a + "/" + e, r = "/" === a.charAt(0))
      }
      return e = n(i(e.split("/"), (function(t) {
       return !!t
      })), !r).join("/"), (r ? "/" : "") + e || "."
     }, e.normalize = function(t) {
      var r = e.isAbsolute(t),
       a = "/" === o(t, -1);
      return t = n(i(t.split("/"), (function(t) {
       return !!t
      })), !r).join("/"), t || r || (t = "."), t && a && (t += "/"), (r ? "/" : "") + t
     }, e.isAbsolute = function(t) {
      return "/" === t.charAt(0)
     }, e.join = function() {
      var t = Array.prototype.slice.call(arguments, 0);
      return e.normalize(i(t, (function(t, e) {
       if ("string" !== typeof t) throw new TypeError("Arguments to path.join must be strings");
       return t
      })).join("/"))
     }, e.relative = function(t, n) {
      function r(t) {
       for (var e = 0; e < t.length; e++)
        if ("" !== t[e]) break;
       for (var n = t.length - 1; n >= 0; n--)
        if ("" !== t[n]) break;
       return e > n ? [] : t.slice(e, n - e + 1)
      }
      t = e.resolve(t).substr(1), n = e.resolve(n).substr(1);
      for (var i = r(t.split("/")), o = r(n.split("/")), a = Math.min(i.length, o.length), s = a, u = 0; u < a; u++)
       if (i[u] !== o[u]) {
        s = u;
        break
       } var c = [];
      for (u = s; u < i.length; u++) c.push("..");
      return c = c.concat(o.slice(s)), c.join("/")
     }, e.sep = "/", e.delimiter = ":", e.dirname = function(t) {
      if ("string" !== typeof t && (t += ""), 0 === t.length) return ".";
      for (var e = t.charCodeAt(0), n = 47 === e, r = -1, i = !0, o = t.length - 1; o >= 1; --o)
       if (e = t.charCodeAt(o), 47 === e) {
        if (!i) {
         r = o;
         break
        }
       } else i = !1;
      return -1 === r ? n ? "/" : "." : n && 1 === r ? "/" : t.slice(0, r)
     }, e.basename = function(t, e) {
      var n = r(t);
      return e && n.substr(-1 * e.length) === e && (n = n.substr(0, n.length - e.length)), n
     }, e.extname = function(t) {
      "string" !== typeof t && (t += "");
      for (var e = -1, n = 0, r = -1, i = !0, o = 0, a = t.length - 1; a >= 0; --a) {
       var s = t.charCodeAt(a);
       if (47 !== s) - 1 === r && (i = !1, r = a + 1), 46 === s ? -1 === e ? e = a : 1 !== o && (o = 1) : -1 !== e && (o = -1);
       else if (!i) {
        n = a + 1;
        break
       }
      }
      return -1 === e || -1 === r || 0 === o || 1 === o && e === r - 1 && e === n + 1 ? "" : t.slice(e, r)
     };
     var o = "b" === "ab".substr(-1) ? function(t, e, n) {
      return t.substr(e, n)
     } : function(t, e, n) {
      return e < 0 && (e = t.length + e), t.substr(e, n)
     }
    }).call(this, n("4362"))
   },
   df86: function(t, e, n) {},
   e01a: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("83ab"),
     o = n("da84"),
     a = n("5135"),
     s = n("861d"),
     u = n("9bf2").f,
     c = n("e893"),
     l = o.Symbol;
    if (i && "function" == typeof l && (!("description" in l.prototype) || void 0 !== l().description)) {
     var h = {},
      p = function() {
       var t = arguments.length < 1 || void 0 === arguments[0] ? void 0 : String(arguments[0]),
        e = this instanceof p ? new l(t) : void 0 === t ? l() : l(t);
       return "" === t && (h[e] = !0), e
      };
     c(p, l);
     var f = p.prototype = l.prototype;
     f.constructor = p;
     var d = f.toString,
      v = "Symbol(test)" == String(l("test")),
      m = /^Symbol\((.*)\)[^)]+$/;
     u(f, "description", {
      configurable: !0,
      get: function() {
       var t = s(this) ? this.valueOf() : this,
        e = d.call(t);
       if (a(h, t)) return "";
       var n = v ? e.slice(7, -1) : e.replace(m, "$1");
       return "" === n ? void 0 : n
      }
     }), r({
      global: !0,
      forced: !0
     }, {
      Symbol: p
     })
    }
   },
   e0c7: function(t, e, n) {
    "use strict";
    var r = n("5530"),
     i = (n("0bc6"), n("7560")),
     o = n("58df");
    e["a"] = Object(o["a"])(i["a"]).extend({
     name: "v-subheader",
     props: {
      inset: Boolean
     },
     render: function(t) {
      return t("div", {
       staticClass: "v-subheader",
       class: Object(r["a"])({
        "v-subheader--inset": this.inset
       }, this.themeClasses),
       attrs: this.$attrs,
       on: this.$listeners
      }, this.$slots.default)
     }
    })
   },
   e163: function(t, e, n) {
    var r = n("5135"),
     i = n("7b0b"),
     o = n("f772"),
     a = n("e177"),
     s = o("IE_PROTO"),
     u = Object.prototype;
    t.exports = a ? Object.getPrototypeOf : function(t) {
     return t = i(t), r(t, s) ? t[s] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? u : null
    }
   },
   e177: function(t, e, n) {
    var r = n("d039");
    t.exports = !r((function() {
     function t() {}
     return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
    }))
   },
   e260: function(t, e, n) {
    "use strict";
    var r = n("fc6a"),
     i = n("44d2"),
     o = n("3f8c"),
     a = n("69f3"),
     s = n("7dd0"),
     u = "Array Iterator",
     c = a.set,
     l = a.getterFor(u);
    t.exports = s(Array, "Array", (function(t, e) {
     c(this, {
      type: u,
      target: r(t),
      index: 0,
      kind: e
     })
    }), (function() {
     var t = l(this),
      e = t.target,
      n = t.kind,
      r = t.index++;
     return !e || r >= e.length ? (t.target = void 0, {
      value: void 0,
      done: !0
     }) : "keys" == n ? {
      value: r,
      done: !1
     } : "values" == n ? {
      value: e[r],
      done: !1
     } : {
      value: [r, e[r]],
      done: !1
     }
    }), "values"), o.Arguments = o.Array, i("keys"), i("values"), i("entries")
   },
   e2cc: function(t, e, n) {
    var r = n("6eeb");
    t.exports = function(t, e, n) {
     for (var i in e) r(t, i, e[i], n);
     return t
    }
   },
   e3db: function(t, e) {
    var n = {}.toString;
    t.exports = Array.isArray || function(t) {
     return "[object Array]" == n.call(t)
    }
   },
   e439: function(t, e, n) {
    var r = n("23e7"),
     i = n("d039"),
     o = n("fc6a"),
     a = n("06cf").f,
     s = n("83ab"),
     u = i((function() {
      a(1)
     })),
     c = !s || u;
    r({
     target: "Object",
     stat: !0,
     forced: c,
     sham: !s
    }, {
     getOwnPropertyDescriptor: function(t, e) {
      return a(o(t), e)
     }
    })
   },
   e4d3: function(t, e, n) {
    "use strict";
    var r = n("2b0e");
    e["a"] = r["a"].extend({
     name: "returnable",
     props: {
      returnValue: null
     },
     data: function() {
      return {
       isActive: !1,
       originalValue: null
      }
     },
     watch: {
      isActive: function(t) {
       t ? this.originalValue = this.returnValue : this.$emit("update:return-value", this.originalValue)
      }
     },
     methods: {
      save: function(t) {
       var e = this;
       this.originalValue = t, setTimeout((function() {
        e.isActive = !1
       }))
      }
     }
    })
   },
   e538: function(t, e, n) {
    var r = n("b622");
    e.f = r
   },
   e667: function(t, e) {
    t.exports = function(t) {
     try {
      return {
       error: !1,
       value: t()
      }
     } catch (e) {
      return {
       error: !0,
       value: e
      }
     }
    }
   },
   e683: function(t, e, n) {
    "use strict";
    t.exports = function(t, e) {
     return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
    }
   },
   e6cf: function(t, e, n) {
    "use strict";
    var r, i, o, a, s = n("23e7"),
     u = n("c430"),
     c = n("da84"),
     l = n("d066"),
     h = n("fea9"),
     p = n("6eeb"),
     f = n("e2cc"),
     d = n("d44e"),
     v = n("2626"),
     m = n("861d"),
     g = n("1c0b"),
     y = n("19aa"),
     b = n("c6b6"),
     x = n("8925"),
     w = n("2266"),
     C = n("1c7e"),
     S = n("4840"),
     E = n("2cf4").set,
     k = n("b575"),
     I = n("cdf9"),
     O = n("44de"),
     A = n("f069"),
     N = n("e667"),
     R = n("69f3"),
     T = n("94ca"),
     _ = n("b622"),
     D = n("2d00"),
     F = _("species"),
     M = "Promise",
     L = R.get,
     B = R.set,
     P = R.getterFor(M),
     z = h,
     j = c.TypeError,
     W = c.document,
     V = c.process,
     U = l("fetch"),
     H = A.f,
     $ = H,
     G = "process" == b(V),
     q = !!(W && W.createEvent && c.dispatchEvent),
     K = "unhandledrejection",
     X = "rejectionhandled",
     Y = 0,
     Z = 1,
     J = 2,
     Q = 1,
     tt = 2,
     et = T(M, (function() {
      var t = x(z) !== String(z);
      if (!t) {
       if (66 === D) return !0;
       if (!G && "function" != typeof PromiseRejectionEvent) return !0
      }
      if (u && !z.prototype["finally"]) return !0;
      if (D >= 51 && /native code/.test(z)) return !1;
      var e = z.resolve(1),
       n = function(t) {
        t((function() {}), (function() {}))
       },
       r = e.constructor = {};
      return r[F] = n, !(e.then((function() {})) instanceof n)
     })),
     nt = et || !C((function(t) {
      z.all(t)["catch"]((function() {}))
     })),
     rt = function(t) {
      var e;
      return !(!m(t) || "function" != typeof(e = t.then)) && e
     },
     it = function(t, e, n) {
      if (!e.notified) {
       e.notified = !0;
       var r = e.reactions;
       k((function() {
        var i = e.value,
         o = e.state == Z,
         a = 0;
        while (r.length > a) {
         var s, u, c, l = r[a++],
          h = o ? l.ok : l.fail,
          p = l.resolve,
          f = l.reject,
          d = l.domain;
         try {
          h ? (o || (e.rejection === tt && ut(t, e), e.rejection = Q), !0 === h ? s = i : (d && d.enter(), s = h(i), d && (d.exit(), c = !0)), s === l.promise ? f(j("Promise-chain cycle")) : (u = rt(s)) ? u.call(s, p, f) : p(s)) : f(i)
         } catch (v) {
          d && !c && d.exit(), f(v)
         }
        }
        e.reactions = [], e.notified = !1, n && !e.rejection && at(t, e)
       }))
      }
     },
     ot = function(t, e, n) {
      var r, i;
      q ? (r = W.createEvent("Event"), r.promise = e, r.reason = n, r.initEvent(t, !1, !0), c.dispatchEvent(r)) : r = {
       promise: e,
       reason: n
      }, (i = c["on" + t]) ? i(r) : t === K && O("Unhandled promise rejection", n)
     },
     at = function(t, e) {
      E.call(c, (function() {
       var n, r = e.value,
        i = st(e);
       if (i && (n = N((function() {
         G ? V.emit("unhandledRejection", r, t) : ot(K, t, r)
        })), e.rejection = G || st(e) ? tt : Q, n.error)) throw n.value
      }))
     },
     st = function(t) {
      return t.rejection !== Q && !t.parent
     },
     ut = function(t, e) {
      E.call(c, (function() {
       G ? V.emit("rejectionHandled", t) : ot(X, t, e.value)
      }))
     },
     ct = function(t, e, n, r) {
      return function(i) {
       t(e, n, i, r)
      }
     },
     lt = function(t, e, n, r) {
      e.done || (e.done = !0, r && (e = r), e.value = n, e.state = J, it(t, e, !0))
     },
     ht = function(t, e, n, r) {
      if (!e.done) {
       e.done = !0, r && (e = r);
       try {
        if (t === n) throw j("Promise can't be resolved itself");
        var i = rt(n);
        i ? k((function() {
         var r = {
          done: !1
         };
         try {
          i.call(n, ct(ht, t, r, e), ct(lt, t, r, e))
         } catch (o) {
          lt(t, r, o, e)
         }
        })) : (e.value = n, e.state = Z, it(t, e, !1))
       } catch (o) {
        lt(t, {
         done: !1
        }, o, e)
       }
      }
     };
    et && (z = function(t) {
     y(this, z, M), g(t), r.call(this);
     var e = L(this);
     try {
      t(ct(ht, this, e), ct(lt, this, e))
     } catch (n) {
      lt(this, e, n)
     }
    }, r = function(t) {
     B(this, {
      type: M,
      done: !1,
      notified: !1,
      parent: !1,
      reactions: [],
      rejection: !1,
      state: Y,
      value: void 0
     })
    }, r.prototype = f(z.prototype, {
     then: function(t, e) {
      var n = P(this),
       r = H(S(this, z));
      return r.ok = "function" != typeof t || t, r.fail = "function" == typeof e && e, r.domain = G ? V.domain : void 0, n.parent = !0, n.reactions.push(r), n.state != Y && it(this, n, !1), r.promise
     },
     catch: function(t) {
      return this.then(void 0, t)
     }
    }), i = function() {
     var t = new r,
      e = L(t);
     this.promise = t, this.resolve = ct(ht, t, e), this.reject = ct(lt, t, e)
    }, A.f = H = function(t) {
     return t === z || t === o ? new i(t) : $(t)
    }, u || "function" != typeof h || (a = h.prototype.then, p(h.prototype, "then", (function(t, e) {
     var n = this;
     return new z((function(t, e) {
      a.call(n, t, e)
     })).then(t, e)
    }), {
     unsafe: !0
    }), "function" == typeof U && s({
     global: !0,
     enumerable: !0,
     forced: !0
    }, {
     fetch: function(t) {
      return I(z, U.apply(c, arguments))
     }
    }))), s({
     global: !0,
     wrap: !0,
     forced: et
    }, {
     Promise: z
    }), d(z, M, !1, !0), v(M), o = l(M), s({
     target: M,
     stat: !0,
     forced: et
    }, {
     reject: function(t) {
      var e = H(this);
      return e.reject.call(void 0, t), e.promise
     }
    }), s({
     target: M,
     stat: !0,
     forced: u || et
    }, {
     resolve: function(t) {
      return I(u && this === o ? z : this, t)
     }
    }), s({
     target: M,
     stat: !0,
     forced: nt
    }, {
     all: function(t) {
      var e = this,
       n = H(e),
       r = n.resolve,
       i = n.reject,
       o = N((function() {
        var n = g(e.resolve),
         o = [],
         a = 0,
         s = 1;
        w(t, (function(t) {
         var u = a++,
          c = !1;
         o.push(void 0), s++, n.call(e, t).then((function(t) {
          c || (c = !0, o[u] = t, --s || r(o))
         }), i)
        })), --s || r(o)
       }));
      return o.error && i(o.value), n.promise
     },
     race: function(t) {
      var e = this,
       n = H(e),
       r = n.reject,
       i = N((function() {
        var i = g(e.resolve);
        w(t, (function(t) {
         i.call(e, t).then(n.resolve, r)
        }))
       }));
      return i.error && r(i.value), n.promise
     }
    })
   },
   e893: function(t, e, n) {
    var r = n("5135"),
     i = n("56ef"),
     o = n("06cf"),
     a = n("9bf2");
    t.exports = function(t, e) {
     for (var n = i(e), s = a.f, u = o.f, c = 0; c < n.length; c++) {
      var l = n[c];
      r(t, l) || s(t, l, u(e, l))
     }
    }
   },
   e8b5: function(t, e, n) {
    var r = n("c6b6");
    t.exports = Array.isArray || function(t) {
     return "Array" == r(t)
    }
   },
   e95a: function(t, e, n) {
    var r = n("b622"),
     i = n("3f8c"),
     o = r("iterator"),
     a = Array.prototype;
    t.exports = function(t) {
     return void 0 !== t && (i.Array === t || a[o] === t)
    }
   },
   e9b1: function(t, e, n) {},
   ee6f: function(t, e, n) {},
   f069: function(t, e, n) {
    "use strict";
    var r = n("1c0b"),
     i = function(t) {
      var e, n;
      this.promise = new t((function(t, r) {
       if (void 0 !== e || void 0 !== n) throw TypeError("Bad Promise constructor");
       e = t, n = r
      })), this.resolve = r(e), this.reject = r(n)
     };
    t.exports.f = function(t) {
     return new i(t)
    }
   },
   f183: function(t, e, n) {
    var r = n("d012"),
     i = n("861d"),
     o = n("5135"),
     a = n("9bf2").f,
     s = n("90e3"),
     u = n("bb2f"),
     c = s("meta"),
     l = 0,
     h = Object.isExtensible || function() {
      return !0
     },
     p = function(t) {
      a(t, c, {
       value: {
        objectID: "O" + ++l,
        weakData: {}
       }
      })
     },
     f = function(t, e) {
      if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
      if (!o(t, c)) {
       if (!h(t)) return "F";
       if (!e) return "E";
       p(t)
      }
      return t[c].objectID
     },
     d = function(t, e) {
      if (!o(t, c)) {
       if (!h(t)) return !0;
       if (!e) return !1;
       p(t)
      }
      return t[c].weakData
     },
     v = function(t) {
      return u && m.REQUIRED && h(t) && !o(t, c) && p(t), t
     },
     m = t.exports = {
      REQUIRED: !1,
      fastKey: f,
      getWeakData: d,
      onFreeze: v
     };
    r[c] = !0
   },
   f2e7: function(t, e, n) {
    "use strict";
    n.d(e, "b", (function() {
     return o
    }));
    var r = n("ade3"),
     i = n("2b0e");
 
    function o() {
     var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "value",
      n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "input";
     return i["a"].extend({
      name: "toggleable",
      model: {
       prop: e,
       event: n
      },
      props: Object(r["a"])({}, e, {
       required: !1
      }),
      data: function() {
       return {
        isActive: !!this[e]
       }
      },
      watch: (t = {}, Object(r["a"])(t, e, (function(t) {
       this.isActive = !!t
      })), Object(r["a"])(t, "isActive", (function(t) {
       !!t !== this[e] && this.$emit(n, t)
      })), t)
     })
    }
    var a = o();
    e["a"] = a
   },
   f309: function(t, e, n) {
    "use strict";
    var r = {};
    n.r(r), n.d(r, "linear", (function() {
     return O
    })), n.d(r, "easeInQuad", (function() {
     return A
    })), n.d(r, "easeOutQuad", (function() {
     return N
    })), n.d(r, "easeInOutQuad", (function() {
     return R
    })), n.d(r, "easeInCubic", (function() {
     return T
    })), n.d(r, "easeOutCubic", (function() {
     return _
    })), n.d(r, "easeInOutCubic", (function() {
     return D
    })), n.d(r, "easeInQuart", (function() {
     return F
    })), n.d(r, "easeOutQuart", (function() {
     return M
    })), n.d(r, "easeInOutQuart", (function() {
     return L
    })), n.d(r, "easeInQuint", (function() {
     return B
    })), n.d(r, "easeOutQuint", (function() {
     return P
    })), n.d(r, "easeInOutQuint", (function() {
     return z
    }));
    n("4160"), n("caad"), n("2532"), n("159b");
 
    function i(t, e) {
     if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }
 
    function o(t, e) {
     for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
     }
    }
 
    function a(t, e, n) {
     return e && o(t.prototype, e), n && o(t, n), t
    }
    var s = n("2b0e"),
     u = n("d9bd");
 
    function c(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
     if (!c.installed) {
      c.installed = !0, s["a"] !== t && Object(u["b"])("Multiple instances of Vue detected\nSee https://github.com/vuetifyjs/vuetify/issues/4068\n\nIf you're seeing \"$attrs is readonly\", it's caused by this");
      var n = e.components || {},
       r = e.directives || {};
      for (var i in r) {
       var o = r[i];
       t.directive(i, o)
      }(function e(n) {
       if (n) {
        for (var r in n) {
         var i = n[r];
         i && !e(i.$_vuetify_subcomponents) && t.component(r, i)
        }
        return !0
       }
       return !1
      })(n), t.$_vuetify_installed || (t.$_vuetify_installed = !0, t.mixin({
       beforeCreate: function() {
        var e = this.$options;
        e.vuetify ? (e.vuetify.init(this, e.ssrContext), this.$vuetify = t.observable(e.vuetify.framework)) : this.$vuetify = e.parent && e.parent.$vuetify || this
       }
      }))
     }
    }
    n("a4d3"), n("c975"), n("b64b");
 
    function l(t, e) {
     if (null == t) return {};
     var n, r, i = {},
      o = Object.keys(t);
     for (r = 0; r < o.length; r++) n = o[r], e.indexOf(n) >= 0 || (i[n] = t[n]);
     return i
    }
 
    function h(t, e) {
     if (null == t) return {};
     var n, r, i = l(t, e);
     if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(t);
      for (r = 0; r < o.length; r++) n = o[r], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (i[n] = t[n])
     }
     return i
    }
    var p = n("53ca");
 
    function f(t) {
     if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
     return t
    }
 
    function d(t, e) {
     return !e || "object" !== Object(p["a"])(e) && "function" !== typeof e ? f(t) : e
    }
    n("3410"), n("131a");
 
    function v(t) {
     return v = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t)
     }, v(t)
    }
 
    function m(t, e) {
     return m = Object.setPrototypeOf || function(t, e) {
      return t.__proto__ = e, t
     }, m(t, e)
    }
 
    function g(t, e) {
     if ("function" !== typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
     t.prototype = Object.create(e && e.prototype, {
      constructor: {
       value: t,
       writable: !0,
       configurable: !0
      }
     }), e && m(t, e)
    }
    n("95ed");
    var y = {
      badge: "Badge",
      close: "Close",
      dataIterator: {
       noResultsText: "No matching records found",
       loadingText: "Loading items..."
      },
      dataTable: {
       itemsPerPageText: "Rows per page:",
       ariaLabel: {
        sortDescending: ": Sorted descending. Activate to remove sorting.",
        sortAscending: ": Sorted ascending. Activate to sort descending.",
        sortNone: ": Not sorted. Activate to sort ascending."
       },
       sortBy: "Sort by"
      },
      dataFooter: {
       itemsPerPageText: "Items per page:",
       itemsPerPageAll: "All",
       nextPage: "Next page",
       prevPage: "Previous page",
       firstPage: "First page",
       lastPage: "Last page",
       pageText: "{0}-{1} of {2}"
      },
      datePicker: {
       itemsSelected: "{0} selected"
      },
      noDataText: "No data available",
      carousel: {
       prev: "Previous visual",
       next: "Next visual",
       ariaLabel: {
        delimiter: "Carousel slide {0} of {1}"
       }
      },
      calendar: {
       moreEvents: "{0} more"
      },
      fileInput: {
       counter: "{0} files",
       counterSize: "{0} files ({1} in total)"
      },
      timePicker: {
       am: "AM",
       pm: "PM"
      }
     },
     b = {
      breakpoint: {
       scrollBarWidth: 16,
       thresholds: {
        xs: 600,
        sm: 960,
        md: 1280,
        lg: 1920
       }
      },
      icons: {
       iconfont: "mdi",
       values: {}
      },
      lang: {
       current: "en",
       locales: {
        en: y
       },
       t: void 0
      },
      rtl: !1,
      theme: {
       dark: !1,
       default: "light",
       disable: !1,
       options: {
        cspNonce: void 0,
        customProperties: void 0,
        minifyTheme: void 0,
        themeCache: void 0
       },
       themes: {
        light: {
         primary: "#1976D2",
         secondary: "#424242",
         accent: "#82B1FF",
         error: "#FF5252",
         info: "#2196F3",
         success: "#4CAF50",
         warning: "#FB8C00"
        },
        dark: {
         primary: "#2196F3",
         secondary: "#424242",
         accent: "#FF4081",
         error: "#FF5252",
         info: "#2196F3",
         success: "#4CAF50",
         warning: "#FB8C00"
        }
       }
      }
     },
     x = n("80d2"),
     w = function() {
      function t() {
       i(this, t), this.framework = {}
      }
      return a(t, [{
       key: "init",
       value: function(t, e) {}
      }]), t
     }(),
     C = function(t) {
      function e(t, n) {
       var r;
       i(this, e), r = d(this, v(e).call(this));
       var o = Object(x["s"])({}, b),
        a = n.userPreset,
        s = a.preset,
        c = void 0 === s ? {} : s,
        l = h(a, ["preset"]);
       return null != c.preset && Object(u["c"])("Global presets do not support the **preset** option, it can be safely omitted"), n.preset = Object(x["s"])(Object(x["s"])(o, c), l), r
      }
      return g(e, t), e
     }(w);
    C.property = "presets";
    n("13d5"), n("07ac");
    var S = n("ade3"),
     E = function(t) {
      function e() {
       var t;
       return i(this, e), t = d(this, v(e).apply(this, arguments)), t.bar = 0, t.top = 0, t.left = 0, t.insetFooter = 0, t.right = 0, t.bottom = 0, t.footer = 0, t.application = {
        bar: {},
        top: {},
        left: {},
        insetFooter: {},
        right: {},
        bottom: {},
        footer: {}
       }, t
      }
      return g(e, t), a(e, [{
       key: "register",
       value: function(t, e, n) {
        this.application[e] = Object(S["a"])({}, t, n), this.update(e)
       }
      }, {
       key: "unregister",
       value: function(t, e) {
        null != this.application[e][t] && (delete this.application[e][t], this.update(e))
       }
      }, {
       key: "update",
       value: function(t) {
        this[t] = Object.values(this.application[t]).reduce((function(t, e) {
         return t + e
        }), 0)
       }
      }]), e
     }(w);
    E.property = "application";
    n("b0c0");
    var k = function(t) {
     function e(t) {
      var n;
      i(this, e), n = d(this, v(e).call(this)), n.xs = !1, n.sm = !1, n.md = !1, n.lg = !1, n.xl = !1, n.xsOnly = !1, n.smOnly = !1, n.smAndDown = !1, n.smAndUp = !1, n.mdOnly = !1, n.mdAndDown = !1, n.mdAndUp = !1, n.lgOnly = !1, n.lgAndDown = !1, n.lgAndUp = !1, n.xlOnly = !1, n.name = "", n.height = 0, n.width = 0, n.resizeTimeout = 0;
      var r = t[e.property],
       o = r.scrollBarWidth,
       a = r.thresholds;
      return n.scrollBarWidth = o, n.thresholds = a, n.init(), n
     }
     return g(e, t), a(e, [{
      key: "init",
      value: function() {
       "undefined" !== typeof window && (window.addEventListener("resize", this.onResize.bind(this), {
        passive: !0
       }), this.update())
      }
     }, {
      key: "onResize",
      value: function() {
       clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(this.update.bind(this), 200)
      }
     }, {
      key: "update",
      value: function() {
       var t = this.getClientHeight(),
        e = this.getClientWidth(),
        n = e < this.thresholds.xs,
        r = e < this.thresholds.sm && !n,
        i = e < this.thresholds.md - this.scrollBarWidth && !(r || n),
        o = e < this.thresholds.lg - this.scrollBarWidth && !(i || r || n),
        a = e >= this.thresholds.lg - this.scrollBarWidth;
       switch (this.height = t, this.width = e, this.xs = n, this.sm = r, this.md = i, this.lg = o, this.xl = a, this.xsOnly = n, this.smOnly = r, this.smAndDown = (n || r) && !(i || o || a), this.smAndUp = !n && (r || i || o || a), this.mdOnly = i, this.mdAndDown = (n || r || i) && !(o || a), this.mdAndUp = !(n || r) && (i || o || a), this.lgOnly = o, this.lgAndDown = (n || r || i || o) && !a, this.lgAndUp = !(n || r || i) && (o || a), this.xlOnly = a, !0) {
        case n:
         this.name = "xs";
         break;
        case r:
         this.name = "sm";
         break;
        case i:
         this.name = "md";
         break;
        case o:
         this.name = "lg";
         break;
        default:
         this.name = "xl";
         break
       }
      }
     }, {
      key: "getClientWidth",
      value: function() {
       return "undefined" === typeof document ? 0 : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
      }
     }, {
      key: "getClientHeight",
      value: function() {
       return "undefined" === typeof document ? 0 : Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
      }
     }]), e
    }(w);
    k.property = "breakpoint";
    n("d3b7");
    var I = n("5530"),
     O = function(t) {
      return t
     },
     A = function(t) {
      return Math.pow(t, 2)
     },
     N = function(t) {
      return t * (2 - t)
     },
     R = function(t) {
      return t < .5 ? 2 * Math.pow(t, 2) : (4 - 2 * t) * t - 1
     },
     T = function(t) {
      return Math.pow(t, 3)
     },
     _ = function(t) {
      return Math.pow(--t, 3) + 1
     },
     D = function(t) {
      return t < .5 ? 4 * Math.pow(t, 3) : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1
     },
     F = function(t) {
      return Math.pow(t, 4)
     },
     M = function(t) {
      return 1 - Math.pow(--t, 4)
     },
     L = function(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t
     },
     B = function(t) {
      return Math.pow(t, 5)
     },
     P = function(t) {
      return 1 + Math.pow(--t, 5)
     },
     z = function(t) {
      return t < .5 ? 16 * Math.pow(t, 5) : 1 + 16 * Math.pow(--t, 5)
     };
 
    function j(t) {
     if ("number" === typeof t) return t;
     var e = U(t);
     if (!e) throw "string" === typeof t ? new Error('Target element "'.concat(t, '" not found.')) : new TypeError("Target must be a Number/Selector/HTMLElement/VueComponent, received ".concat(V(t), " instead."));
     var n = 0;
     while (e) n += e.offsetTop, e = e.offsetParent;
     return n
    }
 
    function W(t) {
     var e = U(t);
     if (e) return e;
     throw "string" === typeof t ? new Error('Container element "'.concat(t, '" not found.')) : new TypeError("Container must be a Selector/HTMLElement/VueComponent, received ".concat(V(t), " instead."))
    }
 
    function V(t) {
     return null == t ? t : t.constructor.name
    }
 
    function U(t) {
     return "string" === typeof t ? document.querySelector(t) : t && t._isVue ? t.$el : t instanceof HTMLElement ? t : null
    }
 
    function H(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = Object(I["a"])({
       container: document.scrollingElement || document.body || document.documentElement,
       duration: 500,
       offset: 0,
       easing: "easeInOutCubic",
       appOffset: !0
      }, e),
      i = W(n.container);
     if (n.appOffset && H.framework.application) {
      var o = i.classList.contains("v-navigation-drawer"),
       a = i.classList.contains("v-navigation-drawer--clipped"),
       s = H.framework.application,
       u = s.bar,
       c = s.top;
      n.offset += u, o && !a || (n.offset += c)
     }
     var l, h = performance.now();
     l = "number" === typeof t ? j(t) - n.offset : j(t) - j(i) - n.offset;
     var p = i.scrollTop;
     if (l === p) return Promise.resolve(l);
     var f = "function" === typeof n.easing ? n.easing : r[n.easing];
     if (!f) throw new TypeError('Easing function "'.concat(n.easing, '" not found.'));
     return new Promise((function(t) {
      return requestAnimationFrame((function e(r) {
       var o = r - h,
        a = Math.abs(n.duration ? Math.min(o / n.duration, 1) : 1);
       i.scrollTop = Math.floor(p + (l - p) * f(a));
       var s = i === document.body ? document.documentElement.clientHeight : i.clientHeight;
       if (1 === a || s + i.scrollTop === i.scrollHeight) return t(l);
       requestAnimationFrame(e)
      }))
     }))
    }
    H.framework = {}, H.init = function() {};
    var $ = function(t) {
     function e() {
      var t;
      return i(this, e), t = d(this, v(e).call(this)), d(t, H)
     }
     return g(e, t), e
    }(w);
    $.property = "goTo";
    n("ddb0"), n("dca8");
    var G = {
      complete: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z",
      cancel: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
      close: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
      delete: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
      clear: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
      success: "M12,2C17.52,2 22,6.48 22,12C22,17.52 17.52,22 12,22C6.48,22 2,17.52 2,12C2,6.48 6.48,2 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z",
      info: "M13,9H11V7H13M13,17H11V11H13M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
      warning: "M11,4.5H13V15.5H11V4.5M13,17.5V19.5H11V17.5H13Z",
      error: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z",
      prev: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z",
      next: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z",
      checkboxOn: "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
      checkboxOff: "M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z",
      checkboxIndeterminate: "M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
      delimiter: "M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
      sort: "M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z",
      expand: "M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z",
      menu: "M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z",
      subgroup: "M7,10L12,15L17,10H7Z",
      dropdown: "M7,10L12,15L17,10H7Z",
      radioOn: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,7C9.24,7 7,9.24 7,12C7,14.76 9.24,17 12,17C14.76,17 17,14.76 17,12C17,9.24 14.76,7 12,7Z",
      radioOff: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
      edit: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
      ratingEmpty: "M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
      ratingFull: "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z",
      ratingHalf: "M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
      loading: "M19,8L15,12H18C18,15.31 15.31,18 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20C16.42,20 20,16.42 20,12H23M6,12C6,8.69 8.69,6 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4C7.58,4 4,7.58 4,12H1L5,16L9,12",
      first: "M18.41,16.59L13.82,12L18.41,7.41L17,6L11,12L17,18L18.41,16.59M6,6H8V18H6V6Z",
      last: "M5.59,7.41L10.18,12L5.59,16.59L7,18L13,12L7,6L5.59,7.41M16,6H18V18H16V6Z",
      unfold: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z",
      file: "M16.5,6V17.5C16.5,19.71 14.71,21.5 12.5,21.5C10.29,21.5 8.5,19.71 8.5,17.5V5C8.5,3.62 9.62,2.5 11,2.5C12.38,2.5 13.5,3.62 13.5,5V15.5C13.5,16.05 13.05,16.5 12.5,16.5C11.95,16.5 11.5,16.05 11.5,15.5V6H10V15.5C10,16.88 11.12,18 12.5,18C13.88,18 15,16.88 15,15.5V5C15,2.79 13.21,1 11,1C8.79,1 7,2.79 7,5V17.5C7,20.54 9.46,23 12.5,23C15.54,23 18,20.54 18,17.5V6H16.5Z",
      plus: "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z",
      minus: "M19,13H5V11H19V13Z"
     },
     q = G,
     K = {
      complete: "check",
      cancel: "cancel",
      close: "close",
      delete: "cancel",
      clear: "clear",
      success: "check_circle",
      info: "info",
      warning: "priority_high",
      error: "warning",
      prev: "chevron_left",
      next: "chevron_right",
      checkboxOn: "check_box",
      checkboxOff: "check_box_outline_blank",
      checkboxIndeterminate: "indeterminate_check_box",
      delimiter: "fiber_manual_record",
      sort: "arrow_upward",
      expand: "keyboard_arrow_down",
      menu: "menu",
      subgroup: "arrow_drop_down",
      dropdown: "arrow_drop_down",
      radioOn: "radio_button_checked",
      radioOff: "radio_button_unchecked",
      edit: "edit",
      ratingEmpty: "star_border",
      ratingFull: "star",
      ratingHalf: "star_half",
      loading: "cached",
      first: "first_page",
      last: "last_page",
      unfold: "unfold_more",
      file: "attach_file",
      plus: "add",
      minus: "remove"
     },
     X = K,
     Y = {
      complete: "mdi-check",
      cancel: "mdi-close-circle",
      close: "mdi-close",
      delete: "mdi-close-circle",
      clear: "mdi-close",
      success: "mdi-check-circle",
      info: "mdi-information",
      warning: "mdi-exclamation",
      error: "mdi-alert",
      prev: "mdi-chevron-left",
      next: "mdi-chevron-right",
      checkboxOn: "mdi-checkbox-marked",
      checkboxOff: "mdi-checkbox-blank-outline",
      checkboxIndeterminate: "mdi-minus-box",
      delimiter: "mdi-circle",
      sort: "mdi-arrow-up",
      expand: "mdi-chevron-down",
      menu: "mdi-menu",
      subgroup: "mdi-menu-down",
      dropdown: "mdi-menu-down",
      radioOn: "mdi-radiobox-marked",
      radioOff: "mdi-radiobox-blank",
      edit: "mdi-pencil",
      ratingEmpty: "mdi-star-outline",
      ratingFull: "mdi-star",
      ratingHalf: "mdi-star-half",
      loading: "mdi-cached",
      first: "mdi-page-first",
      last: "mdi-page-last",
      unfold: "mdi-unfold-more-horizontal",
      file: "mdi-paperclip",
      plus: "mdi-plus",
      minus: "mdi-minus"
     },
     Z = Y,
     J = {
      complete: "fas fa-check",
      cancel: "fas fa-times-circle",
      close: "fas fa-times",
      delete: "fas fa-times-circle",
      clear: "fas fa-times-circle",
      success: "fas fa-check-circle",
      info: "fas fa-info-circle",
      warning: "fas fa-exclamation",
      error: "fas fa-exclamation-triangle",
      prev: "fas fa-chevron-left",
      next: "fas fa-chevron-right",
      checkboxOn: "fas fa-check-square",
      checkboxOff: "far fa-square",
      checkboxIndeterminate: "fas fa-minus-square",
      delimiter: "fas fa-circle",
      sort: "fas fa-sort-up",
      expand: "fas fa-chevron-down",
      menu: "fas fa-bars",
      subgroup: "fas fa-caret-down",
      dropdown: "fas fa-caret-down",
      radioOn: "far fa-dot-circle",
      radioOff: "far fa-circle",
      edit: "fas fa-edit",
      ratingEmpty: "far fa-star",
      ratingFull: "fas fa-star",
      ratingHalf: "fas fa-star-half",
      loading: "fas fa-sync",
      first: "fas fa-step-backward",
      last: "fas fa-step-forward",
      unfold: "fas fa-arrows-alt-v",
      file: "fas fa-paperclip",
      plus: "fas fa-plus",
      minus: "fas fa-minus"
     },
     Q = J,
     tt = {
      complete: "fa fa-check",
      cancel: "fa fa-times-circle",
      close: "fa fa-times",
      delete: "fa fa-times-circle",
      clear: "fa fa-times-circle",
      success: "fa fa-check-circle",
      info: "fa fa-info-circle",
      warning: "fa fa-exclamation",
      error: "fa fa-exclamation-triangle",
      prev: "fa fa-chevron-left",
      next: "fa fa-chevron-right",
      checkboxOn: "fa fa-check-square",
      checkboxOff: "far fa-square",
      checkboxIndeterminate: "fa fa-minus-square",
      delimiter: "fa fa-circle",
      sort: "fa fa-sort-up",
      expand: "fa fa-chevron-down",
      menu: "fa fa-bars",
      subgroup: "fa fa-caret-down",
      dropdown: "fa fa-caret-down",
      radioOn: "fa fa-dot-circle-o",
      radioOff: "fa fa-circle-o",
      edit: "fa fa-pencil",
      ratingEmpty: "fa fa-star-o",
      ratingFull: "fa fa-star",
      ratingHalf: "fa fa-star-half-o",
      loading: "fa fa-refresh",
      first: "fa fa-step-backward",
      last: "fa fa-step-forward",
      unfold: "fa fa-angle-double-down",
      file: "fa fa-paperclip",
      plus: "fa fa-plus",
      minus: "fa fa-minus"
     },
     et = tt;
    n("ac1f"), n("1276");
 
    function nt(t, e) {
     var n = {};
     for (var r in e) n[r] = {
      component: t,
      props: {
       icon: e[r].split(" fa-")
      }
     };
     return n
    }
    var rt = nt("font-awesome-icon", Q),
     it = Object.freeze({
      mdiSvg: q,
      md: X,
      mdi: Z,
      fa: Q,
      fa4: et,
      faSvg: rt
     }),
     ot = function(t) {
      function e(t) {
       var n;
       i(this, e), n = d(this, v(e).call(this));
       var r = t[e.property],
        o = r.iconfont,
        a = r.values;
       return n.iconfont = o, n.values = Object(x["s"])(it[o], a), n
      }
      return g(e, t), e
     }(w);
    ot.property = "icons";
    n("e01a"), n("99af"), n("5319"), n("2ca0");
    var at = "$vuetify.",
     st = Symbol("Lang fallback");
 
    function ut(t, e) {
     var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
      r = arguments.length > 3 ? arguments[3] : void 0,
      i = e.replace(at, ""),
      o = Object(x["k"])(t, i, st);
     return o === st && (n ? (Object(u["b"])('Translation key "'.concat(i, '" not found in fallback')), o = e) : (Object(u["c"])('Translation key "'.concat(i, '" not found, falling back to default')), o = ut(r, e, !0, r))), o
    }
    var ct = function(t) {
     function e(t) {
      var n;
      i(this, e), n = d(this, v(e).call(this)), n.defaultLocale = "en";
      var r = t[e.property],
       o = r.current,
       a = r.locales,
       s = r.t;
      return n.current = o, n.locales = a, n.translator = s || n.defaultTranslator, n
     }
     return g(e, t), a(e, [{
      key: "currentLocale",
      value: function(t) {
       var e = this.locales[this.current],
        n = this.locales[this.defaultLocale];
       return ut(e, t, !1, n)
      }
     }, {
      key: "t",
      value: function(t) {
       for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
       return t.startsWith(at) ? this.translator.apply(this, [t].concat(n)) : this.replace(t, n)
      }
     }, {
      key: "defaultTranslator",
      value: function(t) {
       for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
       return this.replace(this.currentLocale(t), n)
      }
     }, {
      key: "replace",
      value: function(t, e) {
       return t.replace(/\{(\d+)\}/g, (function(t, n) {
        return String(e[+n])
       }))
      }
     }]), e
    }(w);
    ct.property = "lang";
    n("7db0"), n("18a5");
    var lt = n("3835"),
     ht = (n("a15b"), n("d81d"), n("fb6a"), n("25f0"), n("38cf"), [
      [3.2406, -1.5372, -.4986],
      [-.9689, 1.8758, .0415],
      [.0557, -.204, 1.057]
     ]),
     pt = function(t) {
      return t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055
     },
     ft = [
      [.4124, .3576, .1805],
      [.2126, .7152, .0722],
      [.0193, .1192, .9505]
     ],
     dt = function(t) {
      return t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
     };
 
    function vt(t) {
     for (var e = Array(3), n = pt, r = ht, i = 0; i < 3; ++i) e[i] = Math.round(255 * Object(x["e"])(n(r[i][0] * t[0] + r[i][1] * t[1] + r[i][2] * t[2])));
     return (e[0] << 16) + (e[1] << 8) + (e[2] << 0)
    }
 
    function mt(t) {
     for (var e = [0, 0, 0], n = dt, r = ft, i = n((t >> 16 & 255) / 255), o = n((t >> 8 & 255) / 255), a = n((t >> 0 & 255) / 255), s = 0; s < 3; ++s) e[s] = r[s][0] * i + r[s][1] * o + r[s][2] * a;
     return e
    }
 
    function gt(t) {
     var e;
     if ("number" === typeof t) e = t;
     else {
      if ("string" !== typeof t) throw new TypeError("Colors can only be numbers or strings, recieved ".concat(null == t ? t : t.constructor.name, " instead"));
      var n = "#" === t[0] ? t.substring(1) : t;
      3 === n.length && (n = n.split("").map((function(t) {
       return t + t
      })).join("")), 6 !== n.length && Object(u["c"])("'".concat(t, "' is not a valid rgb color")), e = parseInt(n, 16)
     }
     return e < 0 ? (Object(u["c"])("Colors cannot be negative: '".concat(t, "'")), e = 0) : (e > 16777215 || isNaN(e)) && (Object(u["c"])("'".concat(t, "' is not a valid rgb color")), e = 16777215), e
    }
 
    function yt(t) {
     var e = t.toString(16);
     return e.length < 6 && (e = "0".repeat(6 - e.length) + e), "#" + e
    }
 
    function bt(t) {
     return yt(gt(t))
    }
    n("3ea3");
    var xt = .20689655172413793,
     wt = function(t) {
      return t > Math.pow(xt, 3) ? Math.cbrt(t) : t / (3 * Math.pow(xt, 2)) + 4 / 29
     },
     Ct = function(t) {
      return t > xt ? Math.pow(t, 3) : 3 * Math.pow(xt, 2) * (t - 4 / 29)
     };
 
    function St(t) {
     var e = wt,
      n = e(t[1]);
     return [116 * n - 16, 500 * (e(t[0] / .95047) - n), 200 * (n - e(t[2] / 1.08883))]
    }
 
    function Et(t) {
     var e = Ct,
      n = (t[0] + 16) / 116;
     return [.95047 * e(n + t[1] / 500), e(n), 1.08883 * e(n - t[2] / 200)]
    }
 
    function kt(t) {
     for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = t.anchor, r = h(t, ["anchor"]), i = Object.keys(r), o = {}, a = 0; a < i.length; ++a) {
      var s = i[a],
       u = t[s];
      null != u && (e ? ("base" === s || s.startsWith("lighten") || s.startsWith("darken")) && (o[s] = bt(u)) : "object" === Object(p["a"])(u) ? o[s] = kt(u, !0) : o[s] = Tt(s, gt(u)))
     }
     return e || (o.anchor = n || o.base || o.primary.base), o
    }
    var It = function(t, e) {
      return "\n.v-application .".concat(t, " {\n  background-color: ").concat(e, " !important;\n  border-color: ").concat(e, " !important;\n}\n.v-application .").concat(t, "--text {\n  color: ").concat(e, " !important;\n  caret-color: ").concat(e, " !important;\n}")
     },
     Ot = function(t, e, n) {
      var r = e.split(/(\d)/, 2),
       i = Object(lt["a"])(r, 2),
       o = i[0],
       a = i[1];
      return "\n.v-application .".concat(t, ".").concat(o, "-").concat(a, " {\n  background-color: ").concat(n, " !important;\n  border-color: ").concat(n, " !important;\n}\n.v-application .").concat(t, "--text.text--").concat(o, "-").concat(a, " {\n  color: ").concat(n, " !important;\n  caret-color: ").concat(n, " !important;\n}")
     },
     At = function(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "base";
      return "--v-".concat(t, "-").concat(e)
     },
     Nt = function(t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "base";
      return "var(".concat(At(t, e), ")")
     };
 
    function Rt(t) {
     var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
      n = t.anchor,
      r = h(t, ["anchor"]),
      i = Object.keys(r);
     if (!i.length) return "";
     var o = "",
      a = "",
      s = e ? Nt("anchor") : n;
     a += ".v-application a { color: ".concat(s, "; }"), e && (o += "  ".concat(At("anchor"), ": ").concat(n, ";\n"));
     for (var u = 0; u < i.length; ++u) {
      var c = i[u],
       l = t[c];
      a += It(c, e ? Nt(c) : l.base), e && (o += "  ".concat(At(c), ": ").concat(l.base, ";\n"));
      for (var p = Object.keys(l), f = 0; f < p.length; ++f) {
       var d = p[f],
        v = l[d];
       "base" !== d && (a += Ot(c, d, e ? Nt(c, d) : v), e && (o += "  ".concat(At(c, d), ": ").concat(v, ";\n")))
      }
     }
     return e && (o = ":root {\n".concat(o, "}\n\n")), o + a
    }
 
    function Tt(t, e) {
     for (var n = {
       base: yt(e)
      }, r = 5; r > 0; --r) n["lighten".concat(r)] = yt(_t(e, r));
     for (var i = 1; i <= 4; ++i) n["darken".concat(i)] = yt(Dt(e, i));
     return n
    }
 
    function _t(t, e) {
     var n = St(mt(t));
     return n[0] = n[0] + 10 * e, vt(Et(n))
    }
 
    function Dt(t, e) {
     var n = St(mt(t));
     return n[0] = n[0] - 10 * e, vt(Et(n))
    }
    var Ft = function(t) {
     function e(t) {
      var n;
      i(this, e), n = d(this, v(e).call(this)), n.disabled = !1, n.isDark = null, n.vueInstance = null, n.vueMeta = null;
      var r = t[e.property],
       o = r.dark,
       a = r.disable,
       s = r.options,
       u = r.themes;
      return n.dark = Boolean(o), n.defaults = n.themes = u, n.options = s, a ? (n.disabled = !0, d(n)) : (n.themes = {
       dark: n.fillVariant(u.dark, !0),
       light: n.fillVariant(u.light, !1)
      }, n)
     }
     return g(e, t), a(e, [{
      key: "applyTheme",
      value: function() {
       if (this.disabled) return this.clearCss();
       this.css = this.generatedStyles
      }
     }, {
      key: "clearCss",
      value: function() {
       this.css = ""
      }
     }, {
      key: "init",
      value: function(t, e) {
       this.disabled || (t.$meta ? this.initVueMeta(t) : e && this.initSSR(e), this.initTheme())
      }
     }, {
      key: "setTheme",
      value: function(t, e) {
       this.themes[t] = Object.assign(this.themes[t], e), this.applyTheme()
      }
     }, {
      key: "resetThemes",
      value: function() {
       this.themes.light = Object.assign({}, this.defaults.light), this.themes.dark = Object.assign({}, this.defaults.dark), this.applyTheme()
      }
     }, {
      key: "checkOrCreateStyleElement",
      value: function() {
       return this.styleEl = document.getElementById("vuetify-theme-stylesheet"), !!this.styleEl || (this.genStyleElement(), Boolean(this.styleEl))
      }
     }, {
      key: "fillVariant",
      value: function() {
       var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        e = arguments.length > 1 ? arguments[1] : void 0,
        n = this.themes[e ? "dark" : "light"];
       return Object.assign({}, n, t)
      }
     }, {
      key: "genStyleElement",
      value: function() {
       if ("undefined" !== typeof document) {
        var t = this.options || {};
        this.styleEl = document.createElement("style"), this.styleEl.type = "text/css", this.styleEl.id = "vuetify-theme-stylesheet", t.cspNonce && this.styleEl.setAttribute("nonce", t.cspNonce), document.head.appendChild(this.styleEl)
       }
      }
     }, {
      key: "initVueMeta",
      value: function(t) {
       var e = this;
       if (this.vueMeta = t.$meta(), this.isVueMeta23) t.$nextTick((function() {
        e.applyVueMeta23()
       }));
       else {
        var n = "function" === typeof this.vueMeta.getOptions ? this.vueMeta.getOptions().keyName : "metaInfo",
         r = t.$options[n] || {};
        t.$options[n] = function() {
         r.style = r.style || [];
         var t = r.style.find((function(t) {
          return "vuetify-theme-stylesheet" === t.id
         }));
         return t ? t.cssText = e.generatedStyles : r.style.push({
          cssText: e.generatedStyles,
          type: "text/css",
          id: "vuetify-theme-stylesheet",
          nonce: (e.options || {}).cspNonce
         }), r
        }
       }
      }
     }, {
      key: "applyVueMeta23",
      value: function() {
       var t = this.vueMeta.addApp("vuetify"),
        e = t.set;
       e({
        style: [{
         cssText: this.generatedStyles,
         type: "text/css",
         id: "vuetify-theme-stylesheet",
         nonce: (this.options || {}).cspNonce
        }]
       })
      }
     }, {
      key: "initSSR",
      value: function(t) {
       var e = this.options || {},
        n = e.cspNonce ? ' nonce="'.concat(e.cspNonce, '"') : "";
       t.head = t.head || "", t.head += '<style type="text/css" id="vuetify-theme-stylesheet"'.concat(n, ">").concat(this.generatedStyles, "</style>")
      }
     }, {
      key: "initTheme",
      value: function() {
       var t = this;
       "undefined" !== typeof document && (this.vueInstance && this.vueInstance.$destroy(), this.vueInstance = new s["a"]({
        data: {
         themes: this.themes
        },
        watch: {
         themes: {
          immediate: !0,
          deep: !0,
          handler: function() {
           return t.applyTheme()
          }
         }
        }
       }))
      }
     }, {
      key: "css",
      set: function(t) {
       this.vueMeta ? this.isVueMeta23 && this.applyVueMeta23() : this.checkOrCreateStyleElement() && (this.styleEl.innerHTML = t)
      }
     }, {
      key: "dark",
      set: function(t) {
       var e = this.isDark;
       this.isDark = t, null != e && this.applyTheme()
      },
      get: function() {
       return Boolean(this.isDark)
      }
     }, {
      key: "currentTheme",
      get: function() {
       var t = this.dark ? "dark" : "light";
       return this.themes[t]
      }
     }, {
      key: "generatedStyles",
      get: function() {
       var t, e = this.parsedTheme,
        n = this.options || {};
       return null != n.themeCache && (t = n.themeCache.get(e), null != t) ? t : (t = Rt(e, n.customProperties), null != n.minifyTheme && (t = n.minifyTheme(t)), null != n.themeCache && n.themeCache.set(e, t), t)
      }
     }, {
      key: "parsedTheme",
      get: function() {
       var t = this.currentTheme || {};
       return kt(t)
      }
     }, {
      key: "isVueMeta23",
      get: function() {
       return "function" === typeof this.vueMeta.addApp
      }
     }]), e
    }(w);
    Ft.property = "theme", n.d(e, "a", (function() {
     return Mt
    }));
    var Mt = function() {
     function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      i(this, t), this.framework = {}, this.installed = [], this.preset = {}, this.userPreset = {}, this.userPreset = e, this.use(C), this.use(E), this.use(k), this.use($), this.use(ot), this.use(ct), this.use(Ft)
     }
     return a(t, [{
      key: "init",
      value: function(t, e) {
       var n = this;
       this.installed.forEach((function(r) {
        var i = n.framework[r];
        i.framework = n.framework, i.init(t, e)
       })), this.framework.rtl = Boolean(this.preset.rtl)
      }
     }, {
      key: "use",
      value: function(t) {
       var e = t.property;
       this.installed.includes(e) || (this.framework[e] = new t(this.preset, this), this.installed.push(e))
      }
     }]), t
    }();
    Mt.install = c, Mt.installed = !1, Mt.version = "2.2.12"
   },
   f5df: function(t, e, n) {
    var r = n("00ee"),
     i = n("c6b6"),
     o = n("b622"),
     a = o("toStringTag"),
     s = "Arguments" == i(function() {
      return arguments
     }()),
     u = function(t, e) {
      try {
       return t[e]
      } catch (n) {}
     };
    t.exports = r ? i : function(t) {
     var e, n, r;
     return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(n = u(e = Object(t), a)) ? n : s ? i(e) : "Object" == (r = i(e)) && "function" == typeof e.callee ? "Arguments" : r
    }
   },
   f6b4: function(t, e, n) {
    "use strict";
    var r = n("c532");
 
    function i() {
     this.handlers = []
    }
    i.prototype.use = function(t, e) {
     return this.handlers.push({
      fulfilled: t,
      rejected: e
     }), this.handlers.length - 1
    }, i.prototype.eject = function(t) {
     this.handlers[t] && (this.handlers[t] = null)
    }, i.prototype.forEach = function(t) {
     r.forEach(this.handlers, (function(e) {
      null !== e && t(e)
     }))
    }, t.exports = i
   },
   f748: function(t, e) {
    t.exports = Math.sign || function(t) {
     return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
    }
   },
   f772: function(t, e, n) {
    var r = n("5692"),
     i = n("90e3"),
     o = r("keys");
    t.exports = function(t) {
     return o[t] || (o[t] = i(t))
    }
   },
   fb6a: function(t, e, n) {
    "use strict";
    var r = n("23e7"),
     i = n("861d"),
     o = n("e8b5"),
     a = n("23cb"),
     s = n("50c4"),
     u = n("fc6a"),
     c = n("8418"),
     l = n("b622"),
     h = n("1dde"),
     p = n("ae40"),
     f = h("slice"),
     d = p("slice", {
      ACCESSORS: !0,
      0: 0,
      1: 2
     }),
     v = l("species"),
     m = [].slice,
     g = Math.max;
    r({
     target: "Array",
     proto: !0,
     forced: !f || !d
    }, {
     slice: function(t, e) {
      var n, r, l, h = u(this),
       p = s(h.length),
       f = a(t, p),
       d = a(void 0 === e ? p : e, p);
      if (o(h) && (n = h.constructor, "function" != typeof n || n !== Array && !o(n.prototype) ? i(n) && (n = n[v], null === n && (n = void 0)) : n = void 0, n === Array || void 0 === n)) return m.call(h, f, d);
      for (r = new(void 0 === n ? Array : n)(g(d - f, 0)), l = 0; f < d; f++, l++) f in h && c(r, l, h[f]);
      return r.length = l, r
     }
    })
   },
   fc6a: function(t, e, n) {
    var r = n("44ad"),
     i = n("1d80");
    t.exports = function(t) {
     return r(i(t))
    }
   },
   fdbc: function(t, e) {
    t.exports = {
     CSSRuleList: 0,
     CSSStyleDeclaration: 0,
     CSSValueList: 0,
     ClientRectList: 0,
     DOMRectList: 0,
     DOMStringList: 0,
     DOMTokenList: 1,
     DataTransferItemList: 0,
     FileList: 0,
     HTMLAllCollection: 0,
     HTMLCollection: 0,
     HTMLFormElement: 0,
     HTMLSelectElement: 0,
     MediaList: 0,
     MimeTypeArray: 0,
     NamedNodeMap: 0,
     NodeList: 1,
     PaintRequestList: 0,
     Plugin: 0,
     PluginArray: 0,
     SVGLengthList: 0,
     SVGNumberList: 0,
     SVGPathSegList: 0,
     SVGPointList: 0,
     SVGStringList: 0,
     SVGTransformList: 0,
     SourceBufferList: 0,
     StyleSheetList: 0,
     TextTrackCueList: 0,
     TextTrackList: 0,
     TouchList: 0
    }
   },
   fdbf: function(t, e, n) {
    var r = n("4930");
    t.exports = r && !Symbol.sham && "symbol" == typeof Symbol.iterator
   },
   fe6c: function(t, e, n) {
    "use strict";
    n.d(e, "b", (function() {
     return a
    }));
    var r = n("2b0e"),
     i = n("80d2"),
     o = {
      absolute: Boolean,
      bottom: Boolean,
      fixed: Boolean,
      left: Boolean,
      right: Boolean,
      top: Boolean
     };
 
    function a() {
     var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
     return r["a"].extend({
      name: "positionable",
      props: t.length ? Object(i["j"])(o, t) : o
     })
    }
    e["a"] = a()
   },
   fea9: function(t, e, n) {
    var r = n("da84");
    t.exports = r.Promise
   }
  }
 ]);
 //# sourceMappingURL=chunk-vendors.7eb54aaf.js.map
 _